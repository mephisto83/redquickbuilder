module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/app.global.css":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./app/components/selectinput.css":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./app/components/typeahead.css":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin
module.exports = {"typeahead":"typeahead__typeahead__2A0HM","typeaheadContainer":"typeahead__typeaheadContainer__3ebTA"};

/***/ }),

/***/ "./app/constants/routes.json":
/***/ (function(module) {

module.exports = {"HOME":"/","COUNTER":"/counter"};

/***/ }),

/***/ "./app/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var functiontypes_namespaceObject = {};
__webpack_require__.r(functiontypes_namespaceObject);
__webpack_require__.d(functiontypes_namespaceObject, "FunctionTypes", function() { return functiontypes_FunctionTypes; });
__webpack_require__.d(functiontypes_namespaceObject, "FunctionTemplateKeys", function() { return FunctionTemplateKeys; });
__webpack_require__.d(functiontypes_namespaceObject, "FunctionConstraintKeys", function() { return FunctionConstraintKeys; });
__webpack_require__.d(functiontypes_namespaceObject, "AFTER_EFFECTS", function() { return AFTER_EFFECTS; });
__webpack_require__.d(functiontypes_namespaceObject, "INTERNAL_TEMPLATE_REQUIREMENTS", function() { return INTERNAL_TEMPLATE_REQUIREMENTS; });
__webpack_require__.d(functiontypes_namespaceObject, "FUNCTION_REQUIREMENT_KEYS", function() { return FUNCTION_REQUIREMENT_KEYS; });
__webpack_require__.d(functiontypes_namespaceObject, "TEMPLATE_KEY_MODIFIERS", function() { return TEMPLATE_KEY_MODIFIERS; });
__webpack_require__.d(functiontypes_namespaceObject, "ToInterface", function() { return ToInterface; });
__webpack_require__.d(functiontypes_namespaceObject, "HTTP_METHODS", function() { return HTTP_METHODS; });
__webpack_require__.d(functiontypes_namespaceObject, "COMMON_FUNCTION_TEMPLATE_KEYS", function() { return COMMON_FUNCTION_TEMPLATE_KEYS; });
__webpack_require__.d(functiontypes_namespaceObject, "COMMON_FUNCTION_TEMPLATE_KEYS_USER", function() { return COMMON_FUNCTION_TEMPLATE_KEYS_USER; });
__webpack_require__.d(functiontypes_namespaceObject, "QUERY_PARAMETER_KEYS", function() { return QUERY_PARAMETER_KEYS; });
__webpack_require__.d(functiontypes_namespaceObject, "TEMPLATE_PARAMETER_KEYS", function() { return TEMPLATE_PARAMETER_KEYS; });
__webpack_require__.d(functiontypes_namespaceObject, "QUERY_PARAMETERS", function() { return QUERY_PARAMETERS; });
__webpack_require__.d(functiontypes_namespaceObject, "TEMPLATE_PARAMETERS", function() { return TEMPLATE_PARAMETERS; });
__webpack_require__.d(functiontypes_namespaceObject, "GET_QUERY_PARAMETERS", function() { return GET_QUERY_PARAMETERS; });
__webpack_require__.d(functiontypes_namespaceObject, "MethodFunctions", function() { return MethodFunctions; });
__webpack_require__.d(functiontypes_namespaceObject, "MethodTemplateKeys", function() { return MethodTemplateKeys; });
__webpack_require__.d(functiontypes_namespaceObject, "FunctionMethodTypes", function() { return FunctionMethodTypes; });
__webpack_require__.d(functiontypes_namespaceObject, "ConditionTypes", function() { return ConditionTypes; });
__webpack_require__.d(functiontypes_namespaceObject, "ConditionCases", function() { return ConditionCases; });
__webpack_require__.d(functiontypes_namespaceObject, "ConditionTypeParameters", function() { return ConditionTypeParameters; });
__webpack_require__.d(functiontypes_namespaceObject, "ConditionTypeOptions", function() { return ConditionTypeOptions; });
__webpack_require__.d(functiontypes_namespaceObject, "ConditionFunctionSetups", function() { return ConditionFunctionSetups; });
__webpack_require__.d(functiontypes_namespaceObject, "FunctionPerpetrators", function() { return FunctionPerpetrators; });
__webpack_require__.d(functiontypes_namespaceObject, "ReturnTypes", function() { return ReturnTypes; });
__webpack_require__.d(functiontypes_namespaceObject, "hasTemplate", function() { return hasTemplate; });
__webpack_require__.d(functiontypes_namespaceObject, "bindTemplate", function() { return bindTemplate; });
__webpack_require__.d(functiontypes_namespaceObject, "bindReferenceTemplate", function() { return bindReferenceTemplate; });
var uiactions_namespaceObject = {};
__webpack_require__.r(uiactions_namespaceObject);
__webpack_require__.d(uiactions_namespaceObject, "VISUAL", function() { return VISUAL; });
__webpack_require__.d(uiactions_namespaceObject, "MINIMIZED", function() { return MINIMIZED; });
__webpack_require__.d(uiactions_namespaceObject, "HIDDEN", function() { return HIDDEN; });
__webpack_require__.d(uiactions_namespaceObject, "APPLICATION", function() { return APPLICATION; });
__webpack_require__.d(uiactions_namespaceObject, "GRAPHS", function() { return GRAPHS; });
__webpack_require__.d(uiactions_namespaceObject, "VISUAL_GRAPH", function() { return VISUAL_GRAPH; });
__webpack_require__.d(uiactions_namespaceObject, "DASHBOARD_MENU", function() { return DASHBOARD_MENU; });
__webpack_require__.d(uiactions_namespaceObject, "SELECTED_NODE_BB", function() { return SELECTED_NODE_BB; });
__webpack_require__.d(uiactions_namespaceObject, "GROUPS_ENABLED", function() { return GROUPS_ENABLED; });
__webpack_require__.d(uiactions_namespaceObject, "SIDE_PANEL_EXTRA_WIDTH", function() { return SIDE_PANEL_EXTRA_WIDTH; });
__webpack_require__.d(uiactions_namespaceObject, "NodeTypes", function() { return uiactions_NodeTypes; });
__webpack_require__.d(uiactions_namespaceObject, "NodeTypeColors", function() { return uiactions_NodeTypeColors; });
__webpack_require__.d(uiactions_namespaceObject, "NodeProperties", function() { return uiactions_NodeProperties; });
__webpack_require__.d(uiactions_namespaceObject, "LinkProperties", function() { return uiactions_LinkProperties; });
__webpack_require__.d(uiactions_namespaceObject, "NodeAttributePropertyTypes", function() { return uiactions_NodeAttributePropertyTypes; });
__webpack_require__.d(uiactions_namespaceObject, "NodePropertyTypes", function() { return uiactions_NodePropertyTypes; });
__webpack_require__.d(uiactions_namespaceObject, "ValidationRules", function() { return uiactions_ValidationRules; });
__webpack_require__.d(uiactions_namespaceObject, "OptionsTypes", function() { return uiactions_OptionsTypes; });
__webpack_require__.d(uiactions_namespaceObject, "NODE_COST", function() { return NODE_COST; });
__webpack_require__.d(uiactions_namespaceObject, "NODE_CONNECTION_COST", function() { return NODE_CONNECTION_COST; });
__webpack_require__.d(uiactions_namespaceObject, "BATCH_MODEL", function() { return BATCH_MODEL; });
__webpack_require__.d(uiactions_namespaceObject, "BATCH_AGENT", function() { return BATCH_AGENT; });
__webpack_require__.d(uiactions_namespaceObject, "BATCH_PARENT", function() { return BATCH_PARENT; });
__webpack_require__.d(uiactions_namespaceObject, "BATCH_FUNCTION_NAME", function() { return BATCH_FUNCTION_NAME; });
__webpack_require__.d(uiactions_namespaceObject, "RECORDING", function() { return RECORDING; });
__webpack_require__.d(uiactions_namespaceObject, "BATCH_FUNCTION_TYPE", function() { return BATCH_FUNCTION_TYPE; });
__webpack_require__.d(uiactions_namespaceObject, "GetScreenUrl", function() { return GetScreenUrl; });
__webpack_require__.d(uiactions_namespaceObject, "convertToURLRoute", function() { return convertToURLRoute; });
__webpack_require__.d(uiactions_namespaceObject, "UI_UPDATE", function() { return UI_UPDATE; });
__webpack_require__.d(uiactions_namespaceObject, "GetC", function() { return GetC; });
__webpack_require__.d(uiactions_namespaceObject, "Get", function() { return Get; });
__webpack_require__.d(uiactions_namespaceObject, "generateDataSeed", function() { return generateDataSeed; });
__webpack_require__.d(uiactions_namespaceObject, "generateDataSeeds", function() { return generateDataSeeds; });
__webpack_require__.d(uiactions_namespaceObject, "Visual", function() { return Visual; });
__webpack_require__.d(uiactions_namespaceObject, "ChoseModel", function() { return ChoseModel; });
__webpack_require__.d(uiactions_namespaceObject, "Minimized", function() { return Minimized; });
__webpack_require__.d(uiactions_namespaceObject, "Hidden", function() { return Hidden; });
__webpack_require__.d(uiactions_namespaceObject, "CopyKey", function() { return CopyKey; });
__webpack_require__.d(uiactions_namespaceObject, "IsCurrentNodeA", function() { return IsCurrentNodeA; });
__webpack_require__.d(uiactions_namespaceObject, "Use", function() { return Use; });
__webpack_require__.d(uiactions_namespaceObject, "GetManyToManyNodes", function() { return uiactions_GetManyToManyNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeProp", function() { return uiactions_GetNodeProp; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeType", function() { return GetNodeType; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodePropDirty", function() { return GetNodePropDirty; });
__webpack_require__.d(uiactions_namespaceObject, "GetGroupProp", function() { return GetGroupProp; });
__webpack_require__.d(uiactions_namespaceObject, "GetSharedComponentFor", function() { return GetSharedComponentFor; });
__webpack_require__.d(uiactions_namespaceObject, "getViewTypeEndpointsForDefaults", function() { return getViewTypeEndpointsForDefaults; });
__webpack_require__.d(uiactions_namespaceObject, "setSharedComponent", function() { return setSharedComponent; });
__webpack_require__.d(uiactions_namespaceObject, "setComponentApiConnection", function() { return setComponentApiConnection; });
__webpack_require__.d(uiactions_namespaceObject, "addQueryMethodParameter", function() { return addQueryMethodParameter; });
__webpack_require__.d(uiactions_namespaceObject, "addQueryMethodApi", function() { return addQueryMethodApi; });
__webpack_require__.d(uiactions_namespaceObject, "connectLifeCycleMethod", function() { return connectLifeCycleMethod; });
__webpack_require__.d(uiactions_namespaceObject, "addComponentEventTo", function() { return addComponentEventTo; });
__webpack_require__.d(uiactions_namespaceObject, "ComponentEventTo", function() { return ComponentEventTo; });
__webpack_require__.d(uiactions_namespaceObject, "GetTitleService", function() { return GetTitleService; });
__webpack_require__.d(uiactions_namespaceObject, "AgentHasExecutor", function() { return AgentHasExecutor; });
__webpack_require__.d(uiactions_namespaceObject, "setupDefaultViewType", function() { return setupDefaultViewType; });
__webpack_require__.d(uiactions_namespaceObject, "GetConditionNodes", function() { return uiactions_GetConditionNodes; });
__webpack_require__.d(uiactions_namespaceObject, "IsAgent", function() { return uiactions_IsAgent; });
__webpack_require__.d(uiactions_namespaceObject, "GetLinkChainItem", function() { return uiactions_GetLinkChainItem; });
__webpack_require__.d(uiactions_namespaceObject, "GetCodeName", function() { return GetCodeName; });
__webpack_require__.d(uiactions_namespaceObject, "GetRelativeDataChainPath", function() { return GetRelativeDataChainPath; });
__webpack_require__.d(uiactions_namespaceObject, "computeNamespace", function() { return computeNamespace; });
__webpack_require__.d(uiactions_namespaceObject, "GetJSCodeName", function() { return GetJSCodeName; });
__webpack_require__.d(uiactions_namespaceObject, "GetModelPropertyChildren", function() { return GetModelPropertyChildren; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodParameters", function() { return GetMethodParameters; });
__webpack_require__.d(uiactions_namespaceObject, "updateMethodParameters", function() { return updateMethodParameters; });
__webpack_require__.d(uiactions_namespaceObject, "Connect", function() { return Connect; });
__webpack_require__.d(uiactions_namespaceObject, "attachMethodToMaestro", function() { return attachMethodToMaestro; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodParametersFor", function() { return GetMethodParametersFor; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeById", function() { return GetNodeById; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodesByProperties", function() { return GetNodesByProperties; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeByProperties", function() { return GetNodeByProperties; });
__webpack_require__.d(uiactions_namespaceObject, "GetChildComponentAncestors", function() { return uiactions_GetChildComponentAncestors; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodDefinition", function() { return GetMethodDefinition; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodFunctionType", function() { return GetMethodFunctionType; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodFunctionValidation", function() { return GetMethodFunctionValidation; });
__webpack_require__.d(uiactions_namespaceObject, "GetPermissionNode", function() { return uiactions_GetPermissionNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetValidationNode", function() { return uiactions_GetValidationNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataSourceNode", function() { return uiactions_GetDataSourceNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetModelItemFilter", function() { return uiactions_GetModelItemFilter; });
__webpack_require__.d(uiactions_namespaceObject, "GetPermissionsConditions", function() { return GetPermissionsConditions; });
__webpack_require__.d(uiactions_namespaceObject, "GetServiceInterfaceMethodCalls", function() { return GetServiceInterfaceMethodCalls; });
__webpack_require__.d(uiactions_namespaceObject, "GetServiceInterfaceCalls", function() { return GetServiceInterfaceCalls; });
__webpack_require__.d(uiactions_namespaceObject, "GetValidationsConditions", function() { return GetValidationsConditions; });
__webpack_require__.d(uiactions_namespaceObject, "GetModelItemConditions", function() { return GetModelItemConditions; });
__webpack_require__.d(uiactions_namespaceObject, "GetConditionSetup", function() { return GetConditionSetup; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainEntryNodes", function() { return uiactions_GetDataChainEntryNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetLambdaDefinition", function() { return GetLambdaDefinition; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateDataChainArguments", function() { return GenerateDataChainArguments; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateCSChainFunction", function() { return GenerateCSChainFunction; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateChainFunction", function() { return GenerateChainFunction; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateSetProcess", function() { return GenerateSetProcess; });
__webpack_require__.d(uiactions_namespaceObject, "GetSubscribes", function() { return GetSubscribes; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateArgs", function() { return GenerateArgs; });
__webpack_require__.d(uiactions_namespaceObject, "GetLastChainLink", function() { return GetLastChainLink; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateObservable", function() { return GenerateObservable; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateDataChainFunc", function() { return GenerateDataChainFunc; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainArgs", function() { return GetDataChainArgs; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateChainFunctions", function() { return GenerateChainFunctions; });
__webpack_require__.d(uiactions_namespaceObject, "CollectionIsInLanguage", function() { return CollectionIsInLanguage; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainCollections", function() { return GetDataChainCollections; });
__webpack_require__.d(uiactions_namespaceObject, "GetComponentExternalApiNode", function() { return GetComponentExternalApiNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetComponentApiNode", function() { return GetComponentApiNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetComponentExternalApiNodes", function() { return GetComponentExternalApiNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeMethodCall", function() { return GetNodeMethodCall; });
__webpack_require__.d(uiactions_namespaceObject, "GetComponentInternalApiNode", function() { return GetComponentInternalApiNode; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateChainFunctionSpecs", function() { return GenerateChainFunctionSpecs; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateSimpleTest", function() { return GenerateSimpleTest; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainNext", function() { return GetDataChainNext; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainNextId", function() { return GetDataChainNextId; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainParts", function() { return GetDataChainParts; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodesInGroup", function() { return uiactions_GetNodesInGroup; });
__webpack_require__.d(uiactions_namespaceObject, "GetDataChainFrom", function() { return GetDataChainFrom; });
__webpack_require__.d(uiactions_namespaceObject, "getGroup", function() { return uiactions_getGroup; });
__webpack_require__.d(uiactions_namespaceObject, "hasGroup", function() { return uiactions_hasGroup; });
__webpack_require__.d(uiactions_namespaceObject, "IsEndOfDataChain", function() { return IsEndOfDataChain; });
__webpack_require__.d(uiactions_namespaceObject, "GetLambdaVariableNode", function() { return GetLambdaVariableNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetArbitersInCSDataChainMethod", function() { return GetArbitersInCSDataChainMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GetOutputTypeInCSDataChainMethod", function() { return GetOutputTypeInCSDataChainMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateCDDataChainMethod", function() { return GenerateCDDataChainMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GenerateDataChainMethod", function() { return GenerateDataChainMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GetPermissionsSortedByAgent", function() { return GetPermissionsSortedByAgent; });
__webpack_require__.d(uiactions_namespaceObject, "GetValidationsSortedByAgent", function() { return GetValidationsSortedByAgent; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodesSortedByAgent", function() { return GetNodesSortedByAgent; });
__webpack_require__.d(uiactions_namespaceObject, "GetArbitersForNodeType", function() { return GetArbitersForNodeType; });
__webpack_require__.d(uiactions_namespaceObject, "GetCustomServicesForNodeType", function() { return GetCustomServicesForNodeType; });
__webpack_require__.d(uiactions_namespaceObject, "GetAgentNodes", function() { return GetAgentNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetUsers", function() { return GetUsers; });
__webpack_require__.d(uiactions_namespaceObject, "GetArbitersForPermissions", function() { return GetArbitersForPermissions; });
__webpack_require__.d(uiactions_namespaceObject, "GetArbitersForValidations", function() { return GetArbitersForValidations; });
__webpack_require__.d(uiactions_namespaceObject, "GetNameSpace", function() { return GetNameSpace; });
__webpack_require__.d(uiactions_namespaceObject, "GetArbiterPropertyDefinitions", function() { return GetArbiterPropertyDefinitions; });
__webpack_require__.d(uiactions_namespaceObject, "GetCustomServiceDefinitions", function() { return GetCustomServiceDefinitions; });
__webpack_require__.d(uiactions_namespaceObject, "GetArbiterPropertyImplementations", function() { return GetArbiterPropertyImplementations; });
__webpack_require__.d(uiactions_namespaceObject, "GetCustomServiceImplementations", function() { return GetCustomServiceImplementations; });
__webpack_require__.d(uiactions_namespaceObject, "GetCombinedCondition", function() { return GetCombinedCondition; });
__webpack_require__.d(uiactions_namespaceObject, "GetCustomMethodClauses", function() { return GetCustomMethodClauses; });
__webpack_require__.d(uiactions_namespaceObject, "GetConditionsClauses", function() { return GetConditionsClauses; });
__webpack_require__.d(uiactions_namespaceObject, "safeFormatTemplateProperty", function() { return safeFormatTemplateProperty; });
__webpack_require__.d(uiactions_namespaceObject, "GetConditionClause", function() { return GetConditionClause; });
__webpack_require__.d(uiactions_namespaceObject, "GetConnectionClause", function() { return GetConnectionClause; });
__webpack_require__.d(uiactions_namespaceObject, "GetSelectedConditionSetup", function() { return GetSelectedConditionSetup; });
__webpack_require__.d(uiactions_namespaceObject, "_getPermissionsConditions", function() { return _getPermissionsConditions; });
__webpack_require__.d(uiactions_namespaceObject, "_getValidationConditions", function() { return _getValidationConditions; });
__webpack_require__.d(uiactions_namespaceObject, "_getConditions", function() { return _getConditions; });
__webpack_require__.d(uiactions_namespaceObject, "GetComponentNodes", function() { return GetComponentNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetComponentNodeProperties", function() { return GetComponentNodeProperties; });
__webpack_require__.d(uiactions_namespaceObject, "GetConnectedScreenOptions", function() { return GetConnectedScreenOptions; });
__webpack_require__.d(uiactions_namespaceObject, "attachToNavigateNode", function() { return attachToNavigateNode; });
__webpack_require__.d(uiactions_namespaceObject, "_attachToNavigateNode", function() { return _attachToNavigateNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetConnectedScreen", function() { return GetConnectedScreen; });
__webpack_require__.d(uiactions_namespaceObject, "GetModelPropertyNodes", function() { return GetModelPropertyNodes; });
__webpack_require__.d(uiactions_namespaceObject, "getTopComponent", function() { return getTopComponent; });
__webpack_require__.d(uiactions_namespaceObject, "GetParentComponent", function() { return GetParentComponent; });
__webpack_require__.d(uiactions_namespaceObject, "ComponentIsViewType", function() { return ComponentIsViewType; });
__webpack_require__.d(uiactions_namespaceObject, "GetUserReferenceNodes", function() { return GetUserReferenceNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetLogicalChildren", function() { return GetLogicalChildren; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodNodeSelectOptions", function() { return GetMethodNodeSelectOptions; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeCode", function() { return GetNodeCode; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodPropNode", function() { return GetMethodPropNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodOptions", function() { return GetMethodOptions; });
__webpack_require__.d(uiactions_namespaceObject, "GetLinkProperty", function() { return GetLinkProperty; });
__webpack_require__.d(uiactions_namespaceObject, "GetLink", function() { return GetLink; });
__webpack_require__.d(uiactions_namespaceObject, "GetGroupProperty", function() { return GetGroupProperty; });
__webpack_require__.d(uiactions_namespaceObject, "VisualEq", function() { return VisualEq; });
__webpack_require__.d(uiactions_namespaceObject, "Node", function() { return Node; });
__webpack_require__.d(uiactions_namespaceObject, "ModelNotConnectedToFunction", function() { return ModelNotConnectedToFunction; });
__webpack_require__.d(uiactions_namespaceObject, "Application", function() { return Application; });
__webpack_require__.d(uiactions_namespaceObject, "GetVisualGraph", function() { return GetVisualGraph; });
__webpack_require__.d(uiactions_namespaceObject, "SaveApplication", function() { return SaveApplication; });
__webpack_require__.d(uiactions_namespaceObject, "Graphs", function() { return Graphs; });
__webpack_require__.d(uiactions_namespaceObject, "SaveGraph", function() { return SaveGraph; });
__webpack_require__.d(uiactions_namespaceObject, "UIC", function() { return UIC; });
__webpack_require__.d(uiactions_namespaceObject, "toggleVisual", function() { return toggleVisual; });
__webpack_require__.d(uiactions_namespaceObject, "toggleMinimized", function() { return toggleMinimized; });
__webpack_require__.d(uiactions_namespaceObject, "toggleHideByTypes", function() { return toggleHideByTypes; });
__webpack_require__.d(uiactions_namespaceObject, "GUID", function() { return GUID; });
__webpack_require__.d(uiactions_namespaceObject, "setVisual", function() { return setVisual; });
__webpack_require__.d(uiactions_namespaceObject, "setApplication", function() { return setApplication; });
__webpack_require__.d(uiactions_namespaceObject, "SELECTED_LINK", function() { return SELECTED_LINK; });
__webpack_require__.d(uiactions_namespaceObject, "HOVERED_LINK", function() { return HOVERED_LINK; });
__webpack_require__.d(uiactions_namespaceObject, "SELECTED_NODE", function() { return SELECTED_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "CONTEXT_MENU_VISIBLE", function() { return CONTEXT_MENU_VISIBLE; });
__webpack_require__.d(uiactions_namespaceObject, "CONTEXT_MENU_MODE", function() { return CONTEXT_MENU_MODE; });
__webpack_require__.d(uiactions_namespaceObject, "SelectedNode", function() { return SelectedNode; });
__webpack_require__.d(uiactions_namespaceObject, "toggleDashboardMinMax", function() { return toggleDashboardMinMax; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeTitle", function() { return GetNodeTitle; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodes", function() { return GetNodes; });
__webpack_require__.d(uiactions_namespaceObject, "CanChangeType", function() { return CanChangeType; });
__webpack_require__.d(uiactions_namespaceObject, "GetScreenNodes", function() { return GetScreenNodes; });
__webpack_require__.d(uiactions_namespaceObject, "addComponentApiNodes", function() { return addComponentApiNodes; });
__webpack_require__.d(uiactions_namespaceObject, "$addComponentApiNodes", function() { return $addComponentApiNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetScreenOptions", function() { return GetScreenOptions; });
__webpack_require__.d(uiactions_namespaceObject, "GetModelNodes", function() { return GetModelNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetConfigurationNodes", function() { return GetConfigurationNodes; });
__webpack_require__.d(uiactions_namespaceObject, "GetMaestroNode", function() { return GetMaestroNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetControllerNode", function() { return GetControllerNode; });
__webpack_require__.d(uiactions_namespaceObject, "HasCurrentGraph", function() { return HasCurrentGraph; });
__webpack_require__.d(uiactions_namespaceObject, "NodesByType", function() { return uiactions_NodesByType; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodeFromRoot", function() { return GetNodeFromRoot; });
__webpack_require__.d(uiactions_namespaceObject, "NodesConnectedTo", function() { return NodesConnectedTo; });
__webpack_require__.d(uiactions_namespaceObject, "GetState", function() { return GetState; });
__webpack_require__.d(uiactions_namespaceObject, "GetDispatchFunc", function() { return GetDispatchFunc; });
__webpack_require__.d(uiactions_namespaceObject, "GetStateFunc", function() { return GetStateFunc; });
__webpack_require__.d(uiactions_namespaceObject, "setTestGetState", function() { return setTestGetState; });
__webpack_require__.d(uiactions_namespaceObject, "setState", function() { return setState; });
__webpack_require__.d(uiactions_namespaceObject, "clearPinned", function() { return uiactions_clearPinned; });
__webpack_require__.d(uiactions_namespaceObject, "clearMarked", function() { return clearMarked; });
__webpack_require__.d(uiactions_namespaceObject, "selectProperties", function() { return selectProperties; });
__webpack_require__.d(uiactions_namespaceObject, "togglePinnedConnectedNodesByLinkType", function() { return togglePinnedConnectedNodesByLinkType; });
__webpack_require__.d(uiactions_namespaceObject, "toggleNodeMark", function() { return toggleNodeMark; });
__webpack_require__.d(uiactions_namespaceObject, "setInComponentMode", function() { return setInComponentMode; });
__webpack_require__.d(uiactions_namespaceObject, "removeCurrentNode", function() { return removeCurrentNode; });
__webpack_require__.d(uiactions_namespaceObject, "togglePinned", function() { return togglePinned; });
__webpack_require__.d(uiactions_namespaceObject, "GetGraphNode", function() { return GetGraphNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetFunctionType", function() { return GetFunctionType; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodNode", function() { return uiactions_GetMethodNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodNodeProp", function() { return GetMethodNodeProp; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodProps", function() { return GetMethodProps; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodsProperties", function() { return GetMethodsProperties; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodsProperty", function() { return GetMethodsProperty; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodFilterParameters", function() { return GetMethodFilterParameters; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodFilterMetaParameters", function() { return GetMethodFilterMetaParameters; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodPermissionParameters", function() { return GetMethodPermissionParameters; });
__webpack_require__.d(uiactions_namespaceObject, "GetMethodValidationParameters", function() { return GetMethodValidationParameters; });
__webpack_require__.d(uiactions_namespaceObject, "GetPermissionMethod", function() { return GetPermissionMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GetPermissionMethodModel", function() { return GetPermissionMethodModel; });
__webpack_require__.d(uiactions_namespaceObject, "GetValidatorMethod", function() { return GetValidatorMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GetFunctionMethodKey", function() { return GetFunctionMethodKey; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodesMethod", function() { return GetNodesMethod; });
__webpack_require__.d(uiactions_namespaceObject, "GetAppSettings", function() { return GetAppSettings; });
__webpack_require__.d(uiactions_namespaceObject, "GetCurrentGraph", function() { return GetCurrentGraph; });
__webpack_require__.d(uiactions_namespaceObject, "GetCurrentTheme", function() { return GetCurrentTheme; });
__webpack_require__.d(uiactions_namespaceObject, "GetRootGraph", function() { return GetRootGraph; });
__webpack_require__.d(uiactions_namespaceObject, "GetSubGraphs", function() { return GetSubGraphs; });
__webpack_require__.d(uiactions_namespaceObject, "addNewSubGraph", function() { return uiactions_addNewSubGraph; });
__webpack_require__.d(uiactions_namespaceObject, "setRootGraph", function() { return setRootGraph; });
__webpack_require__.d(uiactions_namespaceObject, "setAppsettingsAssemblyPrefixes", function() { return setAppsettingsAssemblyPrefixes; });
__webpack_require__.d(uiactions_namespaceObject, "GetCurrentScopedGraph", function() { return GetCurrentScopedGraph; });
__webpack_require__.d(uiactions_namespaceObject, "SELECTED_TAB", function() { return SELECTED_TAB; });
__webpack_require__.d(uiactions_namespaceObject, "DEFAULT_TAB", function() { return DEFAULT_TAB; });
__webpack_require__.d(uiactions_namespaceObject, "SIDE_PANEL_OPEN", function() { return SIDE_PANEL_OPEN; });
__webpack_require__.d(uiactions_namespaceObject, "PARAMETER_TAB", function() { return PARAMETER_TAB; });
__webpack_require__.d(uiactions_namespaceObject, "SCOPE_TAB", function() { return SCOPE_TAB; });
__webpack_require__.d(uiactions_namespaceObject, "QUICK_MENU", function() { return QUICK_MENU; });
__webpack_require__.d(uiactions_namespaceObject, "newNode", function() { return uiactions_newNode; });
__webpack_require__.d(uiactions_namespaceObject, "GetSelectedSubgraph", function() { return GetSelectedSubgraph; });
__webpack_require__.d(uiactions_namespaceObject, "GetViewTypeModel", function() { return GetViewTypeModel; });
__webpack_require__.d(uiactions_namespaceObject, "BuildPackage", function() { return BuildPackage; });
__webpack_require__.d(uiactions_namespaceObject, "ComponentApiKeys", function() { return ComponentApiKeys; });
__webpack_require__.d(uiactions_namespaceObject, "UPDATE_GRAPH_TITLE", function() { return UPDATE_GRAPH_TITLE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_NODE", function() { return NEW_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "REMOVE_NODE", function() { return REMOVE_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_LINK", function() { return NEW_LINK; });
__webpack_require__.d(uiactions_namespaceObject, "CHANGE_NODE_TEXT", function() { return CHANGE_NODE_TEXT; });
__webpack_require__.d(uiactions_namespaceObject, "CURRENT_GRAPH", function() { return CURRENT_GRAPH; });
__webpack_require__.d(uiactions_namespaceObject, "GRAPH_SCOPE", function() { return GRAPH_SCOPE; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_DEFAULT_PROPERTIES", function() { return ADD_DEFAULT_PROPERTIES; });
__webpack_require__.d(uiactions_namespaceObject, "CHANGE_APP_SETTINGS", function() { return CHANGE_APP_SETTINGS; });
__webpack_require__.d(uiactions_namespaceObject, "CHANGE_NODE_PROPERTY", function() { return CHANGE_NODE_PROPERTY; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_PROPERTY_NODE", function() { return NEW_PROPERTY_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_PERMISSION_NODE", function() { return NEW_PERMISSION_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_ATTRIBUTE_NODE", function() { return NEW_ATTRIBUTE_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_LINK_BETWEEN_NODES", function() { return uiactions_ADD_LINK_BETWEEN_NODES; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_TO_GROUP", function() { return ADD_TO_GROUP; });
__webpack_require__.d(uiactions_namespaceObject, "ESTABLISH_SCOPE", function() { return ESTABLISH_SCOPE; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_LINKS_BETWEEN_NODES", function() { return ADD_LINKS_BETWEEN_NODES; });
__webpack_require__.d(uiactions_namespaceObject, "UPDATE_NODE_DIRTY", function() { return UPDATE_NODE_DIRTY; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_CONDITION_NODE", function() { return NEW_CONDITION_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_NEW_NODE", function() { return ADD_NEW_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "REMOVE_LINK_BETWEEN_NODES", function() { return uiactions_REMOVE_LINK_BETWEEN_NODES; });
__webpack_require__.d(uiactions_namespaceObject, "REMOVE_LINK", function() { return REMOVE_LINK; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_CHOICE_ITEM_NODE", function() { return NEW_CHOICE_ITEM_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NO_OP", function() { return NO_OP; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_PARAMETER_NODE", function() { return NEW_PARAMETER_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_FUNCTION_OUTPUT_NODE", function() { return NEW_FUNCTION_OUTPUT_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_MODEL_ITEM_FILTER", function() { return NEW_MODEL_ITEM_FILTER; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_AFTER_METHOD", function() { return NEW_AFTER_METHOD; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_VALIDATION_ITEM_NODE", function() { return NEW_VALIDATION_ITEM_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_CHOICE_TYPE", function() { return NEW_CHOICE_TYPE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_VALIDATION_TYPE", function() { return NEW_VALIDATION_TYPE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_OPTION_ITEM_NODE", function() { return NEW_OPTION_ITEM_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_OPTION_NODE", function() { return NEW_OPTION_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_CUSTOM_OPTION", function() { return NEW_CUSTOM_OPTION; });
__webpack_require__.d(uiactions_namespaceObject, "UPDATE_NODE_PROPERTY", function() { return UPDATE_NODE_PROPERTY; });
__webpack_require__.d(uiactions_namespaceObject, "UPDATE_GROUP_PROPERTY", function() { return UPDATE_GROUP_PROPERTY; });
__webpack_require__.d(uiactions_namespaceObject, "CONNECT_TO_TITLE_SERVICE", function() { return CONNECT_TO_TITLE_SERVICE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_DATA_SOURCE", function() { return NEW_DATA_SOURCE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_COMPONENT_NODE", function() { return NEW_COMPONENT_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_PERMISSION_PROPERTY_DEPENDENCY_NODE", function() { return NEW_PERMISSION_PROPERTY_DEPENDENCY_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_EXTENSION_LIST_NODE", function() { return NEW_EXTENSION_LIST_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_EXTENTION_NODE", function() { return NEW_EXTENTION_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "NEW_SCREEN_OPTIONS", function() { return NEW_SCREEN_OPTIONS; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_EXTENSION_DEFINITION_CONFIG_PROPERTY", function() { return ADD_EXTENSION_DEFINITION_CONFIG_PROPERTY; });
__webpack_require__.d(uiactions_namespaceObject, "APPLY_FUNCTION_CONSTRAINTS", function() { return APPLY_FUNCTION_CONSTRAINTS; });
__webpack_require__.d(uiactions_namespaceObject, "ADD_NEW_REFERENCE_NODE", function() { return ADD_NEW_REFERENCE_NODE; });
__webpack_require__.d(uiactions_namespaceObject, "UPDATE_LINK_PROPERTY", function() { return UPDATE_LINK_PROPERTY; });
__webpack_require__.d(uiactions_namespaceObject, "SET_DEPTH", function() { return SET_DEPTH; });
__webpack_require__.d(uiactions_namespaceObject, "PerformGraphOperation", function() { return PerformGraphOperation; });
__webpack_require__.d(uiactions_namespaceObject, "executeGraphOperation", function() { return executeGraphOperation; });
__webpack_require__.d(uiactions_namespaceObject, "GetNodesLinkTypes", function() { return GetNodesLinkTypes; });
__webpack_require__.d(uiactions_namespaceObject, "addInstanceFunc", function() { return addInstanceFunc; });
__webpack_require__.d(uiactions_namespaceObject, "executeGraphOperations", function() { return executeGraphOperations; });
__webpack_require__.d(uiactions_namespaceObject, "selectAllConnected", function() { return selectAllConnected; });
__webpack_require__.d(uiactions_namespaceObject, "selectAllInViewPackage", function() { return selectAllInViewPackage; });
__webpack_require__.d(uiactions_namespaceObject, "pinSelected", function() { return pinSelected; });
__webpack_require__.d(uiactions_namespaceObject, "addAllOfType", function() { return addAllOfType; });
__webpack_require__.d(uiactions_namespaceObject, "unPinSelected", function() { return unPinSelected; });
__webpack_require__.d(uiactions_namespaceObject, "deleteAllSelected", function() { return deleteAllSelected; });
__webpack_require__.d(uiactions_namespaceObject, "setViewPackageStamp", function() { return uiactions_setViewPackageStamp; });
__webpack_require__.d(uiactions_namespaceObject, "graphOperation", function() { return graphOperation; });
__webpack_require__.d(uiactions_namespaceObject, "updateGraph", function() { return updateGraph; });
__webpack_require__.d(uiactions_namespaceObject, "GetRecording", function() { return GetRecording; });
__webpack_require__.d(uiactions_namespaceObject, "clearRecording", function() { return clearRecording; });
__webpack_require__.d(uiactions_namespaceObject, "Colors", function() { return Colors; });
var remoteActions_namespaceObject = {};
__webpack_require__.r(remoteActions_namespaceObject);
__webpack_require__.d(remoteActions_namespaceObject, "openGraph", function() { return openGraph; });
__webpack_require__.d(remoteActions_namespaceObject, "toggleContextMenu", function() { return toggleContextMenu; });
__webpack_require__.d(remoteActions_namespaceObject, "toggleVisualKey", function() { return toggleVisualKey; });
__webpack_require__.d(remoteActions_namespaceObject, "setRightMenuTab", function() { return setRightMenuTab; });
__webpack_require__.d(remoteActions_namespaceObject, "openRedQuickBuilderGraph", function() { return openRedQuickBuilderGraph; });
__webpack_require__.d(remoteActions_namespaceObject, "openRedQuickBuilderTheme", function() { return openRedQuickBuilderTheme; });
__webpack_require__.d(remoteActions_namespaceObject, "newRedQuickBuilderGraph", function() { return newRedQuickBuilderGraph; });
__webpack_require__.d(remoteActions_namespaceObject, "newGraph", function() { return newGraph; });
__webpack_require__.d(remoteActions_namespaceObject, "RED_QUICK_FILE_EXT", function() { return RED_QUICK_FILE_EXT; });
__webpack_require__.d(remoteActions_namespaceObject, "RED_QUICK_FILE_EXT$", function() { return RED_QUICK_FILE_EXT$; });
__webpack_require__.d(remoteActions_namespaceObject, "RED_QUICK_FILE_RECORDING_EXT", function() { return RED_QUICK_FILE_RECORDING_EXT; });
__webpack_require__.d(remoteActions_namespaceObject, "RED_QUICK_FILE_RECORDING_EXT$", function() { return RED_QUICK_FILE_RECORDING_EXT$; });
__webpack_require__.d(remoteActions_namespaceObject, "RED_QUICK_FILE_THEME_EXT", function() { return RED_QUICK_FILE_THEME_EXT; });
__webpack_require__.d(remoteActions_namespaceObject, "RED_QUICK_FILE_THEME_EXT$", function() { return RED_QUICK_FILE_THEME_EXT$; });
__webpack_require__.d(remoteActions_namespaceObject, "saveGraphToFile", function() { return saveGraphToFile; });
__webpack_require__.d(remoteActions_namespaceObject, "saveRecording", function() { return saveRecording; });
__webpack_require__.d(remoteActions_namespaceObject, "saveTheme", function() { return saveTheme; });
__webpack_require__.d(remoteActions_namespaceObject, "saveGraph", function() { return saveGraph; });
__webpack_require__.d(remoteActions_namespaceObject, "setRemoteState", function() { return setRemoteState; });
__webpack_require__.d(remoteActions_namespaceObject, "saveCurrentGraph", function() { return saveCurrentGraph; });
__webpack_require__.d(remoteActions_namespaceObject, "setWorkingDirectory", function() { return setWorkingDirectory; });
var ipcActions_namespaceObject = {};
__webpack_require__.r(ipcActions_namespaceObject);
__webpack_require__.d(ipcActions_namespaceObject, "publishFiles", function() { return publishFiles; });
__webpack_require__.d(ipcActions_namespaceObject, "scaffoldProject", function() { return scaffoldProject; });
var counter_namespaceObject = {};
__webpack_require__.r(counter_namespaceObject);
__webpack_require__.d(counter_namespaceObject, "INCREMENT_COUNTER", function() { return INCREMENT_COUNTER; });
__webpack_require__.d(counter_namespaceObject, "DECREMENT_COUNTER", function() { return DECREMENT_COUNTER; });
__webpack_require__.d(counter_namespaceObject, "increment", function() { return increment; });
__webpack_require__.d(counter_namespaceObject, "decrement", function() { return decrement; });
__webpack_require__.d(counter_namespaceObject, "incrementIfOdd", function() { return incrementIfOdd; });
__webpack_require__.d(counter_namespaceObject, "incrementAsync", function() { return incrementAsync; });

// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__("react");
var external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);

// EXTERNAL MODULE: external "react-dom"
var external_react_dom_ = __webpack_require__("react-dom");

// EXTERNAL MODULE: external "react-hot-loader"
var external_react_hot_loader_ = __webpack_require__("react-hot-loader");

// EXTERNAL MODULE: external "react-redux"
var external_react_redux_ = __webpack_require__("react-redux");

// EXTERNAL MODULE: ./node_modules/connected-react-router/lib/index.js
var connected_react_router_lib = __webpack_require__("./node_modules/connected-react-router/lib/index.js");

// EXTERNAL MODULE: external "react-router"
var external_react_router_ = __webpack_require__("react-router");

// EXTERNAL MODULE: ./app/constants/routes.json
var constants_routes = __webpack_require__("./app/constants/routes.json");

// CONCATENATED MODULE: ./app/containers/App.js
var REACT_ELEMENT_TYPE;

function _jsx(type, props, key, children) { if (!REACT_ELEMENT_TYPE) { REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class App_App extends external_react_["Component"] {
  render() {
    const {
      children
    } = this.props;
    return _jsx(external_react_["Fragment"], {}, void 0, children);
  }

}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.function.bind.js
var es6_function_bind = __webpack_require__("./node_modules/core-js/modules/es6.function.bind.js");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __webpack_require__("./node_modules/core-js/modules/web.dom.iterable.js");

// EXTERNAL MODULE: external "react-router-dom"
var external_react_router_dom_ = __webpack_require__("react-router-dom");

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__("os");

// EXTERNAL MODULE: external "async_hooks"
var external_async_hooks_ = __webpack_require__("async_hooks");

// EXTERNAL MODULE: external "redux"
var external_redux_ = __webpack_require__("redux");

// CONCATENATED MODULE: ./app/utils/array.js

function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    let r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

(array => {
  if (!array.relativeCompliment) {
    var extrasection_relativeCompliment = {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (othercollection, func, output) {
        var collection = this;
        var result = [];

        func = func || function (x, y) {
          return x === y;
        };

        for (var i = collection.length; i--;)
        /**/
        {
          //function (x) { return x == collection[i]; }
          if (!othercollection.some(func.bind(null, collection[i]))) {
            result.push(collection[i]);
          } else if (output) {
            output.push(collection[i]);
          }
        }

        return result;
      }
    };

    if (!array.relativeCompliment) {
      Object.defineProperty(array, 'relativeCompliment', extrasection_relativeCompliment);
    }
  }

  if (!array.intersection) {
    Object.defineProperty(array, 'intersection', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (othercollection, func) {
        var collection = this;
        var result = [];

        func = func || function (x, y) {
          return x === y;
        };

        for (var i = collection.length; i--;)
        /**/
        {
          for (var j = othercollection.length; j--;)
          /**/
          {
            if (func(othercollection[j], collection[i])) {
              result.push(collection[i]);
              break;
            }
          }
        }

        return result;
      }
    });
  }

  if (!array.unique) {
    Object.defineProperty(array, 'unique', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var result = [];
        var finalresult = [];

        func = func || function (x) {
          return x;
        };

        var collection = this;

        for (var i = 0; i < collection.length; i++) {
          //if (func(collection[i])) {
          if (result.indexOf(func(collection[i])) === -1) {
            result.push(func(collection[i]));
            finalresult.push(collection[i]);
          } //}

        }

        return finalresult; //return result;
      }
    });
  }

  if (!array.removeIndices) {
    //removeIndices
    Object.defineProperty(array, 'removeIndices', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (indices) {
        indices = indices.orderBy(function (x, y) {
          return y - x;
        });
        var collection = this;
        indices.map(function (index) {
          collection.splice(index, 1);
        });
        return collection;
      }
    });
  }

  if (!array.interpolate) {
    Object.defineProperty(array, 'interpolate', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (start, stop, func) {
        var collection = this;

        func = func || function (x) {
          return x;
        };

        for (var i = start; i < stop; i++) {
          if (collection instanceof Float32Array) {
            collection[i - start] = func(i);
          } else collection.push(func(i, i - start));
        }

        return collection;
      }
    });
  }

  if (!array.flatten) {
    //non recursive flatten deep using a stack
    Object.defineProperty(array, 'flatten', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function () {
        let input = this;
        const stack = [...input];
        const res = [];

        while (stack.length) {
          // pop value from stack
          const next = stack.pop();

          if (Array.isArray(next)) {
            // push back array items, won't modify the original input
            stack.push(...next);
          } else {
            res.push(next);
          }
        } //reverse to restore input order


        return res.reverse();
      }
    });
  }

  if (!array.orderBy) {
    Object.defineProperty(array, 'orderBy', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var collection = this.map(function (x) {
          return x;
        });
        return collection.sort(func);
      }
    });
  }

  ;

  if (!array.groupBy) {
    Object.defineProperty(array, 'groupBy', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var collection = this;
        var result = {};

        for (var i = 0; i < collection.length; i++) {
          var t = func(collection[i]);
          result[t] = result[t] || [];
          result[t].push(collection[i]);
        }

        return result;
      }
    });
  }

  if (!array.subset) {
    Object.defineProperty(array, 'subset', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (start, stop) {
        var collection = this;
        stop = Math.min(collection.length, stop === undefined || stop === null ? collection.length : stop);
        start = Math.min(collection.length, start === undefined || start === null ? collection.length : start);
        start = start < 0 ? 0 : start;
        stop = stop < 0 ? 0 : stop;
        var result = this instanceof Float32Array ? new Float32Array(stop - start) : [];

        for (var i = start; i < stop; i++) {
          if (this instanceof Float32Array) {
            result[i - start] = collection[i];
          } else {
            result.push(collection[i]);
          }
        }

        return result;
      }
    });
  }

  if (!array.maxSelection) {
    Object.defineProperty(array, 'maxSelection', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var result = null;
        var _result = null;
        var collection = this;

        for (var i = 0; i < collection.length; i++) {
          let temp = func(collection[i]);

          if (result == null || temp > result) {
            result = temp;
            _result = collection[i];
          }
        }

        return _result;
      }
    });
  }

  if (!array.maximum) {
    Object.defineProperty(array, 'maximum', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var result = null;
        var _result = null;
        var collection = this;

        func = func || function (x) {
          return x;
        };

        for (var i = 0; i < collection.length; i++) {
          let temp = func(collection[i], i);

          if (result == null || temp > result) {
            result = temp;
            _result = collection[i];
          }
        }

        return result;
      }
    });
  }

  if (!array.minimum) {
    Object.defineProperty(array, 'minimum', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var result = null;
        var _result = null;
        var collection = this;
        var val;

        func = func || function (x) {
          return x;
        };

        for (var i = 0; i < collection.length; i++) {
          val = func(collection[i], i);

          if (result == null || val < result) {
            result = val;
            _result = collection[i];
          }
        }

        return result;
      }
    });
  }

  if (!array.summation) {
    Object.defineProperty(array, 'summation', {
      enumerable: false,
      writable: true,
      configurable: true,
      value: function (func) {
        var result = 0;
        var collection = this;

        for (var i = 0; i < collection.length; i++) {
          result = func(collection[i], result, i, collection.length);
        }

        return result;
      }
    });
  }
})(Array.prototype);

String.prototype.toJavascriptName = function () {
  var str = this || '';

  if (str[0]) {
    try {
      return str[0].toLowerCase() + str.split('').subset(1).join('');
    } catch (e) {
      console.log(str);
      console.log(str.length);
    }
  }

  return str;
};

const NEW_LINE = `
`;

Array.prototype.tightenPs = function () {
  var str = this || '';
  return str.join(NEW_LINE).split(NEW_LINE).filter(x => x.trim()).join(NEW_LINE);
};

function addNewLine(str, count) {
  let spaces = [].interpolate(0, count || 1, () => `    `).join('');
  return ((str ? NEW_LINE + spaces : '') + (str || '')).split(NEW_LINE).filter(x => x.trim()).join(NEW_LINE + spaces);
}
// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__("util");

// CONCATENATED MODULE: ./app/components/titles.js
const AddNode = "Add Node";
const RemoveNode = "Remove Node";
const RemoveValidation = "Remove Validation";
const RemoveExecution = "Remove Execution";
const Copy = "Copy";
const CopyExecution = "Copy Execution";
const SelectValidation = "Select Validation";
const SelectExecution = "Select Execution";
const SelectedValidations = "Selected Validations";
const Remove = "Remove";
const GraphOperations = "Graph Operations";
const AgentBaseMethods = "Agent Based Methods";
const LinkType = "Link Type";
const DefaultViewModel = "Default View Model";
const AddServiceInterfaceMenu = "Add Interface Method";
const AddDefaults = "Add Defaults";
const Type = "Type";
const EventType = "Event Type";
const titles_UIParameters = "UI Parameters";
const IsFetchOutput = "Is Fetch Output";
const GridAreas = "Grid Areas";
const MethodThatValidationComesFrom = 'Method validation source';
const LoadModelsOnComponentMount = 'Load Models On Component Mount';
const GridRow = "GridRow";
const Rows = "Row Count";
const Navigation = "Navigation";
const ComponentTag = 'Component Tag';
const Font = 'Font';
const FontCss = 'Font Css Specification';
const FontCssVar = 'Font Css Variable name';
const Variable = 'Variable';
const MediaSizes = 'Media Sizes';
const Variables = 'Variables';
const GridTemplateRows = 'Grid Template Rows';
const titles_GridPlacement = 'Grid Placement';
const GridTemplateColumns = 'Grid Template Columns';
const Fonts = 'Fonts';
const SpaceTheme = 'Space Theme';
const LinkProperties = 'Link Properties';
const OtherUses = 'CSS Variables';
const ColorUse = 'Color Use';
const BindAll = 'Bind All';
const UseHttps = "Use Https";
const Parameter = "Parameter";
const SelectTargetScreen = '[Select Target Screen]';
const SetupViewType = 'Setup View Type';
const Parameters = "Parameters";
const ServerSideSetup = "Service Side Setup";
const Titles = 'Titles';
const Theme = "Theme";
const Languages = 'Languages';
const OnlyUntranslated = 'Only Untranslated';
const Properties = "Properties";
const Key = "Key";
const titles_EventHandlerActivityMenu = "Event Handlers";
const AddCondition = "Add Condition";
const Style = "Style";
const FormStyle = 'Form';
const Body = "Body";
const UseInstanceType = "Use Instance Type";
const Paste = "Paste";
const AsOutput = "As output";
const AddComponentDidMount = "Add Event ComponentDidMount";
const SelectorType = "Selector Type";
const AuthorizedDashboard = 'Authorized Dashboard';
const GraphPropertiesMenu = "Graph Properties";
const Execute = "Execute";
const Cancel = "Cancel";
const CopyToAll = "Copy To All";
const ViewTypes = "View Types";
const List = "List";
const All = "All";
const DataChain = "Data Chain";
const Styling = "Styling";
const SetFetchServiceOutput = "Set Fetch Service Output";
const AddMethod = "Add Method";
const FontFamily = 'Font Family';
const FontSource = 'Font Source';
const FontSize = 'Font Size';
const Color = 'Color';
const FontWeight = 'Font Weight';
const FontStyle = 'Font Style';
const FontVariant = 'Font Variant';
const titles_ComponentPropertyMenu = "Component Properties";
const titles_ComponentAPIMenu = "Component API";
const Domain = "Domain";
const ClientMethod = "Client Method";
const Layout = "Layout";
const CSEntryPoint = "C# Entry Point";
const CSharp = "C#";
const NodeLabel = "Node Label";
const NodeType = "Node Type";
const ComponentModel = "Component Model";
const EntryPoint = "Entry Point";
const Nodes = "Nodes";
const Models = "Models";
const MethodName = "Method Name";
const OutputModel = "Output Model";
const AddComponentNew = "Add Component";
const ReattachComponent = "Reattach Component";
const Height = "Height";
const Get_Object_Agent_Value__IListObject_By_Specific = "Get Specific Items";
const Component = "Component";
const AddDataSource = "Add Data Source";
const ComponentType = "Component Type";
const ConditionType = "Condition Type";
const Width = "Width";
const titles_QuickMethods = "Quick Methods";
const Reference = "Reference";
const Depth = "Depth";
const Label = "Label";
const SetupLayout = "Setup Layout";
const New = "New";
const FlexDirection = "Flex Direction";
const SetListItem = "Set List Item";
const ClearLayout = "Clear Layout";
const Flex = "Flex";
const Controllers = "Controllers";
const ServiceActivity = "Service Activity";
const CodeTypes = "Code Types";
const ProjectName = "Project Name";
const Project = "Project";
const NameSpace = "NameSpace";
const AddScreenOptions = "Add Screen Options";
const Pinned = "Pinned";
const PinnedShortCut = "Ctrl + p";
const Selected = "Selected";
const SelectedShortCut = "Ctrl + q";
const ColorScheme = "Color Scheme";
const EnableMenu = "Enable Menu";
const ExternalApi = "External Api";
const InternalApi = "Internal Api";
const ScreenOptions = "Screen Options";
const IsUrlParameter = "Is Url Parameter";
const AsLocalContext = "As local context";
const TitleService = "Title Service";
const UseInView = "Use In View";
const InternalApiConnection = "Internal Api Connection";
const Selector = "Selector";
const SelectorInput = "Selector Input";
const Collapsed = "Collapsed";
const MediaQuery = "Media Query";
const GenericLink = "General Link";
const OnLoad = "On Load";
const AddQueryMethodApi = "Add Query Api";
const ChildLink = "Child link";
const UseValue = "Use Value";
const OnFailureLink = "On failure result";
const Lambda = "Lambda";
const ExternalApiConnection = "External Api Connection";
const OnAction = "On Action";
const OnItemSelection = "On Item Selection";
const OnSuccessLink = "On Succesful result";
const UIType = "UI Type";
const SelectedExecutors = "Selected Executions";
const Priority = "Priority";
const Agents = "Agents";
const Parents = "Parents";
const UseAsRoot = "Use as top element";
const OnChange = " On Change";
const OnClick = "On Click";
const OnPress = "On Press";
const titles_SelectProperty = "Select Property";
const DisallowedEnums = "Disallowed values";
const ManyToMany = "Many 2 Many";
const Many2ManyProperties = "Many 2 Many Properties";
const FunctionVariables = "Function Variables";
const Methods = "Methods";
const AllowedEnums = "Allowed values";
const ModelActions = "Model Actions";
const SetDefaultPropertiesDescription = "Set default properties, on the node";
const SetDefaultProperties = "Set default props";
const AddProperty = "Add Property";
const CreateObjectDataSeed = "Create Object Data Seed";
const ComponentApi = "ComponentApi";
const UICheckBox = "UI Checkbox";
const PermissionsDependencyAttribute = "Permission Dependency Attribute";
const GeneratedConstants = "Generated Constants";
const KeyField = "Key fields, are used as constants through out the app.";
const SetFetchSericeAgent = "Set Service Agent";
const GeneratedMethodsConstants = "Generated Methods Constants";
const TargetModel = "Target Model";
const UseEnumeration = "Use Enumeration";
const Enumeration = "Enumeration";
const SharedControl = "Shared Component";
const AddInstance = "Add Instance";
const UseAsDefault = "Use as default";
const ConnectLifeCylceMethods = "Connect Lifecylce Method To Api Method";
const ConnectToDataChainResponseHandler = "Connect to DataChain response handler";
const ConnectToDataChainPrecallHandler = "Connect to DataChain precall handler";
const ConnectToDataChainCaller = 'Datachain Call';
const ConnectEventMethods = "ConnectEventMethods";
const PermissionServiceMethod = "Permission Service Method";
const AddComponentApi = "Add Component Api";
const AddComponentExtApi = "Add Component External Api";
const ExecutorServiceMethod = "Executor Service Method";
const ComponentApiConnection = "Connect Component Api";
const Details = 'Details';
const NavigateTo = "Navigate To";
const ValidatorServiceMethod = "Validator Service Method";
const Themes = 'Themes';
const PermissionDependsOnProperties = "Properties permissions depend on.";
const ViewPackage = "View Package";
const CodeUser = "Code User";
const NavigateBack = "Navigate Back";
const ConnectEventHandler = "Connect Event Handler";
const AddPropertyDescription = "Add a property to the model";
const AddAttribute = "Add Attribute";
const AddAttributeDescription = "Add an attribute to the property";
const UIName = "UI Name";
const UINameDescription = "The text that will be visible to the client.";
const UISingular = "UI Singular";
const MatchIds = "Match Ids";
const ConnectionExists = "Connection Exists";
const Unknown = "Unknown";
const PropertyValueType = "Property value type";
const PropertyModelType = "Property model type";
const AddReference = "Add reference node";
const FunctionSetup = "Function Setup";
const IsReferenceList = "Is Reference List";
const Common = "Common";
const AgentOperator = "Agent Operator";
const Enumerable = "Enumerable";
const Value = "Value";
const AppMenu = "Application Menu";
const Snip = "Snip";
const StandardLink = "Standard Link";
const Insert = "Insert";
const CodeName = "Code Name";
const ValueName = "Value Name";
const AgentName = "Agent Name";
const DataChainCollection = "Data Chain Collection";
const FileMenu = "File Menu";
const Code = "Code";
const QuickColor = 'Quick Color';
const MainNavigation = "Main Navigation";
const DataChainInput = 'Data Chain Input';
const AddParameter = "Add parameter";
const AddParameterDescription = "Parameters are the required things need for the function to execute successfully";
const AddFunctionOutput = "Add Function Output";
const Menu = "Menu";
const AddFunctionOutputDescription = "The output of the function";
const IsAgent = "Agent";
const IsOwnedByAgents = "Is Owned By Agents";
const IsOwnedByAgentsDescriptions = "That would mean any agent/model could own this object.";
const ComponentDidMount = "Component Did Mount";
const IsUser = "User";
const ParameterType = "Parameter Type";
const OwnedResources = "Owned Resources";
const AddAfterMethods = "Add after method";
const AddAfterMethodsDescription = "Adding an after method node, will allow you to append functions to execute after.";
const AddModelItemFilter = "Add model item filter";
const ConnectModelItemFilter = "Connect Model Item Filter";
const ClaimServiceRegistrationCalls = "Registration Calls Methods";
const ClaimServiceUpdateUserMethod = "Update User Methods";
const ExecuteButton = "Execute Button";
const AddModelItemFilterDescription = "Add model item filter for get functions";
const PermissionType = "Permissions";
const PermissionAttributes = "Permission Attributes";
const OwnedResourcesDescription = "Check if permissions are for resources owned by source model.";
const PermissionActions = "Permission Actions";
const PermissionValueType = "Permission Value Type";
const Permissions = {
  Create: "Create",
  Get: "Read",
  GetAll: "Read All",
  Getall: "Read All",
  Delete: "Delete",
  Getbyowner: "Get by owner",
  Update: "Update"
};
const ChoiceTypes = "Choice types";
const ChoiceListActions = "Choice Actions";
const AddChoice = "Add Choice";
const AddChoiceDescription = "Add choice type";
const AddPermissionDescription = "Permission nodes describe the ability of connected models on downstream models";
const AddPermission = "Add permission nodes";
const AddChoiceItem = "Add choice item";
const AddChoiceItemDescription = "Add a new choice item";
const Select = "Select";
const Close = "Close";
const ValidationListActions = "Validation Actions";
const AddValidationItem = "Add validation item";
const AddValidationItemDescription = "Add rule to validate user input.";
const UseUIValidations = "Use Validation";
const AddValidationList = "Add validation type";
const AddValidationListDescription = "Create a new shared validation list";
const ValidationItemActions = "Validation Item Actions";
const Add = "Add";
const Events = "Events";
const ValidationTypes = "Validation Types";
const ValidationType = "Validation Type";
const OptionListActions = "Option Actions";
const AddOptionItem = "Add option";
const AddOptionItemDescription = "Add a new option item";
const Name = "Name";
const OptionsType = "Option Types";
const UseCustomOption = "Use custom option";
const EnterName = "Enter Name";
const UseUIOptions = "Use options";
const AddOptionList = "Create a new option list";
const AddOptionListDescription = "Add option list description";
const DependentProperty = "Depends on";
const UseDependentProperty = "Has dependent property";
const UseUIExtensions = "Use Extensions";
const IncludedInList = "Included in list";
const IsEqualTo = "Is equal";
const UseEqualDescription = "Use equivalancy";
const UseEqual = "Use equal";
const IsEqualToDescription = "If value is equal, it will pass";
const ExcludedFromList = "Excluded from list";
const ExcludedFromListDescription = `The agent's id will have to be excluded from the list to be accepted`;
const IncludedInListDescription = `The agent's id will have to be included in the list to be accepted.`;
const ExtensionTypes = "Extension Types";
const AddExtensionList = "Create an extension list";
const AddExtensionListDescription = "Extension list customize dropdowns/lists.";
const ExtensionListTypeActions = "Extension List Actions";
const AddExtensionNode = "Add Extension";
const ExtensionOptions = "Extension(s)";
const ExtensionDefinitionTypes = "Extension Definition Types";
const AddExtensionNodeDescription = "Add extension node description";
const ExtensionDefinition = "Extension Definition";
const StitchEnd = "Stitch End";
const Extensions = "Extensions";
const titles_ExtensionDefinitionMenu = "Define custom extensions";
const ExtensionConfig = "Extension Config";
const DependsOn = "Depends On";
const UseId = "Use Id";
const NodeProperties = "Node Properties";
const IsHandler = "Is handler";
const InstanceType = "Instance Type";
const Input = "Input";
const Screen = "Screen";
const SelectorProperty = "Selector Property";
const NavigationAction = "Navigation Action";
const StateKey = "StateKey";
const Property = "Property";
const ModelKey = "ModelKey";
const ViewModel = "View Model";
const AddDataChain = "Add data chain";
const AddSelector = "Add Selector";
const SplitDataChain = "Split data chain";
const HandlerType = "Handler type";
const MergeChain = "Merge data chain";
const Condition = "Condition";
const DependsOnDescription = "Defines if a the property associated with this extension is visually dependent on the value of another property on the same object.";
const DependentPropertyDescription = "The property that the current property will be associated.";
const MatchingValue = "Matching Value";
const MatchingValueDescription = "The value that the associated property will have to equal, to enable the current property";
const PermissionImpl = "Permission Implementation";
const titles_Number = "Number";
const FunctionTypes = "Function Types";
const Create_Object_Agent_Many_to_Many_CompositeInput__Object = "Create Object by Agent M2M with Composite Input";
const Create_Object__Object = "Create Object => Object";
const Update_Object_With_User = "Update Object => Object";
const Create_Object_With_User = "Create Object with User";
const GetObjectsFromLIstOfIds = "Fetch Service compatible function";
const AddAllProperties = "Add all properties";
const ApplyCopyToAllProperties = `Apply 'copy' to all properties`;
const Get_ManyToMany_Agent_Value__IListChild = "Get Many to Many => IList<Child>";
const Create_ManyToMany_Agent_Value__IListChild = "Create Many to Many => IList<Child>";
const Update_ManyToMany_Agent_Value__IListChild = "Update Many to Many => IList<Child>";
const Delete_ManyToMany_Agent_Value__IListChild = "Delete Many to Many => IList<Child>";
const Create_Parent$Child_Agent_Value__IListChild = "Create Parent/Child => IList<Child>";
const Update_Parent$Child_Agent_Value__IListChild = "Update Parent/Child => IList<Child>";
const Get_Parent$Child_Agent_Value__IListChild = "Get Parent/Child => IList<Child>";
const Hover = "Hover";
const UseNavigationParams = "Use Navigation Params";
const Create_Object_Agent_Value__IListObject = "Create Object by Agent => IList<Object>";
const Update_Object_Agent_Value__IListObject = "Update Object by Agent => IList<Object>";
const Delete_Object_Agent_Value__IListObject = "Delete Object by Agent => IList<Object>";
const Get_Object_Agent_Value__IListObject = "Get Object by Agent => IList<Object>";
const Get_Agent_Value__IListObject = "Get Objects for an Agent";
const Can_Execute_Agent_Parent_In_Valid_List = "Can Execute Agent Parent In Valid List";
const AddButtonToComponent = "Add Button";
const AddMenu = 'AddMenu';
const AddTitleToComponent = "Add Title";
const Get_Object_Agent_Value__Object = "Get Object by Agent";
const Update_Object_Agent_Value__Object = "Update Object by Agent";
const Update_Object_Agent_Value__Object_With_Object = "Update Object by Agent with object";
const AddLifeCylceEvents = "Add Life Cycle Events";
const CopyPermissionConditions = "Copy Permission Conditions";
const CopyValidationConditions = "Copy Validation Conditions";
const Functions = "Functions";
const IncludeEventHandler = "Include Event Handler";
const Login = "Login";
const AddEvent = "Add Event";
const DeleteAllSelected = "Delete All Selected";
const SelectProperties = "Select Properties";
const SelectAllConnected = "Selected All Connected";
const SelectViewPackage = "Select View Package";
const PinSelected = "Pin Selected";
const UnPinSelected = "Unpin Selected";
const ClearMarked = "Clear Marked";
const Clear = "Clear";
const AddDataChainCollection = "Add Data Chain Collection Parent";
const SelectAll = "Select All";
const CreateComponents = "Create Components";
const Register = "Register";
const AsPlural = "As Plural";
const AddFunction = "Add function";
const MaestroDetails = "Maestro Details";
const Operations = "Operations";
const HttpMethod = "Http Methods";
const AddMaestros = "Add Maestro";
const HttpRoute = "Relative Http Route";
const NotIncludeInController = `Don't include in controller`;
const AsForm = "As Form";
const AsText = "As Text";
const CollectCookies = "Collect Cookies";
const Maestros = "Maestros";
const Collections = "Collections";
const SaveAs = "Save as ...";
const NoApiPrefix = "No api prefix";
const AddSharedViewModel = "Add Shared View Model";
const Save = "Save";
const Open = "Open";
const Record = "Record";
const MinimizeTypeMenu = "Minimize Types";
const HideTypeMenu = "Hide Types";
const Validator = "Validator";
const PublishFiles = "Publish Files";
const Scaffold = "Scaffold";
const SetWorkingDirectory = "Set Working Directory";
const CommonProperties = "Common Properties";
const titles_ModelActivityMenu = "Model Activity Menu";
const titles_MindMap = "Mind Map";
const titles_CodeView = "Code View";
const ParentTo = "Parent to";
const IsParent = "Is parent";
const IsCompositeInput = "Is composite input";
const ExcludeFromController = "Exclude from controller";
const UserModel = "User Model";
const PropertyGeneratedType = "Generated Type";
const ManyToManyNexus = "Many to many";
const ManyToManyExists = "Many to many item must exists";
const ManyToManyNexusModel = "Many to Many model";
const SaveThemeAs = 'Save theme as';
const SelectThemeFromFile = 'Select theme from file';
const ManyToManyNexusDescription = "This property will be a quick access for many to many relationships.";
const HasLogicalChildren = "Has logical children";
const LogicalChildrenTypes = "Logical children types";
const LogicalNieceTypes = "Logical niece types";
const HasLogicalChildrenDescription = "Children have references to this node, as some sort of logical parent.";
const HasLogicalNieces = "Has logical nieces";
const HasLogicalNiecesDescription = "Children have references to this node and others potentially as some sort of logical uncle/aunt. This is for many to many relationships.";
const UseModelAsType = "Use Model as Type";
const CustomFunction = "Custom Function";
const CustomFunctionDescription = "Function can be constructed in an internal graph.";
const AddNewSection = "Add New Section";
const Sections = "Sections";
const AddNewSectionDescription = "Adds a new section to the root graph.";
const titles_SectionEdit = "Enter sub graph name";
const DefaultGraphTitle = "Red Quick Graph";
const DefaultSubGraphTitle = "Red Quick Sub Graph";
const ClearPinned = "Clear Pinned";
const Filter = "Filter";
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__("fs");
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// CONCATENATED MODULE: ./app/constants/viewtypes.js
const viewtypes_ViewTypes = {
  Update: "Update",
  Delete: "Delete",
  Create: "Create",
  Get: "Get",
  GetAll: "GetAll"
};
// CONCATENATED MODULE: ./app/constants/nodetypes.js





const NodeTypes = {
  Concept: "concept",
  Model: "model",
  DataSource: "data-source",
  Property: "model-property",
  StateKey: "StateKey",
  ModelFilter: "model-filter",
  Struct: "struct",
  MethodApiParameters: "method-api-parameters",
  EventHandler: "EventHandler",
  ComponentApiConnector: "component-api-connector",
  ScreenContainer: "screen-container",
  Screen: "screen",
  EventMethod: "EventMethod",
  NavigationAction: "NavigationAction",
  Lists: "Lists",
  EventMethodInstance: "EventMethodInstance",
  LifeCylceMethod: "LifeCylceMethod",
  LifeCylceMethodInstance: "LifeCylceMethodInstance",
  Selector: "selector",
  ComponentApi: "ComponentApi",
  ComponentExternalApi: "ComponentExternalApi",
  ScreenCollection: "screen-collection",
  TitleService: "titleService",
  ScreenItem: "screen-item",
  Attribute: "attribute-property",
  ChoiceList: "choice-list",
  Permission: "permission",
  Configuration: "configuration",
  PermissionDependency: "permission-dependency",
  ComponentNode: "component-node",
  Condition: "condition",
  ModelItemFilter: "model-item-filter",
  Enumeration: "enumeration",
  //Basically a list of const string.
  // ChoiceListItem: 'choice-list-item',
  ValidationList: "validation-list",
  ValidationListItem: "validation-list-item",
  ViewType: "view-type",
  Validator: "validator",
  Executor: "executor",
  // performs the final acts or data manipulation.
  OptionList: "option-list",
  OptionListItem: "option-list-item",
  OptionCustom: "option-custom",
  ScreenOption: "screen-option",
  ExtensionTypeList: "extension-type-list",
  ExtensionType: "extension-type",
  Function: "function",
  Method: "method",
  //NGRX like effect
  AfterEffect: "after-effect",
  // executes after a method finishes successfully.
  Action: "action",
  //NGRX like action
  Parameter: "parameter",
  ClaimService: "ClaimService",
  FunctionOutput: "function-output",
  Controller: "controller",
  Maestro: "maestro",
  Services: "services",
  ReferenceNode: "referenceNode",
  //Is a standing for a node that is at a higher level,
  ClassNode: "class-node",
  DataChain: "data-chain",
  ServiceInterface: "service-interface",
  ServiceInterfaceMethod: "service-interface-method",
  ViewModel: "view-model",
  FetchService: "FetchService",
  Style: "Style",
  Theme: 'Theme',
  DataChainCollection: "DataChainCollection"
};
const NodeTypeIcons = {};
function GetNodeTypeIcon(type) {
  if (!NodeTypeIcons[type]) {
    let files = external_fs_default.a.readdirSync("./app/css/svg");
    Object.values(NodeTypes).map((key, index) => {
      NodeTypeIcons[key] = `./css/svg/${files[index % files.length]}`;
    });
  }

  return NodeTypeIcons[type];
}
const ExcludeDefaultNode = {
  [NodeTypes.Condition]: true,
  [NodeTypes.ModelItemFilter]: false
};
const GeneratedTypes = {
  ChangeParameter: "change-parameter",
  CSDataChain: "data-chain-cs",
  ChangeResponse: "change-response",
  Constants: "constants",
  Validators: "validator-generated",
  Permissions: "permissions-generated",
  Executors: "executors",
  ModelItemFilter: "model-item-filter",
  ModelReturn: "model-return",
  ModelGet: "model-get",
  ModelExceptions: "model-exceptions",
  StreamProcess: "stream-process",
  StreamProcessOrchestration: "stream-process-orchestration",
  CustomService: "custom-service" //  ValidationRule: 'validation-rule'

};
const ReactNativeTypes = {
  Screens: "screens",
  Navigation: "navigation",
  Keys: "keys",
  ControllerActions: "controller-actions",
  TitleService: 'title-service',
  Configuration: "configuration",
  Selectors: "selectors",
  DataChainFunctions: "data-chain",
  Lists: "lists"
};
const IdentityManagement = {
  RedQuickViews: "RedQuickViews"
};
const STANDARD_TEST_USING = ["Microsoft.VisualStudio.TestTools.UnitTesting", "RedQuick.Storage", "RedQuickCore.Worker", "Moq", "Autofac", "RedQuickCore.Worker.Hosts", "RedQuick.Configuration", "Microsoft.Extensions.Configuration.Json"];
const STANDARD_CONTROLLER_USING = ["RedQuick.Data", "RedQuick.Attributes", "RedQuick.Interfaces", "RedQuick.Validation", "RedQuickCore.Identity", "RedQuickCore.Validation.Rules", "RedQuick.Interfaces.Arbiter", "RedQuick.Configuration", "RedQuick.Util", "RedQuick.Interfaces", "RedQuick.Interfaces.Data", "RedQuick.UI", "System", "System.Collections", "System.Collections.Generic", "System.Linq", "System.Net", "System.Net.Http", "System.Threading.Tasks"];
const nodetypes_GeneratedConstants = {
  Methods: "Methods",
  StreamTypes: "StreamType",
  FunctionName: "FunctionName"
};
const GeneratedTypesMatch = {
  [GeneratedTypes.ChangeParameter]: NodeTypes.Model
};
const ColorStates = {
  Error: "Error"
};
const NotSelectableNodeTypes = {
  [NodeTypes.ReferenceNode]: true,
  [NodeTypes.PermissionDependency]: true,
  [NodeTypes.Condition]: true
};
const NodeTypeColors = {
  [ColorStates.Error]: "#FF0000",
  [NodeTypes.Concept]: "#DD4B39",
  [NodeTypes.ModelItemFilter]: "#4ECDC4",
  [NodeTypes.ViewType]: "#412451",
  [NodeTypes.Model]: "#713E5A",
  [NodeTypes.Property]: "#484349",
  [NodeTypes.Screen]: "#3A405A",
  [NodeTypes.Attribute]: "#414770",
  [NodeTypes.ChoiceList]: "#457B9D",
  [NodeTypes.ValidationList]: "#A8DADC",
  [NodeTypes.ValidationListItem]: "#EA526F",
  [NodeTypes.Selector]: "#20063B",
  [NodeTypes.OptionList]: "#2EC4B6",
  [NodeTypes.OptionListItem]: "#856A5D",
  [NodeTypes.OptionCustom]: "#403F4C",
  [NodeTypes.ExtensionTypeList]: "#2C2B3C",
  [NodeTypes.ExtensionType]: "#1B2432",
  [NodeTypes.Method]: "#FE5F55",
  [NodeTypes.Permission]: "#383F51",
  [NodeTypes.Function]: "#553D36",
  [NodeTypes.Parameter]: "#684A52",
  [NodeTypes.FunctionOutput]: "#857885",
  [NodeTypes.Services]: "#59FFA0",
  [NodeTypes.ClassNode]: "#C3BAAA",
  [NodeTypes.Maestro]: "#780116",
  [NodeTypes.Condition]: "#CAFE48",
  [NodeTypes.Validator]: "#151522",
  [NodeTypes.ModelFilter]: "#312313",
  [NodeTypes.Executor]: "#2176FF",
  [NodeTypes.ReferenceNode]: "#F7B538",
  [NodeTypes.ScreenCollection]: "#A9DBB8",
  [NodeTypes.ScreenItem]: "#020887",
  [NodeTypes.ScreenContainer]: "#60B2E5",
  [NodeTypes.ComponentNode]: "#B7245C",
  [NodeTypes.DataSource]: "#002500",
  [NodeTypes.Condition]: "#F90093",
  [NodeTypes.DataChain]: "#FF6B6B",
  [NodeTypes.ServiceInterface]: "#4A6D7C",
  [NodeTypes.MethodApiParameters]: "#ff0001",
  [NodeTypes.ComponentApi]: "#E2C044",
  [NodeTypes.ComponentExternalApi]: "#2E5266",
  [NodeTypes.NavigationAction]: "#1282A2",
  [NodeTypes.Lists]: "#2DC7FF",
  [NodeTypes.ClaimService]: "#034748",
  [NodeTypes.FetchService]: "#BA1200",
  [NodeTypes.Style]: "#f12100",
  [NodeTypes.DataChainCollection]: "#2191FB"
};
const NavigateTypes = {
  Back: "GoBack",
  Replace: "Replace",
  Forward: "GoForward",
  Go: "Go"
};
const FunctionGroups = {
  External: "external",
  Internal: "internal",
  Core: "core"
};
const GroupProperties = {
  IsExternal: "isExternal",
  FunctionGroup: "FunctionGroup",
  GroupEntryNode: "GroupEntryNode",
  GroupExitNode: "GroupExitNode",
  ExternalExitNode: "ExternalExitNode",
  ExternalEntryNode: "ExternalEntryNode"
};
const nodetypes_NameSpace = {
  Model: ".Models",
  StreamProcess: ".ActionStream",
  Executors: ".Executors",
  Tests: ".Tests",
  Extensions: ".Extensions",
  Controllers: ".Controllers",
  Validations: ".Validations",
  Constants: ".Constants",
  Permissions: ".Permissions",
  Parameters: ".Parameters",
  Interface: ".Interface"
};
const MAIN_CONTENT = "MAIN_CONTENT";
const MIND_MAP = "MIND_MAP";
const CODE_VIEW = "CODE_VIEW";
const LAYOUT_VIEW = "LAYOUT_VIEW";
const TRANSLATION_VIEW = 'TRANSLATION_VIEW';
const THEME_VIEW = "THEME_VIEW";
const GeneratedDataTypes = {
  FirstName: "First Name",
  LastName: "Last Name",
  Name: "Name",
  Date: "Date",
  Id: "Id",
  Ids: "Ids",
  ProfileImage: "Profile Image",
  LoremIpsum: "Lorem-Ipsum",
  Guid: "Guid",
  ListOfGuids: "Guids",
  Number: "Number"
};
const ConfigurationProperties = {
  Domain: "Configuration_Domain"
};
const ApiNodeKeys = {
  ViewModel: "viewModel"
};
const SelectorPropertyKeys = {
  Dirty: "dirty",
  Focused: "focused",
  Focus: "focus",
  Object: "object",
  Blur: "blur"
};
const MediaQueries = {
  ["Extra small devices"]: "@media only screen and (max-width: 600px)",
  ["Small devices"]: "@media only screen and (min-width: 600px)",
  ["Media devices"]: "@media only screen and (min-width: 768px)",
  ["Large devices"]: "@media only screen and (min-width: 992px)",
  ["Extra devices"]: "@media only screen and (min-width: 1200px)"
};
const nodetypes_SelectorType = {
  InternalProperties: "InternalProperties"
};
const nodetypes_NodeProperties = {
  ViewPackage: "view-package",
  IsFetchOutput: "IsFetchOutput",
  IsFetchParameter: "IsFetchParameter",
  ViewModelKey: "ViewModelKey",
  StateKey: "StateKey",
  GridPlacement: "GridPlacement",
  GridRowCount: "GridRowCount",
  HoverStyle: ":hover",
  AsLocalContext: "AsLocalContext",
  ActiveStyle: ":active",
  Themes: 'Themes',
  SharedReferenceCollection: "SharedReferenceCollection",
  BeforeStyle: "::before",
  GridAreas: "GridAreas",
  AfterStyle: "::after",
  LastViewPackage: 'LastViewPackage',
  MediaQuery: "MediaQuery",
  UseMediaQuery: "UseMediaQuery",
  UseValue: "UseValue",
  CheckedStyle: ":checked",
  DisabledStyle: ":disabled",
  EmptyStyle: ":empty",
  EnabledStyle: ":enabled",
  FirstChildStyle: ":first-child",
  LastChildStyle: ":last-child",
  FocusStyle: ":focus",
  ReadOnlyStyle: ":read-only",
  DefaultComponentApiValue: "DefaultComponentApiValue",
  ExcludeFromGeneration: "ExcludeFromGeneration",
  ViewPackageTitle: "view-package-title",
  ComponentApi: "component-api",
  DefaultViewModel: "DefaultViewModel",
  SelectorType: "selector-type",
  UseInstanceType: "UseInstanceType",
  SharedComponent: "SharedComponent",
  EventType: "EventType",
  EnabledMenu: "EnabledMenu",
  InstanceType: "InstanceType",
  ComponentParameters: "ComponentParameters",
  NavigationParameters: "NavigationParameters",
  UseNavigationParams: "UseNavigationParams",
  ClientMethod: "ClientMethod",
  MethodParameters: "MethodParameters",
  NavigationParametersProperty: "NavigationParametersProperty",
  ExecuteButton: "ExecuteButton",
  MethodParameterProperty: "MethodParameterProperty",
  ScreenParameters: "ScreenParameters",
  Method: "Method",
  SelectedLayoutCell: "SelectedLayoutCell",
  ChainParent: "ChainParent",
  Navigation: "Navigation",
  ClientMethodParameters: "ClientMethodParameters",
  AsOutput: "AsOutput",
  EntryPoint: "EntryPoint",
  CSEntryPoint: "CSEntryPoint",
  CS: "CS",
  Property: "Property",
  DataChainEntry: "DataChainEntry",
  MergeChain: "MergeChain",
  ComponentProperties: "ComponentProperties",
  Layout: "Layout",
  Domain: "Domain",
  Priority: "Priority",
  DataChain: "DataChain",
  OnBlur: "onBlur",
  Selector: "Selector",
  ScreenOption: "ScreenOption",
  SelectorProperty: "SelectorProperty",
  Value: "Value",
  value: "value",
  Number: "Number",
  OnFocus: "onFocus",
  OnChange: "onChangeText",
  UIType: "UIType",
  TextType: "TextType",
  Enumeration: "Enumeration",
  ConditionType: "ConditionType",
  MatchReference: "MatchReference",
  MatchManyReferenceParameter: "MatchManyReferenceParameter",
  EnumerationReference: "EnumerationReference",
  AllowedExtensionValues: "AllowedExtensionValues",
  ServiceType: "ServiceType",
  DisallowedExtensionValues: "DisallowedExtensionValues",
  AllowedEnumValues: "AllowedEnumerationValue",
  DisallowedEnumValues: "DisallowedEnumValues",
  Condition: "Condition",
  ServiceTypeSettings: "ServiceTypeSettings",
  ValidatorModel: "ValidatorModel",
  ExecutorAgent: "ExecutorAgent",
  ExecutorFunction: "ExecutorFunction",
  ExecutorModel: "ExecutorModel",
  ExecutorModelOutput: "ExecutorModelOutput",
  ExecutorFunctionType: "ExecutorFunctionType",
  ValidatorFunction: "ValidatorFunction",
  UseEnumeration: "UseEnumeration",
  NameSpace: "namespace",
  FilterModel: "filtermodel",
  FilterAgent: "filteragent",
  Validator: "Validator",
  ModelItemFilter: "ModelItemFilter",
  Executor: "Executor",
  ValidatorAgent: "ValidatorAgent",
  Collapsed: "collapsed",
  UseExtension: "usextension",
  IncludedInList: "includedInList",
  IsShared: "IsShared",
  Pinned: "Pinned",
  UseInView: "UseInView",
  Selected: "Selected",
  ExcludedFromList: "excludedInList",
  UseEqual: "UseEqual",
  IsEqualTo: "IsEqualTo",
  CodeUser: "codeUser",
  HttpRoute: "HttpRoute",
  HttpMethod: "HttpMethod",
  ExcludeFromController: "ExcludeFromController",
  IsAgent: "isAgent",
  IsCompositeInput: "IsCompositeInput",
  IsParent: "isParent",
  //This is a program setting. Just for allowing us to hide and show the model picker.
  IsUser: "IsUser",
  //User is the object directly associated with a IdentityProvider.
  IsOwnedByAgents: "IsOwnedByAgents",
  UIUser: "uiUser",
  IsSharedResource: "isSharedResource",
  // Not sure if this helps anything.
  UIPermissions: "uiPermissions",
  IsOwned: "isOwned",
  UIName: "uiName",
  // The name used in the ui.
  QueryParameterObjectExtendible: "QueryParameterObjectExtendible",
  QueryParameterObject: "QueryParameterObject",
  QueryParameterParam: "QueryParameterParam",
  QueryParameterParamType: "QueryParameterParamType",
  TemplateParameter: "TemplateParameter",
  TemplateParameterType: "TemplateParameterType",
  IsQuery: "query",
  AutoDelete: "AutoDelete",
  // Anything matching the properties etc, will auto delete along with the current node.
  UriBody: "UriBody",
  UriParameter: "UriParameter",
  NodePackage: "NodePackage",
  NodePackageType: "NodePackageType",
  NodePackageAgent: "NodePackageAgent",
  IsPagingModel: "IsPagingModel",
  PagingSkip: "Skip",
  IsPaging: "IsPaging",
  PagingTake: "Take",
  PagingFilter: "Filter",
  PagingSort: "PagingSort",
  IsViewModel: "IsViewModel",
  // ComponentApiKey: 'ComponentApiKey',
  IsDataChainPagingSkip: "IsDataChainPagingSkip",
  IsDataChainPagingTake: "IsDataChainPagingTake",
  UIText: "text",
  UseAsValue: "UseAsValue",
  IsUrlParameter: "IsUrlParameter",
  NavigationAction: "NavigationAction",
  AgentBasedMethod: "AgentBasedMethod",
  ViewType: "view-type",
  IsReferenceList: "isReferenceList",
  UseHttps: "UseHttps",
  UISingular: "uiSingular",
  UIChoice: "uiChoice",
  UIChoiceType: "uiChoiceType",
  UIChoiceNode: "uiChoiceNode",
  //A node that the "parameter" node points to.
  PermissionRequester: "permissions-requester",
  // The agent that is requesting permission to do something
  PermissionManyToMany: "permissions-many-to-many",
  MatchIds: "matchs-ids",
  ConnectionExists: "connection-exists",
  PermissionTarget: "permissions-target",
  // Property has a dependent property
  UIDependsOn: "uiDependsOn",
  UseUIDependsOn: "UseuiDependsOn",
  UseUIOptions: "UseuiOptions",
  UIOptionType: "uiOptionType",
  //Use a custom option
  UseCustomUIOption: "useCustomUIOption",
  UIOptionTypeCustom: "uiOptionTypeCustom",
  //An option
  UIOption: "uiOption",
  //Use Extensions
  UseUIExtensionList: "UseuiExtensionList",
  UIExtensionList: "uiExtensionList",
  UIExtension: "uiExtension",
  UIExtensionDefinition: "uiExtensionDefinition",
  Label: "Label",
  Error: "Error",
  Placeholder: "Placeholder",
  Success: "Success",
  Style: "Style",
  MethodProps: "methodProperties",
  FilterPropreties: "filterproperties",
  UIValidationType: "uiValidationType",
  UseUIValidations: "UseuiValidations",
  NODEType: "nodeType",
  DefaultViewTypeGet: "DefaultViewTypeGet",
  DefaultViewTypeGetAll: "DefaultViewTypeGetAll",
  DefaultViewTypeUpdate: "DefaultViewTypeUpdate",
  DefaultViewTypeDelete: "DefaultViewTypeDelete",
  DefaultViewTypeCreate: "DefaultViewTypeCreate",
  ComponentType: "component-type",
  ReferenceType: "referenceType",
  //Reference nodes will have this type.
  ComponentDidMountEvent: "component-did-mount",
  UIAttributeType: "uiAttributeType",
  PermissionValueType: "PermissionValueType",
  UseModelAsType: "useModelAsType",
  IsDefaultProperty: "isDefaultProperty",
  ExecuteComponent: "ExecuteComponent",
  HasLogicalChildren: "hasLogicalChildren",
  LogicalChildrenTypes: "logicalChildrenTypes",
  HasLogicalNieces: "hasLogicalNieces",
  LogicalNieceTypes: "logicalNieceTypes",
  IsPluralComponent: "IsPluralComponent",
  DataGenerationType: "data-generation-type",
  ManyToManyNexus: "manyToManyNexux",
  ManyToManyNexusType: "manyToManyNexusType",
  ManyToManyNexusTypes: "manyToManyNexusTypes",
  MethodType: "MethodType",
  ChainNodeInput2: "ChainNodeInput2",
  ScreenInstance: "ScreenInstance",
  Model: "Model",
  Screen: "Screen",
  ChainNodeInput1: "ChainNodeInput1",
  List: "List",
  UIModelType: "uiModelType",
  IsTypeList: "IsTypeList",
  DataChainReferences: "DataChainReferences",
  Lambda: "Lambda",
  LambdaInsertArguments: "LambdaInsertArguments",
  ModelKey: "ModelKey",
  DataChainReference: "DataChainReference",
  NumberParameter: "NumberParameter",
  UseScopeGraph: "UseScopeGraph",
  ScopeGraph: "scopedGraph",
  DataChainFunctionType: "DataChainFunctionType",
  DataChainProperty: "DataChainProperty",
  QueryParameterType: "QueryParameterType",
  Component: "Component",
  AfterMethod: "after-method",
  AfterMethodSetup: "after-method-setup",
  //The name used for code.
  Groups: "groups",
  GroupParent: "groupParent",
  CodeName: "codeName",
  ValueName: "valueName",
  //The name of the instance variable to be used
  AgentName: "agentName",
  //The name of the instance variable to be used
  CodePropertyType: "codeProperty",
  FunctionType: "functionType",
  MethodFunctionValidation: "method-function-validation",
  NotIncludedInController: "not-included-in-controller",
  PermissionImpl: "permission-implementation",
  NoApiPrefix: "no-api-prefix",
  AsForm: "as-form",
  CollectCookies: "collect-cookies",
  AsText: "as-text",
  ClassConstructionInformation: "ClassConstructionInformation",
  DataChainCollection: "DataChainCollection"
};
const StyleNodeProperties = [nodetypes_NodeProperties.ActiveStyle, nodetypes_NodeProperties.HoverStyle, nodetypes_NodeProperties.CheckedStyle, nodetypes_NodeProperties.DisabledStyle, nodetypes_NodeProperties.EmptyStyle, nodetypes_NodeProperties.EnabledStyle, nodetypes_NodeProperties.FirstChildStyle, nodetypes_NodeProperties.LastChildStyle, nodetypes_NodeProperties.FocusStyle, nodetypes_NodeProperties.ReadOnlyStyle, nodetypes_NodeProperties.BeforeStyle, nodetypes_NodeProperties.AfterStyle];

function codeTypeWord(x) {
  if (typeof x === "string") {
    return x.split("").filter(y => "abcdefghijklmnopqrstuvwxyzzz1234567890_".indexOf(y.toLowerCase()) !== -1).join("");
  }

  return x;
}

const DIRTY_PROP_EXT = "$ _dirty_ $";
const NodePropertiesDirtyChain = {
  [nodetypes_NodeProperties.ServiceType]: [{
    chainProp: nodetypes_NodeProperties.CodeName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.AgentName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.ValueName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.UIName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.UIText,
    chainFunc: codeTypeWord
  }],
  [nodetypes_NodeProperties.UIText]: [{
    chainProp: nodetypes_NodeProperties.CodeName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.AgentName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.ValueName,
    chainFunc: codeTypeWord
  }, {
    chainProp: nodetypes_NodeProperties.HttpRoute,
    chainFunc: (x, node) => {
      if (typeof x === "string") {
        let template = [];

        if (uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType) === NodeTypes.Screen) {
          return GetScreenUrl(node, undefined, x);
        }

        return convertToURLRoute(x);
      }

      return x;
    }
  }, {
    chainProp: nodetypes_NodeProperties.UIName,
    chainFunc: x => {
      return x;
    }
  }, {
    chainProp: nodetypes_NodeProperties.Label,
    chainFunc: x => {
      return x;
    }
  }]
};
const letters = "abcdefghijklmnopqrstuvwxyz";
const alphanumerics = letters + "0123456789";
const allowedchars = alphanumerics + " ";
function MakeConstant(val) {
  if (val) {
    if (!isNaN(val)) {
      return `"${val}"`;
    }

    val = `${val}`;
    val = val.split("").filter(x => allowedchars.indexOf(x.toLowerCase()) !== -1).join("");

    if (letters.indexOf(val[0].toLowerCase()) === -1) {
      val = "_" + val;
    }

    return val.split(" ").join("_").toUpperCase();
  }

  throw "needs to have value";
}
function ConstantsDeclaration(options) {
  var {
    name,
    value
  } = options;
  return `public const string ${name} = ${value};`;
}
function CreateStringList(options) {
  var {
    name,
    list,
    instance
  } = options;
  return `${instance ? "" : "public"} IList<string> ${name} = new List<string> {
        ${list}
    }`;
}
const LinkEvents = {
  Remove: "remove"
};
const nodetypes_LinkType = {
  Choice: "choice",
  MethodApiParameters: "MethodApiParameters",
  DefaultViewType: "DefaultViewType",
  SharedComponent: "SharedComponent",
  // Connections to arguments used inside a lambda
  LambdaInsertArguments: "LambdaInsertArguments",
  ClaimServiceAuthorizationMethod: "ClaimServiceAuthorizationMethod",
  ClaimServiceUpdateUserMethod: "ClaimServiceUpdateUserMethod",
  ExecutorServiceMethod: "ExecutorServiceMethod",
  StateKey: "StateKey",
  LifeCylceMethodInstance: "LifeCylceMethodInstance",
  ModelKey: "ModelKey",
  ViewModelKey: "ViewModelKey",
  LifeCylceMethod: "LifeCylceMethod",
  ComponentApiConnector: "Component Api Connector",
  EventMethod: "EventMethod",
  UsingSharedComponent: "UsingSharedComponent",
  EventMethodInstance: "EventMethodInstance",
  NavigationMethod: "NavigationMethod",
  MethodCall: "MethodCall",
  ValidatorServiceMethod: "ValidatorServiceMethod",
  PermissionServiceMethod: "PermissionServiceMethod",
  ComponentApiConnection: "ComponentApiConnection",
  Lists: "Lists",
  EventHandler: "EventHandler",
  SharedComponentInstance: "SharedComponentInstance",
  Executor: "executor",
  ExecutorItem: "executor-item",
  ExecutorProperty: "executor-property",
  ServiceInterfaceMethod: "service-interface-method",
  ExecutorModel: "executor-model",
  Condition: "condtion",
  ModelItemFilter: "model-item-filter",
  AfterMethod: "after-method",
  Validation: "validation",
  ValidationItem: "validation-item",
  Validator: "validator",
  ValidatorProperty: "validator-property",
  ValidatorModel: "validator-model",
  Configuration: "configuration",
  ExecutorFunction: "executor-function",
  ValidatorFunction: "validator-function",
  ValidatorModelItem: "validator-model-item",
  ValidatorAgent: "validator-agent",
  Option: "option",
  OptionItem: "option-item",
  OptionCustom: "option-custom",
  DependsOn: "depends-on",
  ExtensionList: "extension-list",
  Extension: "extension",
  ScreenOptions: "screen-options",
  ListItem: "list-item",
  FetchService: "FetchService",
  FetchServiceOuput: "FetchServiceOuput",
  FetchSserviceAgent: "FetchSserviceAgent",
  Enumeration: "enumeration",
  ClientMethod: "ClientMethod",
  DataSource: "DataSource",
  ComponentApi: "ComponentApi",
  ComponentInternalConnection: "component-internal-connection",
  ComponentExternalConnection: "component-external-connection",
  ComponentExternalApi: "component-external-api",
  ComponentInternalApi: "component-internal-api",
  ViewModelLink: "view-model-link",
  Component: "component",
  DataChainInputLink: "DataChainInputLink",
  DataChainLink: "data-chain-link",
  PreDataChainLink: 'PreDataChainLink',
  CallDataChainLink: 'CallDataChainLink',
  QueryLink: "query-link",
  SelectorLink: "selector-link",
  SelectorInputLink: "selector-input-link",
  TitleServiceLink: "title-service-link",
  ComponentProperty: "component-link",
  EnumerationReference: "enumeration-reference",
  LogicalChildren: "logical-children",
  LogicalNieces: "logical-nieces",
  ManyToManyLink: "ManyToManyLink",
  Permission: "permission",
  AppliedPermissionLink: "applied-permission",
  RequestorPermissionLink: "request-permission-link",
  //the agent/node that is requesting permissions
  ManyToManyPermissionLink: "many-to-many-permission-link",
  ExtensionDependencyLink: "extension-dependency-link",
  FunctionOperator: "function-operator",
  FunctionLink: "function-link",
  OnScreenLink: "screen-link",
  OnSuccessLink: "on-success-link",
  OnFailureLink: "on-failure-link",
  OnAction: "on-action",
  ChildLink: "child-link",
  //describing a link between screens
  OnItemSelection: "on-item-selection",
  FunctionVariable: "function-variable",
  PropertyLink: "property-link",
  ParentLink: "parent-link",
  FunctionConstraintLink: "function-constraint-link",
  ErrorLink: "error-link",
  RequiredClassLink: "required-class-link",
  ModelTypeLink: "model-type-link",
  AgentTypeLink: "agent-type-link",
  UserLink: "user-link",
  // A link between a user and a personal ([Customer, Manager, Hero])
  MaestroLink: "maestro-link",
  AttributeLink: "attribute-link",
  PermissionFunction: "permission-function",
  Exist: "exist",
  //A node that points with this link type, requires that the node exists, if it doesn't the link and the other node should dissapear.
  PermissionPropertyDependency: "permission-property-dependency",
  //There is a link between a permision and a property.
  PermissionDependencyProperty: "permission-dependency-property",
  //There is a link bewteen a property and a dependency
  PermissionDependencyPropertyManyToManyLink: "permission-dependency-property-many-to-many",
  //There is a link between a property and a dependency in a many to many situation.
  PermissionPropertyDependencyManyToManyLink: "permission-property-dependency-many-to-many",
  //There is a link between a permision and a property in a many to many situnation.
  Style: "Style",
  DataChainCollection: "DataChainCollection",
  DataChainCollectionReference: "DataChainCollectionReference",
  DataChainStyleLink: 'DataChainStyleLink'
};
const VIKTIG_LINKS = 5;
const LinkStyles = {
  [nodetypes_LinkType.FunctionLink]: {
    type: nodetypes_LinkType.FunctionLink,
    stroke: NodeTypeColors[NodeTypes.Function]
  },
  [nodetypes_LinkType.ComponentInternalConnection]: {
    stroke: NodeTypeColors[NodeTypes.ComponentApi],
    type: nodetypes_LinkType.ComponentInternalConnection
  },
  [nodetypes_LinkType.DefaultViewType]: {
    type: nodetypes_LinkType.DefaultViewType
  },
  [nodetypes_LinkType.ErrorLink]: {
    type: nodetypes_LinkType.ErrorLink,
    stroke: NodeTypeColors[ColorStates.Error]
  },
  [nodetypes_LinkType.OnScreenLink]: {
    type: nodetypes_LinkType.OnScreenLink,
    stroke: "#E1CE7A",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.DataChainLink]: {
    type: nodetypes_LinkType.DataChainLink,
    stroke: "#33673B",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.SelectorLink]: {
    type: nodetypes_LinkType.SelectorLink,
    stroke: "#20063B"
  },
  [nodetypes_LinkType.OnSuccessLink]: {
    type: nodetypes_LinkType.OnSuccessLink,
    stroke: "#A23B72",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.OnFailureLink]: {
    type: nodetypes_LinkType.OnFailureLink,
    stroke: "#3B1F2B",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.OnItemSelection]: {
    type: nodetypes_LinkType.OnItemSelection,
    stroke: "#2E86AB",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.OnAction]: {
    type: nodetypes_LinkType.OnAction,
    stroke: "#A3320B",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.ChildLink]: {
    type: nodetypes_LinkType.ChildLink,
    stroke: "#47A025",
    strokeWidth: VIKTIG_LINKS
  },
  [nodetypes_LinkType.FunctionConstraintLink]: {
    type: nodetypes_LinkType.FunctionConstraintLink,
    stroke: NodeTypeColors[NodeTypes.Function]
  },
  [nodetypes_LinkType.FunctionOperator]: {
    type: nodetypes_LinkType.FunctionOperator,
    stroke: NodeTypeColors[NodeTypes.Function]
  },
  [nodetypes_LinkType.PropertyLink]: {
    type: nodetypes_LinkType.PropertyLink,
    stroke: NodeTypeColors[NodeTypes.Property]
  },
  [nodetypes_LinkType.Choice]: {
    type: nodetypes_LinkType.Choice,
    stroke: NodeTypeColors[NodeTypes.ChoiceList]
  },
  [nodetypes_LinkType.Permission]: {
    type: nodetypes_LinkType.Permission,
    stroke: NodeTypeColors[NodeTypes.Permission]
  },
  [nodetypes_LinkType.AppliedPermissionLink]: {
    type: nodetypes_LinkType.AppliedPermissionLink,
    stroke: NodeTypeColors[NodeTypes.Permission]
  },
  [nodetypes_LinkType.Validation]: {
    type: nodetypes_LinkType.Validation,
    stroke: NodeTypeColors[NodeTypes.ValidationList]
  },
  [nodetypes_LinkType.Validator]: {
    type: nodetypes_LinkType.Validator,
    stroke: NodeTypeColors[NodeTypes.Validator]
  },
  [nodetypes_LinkType.Option]: {
    type: nodetypes_LinkType.Option,
    stroke: NodeTypeColors[NodeTypes.OptionList]
  },
  // Options for custom defined options, that need to be made later.
  [nodetypes_LinkType.OptionCustom]: {
    type: nodetypes_LinkType.OptionCustom,
    stroke: NodeTypeColors[NodeTypes.OptionCustom]
  },
  [nodetypes_LinkType.DependsOn]: {
    type: nodetypes_LinkType.DependsOn,
    stroke: NodeTypeColors[NodeTypes.Property]
  },
  [nodetypes_LinkType.ExtensionList]: {
    type: nodetypes_LinkType.ExtensionList,
    stroke: NodeTypeColors[NodeTypes.ExtensionTypeList]
  },
  [nodetypes_LinkType.Extension]: {
    type: nodetypes_LinkType.Extension,
    stroke: NodeTypeColors[NodeTypes.ExtensionType]
  },
  //This link is between an extension with a dependsOn property
  // It describes a link between a property and a secondary property.
  [nodetypes_LinkType.ExtensionDependencyLink]: {
    type: nodetypes_LinkType.ExtensionDependencyLink,
    stroke: NodeTypeColors[NodeTypes.ExtensionTypeList]
  }
};
const LinkPropertyKeys = {
  TYPE: "type",
  CONSTRAINTS: "constraints",
  VALID_CONSTRAINTS: "valid-constraints",
  BeforeCall: 'BeforeCall',
  FUNCTION_ID: "function-id",
  InstanceUpdate: "InstanceUpdate",
  ComponentTag: "ComponentTag",
  ComponentStyle: 'ComponentStyle',
  ComponentProperty: "ComponentProperty",
  ViewType: "viewType",
  AsForm: "AsForm"
};
const nodetypes_LinkProperties = {
  SharedComponent: {
    type: nodetypes_LinkType.SharedComponent
  },
  LambdaInsertArguments: {
    type: nodetypes_LinkType.LambdaInsertArguments
  },
  ComponentApiConnector: {
    type: nodetypes_LinkType.ComponentApiConnector
  },
  DataChainCollection: {
    type: nodetypes_LinkType.DataChainCollection
  },
  DataChainCollectionReference: {
    type: nodetypes_LinkType.DataChainCollectionReference
  },
  DataChainStyleLink: {
    type: nodetypes_LinkType.DataChainStyleLink
  },
  LifeCylceMethodInstance: {
    type: nodetypes_LinkType.LifeCylceMethodInstance
  },
  ClaimServiceAuthorizationMethod: {
    type: nodetypes_LinkType.ClaimServiceAuthorizationMethod
  },
  ClaimServiceUpdateUserMethod: {
    type: nodetypes_LinkType.ClaimServiceUpdateUserMethod
  },
  ViewModelKey: {
    type: nodetypes_LinkType.ViewModelKey
  },
  ModelKey: {
    type: nodetypes_LinkType.ModelKey
  },
  StateKey: {
    type: nodetypes_LinkType.StateKey
  },
  MethodCall: {
    type: nodetypes_LinkType.MethodCall
  },
  LifeCylceMethod: {
    type: nodetypes_LinkType.LifeCylceMethod
  },
  EventMethod: {
    type: nodetypes_LinkType.EventMethod
  },
  EventMethodInstance: {
    type: nodetypes_LinkType.EventMethodInstance
  },
  NavigationMethod: {
    type: nodetypes_LinkType.NavigationMethod
  },
  MethodApiParameters: {
    type: nodetypes_LinkType.MethodApiParameters
  },
  PermissionServiceMethod: {
    type: nodetypes_LinkType.PermissionServiceMethod,
    nodeTypes: [NodeTypes.ServiceInterfaceMethod]
  },
  Lists: {
    type: nodetypes_LinkType.Lists
  },
  Style: {
    type: nodetypes_LinkType.Style
  },
  ComponentApiConnection: {
    type: nodetypes_LinkType.ComponentApiConnection
  },
  EventHandler: {
    type: nodetypes_LinkType.EventHandler
  },
  ExecutorServiceMethod: {
    type: nodetypes_LinkType.ExecutorServiceMethod,
    nodeTypes: [NodeTypes.ServiceInterfaceMethod]
  },
  ValidatorServiceMethod: {
    type: nodetypes_LinkType.ValidatorServiceMethod,
    nodeTypes: [NodeTypes.ServiceInterfaceMethod]
  },
  ServiceInterfaceMethod: {
    type: nodetypes_LinkType.ServiceInterfaceMethod
  },
  SharedComponentInstance: {
    type: nodetypes_LinkType.SharedComponentInstance
  },
  DefaultViewType: {
    type: nodetypes_LinkType.DefaultViewType
  },
  EnumerationLink: {
    type: nodetypes_LinkType.Enumeration
  },
  FetchService: {
    type: nodetypes_LinkType.FetchService
  },
  FetchSserviceAgent: {
    type: nodetypes_LinkType.FetchSserviceAgent
  },
  FetchServiceOuput: {
    type: nodetypes_LinkType.FetchServiceOuput
  },
  ClientMethodLink: {
    type: nodetypes_LinkType.ClientMethod
  },
  ComponentApi: {
    type: nodetypes_LinkType.ComponentApi
  },
  DataSourceLink: {
    type: nodetypes_LinkType.DataSource
  },
  ViewModelLink: {
    type: nodetypes_LinkType.ViewModelLink
  },
  ComponentInternalConnection: {
    type: nodetypes_LinkType.ComponentInternalConnection
  },
  ComponentExternalConnection: {
    type: nodetypes_LinkType.ComponentExternalConnection
  },
  ComponentExternalApi: {
    type: nodetypes_LinkType.ComponentExternalApi
  },
  ComponentInternalApi: {
    type: nodetypes_LinkType.ComponentInternalApi
  },
  SelectorLink: {
    type: nodetypes_LinkType.SelectorLink
  },
  SelectorInputLink: {
    type: nodetypes_LinkType.SelectorInputLink
  },
  TitleServiceLink: {
    type: nodetypes_LinkType.TitleServiceLink
  },
  QueryLink: {
    type: nodetypes_LinkType.QueryLink
  },
  DataChainLink: {
    type: nodetypes_LinkType.DataChainLink
  },
  DataChainInputLink: {
    type: nodetypes_LinkType.DataChainInputLink
  },
  PreDataChainLink: {
    type: nodetypes_LinkType.PreDataChainLink
  },
  CallDataChainLink: {
    type: nodetypes_LinkType.CallDataChainLink
  },
  ListItem: {
    type: nodetypes_LinkType.ListItem
  },
  ComponentLink: {
    type: nodetypes_LinkType.Component,
    stroke: NodeTypeColors[NodeTypes.ComponentNode]
  },
  ComponentPropertyLink: {
    type: nodetypes_LinkType.ComponentProperty,
    stroke: NodeTypeColors[NodeTypes.Property]
  },
  ScreenOptionsLink: {
    type: nodetypes_LinkType.ScreenOptions
  },
  ModelItemFilter: {
    type: nodetypes_LinkType.ModelItemFilter
  },
  AfterMethod: {
    type: nodetypes_LinkType.AfterMethod
  },
  EnumerationReferenceLink: {
    type: nodetypes_LinkType.EnumerationReference
  },
  ConditionLink: {
    type: nodetypes_LinkType.Condition
  },
  LogicalChildren: {
    type: nodetypes_LinkType.LogicalChildren
  },
  LogicalNieces: {
    type: nodetypes_LinkType.LogicalNieces
  },
  ManyToManyLink: {
    type: nodetypes_LinkType.ManyToManyLink
  },
  PermissionFunctionLink: {
    type: nodetypes_LinkType.PermissionFunction
  },
  FunctionVariable: {
    type: nodetypes_LinkType.FunctionVariable,
    [LinkPropertyKeys.FUNCTION_ID]: null
  },
  PermissionDependencyPropertyLink: {
    type: nodetypes_LinkType.PermissionDependencyProperty
  },
  PermissionDependencyPropertyManyToManyLink: {
    type: nodetypes_LinkType.PermissionDependencyPropertyManyToManyLink
  },
  PermissionPropertyDependencyLink: {
    type: nodetypes_LinkType.PermissionPropertyDependency
  },
  PermissionPropertyDependencyManyToManyLink: {
    type: nodetypes_LinkType.PermissionPropertyDependencyManyToManyLink
  },
  AttributeLink: {
    type: nodetypes_LinkType.AttributeLink
  },
  ExistLink: {
    exist: nodetypes_LinkType.Exist
  },
  ModelTypeLink: {
    type: nodetypes_LinkType.ModelTypeLink
  },
  AgentTypeLink: {
    type: nodetypes_LinkType.AgentTypeLink
  },
  RequiredClassLink: {
    type: nodetypes_LinkType.RequiredClassLink
  },
  OnScreenLink: {
    type: nodetypes_LinkType.OnScreenLink
  },
  OnSuccessLink: {
    type: nodetypes_LinkType.OnSuccessLink
  },
  OnFailureLink: {
    type: nodetypes_LinkType.OnFailureLink
  },
  OnItemSelection: {
    type: nodetypes_LinkType.OnItemSelection
  },
  OnAction: {
    type: nodetypes_LinkType.OnAction
  },
  ChildLink: {
    type: nodetypes_LinkType.ChildLink
  },
  FunctionLink: {
    type: nodetypes_LinkType.FunctionLink
  },
  FunctionOperator: {
    type: nodetypes_LinkType.FunctionOperator
  },
  FunctionConstraintLink: {
    type: nodetypes_LinkType.FunctionConstraintLink
  },
  ChoiceLink: {
    type: nodetypes_LinkType.Choice
  },
  PermissionLink: {
    type: nodetypes_LinkType.Permission
  },
  AppliedPermissionLink: {
    type: nodetypes_LinkType.AppliedPermissionLink
  },
  RequestorPermissionLink: {
    type: nodetypes_LinkType.RequestorPermissionLink
  },
  ManyToManyPermissionLink: {
    type: nodetypes_LinkType.ManyToManyPermissionLink
  },
  ValdationLink: {
    type: nodetypes_LinkType.Validation
  },
  ValidationLinkItem: {
    type: nodetypes_LinkType.ValidationItem
  },
  ValidatorAgentLink: {
    type: nodetypes_LinkType.ValidatorAgent
  },
  ValidatorModelLink: {
    type: nodetypes_LinkType.ValidatorModel
  },
  ValidatorModelItemLink: {
    type: nodetypes_LinkType.ValidatorModelItem
  },
  ValidatorPropertyLink: {
    type: nodetypes_LinkType.ValidatorProperty
  },
  ExecutorLink: {
    type: nodetypes_LinkType.Executor
  },
  ExecutorLinkItem: {
    type: nodetypes_LinkType.ExecutorItem
  },
  ExecutorAgentLink: {
    type: nodetypes_LinkType.ValidatorAgent
  },
  ExecutorModelLink: {
    type: nodetypes_LinkType.ExecutorModel
  },
  ExecutorModelItemLink: {
    type: nodetypes_LinkType.ValidatorModelItem
  },
  ExecutorPropertyLink: {
    type: nodetypes_LinkType.ValidatorProperty
  },
  ValidatorFunctionLink: {
    type: nodetypes_LinkType.ValidatorFunction
  },
  ExecutorFunctionLink: {
    type: nodetypes_LinkType.ExecutorFunction
  },
  OptionLink: {
    type: nodetypes_LinkType.Option
  },
  OptionItemLink: {
    type: nodetypes_LinkType.OptionItem
  },
  // Options for custom defined options, that need to be made later.
  OptionCustomLink: {
    type: nodetypes_LinkType.OptionCustom
  },
  DependsOnLink: {
    type: nodetypes_LinkType.DependsOn
  },
  ExtensionListLink: {
    type: nodetypes_LinkType.ExtensionList
  },
  ExtensionLink: {
    type: nodetypes_LinkType.Extension
  },
  //This link is between an extension with a dependsOn property
  // It describes a link between a property and a secondary property.
  ExtensionDependencyLink: {
    type: nodetypes_LinkType.ExtensionDependencyLink
  },
  PropertyLink: {
    type: nodetypes_LinkType.PropertyLink
  },
  ParentLink: {
    type: nodetypes_LinkType.ParentLink
  },
  UserLink: {
    type: nodetypes_LinkType.UserLink
  },
  MaestroLink: {
    type: nodetypes_LinkType.MaestroLink
  }
};
Object.keys(nodetypes_LinkProperties).map(propTypes => {
  if (nodetypes_LinkProperties[propTypes] && nodetypes_LinkProperties[propTypes].type) {
    nodetypes_LinkProperties[propTypes][nodetypes_LinkProperties[propTypes].type] = {};
  }
});
const nodetypes_Methods = {
  Create: "Create",
  Get: "Get",
  GetAll: "GetAll",
  Update: "Update",
  Delete: "Delete"
};
const ValidationVector = {
  Content: "content"
};
const UITypes = {
  ReactNative: "ReactNative",
  Web: "Web",
  VR: "VR",
  AR: "AR",
  ElectronIO: "ElectronIO"
};
const ValidationRules = {
  CVV: "cvv",
  AlphaNumericLike: "alphanumericlike",
  AlphaNumericPuncLike: "alphaNumericpunclike",
  AlphaOnly: "alphaonly",
  NumericOnly: "numericonly",
  Numeric: "numeric",
  Empty: "empty",
  AlphaOnlyWithSpaces: "alphaonlywithspaces",
  NotEmpty: "notempty",
  MaxLength: "maxlength",
  MinLength: "minLength",
  MaxLengthEqual: "maxlengthEqual",
  MinLengthEqual: "minLengthEqual",
  MaxValue: "maxValue",
  MinValue: "minValue",
  MaxValueEqual: "maxValueEqual",
  MinValueEqual: "minValueEqual",
  UrlEmpty: "url_empty",
  IsTrue: "is_true",
  IsFalse: "is_false",
  GreaterThan: "greater_than",
  GreaterThanOrEqualTo: "greater_than_equal_to",
  LessThan: "less_than",
  LessThanOrEqualTo: "less_than_equal_to",
  EqualTo: "equal_to",
  Any: "any",
  Url: "url",
  EmailEmpty: "email_empty",
  Credit: "credit",
  Email: "email",
  ExpirationMonth: "expirationMonth",
  BeforeNow: "beforenow",
  Year: "year",
  Debit: "debit",
  ExpirationYear: "expirationYear",
  PastDate: "pastdate",
  ZipEmpty: "zipempty",
  Zip: "zip",
  SocialSecurity: "socialsecurity",
  ListOfGuids: "listofguids",
  IsNull: "isNull",
  IsNotNull: "isNotNull",
  OneOf: "one-of"
};
const nodetypes_ExtensionDefinitionTypes = {
  DictionaryStringString: "DictionaryStringString",
  DictionaryStringDictionary: "DictionaryStringDictionary"
};
const CollectionTypes = {
  DebitCard: "DebitCard",
  Email: "Email",
  Telephone: "Telephone"
};
const OptionsTypes = {
  CHOICELIST: "CHOICELIST",
  CAPITALIZE_FIRST_LETTER: "CAPITALIZE_FIRST_LETTER"
};
const NodePropertyTypes = {
  STRING: "STRING",
  LISTOFSTRINGS: "LISTOFSTRINGS",
  DATETIME: "DATETIME",
  INT: "INT",
  FLOAT: "FLOAT",
  DOUBLE: "DOUBLE",
  BOOLEAN: "BOOLEAN",
  EMAIL: "EMAIL",
  PHONENUMBER: "PHONENUMBER"
};
const nodetypes_NEW_LINE = `
`;
const ProgrammingLanguages = {
  CSHARP: "csharp",
  JavaScript: "java-script"
};
const nodetypes_Languages = {
  [`US-English`]: 'US-English',
  [`NB-Norsk`]: 'NB-Norsk',
  [`FR-Francais`]: 'FR-Francais'
};
const LanguagesCode = {
  [`US-English`]: 'en',
  [`NB-Norsk`]: 'nb',
  [`FR-Francais`]: 'fr'
};
const NodePropertyTypesByLanguage = {
  [ProgrammingLanguages.CSHARP]: {
    [NodePropertyTypes.DATETIME]: "DateTime",
    [NodePropertyTypes.STRING]: "string",
    [NodePropertyTypes.LISTOFSTRINGS]: "IList<string>",
    [NodePropertyTypes.INT]: "int",
    [NodePropertyTypes.FLOAT]: "float",
    [NodePropertyTypes.DOUBLE]: "double",
    [NodePropertyTypes.BOOLEAN]: "bool",
    [NodePropertyTypes.EMAIL]: "Email",
    [NodePropertyTypes.PHONENUMBER]: "PhoneNumber"
  }
};
const RED_QUICK_DATA = "RedQuick.Data";
const RED_QUICK_ATTRIBUTES = "RedQuick.Attributes";
const Usings = {
  [ProgrammingLanguages.CSHARP]: {
    [NodePropertyTypes.EMAIL]: [RED_QUICK_DATA, RED_QUICK_ATTRIBUTES],
    [NodePropertyTypes.PHONENUMBER]: [RED_QUICK_DATA, RED_QUICK_ATTRIBUTES]
  }
};
const NodeAttributePropertyTypes = {
  ROUTINGNUMBER: "ROUTINGNUMBER",
  CURRENCY: "CURRENCY",
  CARMAKE: "CARMAKE",
  SOCIALSECURITY: "SOCIALSECURITY",
  EMAIL: "EMAIL",
  PHONE: "PHONE",
  CARMODEL: "CARMODEL",
  CARYEAR: "CARYEAR",
  VIN: "VIN",
  LONGSTRING: "LONGSTRING",
  CREDITCARD: "CREDITCARD",
  LENGTH: "LENGTH",
  INCH: "INCH",
  DIMENSION: "DIMENSION",
  MONEY: "MONEY",
  COUNTRY: "COUNTRY",
  DEBIT: "DEBIT",
  MONTH: "MONTH",
  STATE: "STATE",
  CHOICE: "CHOICE",
  NUMBER: "NUMBER",
  SLIDER: "SLIDER",
  DATE: "DATE",
  TIME: "TIME",
  BOOLEAN: "BOOLEAN",
  ACCOUNTNUMBER: "ACCOUNTNUMBER",
  ADDRESS: "ADDRESS",
  COLLECTION: "COLLECTION",
  OBJECT: "OBJECT",
  RADIO: "RADIO",
  CHECKLIST: "CHECKLIST",
  STRING: "STRING",
  GEOLOCATION: "GEOLOCATION",
  YEAR: "YEAR"
};
const COMMON_DATETIME_ARGS = {
  value: {
    type: NodePropertyTypes.DATETIME,
    nodeType: NodeTypes.Property
  }
};
const COMMON_STRING_ARGS = {
  value: {
    type: NodePropertyTypes.STRING,
    nodeType: NodeTypes.Property
  }
};
const COMMON_NUMBER_ARGS = {
  value: {
    type: NodePropertyTypes.INT,
    nodeType: NodeTypes.Property
  },
  condition: {
    type: NodePropertyTypes.INT,
    nodeType: null,
    defaultValue: 0
  }
};
const COMMON_NUMBER__EQ_ARGS = { ...COMMON_NUMBER_ARGS,
  condition: {
    type: NodePropertyTypes.INT,
    nodeType: null,
    equals: true,
    defaultValue: 0
  }
};
const COMMON_LISTSTRING_ARGS = {
  value: {
    type: NodePropertyTypes.LISTOFSTRINGS,
    nodeType: NodeTypes.Property
  }
};
function GetValidationsFor(type) {
  let result = {};
  Object.keys(ValidationCases).filter(x => {
    return ValidationCases[x].types.some(v => v === type);
  }).map(t => {
    result[t] = ValidationCases[t];
  });
  return result;
}
function GetMoreCompatibles(a, vector, result = []) {
  var parents = GetValidationParents(a, vector).map(t => t.id);
  parents = parents.filter(t => result.indexOf(t) === -1);
  result = [a, ...result, ...parents].unique();
  parents.map(t => {
    if (result.indexOf(t) !== -1) {
      result = GetMoreCompatibles(t, vector, result);
    }
  });
  return result;
}
function AreCompatible(a, b, vector = ValidationVector.Content) {
  var t = GetMoreCompatibles(a, vector);
  var v = GetMoreCompatibles(b, vector);
  return !!t.intersection(v).length;
}
function SortValidation(a, b, vector) {
  if (a === b) {
    return 0;
  }

  var t = GetMoreCompatibles(a, vector);
  var v = GetMoreCompatibles(b, vector);
  var bIsIncluded = t.some(_t => _t === b);
  var aIsIncluded = v.some(_v => _v === a);

  if (bIsIncluded && aIsIncluded) {
    return 0;
  } else if (bIsIncluded) {
    return -1;
  } else if (aIsIncluded) {
    return 1;
  }

  return 0;
}
function GetValidationParents(type, vector) {
  var vc = ValidationCases[type];

  if (vc) {
    var vects = vc.vectors[vector];

    if (Array.isArray(vects)) {
      return vects.map(t => ValidationCases[t]).filter(x => x);
    } else {
      return Object.keys(vects).map(t => {
        return ValidationCases[t];
      }).filter(x => x);
    }
  }

  return [];
}
function GetValidationTypes(type) {
  var results = [];
  Object.values(ValidationCases).map(t => {
    if (t && t.types && t.types.indexOf(type) !== -1) results.push(t);
  });
  return results;
}
const ValidationCases = {
  [ValidationRules.ListOfGuids]: {
    types: [NodePropertyTypes.LISTOFSTRINGS],
    vectors: {
      content: [ValidationRules.Any],
      length: true
    },
    cases: {
      $true: function (e) {
        return `new List<string> { "${uuidv4()}"}`;
      },
      long: function () {
        return `new List<string> { "${uuidv4()}asdf" }`;
      },
      $empty: function () {
        return `new List<string>()`;
      }
    }
  },
  [ValidationRules.SocialSecurity]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.AlphaNumericPuncLike],
      length: true
    },
    cases: {
      $true: function (e) {
        return `"${[].interpolate(0, 9, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      long: function () {
        return `"${[].interpolate(0, 12, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      short: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      invalid: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("a")}"`;
      },
      empty: function () {
        return `"${[].interpolate(0, 0, e => Math.floor(Math.random() * 10)).join("")}"`;
      }
    }
  },
  [ValidationRules.Zip]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.ZipEmpty],
      length: true
    },
    cases: {
      $true: function (e) {
        return `"${[].interpolate(0, 5, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      long: function () {
        return `"${[].interpolate(0, 12, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      short: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      invalid: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("a")}"`;
      },
      empty: function () {
        return `"${[].interpolate(0, 0, e => Math.floor(Math.random() * 10)).join("")}"`;
      }
    }
  },
  [ValidationRules.ZipEmpty]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: true,
      length: true
    },
    cases: {
      $true: function () {
        return `"${[].interpolate(0, 5, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      long: function () {
        return `"${[].interpolate(0, 12, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      short: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      $empty: function () {
        return `"${[].interpolate(0, 0, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      invalid: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("a")}"`;
      },
      invalid2: function () {
        return `"${[].interpolate(0, 5, e => "a").join("")}"`;
      }
    }
  },
  [ValidationRules.PastDate]: {
    types: [NodePropertyTypes.DATETIME],
    vectors: {
      value: true
    },
    cases: {
      $true: function (e) {
        return `Date.UtcNow().AddDays(1)`;
      },
      false: function () {
        return `Date.UtcNow().AddDays(-1)`;
      }
    }
  },
  [ValidationRules.BeforeNow]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      value: true
    },
    cases: {
      $true: function (e) {
        return `Date.UtcNow().AddDays(-1)`;
      },
      false: function () {
        return `Date.UtcNow().AddDays(1)`;
      }
    }
  },
  [ValidationRules.Email]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: true
    },
    cases: {
      $true: function (e) {
        return `"asdf@asdf.com"`;
      },
      false: function () {
        return `"asdf@asdfdd@asdf@.com"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.EmailEmpty]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: true
    },
    cases: {
      $true: function (e) {
        return `"asadf@asdf.com"`;
      },
      false: function () {
        return `"asdf@afsdfdd@asdf@.com"`;
      },
      $empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.Credit]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: true,
      length: true
    },
    cases: {
      $true: function () {
        return `"${[].interpolate(0, 16, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      long: function () {
        return `"${[].interpolate(0, 23, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      short: function () {
        return `"${[].interpolate(0, 3, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      $empty: function () {
        return `"${[].interpolate(0, 0, e => Math.floor(Math.random() * 10)).join("")}"`;
      },
      invalid: function () {
        return `"${[].interpolate(0, 16, e => Math.floor(Math.random() * 10)).join("a")}"`;
      },
      invalid2: function () {
        return `"${[].interpolate(0, 16, e => "a").join("")}"`;
      }
    }
  },
  [ValidationRules.Url]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.UrlEmpty]
    },
    cases: {
      $true: function (e) {
        return `"http://yahoo.com"`;
      },
      false: function () {
        return `"asdf@afsdfdd@asdf@.com"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.UrlEmpty]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.Any]
    },
    cases: {
      $true: function (e) {
        return `"http://yahoo.com"`;
      },
      false: function () {
        return `"asdf@afsdfdd@asdf@.com"`;
      },
      $empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.Empty]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.Any],
      length: true
    },
    cases: {
      false: function () {
        return `"asdf"`;
      },
      $empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.NotEmpty]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.Any],
      length: true
    },
    cases: {
      $false: function () {
        return `"asdf"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.NumericOnly]: {
    vectors: {
      content: [ValidationRules.Numeric]
    },
    types: [NodePropertyTypes.STRING],
    cases: {
      $true: function (e) {
        return `"1234"`;
      },
      false: function () {
        return `"asdf@ afsdfdd@asdf@.com"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.Numeric]: {
    vectors: {
      content: [ValidationRules.AlphaNumericPuncLike]
    },
    types: [NodePropertyTypes.STRING],
    cases: {
      $true: function (e) {
        return `"1234.34"`;
      },
      false: function () {
        return `"12QW"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  //Cant be empty, that would  be the only difference between it and Any.
  [ValidationRules.AlphaNumericPuncLike]: {
    vectors: {
      content: [ValidationRules.Any]
    },
    types: [NodePropertyTypes.STRING],
    cases: {
      $true: function (e) {
        return `"httas21df.!@#$ #$%^^&*^&*()aom"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.AlphaNumericLike]: {
    vectors: {
      content: [ValidationRules.AlphaNumericPuncLike]
    },
    types: [NodePropertyTypes.STRING],
    cases: {
      $true: function (e) {
        return `"httas21dfaom"`;
      },
      false: function () {
        return `"asdf@ afsdfdd@asdf@.com"`;
      },
      $empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.AlphaOnly]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.AlphaOnlyWithSpaces]
    },
    cases: {
      $true: function (e) {
        return `"httasdfaom"`;
      },
      false: function () {
        return `"asdf@ afsdfdd@asdf12f@.com"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.AlphaOnlyWithSpaces]: {
    types: [NodePropertyTypes.STRING],
    vectors: {
      content: [ValidationRules.AlphaNumericPuncLike]
    },
    cases: {
      $true: function (e) {
        return `"httas dfaom"`;
      },
      $false: function () {
        return `"asdf@ afsdfdd@asdf12f@.com"`;
      },
      empty: function () {
        return `""`;
      }
    }
  },
  [ValidationRules.IsTrue]: {
    types: [NodePropertyTypes.BOOLEAN],
    vectors: {
      value: [ValidationRules.Any]
    },
    cases: {
      $true: function () {
        return "true";
      },
      false: function () {
        return "false";
      }
    }
  },
  [ValidationRules.IsFalse]: {
    types: [NodePropertyTypes.BOOLEAN],
    vectors: {
      value: [ValidationRules.Any]
    },
    cases: {
      true: function () {
        return "true";
      },
      $false: function () {
        return "false";
      }
    }
  },
  [ValidationRules.GreaterThanOrEqualTo]: {
    types: [NodePropertyTypes.DOUBLE, NodePropertyTypes.FLOAT, NodePropertyTypes.INT],
    vectors: {
      value: {
        [ValidationRules.GreaterThan]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.GreaterThanOrEqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.EqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.LessThan]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        },
        [ValidationRules.LessThanOrEqualTo]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        }
      }
    },
    cases: {
      $greater: function () {
        return " >= ";
      },
      notgreater: function () {
        return " >= ";
      }
    }
  },
  [ValidationRules.GreaterThan]: {
    types: [NodePropertyTypes.DOUBLE, NodePropertyTypes.FLOAT, NodePropertyTypes.INT],
    vectors: {
      value: {
        [ValidationRules.GreaterThan]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.GreaterThanOrEqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.EqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.LessThan]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        },
        [ValidationRules.LessThanOrEqualTo]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        }
      }
    },
    cases: {
      $greater: function () {
        return " > ";
      },
      notgreater: function () {
        return " > ";
      }
    }
  },
  [ValidationRules.LessThan]: {
    types: [NodePropertyTypes.DOUBLE, NodePropertyTypes.FLOAT, NodePropertyTypes.INT],
    vectors: {
      value: {
        [ValidationRules.GreaterThan]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.GreaterThanOrEqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.EqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.LessThan]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        },
        [ValidationRules.LessThanOrEqualTo]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        }
      }
    },
    cases: {
      $less: function () {
        return " < ";
      },
      notless: function () {
        return " < ";
      }
    }
  },
  [ValidationRules.EqualTo]: {
    types: [NodePropertyTypes.DOUBLE, NodePropertyTypes.FLOAT, NodePropertyTypes.INT],
    vectors: {
      value: {
        [ValidationRules.GreaterThan]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.GreaterThanOrEqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.EqualTo]: function (self, b) {// based on a parameter, determining which validation is most restrictive should be possible.
        },
        [ValidationRules.LessThan]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        },
        [ValidationRules.LessThanOrEqualTo]: function (self, b) {// based on a parameter, determine if there are any possible success cases.
        }
      }
    },
    cases: {
      $equal_to: function () {
        return " = ";
      },
      not_equal: function () {
        return " = ";
      }
    }
  }
};
Object.keys(ValidationCases).map(t => {
  ValidationCases[t].id = t;
});
const ExecutorRules = {
  ModelReference: "model-reference",
  Copy: "copy",
  AgentReference: "agent-reference",
  ParentReference: "parent-reference",
  AddModelReference: "add-model-reference"
};
const ExecutorUI = {
  [ExecutorRules.ModelReference]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "ModelReference"
    },
    arguments: { ...COMMON_STRING_ARGS,
      nodeType: NodeTypes.Model,
      reference: {
        types: [NodeTypes.Model]
      }
    }
  },
  [ExecutorRules.AgentReference]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "AgentReference"
    },
    arguments: { ...COMMON_STRING_ARGS,
      nodeType: NodeTypes.Model,
      reference: {
        types: [NodeTypes.Model]
      }
    }
  },
  [ExecutorRules.ParentReference]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "ParentReference"
    },
    arguments: { ...COMMON_STRING_ARGS,
      nodeType: NodeTypes.Model,
      reference: {
        types: [NodeTypes.Model]
      }
    }
  },
  [ExecutorRules.AddModelReference]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "AddModelReference"
    },
    arguments: { ...COMMON_LISTSTRING_ARGS,
      nodeType: NodeTypes.Model,
      method_reference: {
        reference: true
      }
    }
  },
  [ExecutorRules.Copy]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "copy"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  }
};
Object.keys(ExecutorUI).map(t => {
  ExecutorUI[t].type = t;
});
const FilterRules = {
  EqualsAgent: "equals-agent",
  EqualsParent: "equals-parent",
  EqualsTrue: "equals-true",
  EqualsFalse: "equals-false",
  EqualsModelRef: "equals-model-ref",
  EqualsModelProperty: "equals-model-property",
  IsInModelPropertyCollection: "is-in-model-property-collection",
  IsNotInModelPropertyCollection: "is-not-in-model-property-collection",
  Many2ManyPropertyIsTrue: "many-2-many-property-is-true"
};
const FilterUI = {
  [FilterRules.EqualsTrue]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EqualsTrue"
    },
    template: "./app/templates/filter/equals_true.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      type: NodePropertyTypes.BOOLEAN
    }
  },
  [FilterRules.EqualsFalse]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EqualsFalse"
    },
    template: "./app/templates/filter/equals_false.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      type: NodePropertyTypes.BOOLEAN
    }
  },
  [FilterRules.EqualsParent]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EqualsParent"
    },
    template: "./app/templates/filter/equals_parent.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      modelproperty: true
    }
  },
  [FilterRules.EqualsAgent]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EqualsAgent"
    },
    arguments: { ...COMMON_STRING_ARGS,
      type: NodePropertyTypes.BOOLEAN
    }
  },
  [FilterRules.EqualsModelRef]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EqualsModelRef"
    },
    arguments: { ...COMMON_STRING_ARGS,
      functionvariables: true
    }
  },
  [FilterRules.EqualsModelProperty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EqualsModelProperty"
    },
    template: "./app/templates/filter/equals-model-property.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      modelproperty: true
    }
  },
  [FilterRules.IsInModelPropertyCollection]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "IsInModelPropertyCollection"
    },
    template: "./app/templates/filter/is_in_model_property_collection.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      modelproperty: true
    }
  },
  [FilterRules.IsNotInModelPropertyCollection]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "IsNotInModelPropertyCollection"
    },
    template: "./app/templates/filter/is_not_in_model_property_collection.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      modelproperty: true
    }
  },
  [FilterRules.Many2ManyPropertyIsTrue]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "Many2ManyPropertyIsTrue"
    },
    template: "./app/templates/filter/many_2_many_property_is_true.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      model2modelproperty: true
    }
  },
  [ValidationRules.OneOf]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "OneOfAttribute"
    },
    template: "./app/templates/filter/one-of.tpl",
    templatejs: "./app/templates/filter/one-ofjs.tpl",
    arguments: { ...COMMON_STRING_ARGS,
      nodeType: NodeTypes.Enumeration,
      reference: {
        types: [NodeTypes.Enumeration, NodeTypes.ExtensionType]
      }
    }
  },
  [ValidationRules.SocialSecurity]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "SocialSecurityAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.Zip]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "ZipAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.ZipEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "ZipEmptyAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.PastDate]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "PastDateAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_DATETIME_ARGS
    }
  },
  [ValidationRules.BeforeNow]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "BeforeNowAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_DATETIME_ARGS
    }
  },
  [ValidationRules.Email]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EmailAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.Credit]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "CreditCardAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.EmailEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EmailEmptyAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.Url]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "UrlAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.UrlEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "UrlEmptyAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.IsNull]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "IsNullAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.IsNotNull]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "IsNotNullAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.AlphaNumericLike]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "AlphaNumericLikeAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.AlphaOnly]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "AlphaOnlyAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.AlphaOnlyWithSpaces]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "NotEmptyAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.MaxLength]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MaximumLengthAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER_ARGS
    }
  },
  [ValidationRules.MinLength]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MinimumLengthAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER_ARGS
    }
  },
  [ValidationRules.MaxLengthEqual]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MaximumLengthAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER__EQ_ARGS
    }
  },
  [ValidationRules.MinLengthEqual]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MinAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER__EQ_ARGS
    }
  },
  [ValidationRules.MaxValue]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MaxAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER_ARGS
    }
  },
  [ValidationRules.MinValue]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MinAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER_ARGS
    }
  },
  [ValidationRules.MaxValueEqual]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MaxAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER__EQ_ARGS
    }
  },
  [ValidationRules.MinValueEqual]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "MinAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_NUMBER__EQ_ARGS
    }
  },
  [ValidationRules.Email]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EmailAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.EmailEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EmailEmptyAttribute"
    },
    template: "./app/templates/validation/validation_generic.tpl",
    templatejs: "./app/templates/validation/validation_generic_js.tpl",
    arguments: { ...COMMON_STRING_ARGS
    }
  }
};
Object.keys(FilterUI).map(t => {
  FilterUI[t].type = t;
});
const ValidationUI = {
  [ValidationRules.OneOf]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "OneOfAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS,
      nodeType: NodeTypes.Enumeration,
      reference: {
        types: [NodeTypes.Enumeration, NodeTypes.ExtensionType]
      }
    }
  },
  [ValidationRules.SocialSecurity]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "SocialSecurityAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.Zip]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "ZipAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.ZipEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "ZipEmptyAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.PastDate]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "PastDateAttribute"
    },
    arguments: { ...COMMON_DATETIME_ARGS
    }
  },
  [ValidationRules.BeforeNow]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "BeforeNowAttribute"
    },
    arguments: { ...COMMON_DATETIME_ARGS
    }
  },
  [ValidationRules.Email]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EmailAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.Credit]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "CreditCardAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.EmailEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "EmailEmptyAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.Url]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "UrlAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.UrlEmpty]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "UrlEmptyAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.AlphaNumericLike]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "AlphaNumericLikeAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.AlphaOnly]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "AlphaOnlyAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  },
  [ValidationRules.AlphaOnlyWithSpaces]: {
    code: {
      [ProgrammingLanguages.CSHARP]: "NotEmptyAttribute"
    },
    arguments: { ...COMMON_STRING_ARGS
    }
  }
};
Object.keys(ValidationUI).map(t => {
  ValidationUI[t].type = t;
});
// CONCATENATED MODULE: ./app/constants/functiontypes.js




const functiontypes_FunctionTypes = {
  //Functions with List<Child> result
  Create_ManyToMany_Agent_Value__IListChild: "Create/ManyToMany/Agent/Value => IList<Child>",
  Update_ManyToMany_Agent_Value__IListChild: "Update/ManyToMany/Agent/Value => IList<Child>",
  Get_ManyToMany_Agent_Value__IListChild: "Get/ManyToMany/Agent/Value => IList<Child>",
  Delete_ManyToMany_Agent_Value__IListChild: "Delete/ManyToMany/Agent/Value => IList<Child>",
  // Functions For Getting Data from lists of ids
  Get_Objects_From_List_Of_Ids: "Get_Objects_From_List_Of_Ids",
  //Functions with List<Child> result
  Create_Parent$Child_Agent_Value__IListChild: "Create/Parent-Child/Agent/Value => IList<Child>",
  Update_Parent$Child_Agent_Value__IListChild: "Update/Parent-Child/Agent/Value => IList<Child>",
  Get_Parent$Child_Agent_Value__IListChild: "Get/Parent-Child/Agent/Value => IList<Child>",
  Delete_Parent$Child_Agent_Value__IListChild: "Delete/Parent-Child/Agent/Value => IList<Child>",
  //Functions with List<Object> result
  Create_Object_Agent_Value__IListObject: "Create/Object/Agent/Value => IList<Object>",
  Update_Object_Agent_Value__IListObject: "Update/Object/Agent/Value => IList<Object>",
  Get_Object_Agent_Value__IListObject: "Get/Object/Agent/Value => IList<Object>",
  Delete_Object_Agent_Value__IListObject: "Delete/Object/Agent/Value => IList<Object>",
  Get_Agent_Value__IListObject: "Get/Agent/Value => IList<Object>",
  Get_Object_Agent_Value__IListObject_By_Specific: "Get/Object/Agent/Value => IList<Object> specific id",
  //Delete
  Delete_M2M_By_Reference: "Delete M2M by reference => list",
  //Functions with Object result
  Create_Parent_Child_Agent_Value__Child: "Create/Parent-Child/Agent/Value => Child",
  Update_Parent_Child_Agent_Value__Child: "Update/Parent-Child/Agent/Value => Child",
  Get_Parent_Child_Agent_Value__Child: "Get/Parent-Child/Agent/Value => Child",
  Delete_Parent_Child_Agent_Value__Child: "Delete/Parent-Child/Agent/Value => Child",
  //Functions width Object result.
  Create_Object_Agent_Value__Object: "Create/Object/Agent/Value => Object",
  Update_Object_Agent_Value__Object: "Update/Object/Agent/Value => Object",
  Update_Object_Agent_Value__Object_With_Object: "Update/Object/with/Model/Agent/Value => Object",
  Get_Object_Agent_Value__Object: "Get/Object/Agent/Value => Object",
  Delete_Object_Agent_Value__Object: "Delete/Object/Agent/Value => Object",
  Create_Object_Agent_Many_to_Many_CompositeInput__Object: "Create/Object/Agent/Many to Many with Composite Input => Object",
  Create_ManyToMany_Object_With_Agent_And_Return_M2M_SET: "Create M2M Object with Agent and Return the updated M2M set",
  Create_Object_With_User: "Create/Object=>Object(with users)",
  Update_Object_With_User: "Update/Object=>Object(with users)",
  Create_Object__Object: "Create/Object => Object",
  Update_Object__Object: "Update/Object => Object",
  Delete_Object__Object: "Delete/Object => Object",
  Get_Object__Object: "Get/Object => Object",
  //Function with bool result
  Can_Execute_Agent_Parent_In_Valid_List: "Can_Execute_Agent_Parent_In_Valid_List",
  Login: "Login",
  Register: "Register" // IAgent_and_Permission_determing_the_permission_based_on_a_PROPERTY: 'Given an Agent and Permission, determing the permission based on a PROPERTY'

};
const FunctionTemplateKeys = {
  Model: "model",
  ModelOutput: "model_output",
  ChangeParameter: "change_parameter",
  UpdateModel: "model_update",
  ReferenceClass: "reference_class",
  Reference: "reference",
  ModelProperty: "model-property",
  Bool: "bool",
  CanExecute: "can-execute",
  ModelDeterminingProperty: "model-determining-property",
  AgentDeterminingProperty: "agent-determining-property",
  Property: "property",
  Parent: "parent",
  AgentInstance: "agent_instance",
  Agent: "agent",
  Item: "item",
  AgentProperty: "agent-property",
  AgentType: "agent_type",
  User: "user",
  ConnectionType: "connect_type",
  ManyToManyModel: "many_to_many",
  Method: "method",
  Executor: "executor",
  Validator: "Validator",
  MethodType: "method_type",
  Permission: "permission",
  UserInstance: "user_instance",
  ModelFilter: "model_filter",
  Value: "value",
  CompositeInput: "composite-input",
  CompositeInputProperty: "composite-input-property",
  FetchParameter: "fetch_parameter"
};
const FunctionConstraintKeys = {
  IsAgent: "isAgent",
  IsUser: "isUser",
  IsTypeOf: "isTypeOf",
  IsParent: "isParent",
  IsChild: "isChild",
  IsList: "isList",
  IsSingleLink: "$single$link",
  IsModel: "isModel",
  IsFunction: "isFunction",
  IsProperty: "isProperty",
  IsEnumerable: "isEnumerable",
  IsInstanceVariable: "isInstanceVariable",
  IsInputVariable: "isInputVariable"
};
const COMMON_CONSTRAINTS = {
  [FunctionTemplateKeys.CanExecute]: {
    [FunctionConstraintKeys.IsSingleLink]: true,
    [FunctionConstraintKeys.IsFunction]: true,
    key: FunctionTemplateKeys.CanExecute
  },
  [FunctionTemplateKeys.Model]: {
    [FunctionConstraintKeys.IsChild]: FunctionTemplateKeys.Parent,
    [FunctionConstraintKeys.IsSingleLink]: true,
    [FunctionConstraintKeys.IsModel]: true,
    key: FunctionTemplateKeys.Model
  },
  [FunctionTemplateKeys.ModelDeterminingProperty]: {
    [FunctionConstraintKeys.IsChild]: FunctionTemplateKeys.Model,
    [FunctionConstraintKeys.IsSingleLink]: true,
    [FunctionConstraintKeys.IsProperty]: true,
    key: FunctionTemplateKeys.ModelDeterminingProperty
  },
  [FunctionTemplateKeys.Parent]: {
    [FunctionConstraintKeys.IsParent]: FunctionTemplateKeys.Model,
    [FunctionConstraintKeys.IsSingleLink]: true,
    [FunctionConstraintKeys.IsModel]: true,
    key: FunctionTemplateKeys.Parent
  },
  [FunctionTemplateKeys.AgentType]: {
    [FunctionConstraintKeys.IsAgent]: true,
    [FunctionConstraintKeys.IsSingleLink]: true,
    [FunctionConstraintKeys.IsModel]: true,
    key: FunctionTemplateKeys.AgentType
  },
  [FunctionTemplateKeys.User]: {
    [FunctionConstraintKeys.IsUser]: true,
    [FunctionConstraintKeys.IsSingleLink]: true,
    [FunctionConstraintKeys.IsModel]: true,
    key: FunctionTemplateKeys.User
  },
  [FunctionTemplateKeys.UserInstance]: {
    [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.User,
    [FunctionConstraintKeys.IsSingleLink]: true,
    key: FunctionTemplateKeys.UserInstance,
    [FunctionConstraintKeys.IsInstanceVariable]: true,
    [FunctionConstraintKeys.IsInputVariable]: true
  },
  [FunctionTemplateKeys.Value]: {
    [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.Model,
    [FunctionConstraintKeys.IsSingleLink]: true,
    key: FunctionTemplateKeys.Value,
    [FunctionConstraintKeys.IsInstanceVariable]: true,
    [FunctionConstraintKeys.IsInputVariable]: true
  }
};
const COMMON_CONSTRAINTS_ANONYMOUS = {
  [FunctionTemplateKeys.Model]: {
    key: FunctionTemplateKeys.Model,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelOutput]: {
    key: FunctionTemplateKeys.ModelOutput,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.User]: {
    [nodetypes_NodeProperties.IsUser]: true,
    key: FunctionTemplateKeys.User,
    nodeTypes: [NodeTypes.Model]
  }
};
const COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD = {
  [FunctionTemplateKeys.Model]: {
    key: FunctionTemplateKeys.Model,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelOutput]: {
    key: FunctionTemplateKeys.ModelOutput,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Agent]: {
    [nodetypes_NodeProperties.IsAgent]: true,
    key: FunctionTemplateKeys.Agent,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.User]: {
    [nodetypes_NodeProperties.IsUser]: true,
    key: FunctionTemplateKeys.User,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Permission]: {
    key: FunctionTemplateKeys.Permission,
    nodeTypes: [NodeTypes.Permission]
  },
  [FunctionTemplateKeys.ManyToManyModel]: {
    [nodetypes_NodeProperties.ManyToManyNexus]: true,
    key: FunctionTemplateKeys.ManyToManyModel,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelFilter]: {
    key: FunctionTemplateKeys.ModelFilter,
    nodeTypes: [NodeTypes.ModelFilter]
  }
};
const COMMON_CREATE_UPDATE_CONSTRAINTS = {
  [FunctionTemplateKeys.Validator]: {
    key: FunctionTemplateKeys.Validator,
    nodeTypes: [NodeTypes.Validator]
  },
  [FunctionTemplateKeys.Executor]: {
    key: FunctionTemplateKeys.Executor,
    nodeTypes: [NodeTypes.Executor]
  }
};
const COMMON_CONSTRAINTS_AGENT_OBJECT_MANY_TO_MANY_COMPOSITEINPUT_METHOD = {
  [FunctionTemplateKeys.Model]: {
    key: FunctionTemplateKeys.Model,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.CompositeInput]: {
    key: FunctionTemplateKeys.CompositeInput,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Agent]: {
    [nodetypes_NodeProperties.IsAgent]: true,
    key: FunctionTemplateKeys.Agent,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.User]: {
    [nodetypes_NodeProperties.IsUser]: true,
    key: FunctionTemplateKeys.User,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Permission]: {
    key: FunctionTemplateKeys.Permission,
    nodeTypes: [NodeTypes.Permission]
  },
  [FunctionTemplateKeys.ModelFilter]: {
    key: FunctionTemplateKeys.ModelFilter,
    nodeTypes: [NodeTypes.ModelFilter]
  }
};
const AfterEffectsTemplate = {
  GenerateM2M_From_Result_and_Input: "Generate Many 2 Many from result and input",
  ExecuteStreamProcess: "Execute stream process",
  ExecuteStreamProcessUpdate: "Execute stream process update"
};
const AFTER_EFFECTS = {
  [AfterEffectsTemplate.GenerateM2M_From_Result_and_Input]: {
    template: "./app/templates/aftereffects/generate_m2m_from_result_and_input.tpl",
    template_call: "                    await {{function_name}}(agent, data, result);",
    templateKeys: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.CompositeInput]: {
        key: FunctionTemplateKeys.CompositeInput,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.CompositeInputProperty]: {
        key: FunctionTemplateKeys.CompositeInputProperty,
        nodeTypes: [NodeTypes.Property],
        parent: FunctionTemplateKeys.CompositeInput
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ManyToManyModel]: {
        key: FunctionTemplateKeys.ManyToManyModel,
        nodeTypes: [NodeTypes.Model]
      }
    }
  },
  [AfterEffectsTemplate.ExecuteStreamProcess]: {
    template: "./app/templates/aftereffects/execute_stream_process.tpl",
    template_call: "                    await {{function_name}}(agent, result);",
    update_with: `./app/templates/standard/update_model_property.tpl`,
    stream_process_change_parameter: `./app/templates/stream_process/stream_process_change_class_extension_update_by_model.tpl`,
    templateKeys: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ModelOutput]: {
        key: FunctionTemplateKeys.ModelOutput,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ManyToManyModel]: {
        key: FunctionTemplateKeys.ManyToManyModel,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Method]: {
        key: FunctionTemplateKeys.Method,
        useNodes: true,
        nodeTypes: [NodeTypes.Method]
      },
      [FunctionTemplateKeys.MethodType]: {
        key: FunctionTemplateKeys.MethodType,
        useMethodTypes: true
      }
    }
  },
  [AfterEffectsTemplate.ExecuteStreamProcessUpdate]: {
    template: "./app/templates/aftereffects/execute_stream_process_update.tpl",
    template_call: `
            var reference = {{reference}};
            var model = result;
            await {{function_name}}(agent, reference, model);`,
    stream_process_change_parameter: `./app/templates/stream_process/stream_process_change_class_extension_update_by_model.tpl`,
    update_with: `./app/templates/standard/update_model_property.tpl`,
    templateKeys: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ModelOutput]: {
        key: FunctionTemplateKeys.ModelOutput,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.UpdateModel]: {
        key: FunctionTemplateKeys.UpdateModel,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ReferenceClass]: {
        key: FunctionTemplateKeys.ReferenceClass,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Reference]: {
        key: FunctionTemplateKeys.Reference,
        nodeTypes: [NodeTypes.Model],
        useString: ["agent", "result", "newData", "data"].map(t => `#${t}`)
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ManyToManyModel]: {
        key: FunctionTemplateKeys.ManyToManyModel,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Method]: {
        key: FunctionTemplateKeys.Method,
        useNodes: true,
        nodeTypes: [NodeTypes.Method]
      },
      [FunctionTemplateKeys.MethodType]: {
        key: FunctionTemplateKeys.MethodType,
        useMethodTypes: true
      }
    }
  }
};
const COMMON_CONSTRAINTS_OBJECT_METHOD_OBJECT = {
  [FunctionTemplateKeys.User]: {
    [nodetypes_NodeProperties.IsUser]: true,
    key: FunctionTemplateKeys.User,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Model]: {
    key: FunctionTemplateKeys.Model,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelOutput]: {
    key: FunctionTemplateKeys.ModelOutput,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Agent]: {
    [nodetypes_NodeProperties.IsAgent]: true,
    key: FunctionTemplateKeys.Agent,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Permission]: {
    key: FunctionTemplateKeys.Permission,
    nodeTypes: [NodeTypes.Permission]
  },
  [FunctionTemplateKeys.ModelFilter]: {
    key: FunctionTemplateKeys.ModelFilter,
    nodeTypes: [NodeTypes.ModelFilter]
  }
};
const COMMON_CONSTRAINTS_OBJECT_METHOD = { ...COMMON_CONSTRAINTS_OBJECT_METHOD_OBJECT,
  [FunctionTemplateKeys.Agent]: {
    [nodetypes_NodeProperties.IsAgent]: true,
    key: FunctionTemplateKeys.Agent,
    nodeTypes: [NodeTypes.Model]
  }
};
const COMMON_CONSTRAINTS_AGENT_PARENT_CHILD_METHOD = {
  [FunctionTemplateKeys.Model]: {
    key: FunctionTemplateKeys.Model,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelOutput]: {
    key: FunctionTemplateKeys.ModelOutput,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Agent]: {
    [nodetypes_NodeProperties.IsAgent]: true,
    key: FunctionTemplateKeys.Agent,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.User]: {
    [nodetypes_NodeProperties.IsUser]: true,
    key: FunctionTemplateKeys.User,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Permission]: {
    key: FunctionTemplateKeys.Permission,
    nodeTypes: [NodeTypes.Permission]
  },
  [FunctionTemplateKeys.ManyToManyModel]: {
    [nodetypes_NodeProperties.ManyToManyNexus]: true,
    key: FunctionTemplateKeys.ManyToManyModel,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelFilter]: {
    key: FunctionTemplateKeys.ModelFilter,
    nodeTypes: [NodeTypes.ModelFilter]
  }
};
const COMMON_CONSTRAINTS_MANYTOMANY_CHILD_METHOD = {
  [FunctionTemplateKeys.Model]: {
    key: FunctionTemplateKeys.Model,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ModelOutput]: {
    key: FunctionTemplateKeys.ModelOutput,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Agent]: {
    [nodetypes_NodeProperties.IsAgent]: true,
    key: FunctionTemplateKeys.Agent,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.User]: {
    [nodetypes_NodeProperties.IsUser]: true,
    key: FunctionTemplateKeys.User,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.ConnectionType]: {
    [nodetypes_NodeProperties.ManyToManyNexus]: true,
    key: FunctionTemplateKeys.ConnectionType,
    nodeTypes: [NodeTypes.Model]
  },
  [FunctionTemplateKeys.Permission]: {
    key: FunctionTemplateKeys.Permission,
    nodeTypes: [NodeTypes.Permission]
  },
  [FunctionTemplateKeys.ModelFilter]: {
    key: FunctionTemplateKeys.ModelFilter,
    nodeTypes: [NodeTypes.ModelFilter]
  }
};
const COMMON_OUTPUT = {
  LIST: {
    [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.Model,
    [FunctionConstraintKeys.IsList]: true
  },
  OBJECT: {
    [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.Model,
    [FunctionConstraintKeys.IsList]: false
  },
  BOOL: {
    [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.Bool
  }
};
const INTERNAL_TEMPLATE_REQUIREMENTS = {
  METHODS: "methods",
  PARAMETERS: "parameters",
  PARAMETERSCLASS: "Parameters",
  // Classes hold the parameters, that go to Change classes. See create____.tpl templates.
  CHANGECLASS: "Change",
  // Class objects are passed to streams for processing
  RESPONSECLASS: "Response",
  // When stream processing completes, these are sent back.
  STREAMPROCESS: "StreamProcess",
  DETERMINING_PROPERTY: "determining_property",
  PARENTS_ID_PROPERTY: "parentIdProperty",
  MODEL: "model",
  CONSTRUCTORS: "constructors",
  TEMPLATE: "template",
  INTERFACE: "interface",
  PARENT: "parent",
  PROPERTY: "property",
  METHOD: {
    CREATE: "Create",
    UPDATE: "Update",
    PROCESS: "Process"
  }
};
const FUNCTION_REQUIREMENT_KEYS = {
  CLASSES: "classes"
};
const COMMON_FUNCTION_REQUIREMENTS = {
  [FUNCTION_REQUIREMENT_KEYS.CLASSES]: {
    [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERSCLASS]: {
      [INTERNAL_TEMPLATE_REQUIREMENTS.TEMPLATE]: external_fs_default.a.readFileSync("./app/templates/stream_process/stream_process_parameter_class.tpl", "utf8"),
      [INTERNAL_TEMPLATE_REQUIREMENTS.CONSTRUCTORS]: external_fs_default.a.readFileSync("./app/templates/stream_process/stream_process_parameter_class.tpl", "utf8"),
      [INTERNAL_TEMPLATE_REQUIREMENTS.MODEL]: FunctionTemplateKeys.Model,
      [INTERNAL_TEMPLATE_REQUIREMENTS.METHODS]: {
        [INTERNAL_TEMPLATE_REQUIREMENTS.METHOD.CREATE]: {
          [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERS]: [FunctionTemplateKeys.AgentType, FunctionTemplateKeys.Model]
        },
        [INTERNAL_TEMPLATE_REQUIREMENTS.METHOD.UPDATE]: {
          [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERS]: [FunctionTemplateKeys.AgentType, FunctionTemplateKeys.Model]
        }
      }
    },
    [INTERNAL_TEMPLATE_REQUIREMENTS.CHANGECLASS]: {
      [INTERNAL_TEMPLATE_REQUIREMENTS.TEMPLATE]: external_fs_default.a.readFileSync("./app/templates/stream_process/stream_process_change_class.tpl", "utf8"),
      [INTERNAL_TEMPLATE_REQUIREMENTS.CONSTRUCTORS]: external_fs_default.a.readFileSync("./app/templates/stream_process/stream_process_change_class.tpl", "utf8"),
      [INTERNAL_TEMPLATE_REQUIREMENTS.MODEL]: FunctionTemplateKeys.Model,
      [INTERNAL_TEMPLATE_REQUIREMENTS.METHODS]: {
        [INTERNAL_TEMPLATE_REQUIREMENTS.METHOD.CREATE]: {
          [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERS]: [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERSCLASS]
        }
      }
    },
    [INTERNAL_TEMPLATE_REQUIREMENTS.RESPONSECLASS]: {
      [INTERNAL_TEMPLATE_REQUIREMENTS.MODEL]: FunctionTemplateKeys.Model,
      [INTERNAL_TEMPLATE_REQUIREMENTS.METHODS]: {
        [INTERNAL_TEMPLATE_REQUIREMENTS.METHOD.CREATE]: {
          [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERS]: [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERSCLASS]
        }
      }
    }
  },
  attachment_methods: {
    [INTERNAL_TEMPLATE_REQUIREMENTS.STREAMPROCESS]: {
      [INTERNAL_TEMPLATE_REQUIREMENTS.MODEL]: FunctionTemplateKeys.Model,
      [INTERNAL_TEMPLATE_REQUIREMENTS.METHODS]: {
        [INTERNAL_TEMPLATE_REQUIREMENTS.METHOD.PROCESS]: {
          [INTERNAL_TEMPLATE_REQUIREMENTS.PARAMETERS]: [INTERNAL_TEMPLATE_REQUIREMENTS.CHANGECLASS]
        }
      }
    }
  },
  propreties: {
    [INTERNAL_TEMPLATE_REQUIREMENTS.DETERMINING_PROPERTY]: {
      [INTERNAL_TEMPLATE_REQUIREMENTS.MODEL]: FunctionTemplateKeys.Model,
      [INTERNAL_TEMPLATE_REQUIREMENTS.PROPERTY]: FunctionTemplateKeys.Property
    }
  }
};
const TEMPLATE_KEY_MODIFIERS = {
  lower: "lower",
  alllower: "alllower",
  upper: "upper"
};
function ToInterface(i) {
  return `I${i}`;
}
const HTTP_METHODS = {
  POST: "HttpPost",
  GET: "HttpGet",
  DELETE: "HttpDelete",
  PATCH: "HttpPatch"
};
const COMMON_FUNCTION_TEMPLATE_KEYS = {
  model: "model",
  function_name: "function_name",
  user: "user",
  user_instance: "user_instance",
  value: "value",
  agent: "agent",
  agent_type: "agent_type"
};
const COMMON_FUNCTION_TEMPLATE_KEYS_USER = {
  model: "model",
  function_name: "function_name",
  user: "user",
  user_instance: "user_instance",
  value: "value"
};
const PERMISSION_DEFAULTS = {
  implementation: "./app/templates/permissions/permission_method.tpl",
  interface_: "./app/templates/permissions/permission_method_interface.tpl",
  params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent]
};
const VALIDATION_DEFAULTS = {
  implementation: "./app/templates/validation/validation_method.tpl",
  interface_: "./app/templates/validation/validation_method_interface.tpl",
  params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent, {
    key: FunctionTemplateKeys.ChangeParameter,
    changeparameter: true,
    template: `{{${FunctionTemplateKeys.Model}}}ChangeBy{{${FunctionTemplateKeys.Agent}}}`
  }]
};
const FILTER_DEFAULTS = {
  implementation: "./app/templates/filter/filter_method.tpl",
  interface_: "./app/templates/filter/filter_method_interface.tpl",
  params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent, {
    key: FunctionTemplateKeys.ModelOutput,
    metaparameter: true
  }]
};
const QUERY_PARAMETER_KEYS = {
  Skip: "skip",
  Take: "take",
  Filter: "filter",
  Sort: "sort",
  Id: "id"
};
const TEMPLATE_PARAMETER_KEYS = {
  ModelId: "modelId",
  ParentId: "parentId"
};
const QUERY_PARAMETERS = {
  [QUERY_PARAMETER_KEYS.Skip]: true,
  [QUERY_PARAMETER_KEYS.Take]: true,
  [QUERY_PARAMETER_KEYS.Filter]: true,
  [QUERY_PARAMETER_KEYS.Sort]: true
};
const TEMPLATE_PARAMETERS = {
  [TEMPLATE_PARAMETER_KEYS.ModelId]: true
};
const GET_QUERY_PARAMETERS = {
  [QUERY_PARAMETER_KEYS.Id]: true
};
const MethodFunctions = {
  [functiontypes_FunctionTypes.Create_Object__Object]: {
    title: Create_Object__Object,
    titleTemplate: function (t, a) {
      return `Create ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/create_model_agent_object.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/create_model_agent_object_interface.tpl", "utf8"),
    templates: {},
    permission: { ...PERMISSION_DEFAULTS
    },
    parameters: {
      body: true,
      parameters: false
    },
    lambda: {
      default: {
        user: "user",
        value: "model",
        model_output: "model",
        "result.IdValue": "string",
        agent: "agent",
        return: "model_output"
      }
    },
    constraints: { ...COMMON_CONSTRAINTS_OBJECT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    isList: false,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Update_Object_With_User]: {
    title: Update_Object_With_User,
    titleTemplate: function (t, a) {
      return `Update ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/update_model_user_object.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/update_model_user_object_interface.tpl", "utf8"),
    templates: {},
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.User]
    },
    parameters: {
      body: true,
      parameters: false
    },
    constraints: { ...COMMON_CONSTRAINTS_OBJECT_METHOD_OBJECT,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    isList: false,
    method: nodetypes_Methods.Update,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS_USER
    }
  },
  [functiontypes_FunctionTypes.Get_Objects_From_List_Of_Ids]: {
    title: GetObjectsFromLIstOfIds,
    description: "Gets objects from a list of Ids",
    titleTemplate: function (t, a) {
      return `Get ${t}s With IdList by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_listobject_with_id_list.tpl", "utf-8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_listobject_with_id_list_interface.tpl", "utf-8"),
    controller: external_fs_default.a.readFileSync("./app/templates/controller/controller_get_all_by_ids.tpl", "utf-8"),
    //controller_get_all_by_ids
    templates: {},
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Agent]
    },
    parameters: {
      body: true,
      parameters: false
    },
    filter: { ...FILTER_DEFAULTS,
      params: [FunctionTemplateKeys.Agent, FunctionTemplateKeys.FetchParameter, {
        key: FunctionTemplateKeys.ModelOutput,
        metaparameter: FunctionTemplateKeys.ModelOutput
      }]
    },
    constraints: { ...COMMON_CONSTRAINTS_OBJECT_METHOD_OBJECT,
      [FunctionTemplateKeys.FetchParameter]: {
        key: FunctionTemplateKeys.FetchParameter,
        nodeTypes: [NodeTypes.Model]
      }
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    isList: true,
    isFetchCompatible: true,
    method: nodetypes_Methods.GetAll,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS_USER
    }
  },
  [functiontypes_FunctionTypes.Create_Object_With_User]: {
    title: Create_Object_With_User,
    titleTemplate: function (t, a) {
      return `Create ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/create_model_user_object.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/create_model_user_object_interface.tpl", "utf8"),
    templates: {},
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.User]
    },
    parameters: {
      body: true,
      parameters: false
    },
    constraints: { ...COMMON_CONSTRAINTS_OBJECT_METHOD_OBJECT,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    isList: false,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS_USER
    }
  },
  [functiontypes_FunctionTypes.Create_ManyToMany_Object_With_Agent_And_Return_M2M_SET]: {
    title: functiontypes_FunctionTypes.Create_ManyToMany_Object_With_Agent_And_Return_M2M_SET,
    titleTemplate: function (t, a) {
      return `Create ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/many_2_many/create_with_agent_and_return_m2m_set.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/many_2_many/create_with_agent_and_return_m2m_set_interface.tpl", "utf8"),
    filter: {
      params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent]
    },
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_OBJECT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    isList: true,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Create_Object_Agent_Many_to_Many_CompositeInput__Object]: {
    title: Create_Object_Agent_Many_to_Many_CompositeInput__Object,
    titleTemplate: function (t, a) {
      return `Create ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/create_object_agent_many_to_many_compositeinput.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/create_object_agent_many_to_many_compositeinput_interface.tpl", "utf8"),
    permission: {
      implementation: "./app/templates/permissions/permission_method.tpl",
      interface_: "./app/templates/permissions/permission_method_interface.tpl",
      params: [FunctionTemplateKeys.CompositeInput, FunctionTemplateKeys.Agent]
    },
    validation: { ...VALIDATION_DEFAULTS,
      asModel: FunctionTemplateKeys.CompositeInput,
      //Used as the model in the validation functions.
      params: [FunctionTemplateKeys.CompositeInput, FunctionTemplateKeys.Agent, {
        key: FunctionTemplateKeys.ChangeParameter,
        changeparameter: true,
        template: `{{${FunctionTemplateKeys.CompositeInput}}}ChangeBy{{${FunctionTemplateKeys.Agent}}}`
      }]
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_MANY_TO_MANY_COMPOSITEINPUT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    ok: true,
    isList: false,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Create_Object_Agent_Value__IListObject]: {
    title: Create_Object_Agent_Value__IListObject,
    titleTemplate: function (t, a) {
      return `Create ${t} by ${a} and Return List of ${t}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/create_model_agent_listobject.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/create_model_agent_listobject_interface.tpl", "utf8"),
    constraints: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ModelOutput]: {
        key: FunctionTemplateKeys.ModelOutput,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.User]: {
        [nodetypes_NodeProperties.IsUser]: true,
        key: FunctionTemplateKeys.User,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Permission]: {
        key: FunctionTemplateKeys.Permission,
        nodeTypes: [NodeTypes.Permission]
      },
      [FunctionTemplateKeys.ModelFilter]: {
        key: FunctionTemplateKeys.ModelFilter,
        nodeTypes: [NodeTypes.ModelFilter]
      },
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Update_Object_Agent_Value__IListObject]: {
    title: Update_Object_Agent_Value__IListObject,
    titleTemplate: function (t, a) {
      return `Update ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/update_model_agent_listobject.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/update_model_agent_listobject_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Update,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Update_Object_Agent_Value__Object]: {
    title: Update_Object_Agent_Value__Object,
    titleTemplate: function (t, a) {
      return `Update ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/update_model_agent_object.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/update_model_agent_object_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    parameters: {
      body: true,
      parameters: false
    },
    isList: false,
    method: nodetypes_Methods.Update,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Update_Object_Agent_Value__Object_With_Object]: {
    title: Update_Object_Agent_Value__Object_With_Object,
    titleTemplate: function (t, a) {
      return `Update ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/update_model_agent_object_with_model.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/update_model_agent_object_with_model_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent, FunctionTemplateKeys.UpdateModel]
    },
    templates: {},
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD,
      [FunctionTemplateKeys.UpdateModel]: {
        key: FunctionTemplateKeys.UpdateModel,
        nodeTypes: [NodeTypes.Model]
      },
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    isList: false,
    method: nodetypes_Methods.Update,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Delete_Object_Agent_Value__IListObject]: {
    title: Delete_Object_Agent_Value__IListObject,
    titleTemplate: function (t, a) {
      return `Delete ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/delete_model_agent_listobject.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/delete_model_agent_listobject_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Delete,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Delete_M2M_By_Reference]: {
    title: functiontypes_FunctionTypes.Delete_M2M_By_Reference,
    titleTemplate: function (t, a) {
      return `Delete ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/delete_m2m_by_reference.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/delete_m2m_by_reference_interface.tpl", "utf8"),
    test: external_fs_default.a.readFileSync("./app/templates/standard/delete_m2m_by_reference_test.tpl", "utf8"),
    controller: external_fs_default.a.readFileSync("./app/templates/standard/delete_m2m_by_reference_controller.tpl", "utf8"),
    filter: {
      params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent, {
        key: FunctionTemplateKeys.ModelOutput,
        metaparameter: true
      }]
    },
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Delete,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Get_Object_Agent_Value__IListObject]: {
    title: Get_Object_Agent_Value__IListObject,
    titleTemplate: function (t, a) {
      return `Get ${t}s by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_listobject.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_listobject_interface.tpl", "utf8"),
    controller_parameters: {
      params: [FunctionTemplateKeys.Model]
    },
    permission: { ...PERMISSION_DEFAULTS
    },
    filter: { ...FILTER_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    parameters: {
      body: false,
      parameters: {
        query: { ...QUERY_PARAMETERS
        }
      }
    },
    isList: true,
    method: nodetypes_Methods.GetAll,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Get_Agent_Value__IListObject]: {
    title: Get_Agent_Value__IListObject,
    titleTemplate: function (t, a) {
      return `Get ${t}s List by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_listobject.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_listobject_interface.tpl", "utf8"),
    controller: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_listobjects_controller.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Agent]
    },
    filter: { ...FILTER_DEFAULTS,
      params: [FunctionTemplateKeys.Agent, {
        key: FunctionTemplateKeys.ModelOutput,
        metaparameter: true
      }]
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_OBJECT_METHOD
    },
    parameters: {
      body: false,
      parameters: {
        query: { ...QUERY_PARAMETERS
        }
      }
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.GetAll,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Login]: {
    title: Login,
    // template: fs.readFileSync('./app/templates/standard/get_agent_listobject.tpl', 'utf8'),
    // interface: fs.readFileSync('./app/templates/standard/get_agent_listobject_interface.tpl', 'utf8'),
    // controller: fs.readFileSync('./app/templates/standard/get_agent_listobjects_controller.tpl', 'utf8'),
    constraints: { ...COMMON_CONSTRAINTS_ANONYMOUS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    permission: false,
    validation: false,
    filter: false,
    parameters: {
      body: {},
      parameters: false
    },
    isList: false,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Register]: {
    title: Register,
    constraints: { ...COMMON_CONSTRAINTS_ANONYMOUS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    permission: false,
    validation: false,
    filter: false,
    parameters: {
      body: {},
      parameters: false
    },
    isList: false,
    method: nodetypes_Methods.Create,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Create_Parent$Child_Agent_Value__IListChild]: {
    title: Create_Parent$Child_Agent_Value__IListChild,
    titleTemplate: function (t, a) {
      return `Create ${t} List by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/create_agent_childparent_listchild.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/create_agent_childparent_listchild_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_PARENT_CHILD_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    parameters: {
      body: true,
      parameters: {
        query: { ...QUERY_PARAMETERS
        }
      }
    },
    isList: true,
    method: nodetypes_Methods.Create,
    ...COMMON_FUNCTION_REQUIREMENTS,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Update_Parent$Child_Agent_Value__IListChild]: {
    title: Update_Parent$Child_Agent_Value__IListChild,
    titleTemplate: function (t, a) {
      return `Update ${t} List by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/update_agent_childparent_listchild.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/update_agent_childparent_listchild_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_AGENT_PARENT_CHILD_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Update,
    ...COMMON_FUNCTION_REQUIREMENTS,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Get_Parent$Child_Agent_Value__IListChild]: {
    title: Get_Parent$Child_Agent_Value__IListChild,
    titleTemplate: function (t, a) {
      return `Get ${t} List by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/get_agent_childparent_listchild.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/get_agent_childparent_listchild_interface.tpl", "utf8"),
    controller: external_fs_default.a.readFileSync("./app/templates/controller/controller_get_all_by_parent.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Parent, FunctionTemplateKeys.Agent]
    },
    filter: { ...FILTER_DEFAULTS,
      params: [FunctionTemplateKeys.Parent, FunctionTemplateKeys.Agent, {
        key: FunctionTemplateKeys.ModelOutput,
        metaparameter: true
      }]
    },
    constraints: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ModelOutput]: {
        key: FunctionTemplateKeys.ModelOutput,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Parent]: {
        key: FunctionTemplateKeys.Parent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ManyToManyModel]: {
        [nodetypes_NodeProperties.ManyToManyNexus]: true,
        key: FunctionTemplateKeys.ManyToManyModel,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.User]: {
        [nodetypes_NodeProperties.IsUser]: true,
        key: FunctionTemplateKeys.User,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Permission]: {
        key: FunctionTemplateKeys.Permission,
        nodeTypes: [NodeTypes.Permission]
      },
      [FunctionTemplateKeys.ModelFilter]: {
        key: FunctionTemplateKeys.ModelFilter,
        nodeTypes: [NodeTypes.ModelFilter]
      }
    },
    parameters: {
      body: false,
      parameters: {
        path: [FunctionTemplateKeys.Parent],
        query: { ...QUERY_PARAMETERS
        }
      }
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    parentGet: true,
    method: nodetypes_Methods.GetAll,
    ...COMMON_FUNCTION_REQUIREMENTS,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Get_Object_Agent_Value__IListObject_By_Specific]: {
    title: Get_Object_Agent_Value__IListObject_By_Specific,
    titleTemplate: function (t, a) {
      return `Get ${t} List by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_listobject_specific.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_listobject_specific_interface.tpl", "utf8"),
    controller: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_listobject_specific_controller.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS,
      params: [FunctionTemplateKeys.Agent]
    },
    filter: { ...FILTER_DEFAULTS,
      params: [FunctionTemplateKeys.Agent, {
        key: FunctionTemplateKeys.ModelOutput,
        metaparameter: true
      }]
    },
    constraints: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.ModelOutput]: {
        key: FunctionTemplateKeys.ModelOutput,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.User]: {
        [nodetypes_NodeProperties.IsUser]: true,
        key: FunctionTemplateKeys.User,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Permission]: {
        key: FunctionTemplateKeys.Permission,
        nodeTypes: [NodeTypes.Permission]
      },
      [FunctionTemplateKeys.ModelFilter]: {
        key: FunctionTemplateKeys.ModelFilter,
        nodeTypes: [NodeTypes.ModelFilter]
      }
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.GetAll,
    ...COMMON_FUNCTION_REQUIREMENTS,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Get_Object_Agent_Value__Object]: {
    title: Get_Object_Agent_Value__Object,
    titleTemplate: function (t, a) {
      return `Get ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_object.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/get_model_agent_object_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: {
      [FunctionTemplateKeys.Model]: {
        key: FunctionTemplateKeys.Model,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Agent]: {
        [nodetypes_NodeProperties.IsAgent]: true,
        key: FunctionTemplateKeys.Agent,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.User]: {
        [nodetypes_NodeProperties.IsUser]: true,
        key: FunctionTemplateKeys.User,
        nodeTypes: [NodeTypes.Model]
      },
      [FunctionTemplateKeys.Permission]: {
        key: FunctionTemplateKeys.Permission,
        nodeTypes: [NodeTypes.Permission]
      },
      [FunctionTemplateKeys.ModelFilter]: {
        key: FunctionTemplateKeys.ModelFilter,
        nodeTypes: [NodeTypes.ModelFilter]
      }
    },
    output: { ...COMMON_OUTPUT.OBJECT
    },
    parameters: {
      body: false,
      parameters: {
        template: { ...TEMPLATE_PARAMETERS
        }
      }
    },
    isList: false,
    method: nodetypes_Methods.Get,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Get_ManyToMany_Agent_Value__IListChild]: {
    title: Get_ManyToMany_Agent_Value__IListChild,
    titleTemplate: function (t, a) {
      return `Get ${t} List by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_manytomany_listchild.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/get_agent_manytomany_listchild_interface.tpl", "utf8"),
    filter: { ...FILTER_DEFAULTS,
      params: [FunctionTemplateKeys.Model, FunctionTemplateKeys.Agent, {
        key: FunctionTemplateKeys.ConnectionType,
        metaparameter: true
      }]
    },
    constraints: { ...COMMON_CONSTRAINTS_MANYTOMANY_CHILD_METHOD
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    parentGet: true,
    isList: true,
    method: nodetypes_Methods.GetAll,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Create_ManyToMany_Agent_Value__IListChild]: {
    title: Create_ManyToMany_Agent_Value__IListChild,
    titleTemplate: function (t, a) {
      return `Create ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/create_agent_manytomany_listchild.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/create_agent_manytomany_listchild_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_MANYTOMANY_CHILD_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Create,
    ...COMMON_FUNCTION_REQUIREMENTS,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Update_ManyToMany_Agent_Value__IListChild]: {
    title: Update_ManyToMany_Agent_Value__IListChild,
    titleTemplate: function (t, a) {
      return `Update ${t} by ${a}`;
    },
    template: external_fs_default.a.readFileSync("./app/templates/standard/update_agent_manytomany_listchild.tpl", "utf8"),
    interface: external_fs_default.a.readFileSync("./app/templates/standard/update_agent_manytomany_listchild_interface.tpl", "utf8"),
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: { ...COMMON_CONSTRAINTS_MANYTOMANY_CHILD_METHOD,
      ...COMMON_CREATE_UPDATE_CONSTRAINTS
    },
    output: { ...COMMON_OUTPUT.LIST
    },
    isList: true,
    method: nodetypes_Methods.Update,
    ...COMMON_FUNCTION_REQUIREMENTS,
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  },
  [functiontypes_FunctionTypes.Can_Execute_Agent_Parent_In_Valid_List]: {
    title: Can_Execute_Agent_Parent_In_Valid_List,
    template: external_fs_default.a.readFileSync("./app/templates/can_execute/can_execute_childparent_valid_list.tpl", "utf8"),
    titleTemplate: function (t, a) {
      return `Can Execute ${t} by ${a}`;
    },
    permission: { ...PERMISSION_DEFAULTS
    },
    constraints: {
      [FunctionTemplateKeys.AgentType]: {
        [FunctionConstraintKeys.IsAgent]: true,
        [FunctionConstraintKeys.IsSingleLink]: true,
        [FunctionConstraintKeys.IsModel]: true,
        key: FunctionTemplateKeys.AgentType
      },
      [FunctionTemplateKeys.AgentDeterminingProperty]: {
        [FunctionConstraintKeys.IsChild]: FunctionTemplateKeys.AgentType,
        [FunctionConstraintKeys.IsSingleLink]: true,
        [FunctionConstraintKeys.IsProperty]: true,
        key: FunctionTemplateKeys.AgentDeterminingProperty
      },
      [FunctionTemplateKeys.Model]: {
        [FunctionConstraintKeys.IsSingleLink]: true,
        [FunctionConstraintKeys.IsModel]: true,
        key: FunctionTemplateKeys.Model
      },
      [FunctionTemplateKeys.ModelDeterminingProperty]: {
        [FunctionConstraintKeys.IsChild]: FunctionTemplateKeys.Model,
        [FunctionConstraintKeys.IsSingleLink]: true,
        [FunctionConstraintKeys.IsProperty]: true,
        [FunctionConstraintKeys.IsEnumerable]: true,
        key: FunctionTemplateKeys.ModelDeterminingProperty
      },
      [FunctionTemplateKeys.AgentInstance]: {
        [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.AgentType,
        [FunctionConstraintKeys.IsSingleLink]: true,
        key: FunctionTemplateKeys.AgentInstance,
        [FunctionConstraintKeys.IsInstanceVariable]: true,
        [FunctionConstraintKeys.IsInputVariable]: true
      },
      [FunctionTemplateKeys.Value]: {
        [FunctionConstraintKeys.IsTypeOf]: FunctionTemplateKeys.Model,
        [FunctionConstraintKeys.IsSingleLink]: true,
        key: FunctionTemplateKeys.Value,
        [FunctionConstraintKeys.IsInstanceVariable]: true,
        [FunctionConstraintKeys.IsInputVariable]: true
      }
    },
    output: { ...COMMON_OUTPUT.BOOL
    },
    [FUNCTION_REQUIREMENT_KEYS.CLASSES]: {},
    attachment_methods: {},
    propreties: {},
    template_keys: { ...COMMON_FUNCTION_TEMPLATE_KEYS
    }
  }
};
Object.values(MethodFunctions).map(t => {
  if (t && !t.permission && t.permission !== false) {
    t.permission = { ...PERMISSION_DEFAULTS
    };
    t.permission.usingDefault = true;
  }

  if (t && !t.validation && t.valdation !== false) {
    t.validation = { ...VALIDATION_DEFAULTS
    };
  }

  if (t && !t.filter && t.filter !== false) {
    t.filter = { ...FILTER_DEFAULTS
    };
  }
});
const MethodTemplateKeys = {
  stream_process_change_parameter: "stream_process_change_parameter",
  update_with: "update_with"
};
const FunctionMethodTypes = {
  GET: "GET",
  CREATE: "CREATE",
  DELETE: "DELETE",
  UPDATE: "UPDATE"
};
const ConditionTypes = {
  InEnumerable: "in-enumeration",
  InExtension: "in-extension",
  MatchReference: "match-reference",
  MatchManyReferenceParameter: "match-many-reference-parameter"
};
const ConditionCases = {
  [ConditionTypes.MatchReference]: {
    $matching: true,
    notmatching: false
  },
  [ConditionTypes.MatchManyReferenceParameter]: {
    $matching: true,
    notmatching: false
  }
};
const ConditionTypeParameters = {
  RefManyToMany: "refManyToMany",
  RefManyToManyProperty: "refManyToManyProperty",
  Ref1: "ref1",
  Ref2: "ref2",
  Ref1UseId: "ref1UseId",
  Ref2UseId: "ref2UseId",
  Ref1Property: "ref1Property",
  Ref2Property: "ref2Property"
};
const ConditionTypeOptions = {
  IsFalse: "is-false",
  IsTrue: "is-true"
};
const ConditionFunctionSetups = {
  [ConditionTypes.MatchReference]: {},
  [ConditionTypes.MatchManyReferenceParameter]: {},
  [ConditionTypes.InEnumerable]: {}
};
Object.keys(MethodFunctions).map(key => {
  if (MethodFunctions[key].constraints) {
    ConditionFunctionSetups[ConditionTypes.MatchReference].functions = ConditionFunctionSetups[ConditionTypes.MatchReference].functions || {};
    ConditionFunctionSetups[ConditionTypes.MatchReference].functions[key] = {
      constraints: { ...MethodFunctions[key].constraints
      }
    };
    ConditionFunctionSetups[ConditionTypes.MatchManyReferenceParameter].functions = ConditionFunctionSetups[ConditionTypes.MatchManyReferenceParameter].functions || {};
    ConditionFunctionSetups[ConditionTypes.MatchManyReferenceParameter].functions[key] = {
      constraints: { ...MethodFunctions[key].constraints
      }
    };
    ConditionFunctionSetups[ConditionTypes.InEnumerable].functions = ConditionFunctionSetups[ConditionTypes.InEnumerable].functions || {};
    ConditionFunctionSetups[ConditionTypes.InEnumerable].functions[key] = {
      constraints: { ...MethodFunctions[key].constraints
      }
    };
  }
});
const FunctionPerpetrators = {
  Agent: "Agent",
  System: "System" // This is theorhetical atm 23.05.2019

};
const ReturnTypes = {
  CHILD: "CHILD",
  OBJECT: "OBJECT",
  LISTCHILD: "LISTCHILD",
  LISTOBJECT: "LISTOBJECT",
  //May end up being a different dimension,
  BOOL: "BOOL"
};
function hasTemplate(templateString) {
  var singularSymbol = "@";
  var regex = new RegExp("({{)[A-Za-z0-9_." + singularSymbol + " ,'|]*(}})", "g");
  var hasTemplate = regex.test(templateString);
  return hasTemplate;
}
function bindTemplate(templateString, data) {
  var singularSymbol = "@";

  try {
    var regex = new RegExp("({{)[A-Za-z0-9_." + singularSymbol + " ,'|]*(}})", "g");
    var hasTemplate;

    try {
      hasTemplate = regex.test(templateString);
    } catch (e) {}

    data = { ...data
    };
    let dataKeyes = Object.keys(data);
    dataKeyes.map(t => {
      if (!data[t + "#lower"]) {
        data[t + "#lower"] = `${data[t]}`.toLowerCase();
      }

      if (!data[t + "#js"]) {
        data[t + "#js"] = `${data[t]}`.toJavascriptName();
      }
    });

    if (hasTemplate) {
      for (var t in data) {
        var subregex = new RegExp("({{)" + t + "(}})", "g");
        var val = data[t];
        templateString = templateString.replace(subregex, val === null || val === undefined ? "" : val);
      }
    }
  } catch (e) {
    console.log("-------------");
    console.log(t);
    console.log(`"${singularSymbol}"`);
    console.log(`"${templateString}"`);
    throw e;
  }

  return templateString;
}
function bindReferenceTemplate(templateString, data) {
  var singularSymbol = "@";

  try {
    var regex = new RegExp("#({)[A-Za-z0-9_." + singularSymbol + " ,'|~]*(})", "g");
    var hasTemplate;

    try {
      hasTemplate = regex.test(templateString);
    } catch (e) {}

    Object.keys(data).map(t => {
      if (!data[t + "#lower"]) {
        data[t + "#lower"] = `${data[t]}`.toLowerCase();
      }
    });

    if (hasTemplate) {
      for (var t in data) {
        var subregex = new RegExp("(#{)" + t + "(})", "g");
        var val = data[t];
        templateString = templateString.replace(subregex, val === null || val === undefined ? "" : val);
      }
    }
  } catch (e) {
    console.log("-------------");
    console.log(t);
    console.log(`"${singularSymbol}"`);
    console.log(`"${templateString}"`);
    throw e;
  }

  return templateString;
}
// CONCATENATED MODULE: ./app/methods/graph_methods.js









const os = __webpack_require__("os");

function createGraph() {
  return {
    id: uuidv4(),
    version: {
      major: 0,
      minor: 0,
      build: 0
    },
    workspace: "",
    title: DefaultGraphTitle,
    path: [],
    namespace: "",
    // Groups
    groups: [],
    groupLib: {},
    groupsNodes: {},
    // group => { node}
    nodesGroups: {},
    // node => {group}
    childGroups: {},
    // group => {group}
    parentGroup: {},
    // group => {group}
    // Groups
    // Reference nodes
    referenceNodes: {},
    // Reference nodes
    nodeLib: {},
    nodes: [],
    nodeLinks: {},
    // A library of nodes, and each nodes that it connects.
    nodeConnections: {},
    // A library of nodes, and each nodes links
    linkLib: {},
    links: [],
    graphs: {},
    classNodes: {},
    functionNodes: {},
    // A function nodes will be run through for checking constraints.
    updated: null,
    visibleNodes: {},
    // Nodes that are visible now, and used to calculate the visibility of other nodes.
    appConfig: {
      Logging: {
        IncludeScopes: false,
        LogLevel: {
          Default: "Debug",
          System: "Information",
          Microsoft: "Information"
        }
      },
      AppSettings: {
        "Local-AuthorizationKey": "C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw==",
        "Local-EndPointUrl": "https://localhost:8081",
        use_local: "true",
        EndPointUrl: "",
        AuthorizationKey: "",
        DatabaseId: "red-db-001",
        AssemblyPrefixes: "Smash;RedQuick",
        "Use-SingleCollection": "true",
        "storage-key": "UseDevelopmentStorage=true",
        "single-thread": true,
        ConfirmEmailController: "Account",
        ConfirmEmailAction: "ConfirmEmail",
        HomeAction: "Index",
        HomeController: "Home",
        ResetPasswordAction: "ResetPassword",
        ResetPasswordController: "Account",
        Domain: "localhost:44338",
        SecurityKey: "ajskdflajsdfklas20klasdkfj9laksdjfl4aksdjf3kanvdlnaekf",
        AppSecret: "YQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6ADAAMQAyADMANAA1AA==",
        Domain: "https://localhost:44338",
        TokenExpirationInMinutes: "250",
        Issuer: "https://localhost:44338",
        Audience: "https://localhost:44338",
        DomainPort: "44338"
      }
    }
  };
}
const GraphKeys = {
  NAMESPACE: "namespace",
  PROJECTNAME: "project_name",
  COLORSCHEME: "color_scheme",
  SERVER_SIDE_SETUP: "server_side_setup",
  THEME: "theme"
};
function updateWorkSpace(graph, options) {
  const {
    workspace
  } = options;
  graph.workspaces = graph.workspaces || {};
  graph.workspaces[os.platform()] = workspace;

  if (graph.workspaces[os.platform()]) {
    graph.workspace = workspace;
  }

  return graph;
}
function CreateLayout() {
  return {
    layout: {},
    properties: {}
  };
}
function FindLayoutRoot(id, root) {
  if (root && root[id]) {
    return root[id];
  }

  let res;
  Object.keys(root).find(t => {
    if (root[t]) res = FindLayoutRoot(id, root[t]);else {
      return false;
    }
    return res;
  });
  return res;
  return false;
}
function FindLayoutRootParent(id, root, parent) {
  if (root[id]) {
    return root || parent;
  }

  let res;
  Object.keys(root).find(t => {
    res = FindLayoutRootParent(id, root[t], root);
    return res;
  });
  return res;
  return false;
}
function GetAllChildren(root) {
  let result = Object.keys(root || {});
  result.map(t => {
    const temp = GetAllChildren(root[t]);
    result = [...result, ...temp];
  });
  return result;
}
const DefaultCellProperties = {
  style: {
    borderStyle: "solid",
    borderWidth: 1
  },
  children: {}
};
function GetCellProperties(setup, id) {
  const {
    properties
  } = setup;
  return properties[id];
}
function RemoveCellLayout(setup, id) {
  if (setup && setup.layout) {
    const parent = FindLayoutRootParent(id, setup.layout);

    if (parent) {
      const kids = GetAllChildren(parent[id]);
      kids.map(t => {
        delete setup.properties[t];
      });
      delete parent[id];
      delete setup.properties[id];
    }
  }

  return setup;
}
function ReorderCellLayout(setup, id, dir = -1) {
  if (setup && setup.layout) {
    const parent = FindLayoutRootParent(id, setup.layout);

    if (parent) {
      //     let kids = GetAllChildren(parent[id]);
      //     // kids.map(t => {
      //     //     delete setup.properties[t];
      //     // });
      //     delete parent[id];
      //     delete setup.properties[id];
      // }
      const layout = parent;
      const keys = Object.keys(layout);

      if (keys.some(v => v === id)) {
        const id_index = keys.indexOf(id);

        if (id_index === 0 && dir === -1) {} else if (id_index === keys.length - 1 && dir === 1) {} else {
          const temp = keys[id_index];
          keys[id_index] = keys[id_index + dir];
          keys[id_index + dir] = temp;
        }

        const temp_layout = { ...layout
        };
        keys.map(k => delete layout[k]);
        keys.map(k => layout[k] = temp_layout[k]);
      }
    }
  }

  return setup;
}
function GetChildren(setup, parentId) {
  const parent = FindLayoutRootParent(parentId, setup.layout);
  return Object.keys(parent[parentId]);
}
function GetFirstCell(setup) {
  const keys = setup ? Object.keys(setup.layout) : [];
  return keys[0] || null;
}
function SetCellsLayout(setup, count, id, properties = DefaultCellProperties) {
  let keys = [];
  let root = null;
  count = parseInt(count);

  if (!id) {
    keys = Object.keys(setup.layout);
    root = setup.layout;
  } else {
    root = FindLayoutRoot(id, setup.layout);

    if (!root) {
      throw "missing root";
    }

    keys = Object.keys(root);
  } // If there is room add keys


  if (keys.length - count < 0) {
    [].interpolate(0, count - keys.length, () => {
      const newkey = uuidv4();
      root[newkey] = {};
      setup.properties[newkey] = { ...JSON.parse(JSON.stringify(properties))
      };
    });
  } else if (keys.length - count > 0) {
    [].interpolate(0, keys.length - count, index => {
      delete root[keys[index]];
      delete setup.properties[keys[index]];
    });
  }

  return setup;
}
function incrementBuild(graph) {
  graph.version.build++;
  return graph;
}
function incrementMinor(graph) {
  graph.version.minor++;
  graph.version.build = 0;
  return graph;
}
function incrementMajor(graph) {
  graph.version.major++;
  graph.version.minor = 0;
  graph.version.build = 0;
  return graph;
}
function updateGraphTitle(graph, ops) {
  const {
    text
  } = ops;
  graph.title = text;
  return graph;
}
function createScreenParameter(parameter) {
  return {
    title: parameter || "",
    id: uuidv4()
  };
}
function GetParameterName(parameter) {
  if (parameter) return parameter.title || "";
  return "";
}
function updateGraphProperty(graph, ops) {
  const {
    prop,
    value
  } = ops;
  graph[prop] = value;
  return graph;
}
function addNewSubGraph(graph) {
  const newgraph = createGraph();
  newgraph.title = DefaultSubGraphTitle;
  graph.graphs[newgraph.id] = newgraph;
  return graph;
}
function removeSubGraph(graph, id) {
  delete graph.graphs[id];
  return graph;
}
function getSubGraphs(graph) {
  return graph && graph.graphs ? Object.keys(graph.graphs || {}).map(t => graph.graphs[t]) : [];
}
function getSubGraph(graph, scopes) {
  let result = graph;
  scopes.map(scope => {
    result = graph.graphs[scope];
  });
  return result;
}
function getScopedGraph(graph, options) {
  const {
    scope
  } = options;

  if (scope && scope.length) {
    console.log(scope);
    scope.map((s, i) => {
      graph = graph.graphs[s];
    });
  }

  return graph;
}
function setScopedGraph(root, options) {
  const {
    scope,
    graph
  } = options;

  if (scope && scope.length) {
    let currentGraph = root;
    scope.map((s, i) => {
      if (i === scope.length - 1) {
        currentGraph.graphs[s] = graph;
      } else {
        currentGraph = currentGraph.graphs[s];
      }
    });
  } else {
    root = graph;
  }

  return root;
}
function newGroup(graph, callback) {
  const group = createGroup();
  const result = addGroup(graph, group);

  if (callback) {
    callback(group);
  }

  return result;
}
function GetNodesInGroup(graph, group) {
  return graph.groupsNodes && graph.groupsNodes[group] && Object.keys(graph.groupsNodes[group]).filter(v => graph.groupsNodes[group][v]) || [];
}
function addLeaf(graph, ops) {
  const {
    leaf,
    id
  } = ops;
  let leaves = graph.groupLib[id].leaves || [];
  leaves = [...leaves, leaf].unique(x => x); // Groups => nodes

  graph.groupsNodes[id] = graph.groupsNodes[id] || {};
  graph.groupsNodes[id][leaf] = true;
  graph.groupsNodes = { ...graph.groupsNodes
  }; // Nodes => groups

  graph.nodesGroups[leaf] = graph.nodesGroups[leaf] || {};
  graph.nodesGroups[leaf][id] = true;
  graph.nodesGroups = { ...graph.nodesGroups
  };
  graph.groupLib[id].leaves = leaves;
  return graph;
}
function removeLeaf(graph, ops) {
  const {
    leaf,
    id
  } = ops;
  const group = graph.groupLib[id];

  if (group) {
    let leaves = group.leaves || [];
    leaves = [...leaves.filter(t => t !== leaf)];
    graph.groupLib[id].leaves = leaves;
  }

  if (graph.groupsNodes[id]) {
    if (graph.groupsNodes[id][leaf]) {
      delete graph.groupsNodes[id][leaf];
    }

    if (Object.keys(graph.groupsNodes[id]).length === 0) {
      delete graph.groupsNodes[id];
      graph.groups = [...graph.groups.filter(x => x !== id)];
      delete graph.groupLib[id];
    }

    graph.groupsNodes = { ...graph.groupsNodes
    };
  }

  if (graph.nodesGroups[leaf]) {
    if (graph.nodesGroups[leaf][id]) {
      delete graph.nodesGroups[leaf][id];
    }

    if (Object.keys(graph.nodesGroups[leaf]).length === 0) {
      delete graph.nodesGroups[leaf];
    }

    graph.nodesGroups = { ...graph.nodesGroups
    };
  }

  return graph;
}
function addGroupToGroup(graph, ops) {
  const {
    groupId,
    id
  } = ops;
  const group = graph.groupLib[id];
  const groups = group.groups || [];
  group.groups = [...groups, groupId].unique(x => x);
  graph.groupLib[id] = group;
  graph.groupLib = { ...graph.groupLib
  }; // Groups need to know who contains them,

  graph.childGroups[id] = graph.childGroups[id] || {};
  graph.childGroups[id][groupId] = true; // and also the containers to know about the groups

  graph.parentGroup[groupId] = graph.parentGroup[groupId] || {};
  graph.parentGroup[groupId][id] = true;
  return graph;
}
function removeGroupFromGroup(graph, ops) {
  const {
    groupId,
    id
  } = ops;
  const group = graph.groupLib[id];

  if (group && group.groups) {
    group.groups = [...group.groups.filter(x => x !== groupId)];
  }

  graph.groupLib[id] = { ...group
  };

  if (graph.childGroups) {
    if (graph.childGroups[id]) {
      delete graph.childGroups[id][groupId];

      if (!Object.keys(graph.childGroups[id]).length) {
        delete graph.childGroups[id];
      }
    }

    if (graph.parentGroup[groupId]) {
      delete graph.parentGroup[groupId][id];

      if (!Object.keys(graph.parentGroup[groupId]).length) {
        delete graph.childGroups[groupId];
      }
    }
  }

  return graph;
}
function getNodesGroups(graph, id) {
  return graph && graph.nodesGroups ? graph.nodesGroups[id] : null;
}
function clearGroup(graph, ops) {
  const {
    id
  } = ops;

  for (const i in graph.groupsNodes[id]) {
    if (graph.nodesGroups[i]) {
      delete graph.nodesGroups[i][id];

      if (Object.keys(graph.nodesGroups[i]).length === 0) {
        delete graph.nodesGroups[i];
      }
    }
  }

  for (const i in graph.childGroups[id]) {
    if (graph.parentGroup[i]) {
      delete graph.parentGroup[i][id];

      if (Object.keys(graph.parentGroup[i]).length === 0) {
        delete graph.parentGroup[i];
      }
    }
  }

  graph.groups = [...graph.groups.filter(x => x !== id)];
  delete graph.groupLib[id];
  delete graph.childGroups[id];
  delete graph.groupsNodes[id];
  return graph;
}
function createValidator() {
  return {
    properties: {}
  };
}
function createMethodValidation(methodType) {
  const res = {
    methods: {}
  };

  if (res && !res.methods[methodType]) {
    res.methods[methodType] = createMethodValidationType();
  }

  return res;
}
function createMethodValidationType() {
  return {};
}
function getMethodValidationType(methodValidation, methodType) {
  const {
    methods
  } = methodValidation;

  if (methods && methods[methodType]) {
    return methods[methodType];
  }

  return null;
}
function addMethodValidationForParamter(methodValidation, methodType, methodParam, methedParamProperty) {
  methodValidation = methodValidation || createMethodValidation(methodType);

  if (getMethodValidationType(methodValidation, methodType)) {
    const methodValidationType = getMethodValidationType(methodValidation, methodType);

    if (methodParam) {
      methodValidationType[methodParam] = methodValidationType[methodParam] || createProperyContainer();

      if (methedParamProperty && methodValidationType[methodParam]) {
        methodValidationType[methodParam].properties[methedParamProperty] = methodValidationType[methodParam].properties[methedParamProperty] || createValidatorProperty();
      }
    }
  }

  return methodValidation;
}
function createProperyContainer() {
  return {
    properties: {}
  };
}
function getMethodValidationForParameter(methodValidation, methodType, methodParam, methodProperty) {
  methodValidation = methodValidation || addMethodValidationForParamter(methodValidation, methodType, methodParam);

  if (methodValidation) {
    const temp = getMethodValidationType(methodValidation, methodType);

    if (!temp) {
      methodValidation.methods[methodType] = createMethodValidation(methodType).methods[methodType];
    }

    if (temp) {
      if (temp[methodParam] && temp[methodParam]) {
        return temp[methodParam];
      }
    }
  }

  return null;
}
function removeMethodValidationParameter(methodValidation, methodType, methodParam, methedParamProperty) {
  if (methodValidation) {
    const temp = getMethodValidationType(methodValidation, methodType);

    if (temp) {
      if (temp[methodParam] && temp[methodParam].properties && temp[methodParam].properties[methedParamProperty]) {
        delete temp[methodParam].properties[methedParamProperty];
      }
    }
  }

  return methodValidation;
}
const createExecutor = createValidator;
function createValidatorProperty() {
  return {
    validators: {}
  };
}
function hasValidator(validator, options) {
  if (validator && validator.properties && validator.properties[options.id]) {
    if (options.validator && validator.properties[options.id].validators) {
      const {
        validators
      } = validator.properties[options.id];
      return Object.keys(validators).some(id => validators[id].type === options.validatorArgs.type);
    }
  }

  return false;
}
function addValidatator(validator, options) {
  validator.properties[options.id] = validator.properties[options.id] || createValidatorProperty();
  if (options.validator) validator.properties[options.id].validators[options.validator] = options.validatorArgs;
  return validator;
}
function removeValidatorValidation(_validator, options) {
  const {
    property,
    validator
  } = options;
  delete _validator.properties[property].validators[validator];
  return _validator;
}
function removeValidator(validator, options) {
  delete validator.properties[options.id];
  return validator;
}
function getValidatorItem(item, options) {
  const {
    property,
    validator
  } = options;
  return item.properties[property].validators[validator];
}
function getValidatorProperties(validator) {
  return validator ? validator.properties : null;
}
function setDepth(graph, options) {
  const {
    depth
  } = options;
  graph.depth = depth;
  return graph;
}
function graph_methods_newNode(graph, options) {
  const node = createNode();

  if (_viewPackageStamp) {
    for (const p in _viewPackageStamp) {
      node.properties[p] = _viewPackageStamp[p];
    }
  }

  return addNode(graph, node, options);
}
function createExtensionDefinition() {
  return {
    // The code generation will define the unique 'value'.
    config: {
      // If this definition is a list or some sort of collection.
      isEnumeration: false,
      // If not, then it is a dictionary, and will have some sort of property that will  be considered the value.
      dictionary: {},
      // A list of objects, with the same shape as the dictionary.
      list: []
    },
    definition: {}
  };
}
function defaultExtensionDefinitionType() {
  return "string";
}
function MatchesProperties(properties, node) {
  if (properties && node) {
    const res = !Object.keys(properties).some(key => properties[key] !== uiactions_GetNodeProp(node, key));
    return res;
  }

  return false;
}
function removeNode(graph, options = {}) {
  const {
    id
  } = options;
  const idsToDelete = [id];
  const autoDelete = uiactions_GetNodeProp(id, nodetypes_NodeProperties.AutoDelete, graph);

  if (autoDelete) {
    GetNodesLinkedTo(graph, {
      id
    }).filter(x => MatchesProperties(autoDelete.properties, x)).map(t => {
      idsToDelete.push(t.id);
    });
  }

  idsToDelete.map(id => {
    const existNodes = getNodesByLinkType(graph, {
      exist: true,
      id,
      direction: graph_methods_TARGET,
      type: nodetypes_LinkType.Exist
    });
    graph = incrementBuild(graph); // links

    graph = clearLinks(graph, options); // groups

    graph = removeNodeFromGroups(graph, options);

    if (graph.functionNodes && graph.functionNodes[id]) {
      delete graph.functionNodes[id];
      graph.functionNodes = { ...graph.functionNodes
      };
    }

    if (graph.classNodes && graph.classNodes[id]) {
      delete graph.classNodes[id];
      graph.classNodes = { ...graph.classNodes
      };
    }

    delete graph.nodeLib[id];
    graph.nodeLib = { ...graph.nodeLib
    };
    graph.nodes = [...graph.nodes.filter(x => x !== id)];

    if (existNodes) {
      existNodes.map(en => {
        graph = removeNode(graph, {
          id: en.id
        });
      });
    }
  });
  return graph;
}
function GetManyToManyNodes(state, ids) {
  if (state && ids && ids.length) {
    return NodesByType(state, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ManyToManyNexus)).filter(x => !(ids || []).some(t => (uiactions_GetNodeProp(x, nodetypes_NodeProperties.ManyToManyNexusTypes) || []).indexOf(t) !== -1));
  }

  return [];
}
function getPropertyNodes(graph, id) {
  return getNodesByLinkType(graph, {
    id,
    direction: SOURCE,
    type: nodetypes_LinkType.PropertyLink
  });
}
function getDataChainNodes(graph, id) {
  return getNodesByLinkType(graph, {
    id,
    direction: graph_methods_TARGET,
    type: nodetypes_LinkType.DataChainLink
  });
}

function isEmpty(obj) {
  return obj && Object.keys(obj).length === 0;
}

function clearGroupDeep(graph, options) {
  const {
    id,
    callback
  } = options;
  let success = true;

  if (graph.childGroups[id]) {
    for (var i in graph.childGroups[id]) {
      var ok = false;
      graph = clearGroupDeep(graph, {
        id: i,
        callback: v => {
          ok = v;
          success = success && v;
        }
      });

      if (graph.childGroups[id]) {
        delete graph.childGroups[id][i];
      }
    }
  }

  if (success) {
    // If the children were empty this can be cleared out
    if (!graph.groupLib[id] || !graph.groupLib[id].leaves || !graph.groupLib[id].leaves.length) {
      if (!graph.groupLib[id] || !graph.groupLib[id].groups || !graph.groupLib[id].groups.length) {
        // if these conditions are met.
        delete graph.groupLib[id];
        graph.groups = [...graph.groups.filter(x => x !== id)];
        delete graph.childGroups[id];

        if (graph.parentGroup[id]) {
          for (var i in graph.parentGroup[id]) {
            graph = removeGroupFromGroup(graph, {
              groupId: id,
              id: i
            });
            graph = clearGroupDeep(graph, {
              id: i
            });
            if (graph.childGroups[i]) delete graph.childGroups[i][id];
          }

          delete graph.parentGroup[id];
        }
      }
    }
  } else if (callback) {
    callback(false);
  }

  return graph;
}

function removeNodeFromGroups(graph, options) {
  const {
    id
  } = options;
  let groupsContainingNode = []; // nodesGroups

  if (graph.nodesGroups[id]) {
    groupsContainingNode = Object.keys(graph.nodesGroups[id]);
    groupsContainingNode.map(group => {
      graph = removeLeaf(graph, {
        leaf: id,
        id: group
      });
    });
  } // groupsNodes


  if (graph.groupsNodes) {
    groupsContainingNode.map(group => {
      if (graph.groupsNodes[group]) {
        if (graph.groupsNodes[group][id]) {
          delete graph.groupsNodes[group][id];
        }

        if (Object.keys(graph.groupsNodes[group]).length === 0) {
          delete graph.groupsNodes[group];
        }
      }

      graph = clearGroupDeep(graph, {
        id: group
      });
    });
  }

  return graph;
}
function clearLinks(graph, options) {
  const {
    id
  } = options;
  const linksToRemove = getAllLinksWithNode(graph, id);

  for (let i = 0; i < linksToRemove.length; i++) {
    const link = linksToRemove[i];
    graph = removeLink(graph, link);
  }

  return graph;
}
function addNode(graph, node, options) {
  graph.nodeLib[node.id] = node;
  graph.nodeLib = { ...graph.nodeLib
  };
  graph.nodes = [...graph.nodes, node.id];
  graph = { ...graph
  };
  graph = incrementBuild(graph);

  if (options && options.callback) {
    options.callback(node);
  }

  return graph;
}
function addGroup(graph, group) {
  graph.groupLib[group.id] = group;
  graph.groupLib = { ...graph.groupLib
  };
  graph.groups = [...graph.groups, group.id].unique(x => x);
  graph = { ...graph
  };
  return graph;
}
function addNewPropertyNode(graph, options) {
  return addNewNodeOfType(graph, options, NodeTypes.Property);
}
const DEFAULT_PROPERTIES = [{
  title: "Owner",
  type: NodePropertyTypes.STRING
}, {
  title: "Id",
  type: NodePropertyTypes.STRING
}, {
  title: "Created",
  type: NodePropertyTypes.DATETIME
}, {
  title: "Updated",
  type: NodePropertyTypes.DATETIME
}, {
  title: "Deleted",
  type: NodePropertyTypes.BOOLEAN
}, {
  title: "Version",
  type: NodePropertyTypes.INT
}].map(t => {
  t.nodeType = NodeTypes.Property;
  return t;
});
function addDefaultProperties(graph, options) {
  // updateNodeProperty
  const propertyNodes = GetLinkChainFromGraph(graph, {
    id: options.parent,
    links: [{
      direction: SOURCE,
      type: nodetypes_LinkType.PropertyLink
    }]
  }).map(t => uiactions_GetNodeProp(t, nodetypes_NodeProperties.UIText));
  DEFAULT_PROPERTIES.filter(t => propertyNodes.indexOf(t.title) === -1).map(dp => {
    graph = addNewNodeOfType(graph, options, dp.nodeType, (new_node, _graph) => {
      _graph = updateNodeProperty(_graph, {
        id: new_node.id,
        prop: nodetypes_NodeProperties.UIText,
        value: dp.title
      });
      _graph = updateNodeProperty(_graph, {
        id: new_node.id,
        prop: nodetypes_NodeProperties.IsDefaultProperty,
        value: true
      });
      _graph = updateNodeProperty(_graph, {
        id: new_node.id,
        prop: nodetypes_NodeProperties.UIAttributeType,
        value: dp.type
      });
      _graph = updateNodeProperty(_graph, {
        id: new_node.id,
        prop: nodetypes_NodeProperties.Pinned,
        value: false
      });
      return _graph;
    });
  });
  return graph;
}

function updateNode(node, options) {
  if (options.node) {
    Object.apply(node.properties, JSON.parse(JSON.stringify(options.node.properties)));
  }
}

let _viewPackageStamp = null;
let _view_package_key = null;
function setViewPackageStamp(viewPackageStamp, key) {
  if (!_viewPackageStamp || !viewPackageStamp) if (_view_package_key === key || !_view_package_key) {
    _viewPackageStamp = viewPackageStamp;
    _view_package_key = !_viewPackageStamp ? null : key;
  }
}
function isStamped() {
  return !!_view_package_key;
}
const Flags = {
  HIDE_NEW_NODES: 'HIDE_NEW_NODES'
};
const FunctionFlags = {};
const FunctionFlagKeys = {};
function setFlag(hideNewNode, key, flag) {
  if (!FunctionFlags[flag] || !hideNewNode) if (FunctionFlagKeys[flag] === key || !FunctionFlagKeys[flag]) {
    FunctionFlags[flag] = hideNewNode;
    FunctionFlagKeys[flag] = !FunctionFlags[flag] ? null : key;
  }
}
function isFlagged(flag) {
  return FunctionFlags[flag];
}
function addNewNodeOfType(graph, options, nodeType, callback) {
  const {
    parent,
    linkProperties,
    groupProperties
  } = options;

  if (!callback) {
    callback = options.callback;
  }

  const node = createNode(nodeType);

  if (options.node) {
    updateNode(node, options);

    if (nodeType === NodeTypes.ReferenceNode) {
      if (options.rootNode) {
        options.rootNode.referenceNodes[graph.id] = { ...(options.rootNode.referenceNodes[graph.id] || {}),
          ...{
            [node.id]: options.node.id
          }
        };
      }
    }
  }

  graph = addNode(graph, node);

  if (parent) {
    graph = newLink(graph, {
      source: parent,
      target: node.id,
      properties: linkProperties ? linkProperties.properties : null
    });
  }

  if (options.links) {
    options.links.filter(x => x).map(link => {
      if (typeof link === "function") {
        link = link(graph);
        link = link.find(x => x);
      }

      graph = newLink(graph, {
        source: node.id,
        target: link.target,
        properties: link.linkProperties ? link.linkProperties.properties : null
      });
    });
  }

  graph = updateNodeProperty(graph, {
    id: node.id,
    prop: nodetypes_NodeProperties.NODEType,
    value: nodeType
  });
  graph = updateNodeProperty(graph, {
    id: node.id,
    prop: nodetypes_NodeProperties.Pinned,
    value: true
  });

  if (isFlagged(Flags.HIDE_NEW_NODES)) {
    graph = updateNodeProperty(graph, {
      id: node.id,
      prop: nodetypes_NodeProperties.Pinned,
      value: false
    });
  }

  if (options.properties) {
    for (var p in options.properties) {
      graph = updateNodeProperty(graph, {
        id: node.id,
        prop: p,
        value: options.properties[p]
      });
    }
  }

  if (_viewPackageStamp) {
    for (var p in _viewPackageStamp) {
      graph = updateNodeProperty(graph, {
        id: node.id,
        prop: p,
        value: _viewPackageStamp[p]
      });
    }
  }

  let groupId = null;

  if (groupProperties) {
    graph = updateNodeGroup(graph, {
      id: node.id,
      groupProperties,
      parent,
      callback: _gid => {
        groupId = _gid;
      }
    });
  }

  if (callback) {
    graph = callback(GetNodeById(node.id, graph), graph, groupId) || graph;
  }

  return graph;
}
function updateNodeGroup(graph, options) {
  const {
    id,
    groupProperties,
    parent,
    callback,
    groupCallback
  } = options;
  var group = null;

  if (groupProperties && groupProperties.id) {
    group = getGroup(graph, groupProperties.id);
  } else if (!hasGroup(graph, parent)) {
    var group = createGroup();
    graph = addGroup(graph, group);
    graph = updateNodeProperty(graph, {
      id: parent,
      value: {
        group: group.id
      },
      prop: nodetypes_NodeProperties.Groups
    });
    graph = addLeaf(graph, {
      leaf: parent,
      id: group.id
    });
    const grandParent = uiactions_GetNodeProp(graph.nodeLib[parent], nodetypes_NodeProperties.GroupParent);

    if (grandParent && graph.groupLib[grandParent]) {
      const gparentGroup = graph.groupLib[grandParent];

      if (gparentGroup) {
        const ancestores = getGroupAncenstors(graph, gparentGroup.id);
        graph = addGroupToGroup(graph, {
          id: gparentGroup.id,
          groupId: group.id
        });
        ancestores.map(anc => {
          graph = addGroupToGroup(graph, {
            id: anc,
            groupId: group.id
          });
        });
      }
    }
  } else {
    const nodeGroupProp = uiactions_GetNodeProp(graph.nodeLib[parent], nodetypes_NodeProperties.Groups);
    group = getGroup(graph, nodeGroupProp.group);
  }

  if (group) {
    graph = addLeaf(graph, {
      leaf: id,
      id: group.id
    });
    graph = updateNodeProperty(graph, {
      id,
      value: group.id,
      prop: nodetypes_NodeProperties.GroupParent
    });

    if (groupProperties) {
      for (const gp in groupProperties) {
        graph = updateGroupProperty(graph, {
          id: group.id,
          prop: gp,
          value: groupProperties[gp]
        });
      }

      if (callback) {
        callback(group.id);
      }
    }

    if (groupCallback && group) {
      groupCallback(group.id);
    }
  }

  return graph;
}

function getGroupAncenstors(graph, id) {
  let result = [];

  if (graph.parentGroup[id]) {
    for (const i in graph.parentGroup[id]) {
      result = [...result, ...getGroupAncenstors(graph, i)];
    }
  }

  return result;
}

function getGroup(graph, id) {
  return graph.groupLib[id];
}
function hasGroup(graph, parent) {
  return !!(graph.nodeLib[parent] && uiactions_GetNodeProp(graph.nodeLib[parent], nodetypes_NodeProperties.Groups));
}
function GetNode(graph, id) {
  if (graph && graph.nodeLib) {
    return graph.nodeLib[id];
  }

  return null;
}
function GetChildComponentAncestors(state, id) {
  let result = [];
  const graph = GetRootGraph(state);
  const ancestors = GetNodesLinkedTo(graph, {
    id,
    direction: graph_methods_TARGET
  }).filter(x => {
    const nodeType = uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType);

    switch (nodeType) {
      case NodeTypes.ScreenOption:
      case NodeTypes.ComponentNode:
        return true;
    }

    return false;
  }).map(t => t.id);
  result = [...result, ...ancestors].unique();
  ancestors.map(t => {
    const temp = GetChildComponentAncestors(state, t);
    result = [...result, ...temp];
  });
  return result.unique();
}
function createComponentProperties() {
  return {
    properties: {},
    instanceTypes: {}
  };
}
function addComponentProperty(props, ops) {
  const {
    modelType,
    modelProp,
    instanceType
  } = ops;

  if (props && props.properties) {
    props.properties[modelProp] = modelType;
    props.instanceTypes[modelProp] = instanceType;
  }

  return props;
}
function removeComponentProperty(props, ops) {
  const {
    modelProp
  } = ops;

  if (props && props.properties) {
    delete props.properties[modelProp];
    delete props.instanceTypes[modelProp];
  }

  return props;
}
function updateClientMethod(methodParams, key, param, mparam, value) {
  methodParams[key] = methodParams[key] || {};
  methodParams[key].parameters = methodParams[key].parameters || {};
  methodParams[key].parameters[param] = methodParams[key].parameters[param] || {};
  methodParams[key].parameters[param] = { ...methodParams[key].parameters[param],
    [mparam]: value
  };
  return methodParams;
}
function getClientMethod(methodParams, key, param, mparam) {
  if (methodParams && methodParams[key] && methodParams[key].parameters && methodParams[key].parameters[param] && methodParams[key].parameters[param][mparam]) return methodParams[key].parameters[param][mparam];
  return null;
}
function getComponentPropertyList(props) {
  if (props && props.properties) {
    return Object.keys(props.properties).map(t => ({
      title: t,
      id: props.properties[t],
      value: t
    }));
  }

  return [];
}
function hasComponentProperty(props, prop) {
  return props && props.properties && props.properties.hasOwnProperty(prop);
}
function getComponentProperty(props, prop, type = "properties") {
  return props && props[type] && props[type][prop];
}
function GetGroup(graph, id) {
  if (graph && graph.groupLib) {
    return graph.groupLib[id];
  }

  return null;
}
function applyConstraints(graph) {
  const functionNodes = graph.functionNodes;

  if (functionNodes) {
    for (const i in functionNodes) {
      const node = GetNode(graph, i);

      if (node) {
        const functionType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.FunctionType);

        if (functionType) {
          const functionConstraintObject = functiontypes_namespaceObject[functionType];

          if (functionConstraintObject) {
            graph = checkConstraints(graph, {
              id: i,
              functionConstraints: functionConstraintObject
            });
          }
        }
      }
    }
  }

  const validationNodes = NodesByType(graph, NodeTypes.Validator);
  validationNodes.map(x => {
    graph = applyValidationNodeRules(graph, x);
  });
  return graph;
}

function applyValidationNodeRules(graph, node) {
  const validator = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Validator);

  if (validator) {
    const nodesLinks = getNodesLinkedTo(graph, {
      id: node.id
    });
    const validatorProperties = getValidatorProperties(validator);
    Object.keys(validatorProperties).map(property => {
      if (graph.nodeLinks[property] && graph.nodeLinks[property][node.id]) {// link between nodes exists.
      } else {// link between nodes exists.
        }
    });
  }

  return graph;
}

function NodesByType(graph, nodeType, options = {}) {
  const currentGraph = graph;

  if (currentGraph) {
    if (!Array.isArray(nodeType)) {
      nodeType = [nodeType];
    }

    return currentGraph.nodes.filter(x => currentGraph.nodeLib && currentGraph.nodeLib[x] && currentGraph.nodeLib[x].properties && nodeType.indexOf(currentGraph.nodeLib[x].properties[nodetypes_NodeProperties.NODEType]) !== -1 || !options.excludeRefs && currentGraph.nodeLib[x] && currentGraph.nodeLib[x].properties && currentGraph.nodeLib[x].properties[nodetypes_NodeProperties.ReferenceType] === nodeType).map(x => currentGraph.nodeLib[x]);
  }

  return [];
}

function existsLinkBetween(graph, options) {
  const {
    source,
    target,
    type,
    direction,
    properties
  } = options;
  const link = findLink(graph, {
    source,
    target
  });

  if (link) {
    if (properties && Object.key(properties).some(prop => GetLinkProperty(link, prop) !== properties[prop])) {
      return false;
    }

    return GetLinkProperty(link, LinkPropertyKeys.TYPE) === type || !type;
  }

  return false;
}
function updateReferenceNodes(root) {
  if (root && root.referenceNodes) {
    for (const scope in root.referenceNodes) {
      if (root.graphs && root.graphs[scope]) {
        const scopedGraph = root.graphs[scope];

        for (const nodeId in root.referenceNodes[scope]) {
          const masterNode = root.nodeLib[root.referenceNodes[scope][nodeId]];

          if (masterNode) {
            const refNode = GetNode(scopedGraph, nodeId);

            if (refNode) {
              // may be more properties later.
              refNode.properties.text = masterNode.properties.text;
              refNode.properties.referenceType = masterNode.properties.nodeType;
            }
          }
        }
      }
    }
  }

  return root;
}
function constraintSideEffects(graph) {
  const functionNodes = graph.functionNodes;

  if (functionNodes) {
    let classes_that_must_exist = [];

    for (const i in functionNodes) {
      var function_node = GetNode(graph, i);

      if (function_node) {
        const functionType = uiactions_GetNodeProp(function_node, nodetypes_NodeProperties.FunctionType);

        if (functionType) {
          const functionConstraintObject = functiontypes_namespaceObject[functionType];

          if (functionConstraintObject && functionConstraintObject[FUNCTION_REQUIREMENT_KEYS.CLASSES]) {
            const functionConstraintRequiredClasses = functionConstraintObject[FUNCTION_REQUIREMENT_KEYS.CLASSES];

            if (functionConstraintRequiredClasses) {
              for (const j in functionConstraintRequiredClasses) {
                // Get the model constraint key.
                // Should be able to find the singular model that is connected to the functionNode and children, if it exists.
                const constraintModelKey = functionConstraintRequiredClasses[j][INTERNAL_TEMPLATE_REQUIREMENTS.MODEL];

                if (constraintModelKey) {
                  const constraint_nodes = getNodesFunctionsConnected(graph, {
                    id: i,
                    constraintKey: constraintModelKey
                  });
                  var nodes_one_step_down_the_line = [];
                  constraint_nodes.map(cn => {
                    const nextNodes = getNodesLinkedTo(graph, {
                      id: cn.id
                    });
                    nodes_one_step_down_the_line.push(...nextNodes);
                  });
                  nodes_one_step_down_the_line.map(node => {
                    classes_that_must_exist.push({
                      nodeId: node.id,
                      functionNode: function_node.id,
                      key: constraintModelKey,
                      class: j
                    });
                  });
                }
              }
            }
          }
        }
      }

      classes_that_must_exist = [...classes_that_must_exist.unique(x => JSON.stringify(x))]; // Remove class nodes that are no longer cool.

      Object.keys(graph.classNodes).map(i => {
        if (!classes_that_must_exist.find(cls => {
          const _cnode = graph.nodeLib[i];
          const res = uiactions_GetNodeProp(_cnode, nodetypes_NodeProperties.ClassConstructionInformation);
          return matchObject(res, cls);
        })) {
          graph = removeNode(graph, {
            id: i
          });
        } else {}
      }); // Could make this faster by using a dictionary

      classes_that_must_exist.map(cls => {
        const matching_nodes = Object.keys(graph.classNodes).filter(i => {
          const _cnode = graph.nodeLib[i];
          const res = uiactions_GetNodeProp(_cnode, nodetypes_NodeProperties.ClassConstructionInformation);

          if (matchObject(res, cls)) {
            return true;
          }

          return false;
        });

        if (matching_nodes.length === 0) {
          // Create new classNodes
          graph = addNewNodeOfType(graph, {
            parent: cls.functionNode,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.RequiredClassLink
              }
            }
          }, NodeTypes.ClassNode, new_node => {
            graph = updateNodeProperty(graph, {
              id: new_node.id,
              prop: nodetypes_NodeProperties.UIText,
              value: RequiredClassName(cls.class, uiactions_GetNodeProp(GetNode(graph, cls.nodeId), nodetypes_NodeProperties.CodeName))
            });
            graph = updateNodeProperty(graph, {
              id: new_node.id,
              prop: nodetypes_NodeProperties.ClassConstructionInformation,
              value: cls
            });
          });
        } else if (matching_nodes.length === 1) {
          const _cnode = graph.nodeLib[matching_nodes[0]]; // The existing classNodes can be updated with any new dependent values. e.g. Text/title

          graph = updateNodeProperty(graph, {
            id: _cnode.id,
            prop: nodetypes_NodeProperties.UIText,
            value: RequiredClassName(cls.class, uiactions_GetNodeProp(GetNode(graph, cls.nodeId), nodetypes_NodeProperties.CodeName))
          });
        } else {
          console.error("There should never be more than one");
        }
      });
    }
  }

  return graph;
}
function RequiredClassName(cls, node_name) {
  return `${node_name}${cls}`;
}
function getNodesFunctionsConnected(graph, options) {
  const {
    id,
    constraintKey
  } = options;
  const result = [];
  const links = getNodeLinksWithKey(graph, {
    id,
    key: constraintKey
  });
  return links.map(link => graph.nodeLib[link.target]);
}
function checkConstraints(graph, options) {
  const {
    id,
    functionConstraints
  } = options;

  if (graph.nodeConnections[id]) {
    const node = graph.nodeLib[id];
    Object.keys(graph.nodeConnections[id]).map(link => {
      // check if link has a constraint attached.
      const {
        properties
      } = graph.linkLib[link];
      const _link = graph.linkLib[link];

      if (properties) {
        const {
          constraints
        } = properties;

        if (constraints) {
          Object.keys(FunctionTemplateKeys).map(ftk => {
            const functionTemplateKey = FunctionTemplateKeys[ftk];
            const constraintObj = functionConstraints.constraints[functionTemplateKey];

            if (constraintObj && _link && _link.properties && _link.properties.constraints && _link.properties.constraints.key) {
              if (_link.properties.constraints.key === constraintObj.key) {
                const valid = FunctionMeetsConstraint.meets(constraintObj, constraints, _link, node, graph);
                graph = updateLinkProperty(graph, {
                  id: _link.id,
                  prop: LinkPropertyKeys.VALID_CONSTRAINTS,
                  value: !!valid
                });
              }
            }
          });
        }
      }
    });
  }

  return graph;
}
function applyFunctionConstraints(graph, options) {
  const {
    id,
    value
  } = options;
  const functionConstraints = functiontypes_namespaceObject[value];

  if (functionConstraints) {
    if (functionConstraints.constraints) {
      if (graph.nodeConnections[id]) {
        getNodeFunctionConstraintLinks(graph, {
          id
        }).map(link => {
          const link_constraints = GetLinkProperty(link, LinkPropertyKeys.CONSTRAINTS);

          if (!hasMatchingConstraints(link_constraints, functionConstraints.constraints)) {
            const nodeToRemove = GetTargetNode(graph, link.id);

            if (nodeToRemove) {
              graph = removeNode(graph, {
                id: nodeToRemove.id
              });
            } else {
              console.warn("No nodes were removed as exepected");
            }
          }
        });
      }

      let core_group = null;
      let internal_group = null; // Internal scope group

      let external_group = null; // API Group

      const node = graph.nodeLib[id];
      const existingGroups = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Groups);

      if (existingGroups) {
        for (const i in existingGroups) {
          graph = clearGroup(graph, {
            id: existingGroups[i]
          });
        }
      }

      if (graph.nodesGroups[id]) {
        for (const i in graph.nodesGroups[id]) {
          switch (GetGroupProperty(graph.groupLib[i], GroupProperties.FunctionGroup)) {
            case FunctionGroups.Core:
              core_group = graph.groupLib[i];
              break;
          }
        }
      }

      if (!core_group) {
        graph = newGroup(graph, _group => {
          core_group = _group;
          graph = updateGroupProperty(graph, {
            id: _group.id,
            prop: GroupProperties.FunctionGroup,
            value: FunctionGroups.Core
          });
        });
      }

      if (!internal_group) {
        graph = newGroup(graph, _group => {
          internal_group = _group;
          graph = updateGroupProperty(graph, {
            id: _group.id,
            prop: GroupProperties.FunctionGroup,
            value: FunctionGroups.Internal
          });
        });
      }

      if (!external_group) {
        graph = newGroup(graph, _group => {
          external_group = _group;
          graph = updateGroupProperty(graph, {
            id: _group.id,
            prop: GroupProperties.FunctionGroup,
            value: FunctionGroups.External
          });
        });
      }

      if (!graph.groupsNodes[external_group.id] || !graph.groupsNodes[external_group.id][id]) {
        graph = addLeaf(graph, {
          leaf: id,
          id: external_group.id
        });
      }

      if (!graph.childGroups[internal_group.id] || !graph.childGroups[internal_group.id][external_group.id]) {
        graph = addGroupToGroup(graph, {
          groupId: internal_group.id,
          id: external_group.id
        });
      }

      if (!graph.childGroups[core_group.id] || !graph.childGroups[core_group.id][internal_group.id]) {
        graph = addGroupToGroup(graph, {
          groupId: core_group.id,
          id: internal_group.id
        });
      }

      const existMatchinLinks = getNodeFunctionConstraintLinks(graph, {
        id
      });
      const constraintKeys = existMatchinLinks.map(link => {
        const link_constraints = GetLinkProperty(link, LinkPropertyKeys.CONSTRAINTS);
        return findMatchingConstraints(link_constraints, functionConstraints.constraints);
      });
      Object.keys(functionConstraints.constraints).map(constraint => {
        // Create links to new nodes representing those constraints.
        if (constraintKeys.indexOf(constraint) === -1) {
          graph = addNewNodeOfType(graph, {
            parent: node.id,
            linkProperties: {
              properties: {
                type: nodetypes_LinkType.FunctionConstraintLink,
                constraints: { ...functionConstraints.constraints[constraint]
                }
              }
            }
          }, NodeTypes.Parameter, new_node => {
            graph = updateNodeProperty(graph, {
              id: new_node.id,
              prop: nodetypes_NodeProperties.UIText,
              value: constraint
            });
          });
        }
      });
      const nodes_with_link = getNodeFunctionConstraintLinks(graph, {
        id: node.id
      });
      nodes_with_link.map(link => {
        const new_node = graph.nodeLib[link.target];
        const constraint = GetLinkProperty(link, LinkPropertyKeys.CONSTRAINTS);

        if (constraint && constraint.key && functionConstraints.constraints[constraint.key] && functionConstraints.constraints[constraint.key][FunctionConstraintKeys.IsInputVariable]) {
          graph = addLeaf(graph, {
            leaf: new_node.id,
            id: internal_group.id
          });
        } else {
          graph = addLeaf(graph, {
            leaf: new_node.id,
            id: core_group.id
          });
        }
      });

      if (graph.nodeConnections[id]) {
        Object.keys(graph.nodeConnections[id]).map(link => {
          // check if link has a constraint attached.
          const {
            properties
          } = graph.linkLib[link];
          const _link = graph.linkLib[link];

          if (properties) {
            const {
              constraints
            } = properties;

            if (constraints) {
              Object.keys(FunctionTemplateKeys).map(ftk => {
                const functionTemplateKey = FunctionTemplateKeys[ftk];
                const constraintObj = functionConstraints.constraints[functionTemplateKey];

                if (constraintObj && _link && _link.properties && _link.properties.constraints && _link.properties.constraints.key) {
                  if (_link.properties.constraints.key === constraintObj.key) {
                    const valid = FunctionMeetsConstraint.meets(constraintObj, constraints, _link, node, graph);
                    graph = updateLinkProperty(graph, {
                      id: _link.id,
                      prop: LinkPropertyKeys.VALID_CONSTRAINTS,
                      value: !!valid
                    });
                  }
                }
              });
            }
          }
        });
      }

      graph = updateNodeProperty(graph, {
        id,
        prop: nodetypes_NodeProperties.Groups,
        value: {
          core: core_group.id,
          internal: internal_group.id,
          external: external_group.id
        }
      });
    }
  }

  return graph;
}

function getNodeLinksWithKey(graph, options) {
  const {
    id,
    key
  } = options;
  const result = [];

  if (graph.nodeConnections[id]) {
    return Object.keys(graph.nodeConnections[id]).map(link => {
      const _link = graph.linkLib[link];
      return _link;
    }).filter(_link => _link && _link.source === id && _link.properties && _link.properties.constraints && _link.properties.constraints.key === key);
  }

  return result;
}

function hasMatchingConstraints(linkConstraint, functionConstraints) {
  return !!findMatchingConstraints(linkConstraint, functionConstraints);
}

function findMatchingConstraints(linkConstraint, functionConstraints) {
  const lcj = JSON.stringify(linkConstraint);
  return Object.keys(functionConstraints).find(f => JSON.stringify(functionConstraints[f]) === lcj);
}

function getNodeFunctionConstraintLinks(graph, options) {
  const {
    id
  } = options;

  if (graph && graph.nodeConnections && graph.nodeConnections[id]) {
    return Object.keys(graph.nodeConnections[id]).filter(link => GetLinkProperty(graph.linkLib[link], LinkPropertyKeys.TYPE) === nodetypes_LinkType.FunctionConstraintLink).map(link => graph.linkLib[link]);
  }

  return [];
}

const FunctionMeetsConstraint = {
  meets: (constraintObj, constraints, link, node, graph) => {
    if (constraintObj) {
      const _targetNode = graph.nodeLib[link.target];
      const nextNodes = getNodesLinkedTo(graph, {
        id: _targetNode.id
      });
      return nextNodes.find(targetNode => Object.keys(constraintObj).find(constraint => {
        let result = true;

        if (result === false) {
          return;
        }

        switch (constraint) {
          // Instance variable are always ok
          // case FunctionConstraintKeys.IsInstanceVariable:
          //     result = true;
          //     break;
          case FunctionConstraintKeys.IsAgent:
            if (targetNode) {
              if (!uiactions_GetNodeProp(targetNode, nodetypes_NodeProperties.IsAgent)) {
                result = false;
              }
            } else {
              result = false;
            }

            break;

          case FunctionConstraintKeys.IsUser:
            if (targetNode) {
              if (!uiactions_GetNodeProp(targetNode, nodetypes_NodeProperties.IsUser)) {
                result = false;
              }
            } else {
              result = false;
            }

            break;

          case FunctionConstraintKeys.IsTypeOf:
            // If it is an input variable, then we will all anything.
            if (!constraintObj[FunctionConstraintKeys.IsInputVariable]) {
              if (targetNode) {
                const targetNodeType = uiactions_GetNodeProp(targetNode, nodetypes_NodeProperties.NODEType);
                const targetConstraint = constraintObj[constraint]; // FunctionConstraintKeys.Model
                // The targetNodeType should match the other node.

                const linkWithConstraints = findLinkWithConstraint(node.id, graph, targetConstraint);

                if (linkWithConstraints.length) {
                  const links = linkWithConstraints.filter(linkWithConstraint => {
                    const nodeToMatchWith = graph.nodeLib[linkWithConstraint.target];
                    const nodeToMatchWithType = uiactions_GetNodeProp(nodeToMatchWith, nodetypes_NodeProperties.NODEType);
                    return nodeToMatchWithType !== targetNodeType;
                  });

                  if (links.length === 0) {
                    result = false;
                  }
                } else {
                  result = false;
                }
              } else {
                result = false;
              }
            }

            break;

          case FunctionConstraintKeys.IsChild:
            if (targetNode) {
              // let targetNodeType = GetNodeProp(targetNode, NodeProperties.NODEType);
              const targetConstraint = constraintObj[constraint]; // FunctionConstraintKeys.Model
              // The targetNodeType should match the other node.

              const linkWithConstraints = findLinkWithConstraint(node.id, graph, targetConstraint);

              if (linkWithConstraints) {
                const links = linkWithConstraints.filter(linkWithConstraint => {
                  const nodeToMatchWith = graph.nodeLib[linkWithConstraint.target];
                  const linkToParentParameter = getNodeLinkedTo(graph, {
                    id: nodeToMatchWith.id
                  });

                  if (linkToParentParameter && linkToParentParameter.length) {
                    const relationshipLink = findLink(graph, {
                      target: targetNode.id,
                      source: linkToParentParameter[0].id
                    });

                    if (!relationshipLink || GetLinkProperty(relationshipLink, LinkPropertyKeys.TYPE) !== nodetypes_LinkProperties.ParentLink.type) {
                      return false;
                    }
                  } else {
                    return false;
                  }

                  return true;
                });

                if (links.length === 0) {
                  result = false;
                }
              } else {
                result = false;
              }
            } else {
              result = false;
            }

            break;

          case FunctionConstraintKeys.IsParent:
            if (targetNode) {
              // let targetNodeType = GetNodeProp(targetNode, NodeProperties.NODEType);
              const targetConstraint = constraintObj[constraint]; // FunctionConstraintKeys.Model
              // The targetNodeType should match the other node.

              const linkWithConstraints = findLinkWithConstraint(node.id, graph, targetConstraint);

              if (linkWithConstraints) {
                const links = linkWithConstraints.filter(linkWithConstraint => {
                  const nodeToMatchWith = graph.nodeLib[linkWithConstraint.target];
                  const linkToParentParameter = getNodeLinkedTo(graph, {
                    id: nodeToMatchWith.id
                  });

                  if (linkToParentParameter && linkToParentParameter.length) {
                    const relationshipLink = findLink(graph, {
                      target: targetNode.id,
                      source: linkToParentParameter[0].id
                    });

                    if (!relationshipLink || GetLinkProperty(relationshipLink, LinkPropertyKeys.TYPE) !== nodetypes_LinkProperties.ParentLink.type) {
                      return false;
                    }
                  } else {
                    return false;
                  }

                  return true;
                });

                if (links.length === 0) {
                  result = false;
                }
              } else {
                result = false;
              }
            } else {
              result = false;
            }

            break;
        }

        return result;
      }));
    }

    return false;
  }
};

function findLinkWithConstraint(nodeId, graph, targetConstraint) {
  return Object.keys(graph.nodeConnections[nodeId]).filter(t => graph.nodeConnections[nodeId][t] === SOURCE).filter(link => {
    if (link && graph.linkLib && graph.linkLib[link] && graph.linkLib[link].properties && graph.linkLib[link].properties.constraints && graph.linkLib[link].properties.constraints.key === targetConstraint) {
      return graph.linkLib[link];
    }

    return false;
  }).map(link => graph.linkLib[link]);
}

function getNodeLinks(graph, id, direction) {
  if (graph && graph.nodeConnections) {
    return Object.keys(graph.nodeConnections[id]).filter(x => {
      if (direction) {
        return graph.nodeConnections[id][x] === direction;
      }

      return true;
    }).map(link => graph.linkLib[link]);
  }

  return [];
}
function findLink(graph, options) {
  const {
    target,
    source
  } = options;
  const res = graph.links.find(link => graph.linkLib && graph.linkLib[link] && graph.linkLib[link].target === target && graph.linkLib[link].source === source);

  if (res) {
    return graph.linkLib[res];
  }

  return null;
}
function newLink(graph, options) {
  const {
    target,
    source,
    properties
  } = options;
  const link = createLink(target, source, properties);
  return addLink(graph, options, link);
}
function GetTargetNode(graph, linkId) {
  if (graph && graph.linkLib && graph.linkLib[linkId]) {
    const target = graph.linkLib[linkId].target;
    return graph.nodeLib[target];
  }

  return null;
}
function getNodesLinkedFrom(graph, options) {
  return getNodeLinked(graph, { ...(options || {}),
    direction: graph_methods_TARGET
  });
}
function getNodesLinkedTo(graph, options) {
  return getNodeLinkedTo(graph, options);
}
function getNodeLinkedTo(graph, options) {
  return getNodeLinked(graph, { ...(options || {}),
    direction: SOURCE
  });
}
function matchOneWay(obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }

  if (!obj1) {
    return false;
  }

  if (!obj2) {
    return false;
  }

  for (const i in obj1) {
    if (obj1[i] !== obj2[i]) {
      return false;
    }
  }

  return true;
}
function matchObject(obj1, obj2) {
  if (Object.keys(obj1).length !== Object.keys(obj2).length) {
    return false;
  }

  for (const i in obj1) {
    if (obj1[i] !== obj2[i]) {
      return false;
    }
  }

  return true;
}
function GetLinkByNodes(graph, options) {
  const {
    source,
    target
  } = options;
  return Object.values(graph.linkLib).find(t => t.source === source && t.target === target);
}
function GetLinkChainItem(state, options) {
  const chains = GetLinkChain(state, options);

  if (chains && chains.length) {
    return chains[0];
  }

  return null;
}
function SetAffterEffectProperty(currentNode, afterMethod, key, value) {
  const afterEffectSetup = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.AfterMethodSetup) || {};
  afterEffectSetup[afterMethod] = afterEffectSetup[afterMethod] || {};
  afterEffectSetup[afterMethod] = { ...afterEffectSetup[afterMethod],
    ...{
      [key]: value
    }
  };
  return afterEffectSetup;
}
function GetAffterEffectProperty(currentNode, afterMethod, key) {
  const afterEffectSetup = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.AfterMethodSetup);
  if (afterEffectSetup && afterEffectSetup[afterMethod] && afterEffectSetup[afterMethod][key]) return afterEffectSetup[afterMethod][key];
  return null;
}
function GetMethodNode(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Method);
}
function GetPermissionNode(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Permission);
}
function GetConditionNodes(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Condition);
}
function GetConnectedNodesByType(state, id, type, direction) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id,
    direction
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === type);
}
function GetDataChainEntryNodes(state, cs) {
  const graph = GetRootGraph(state);
  return NodesByType(graph, NodeTypes.DataChain).filter(x => !cs && uiactions_GetNodeProp(x, nodetypes_NodeProperties.EntryPoint) || cs && uiactions_GetNodeProp(x, nodetypes_NodeProperties.CSEntryPoint));
}
function GetConnectedNodeByType(state, id, type, direction, graph) {
  if (!Array.isArray(type)) {
    type = [type];
  }

  graph = graph || GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id,
    direction
  }).find(x => {
    const ntype = uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType);
    return type.some(v => v === ntype);
  });
}
function GetValidationNode(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Validator);
}
function GetDataSourceNode(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.DataSource);
}
function GetModelItemFilter(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ModelItemFilter);
}
function GetLinkChain(state, options) {
  const graph = GetCurrentGraph(state);
  return GetLinkChainFromGraph(graph, options);
}
function GetLinkChainFromGraph(graph, options, nodeType) {
  const {
    id,
    links
  } = options;
  let ids = [id];
  let result = [];
  links.map((op, il) => {
    let newids = [];
    ids.map(i => {
      const newnodes = getNodesByLinkType(graph, {
        id: i,
        ...op
      });

      if (il === links.length - 1) {
        result = newnodes;
      } else {
        newids = [...newids, ...newnodes.map(t => t.id)];
      }
    });
    newids = newids.unique(x => x);
    ids = newids;
  });
  return result.filter(x => {
    if (!nodeType) {
      return true;
    }

    return nodeType.indexOf(uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType)) !== -1;
  });
}
function getNodesLinkTypes(graph, options) {
  if (options) {
    const {
      id
    } = options;
    const links = graph.nodeConnections[id] || {};
    const groups = Object.keys(links).groupBy(x => GetLinkProperty(graph.linkLib[x], LinkPropertyKeys.TYPE));
    return Object.keys(groups);
  }

  return [];
}
function getNodesByLinkType(graph, options) {
  if (options) {
    const {
      id,
      direction,
      type,
      exist
    } = options;

    if (graph && graph.nodeConnections && id) {
      const nodeLinks = graph.nodeConnections[id];

      if (nodeLinks) {
        return Object.keys(nodeLinks).filter(x => nodeLinks[x]).map(_id => {
          const target = graph.linkLib[_id] ? direction === graph_methods_TARGET ? graph.linkLib[_id].source : graph.linkLib[_id].target : null;

          if (!target) {
            console.warn("Missing value in linkLib");
            return null;
          }

          if (exist && graph.linkLib[_id].properties && graph.linkLib[_id].properties.exist) {
            return graph.nodeLib[target];
          }

          if (!type || graph.linkLib[_id].properties && (graph.linkLib[_id].properties.type === type || graph.linkLib[_id].properties[type])) {
            return graph.nodeLib[target];
          }

          return null;
        }).filter(x => x);
      }
    }
  }

  return [];
}
function GetLinkBetween(a, b, graph) {
  return getNodeLinks(graph, a, SOURCE).find(v => v.target === b);
}
function getNodeLinked(graph, options) {
  if (options) {
    const {
      id,
      direction,
      constraints
    } = options;

    if (graph && graph.nodeConnections && id) {
      const nodeLinks = graph.nodeConnections[id];

      if (nodeLinks) {
        return Object.keys(nodeLinks).filter(x => nodeLinks[x] === direction).map(_id => {
          const target = graph.linkLib[_id] ? direction === graph_methods_TARGET ? graph.linkLib[_id].source : graph.linkLib[_id].target : null;

          if (!target) {
            console.warn("Missing value in linkLib");
            return null;
          }

          if (constraints) {
            const link = graph.linkLib[_id];
            const link_constraints = GetLinkProperty(link, LinkPropertyKeys.CONSTRAINTS);

            if (matchOneWay(constraints, link_constraints)) {
              return graph.nodeLib[target];
            }

            return null;
          }

          return graph.nodeLib[target];
        }).filter(x => x);
      }
    }
  }

  return [];
}
function GetNodeLinkedTo(graph, options) {
  return GetNodesLinkedTo(graph, options)[0];
}
function GetLinkedNodes(graph, options) {
  const {
    id
  } = options;
  graph = graph || GetCurrentGraph();

  if (graph && graph.nodeLinks && id) {
    const nodeLinks = graph.nodeLinks[id];
    return { ...nodeLinks
    };
  }

  return {};
}
function GetNodesLinkedTo(graph, options) {
  if (options) {
    graph = graph || GetCurrentGraph();
    const {
      id,
      direction,
      link,
      componentType,
      properties
    } = options;

    if (graph && graph.nodeConnections && id) {
      const nodeLinks = graph.nodeConnections[id];

      if (nodeLinks) {
        return Object.keys(nodeLinks).map(_id => {
          let target = null;

          if (link) {
            if (GetLinkProperty(graph.linkLib[_id], LinkPropertyKeys.TYPE) !== link) {
              return null;
            }

            if (properties) {
              for (const prop in properties) {
                if (properties[prop] !== GetLinkProperty(graph.linkLib[_id], prop)) {
                  return null;
                }
              }
            }
          }

          if (graph.linkLib[_id]) {
            if (graph.linkLib[_id].source !== id) {
              if (!direction || direction === graph_methods_TARGET) target = graph.linkLib[_id].source;
            } else if (!direction || direction === SOURCE) target = graph.linkLib[_id].target;
          }

          if (!target) {
            // console.warn('Missing value in linkLib');
            return null;
          }

          return graph.nodeLib[target];
        }).filter(x => x).filter(x => {
          if (componentType) {
            return uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === componentType;
          }

          return true;
        });
      }
    }
  }

  return [];
}
const SOURCE = "SOURCE";
const graph_methods_TARGET = "TARGET";
function addLink(graph, options, link) {
  const {
    target,
    source
  } = options;

  if (target && source && target !== source) {
    if (graph.nodeLib[target] && graph.nodeLib[source]) {
      if (noSameLink(graph, {
        target,
        source
      })) {
        graph.linkLib[link.id] = link;
        graph.linkLib = { ...graph.linkLib
        };
        graph.links = [...graph.links, link.id]; // Keeps track of the links for each node.

        graph.nodeConnections[link.source] = { ...(graph.nodeConnections[link.source] || {}),
          ...{
            [link.id]: SOURCE
          }
        }; // Keeps track of the links for each node.

        graph.nodeConnections[link.target] = { ...(graph.nodeConnections[link.target] || {}),
          ...{
            [link.id]: graph_methods_TARGET
          }
        }; // Keeps track of the number of links between nodes.

        graph.nodeLinks[link.source] = { ...(graph.nodeLinks[link.source] || {}),
          ...{
            [link.target]: graph.nodeLinks[link.source] ? (graph.nodeLinks[link.source][link.target] || 0) + 1 : 1
          }
        }; // Keeps track of the number of links between nodes.

        graph.nodeLinks[link.target] = { ...graph.nodeLinks[link.target],
          ...{
            [link.source]: graph.nodeLinks[link.target] ? (graph.nodeLinks[link.target][link.source] || 0) + 1 : 1
          }
        };
      } else {
        const oldLink = findLink(graph, {
          target,
          source
        });

        if (oldLink) {
          //  the type won't change onces its set
          // But the other properties can be
          oldLink.properties = { ...oldLink.properties,
            ...link.properties,
            ...{
              type: oldLink.properties.type
            }
          };
        }
      }

      graph.nodeLinks = { ...graph.nodeLinks
      };
      graph = { ...graph
      };
    }

    graph = incrementMinor(graph);
  }

  return graph;
}
function addLinksBetweenNodes(graph, options) {
  const {
    links
  } = options;

  if (links && links.length) {
    links.map(link => {
      graph = addLinkBetweenNodes(graph, link);
    });
  }

  return graph;
}
function addLinkBetweenNodes(graph, options) {
  const {
    target,
    source,
    properties
  } = options;

  if (target !== source && target) {
    const link = createLink(target, source, properties);
    return addLink(graph, options, link);
  }

  return graph;
}
function findLinkInstance(graph, options) {
  const {
    target,
    source,
    properties
  } = options;

  if (properties) {
    const link = graph.links.find(x => {
      if (graph.linkLib[x].source === source && graph.linkLib[x].target == target) {
        for (const i in properties) {
          if (!graph.linkLib[x].properties || graph.linkLib[x].properties[i] !== properties[i]) {
            if (typeof graph.linkLib[x].properties[i] === "object") {
              return JSON.stringify(graph.linkLib[x].properties) === JSON.stringify(properties);
            }

            return false;
          }
        }

        return true;
      }
    });
    return link;
  }

  const link = graph && graph.links ? graph.links.find(x => graph.linkLib[x] && graph.linkLib[x].source === source && graph.linkLib[x].target == target) : null;
  return link;
}
function getLinkInstance(graph, options) {
  const linkId = findLinkInstance(graph, options);

  if (linkId) {
    return graph.linkLib[linkId];
  }

  return null;
}
function getLink(graph, options) {
  const {
    id
  } = options;

  if (id && graph && graph.linkLib) {
    return graph.linkLib[id];
  }

  return null;
}
function getAllLinksWithNode(graph, id) {
  return graph.links.filter(x => {
    if (!graph.linkLib[x]) {
      delete graph.linkLib[x];
    }

    return graph.linkLib[x] && (graph.linkLib[x].source === id || graph.linkLib[x].target === id);
  });
}
function removeLinkBetweenNodes(graph, options) {
  const link = findLinkInstance(graph, options);
  return removeLink(graph, link, options);
}
function removeLinkById(graph, options) {
  const link = graph.linkLib[options.id];
  return removeLink(graph, link);
}
function executeEvents(graph, link, evt) {
  switch (evt) {
    case LinkEvents.Remove:
      graph = executeRemoveEvents(graph, link);
      break;
  }

  return graph;
}
const EventFunctions = {};
function addEventFunction(key, func) {
  EventFunctions[key] = func;
}
function removeEventFunction(key) {
  delete EventFunctions[key];
}
function executeRemoveEvents(graph, link) {
  if (link && link.properties && link.properties.on && link.properties.on[LinkEvents.Remove]) {
    link.properties.on[LinkEvents.Remove].map(args => {
      if (args.function && EventFunctions[args.function]) {
        graph = EventFunctions[args.function](graph, link, args.function, args);
      }
    });
  }

  return graph;
}
function isUIExtensionEnumerable(node) {
  const _node = uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIExtensionDefinition);

  if (_node && _node.config) {
    return _node.config.isEnumeration;
  }
}
function GetUIExentionEnumeration(node) {
  if (isUIExtensionEnumerable(node)) {
    const _node = uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIExtensionDefinition);

    return _node.config.list;
  }

  return null;
}
function GetUIExentionKeyField(node) {
  if (isUIExtensionEnumerable(node)) {
    const _node = uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIExtensionDefinition);

    return _node.config.keyField;
  }

  return null;
}
addEventFunction("OnRemoveValidationPropConnection", (graph, link, func) => {
  const {
    source,
    target
  } = link;
  const node = GetNode(graph, source);
  if (node && node.properties) removeValidator(uiactions_GetNodeProp(node, nodetypes_NodeProperties.Validator), {
    id: target
  });
  return graph;
});
addEventFunction("OnRemoveExecutorPropConnection", (graph, link, func) => {
  const {
    source,
    target
  } = link;
  const node = GetNode(graph, source);
  if (node && node.properties) removeValidator(uiactions_GetNodeProp(node, nodetypes_NodeProperties.Executor), {
    id: target
  });
  return graph;
});
addEventFunction("OnRemoveModelFilterPropConnection", (graph, link, func) => {
  const {
    source,
    target
  } = link;
  const node = GetNode(graph, source);
  if (node && node.properties) removeValidator(uiactions_GetNodeProp(node, nodetypes_NodeProperties.FilterModel), {
    id: target
  });
  return graph;
});
addEventFunction("OnRemoveValidationItemPropConnection", (graph, link, func, args) => {
  const {
    source,
    target
  } = link;
  const node = GetNode(graph, source);
  const {
    property,
    validator
  } = args || {};

  const _validator = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Validator);

  if (node && node.properties && _validator.properties && _validator.properties[property] && _validator.properties[property].validators && _validator.properties[property].validators[validator] && _validator.properties[property].validators[validator].node === target) {
    removeValidatorItem(_validator, { ...args,
      id: target
    });
  }

  return graph;
});
addEventFunction("OnRemoveExecutorItemPropConnection", (graph, link, func, args) => {
  const {
    source,
    target
  } = link;
  const node = GetNode(graph, source);
  const {
    property,
    validator
  } = args || {};

  const _validator = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Executor);

  if (node && node.properties && _validator.properties && _validator.properties[property] && _validator.properties[property].validators && _validator.properties[property].validators[validator] && _validator.properties[property].validators[validator].node === target) {
    removeValidatorItem(_validator, { ...args,
      id: target
    });
  }

  return graph;
});
function removeValidatorItem(_validator, options) {
  const {
    property,
    validator
  } = options;
  delete _validator.properties[property].validators[validator];
}
function createEventProp(type, options = {}) {
  const res = {
    on: {}
  };

  switch (type) {
    case LinkEvents.Remove:
      res.on[type] = [{ ...options
      }];
      break;
  }

  return res;
}
function removeLink(graph, link, options = {}) {
  if (link && options.linkType) {
    const update_link = graph.linkLib[link];

    if (update_link && update_link.properties && update_link.properties[options.linkType]) {
      delete update_link.properties[options.linkType]; // If only the type is on the property
    }

    if (update_link && update_link.properties && Object.keys(update_link.properties).length > 1) {
      return { ...graph
      };
    }
  }

  if (link) {
    graph.links = [...graph.links.filter(x => x !== link)];
    const del_link = graph.linkLib[link];

    if (del_link.properties) {
      if (del_link.properties.on && del_link.properties.on[LinkEvents.Remove]) {
        graph = executeEvents(graph, del_link, LinkEvents.Remove);
      }
    }

    delete graph.linkLib[link];
    graph.linkLib = { ...graph.linkLib
    };
    graph.nodeLinks[del_link.source] = { ...graph.nodeLinks[del_link.source],
      ...{
        [del_link.target]: graph.nodeLinks[del_link.source] ? (graph.nodeLinks[del_link.source][del_link.target] || 0) - 1 : 0
      }
    };

    if (graph.nodeLinks[del_link.source] && !graph.nodeLinks[del_link.source][del_link.target]) {
      delete graph.nodeLinks[del_link.source][del_link.target];

      if (Object.keys(graph.nodeLinks[del_link.source]).length === 0) {
        delete graph.nodeLinks[del_link.source];
      }
    }

    graph.nodeLinks[del_link.target] = { ...graph.nodeLinks[del_link.target],
      ...{
        [del_link.source]: graph.nodeLinks[del_link.target] ? (graph.nodeLinks[del_link.target][del_link.source] || 0) - 1 : 0
      }
    };

    if (graph.nodeLinks[del_link.target] && !graph.nodeLinks[del_link.target][del_link.source]) {
      delete graph.nodeLinks[del_link.target][del_link.source];

      if (Object.keys(graph.nodeLinks[del_link.target]).length === 0) {
        delete graph.nodeLinks[del_link.target];
      }
    } // Keeps track of the links for each node.


    if (graph.nodeConnections[del_link.source] && graph.nodeConnections[del_link.source][del_link.id]) {
      delete graph.nodeConnections[del_link.source][del_link.id];
    }

    if (Object.keys(graph.nodeConnections[del_link.source]).length === 0) {
      delete graph.nodeConnections[del_link.source];
    } // Keeps track of the links for each node.


    if (graph.nodeConnections[del_link.target] && graph.nodeConnections[del_link.target][del_link.id]) {
      delete graph.nodeConnections[del_link.target][del_link.id];
    }

    if (Object.keys(graph.nodeConnections[del_link.target]).length === 0) {
      delete graph.nodeConnections[del_link.target];
    }

    graph = incrementMinor(graph);
  }

  return { ...graph
  };
}
function updateNodeText(graph, options) {
  const {
    id,
    value
  } = options;

  if (id && graph.nodeLib && graph.nodeLib[id]) {
    graph.nodeLib[id] = { ...graph.nodeLib[id],
      ...{
        _properties: { ...(graph.nodeLib[id].properties || {}),
          i: value
        },

        get properties() {
          return this._properties;
        },

        set properties(value) {
          this._properties = value;
        }

      }
    };
  }
}
function updateAppSettings(graph, options) {
  const {
    prop,
    value
  } = options;

  if (prop && value) {
    graph.appConfig = graph.appConfig || {};
    graph.appConfig.AppSettings = graph.appConfig.AppSettings || {};
    graph.appConfig.AppSettings[prop] = value;
  }

  return graph;
}
function updateNodeProperties(graph, options) {
  const {
    properties,
    id
  } = options || {};

  if (properties) {
    for (const i in properties) {
      graph = updateNodeProperty(graph, {
        id,
        value: properties[i],
        prop: i
      });
    }
  }

  return graph;
}
function updateNodePropertyDirty(graph, options) {
  const {
    id,
    value,
    prop
  } = options;

  if (id && prop && graph.nodeLib && graph.nodeLib[id]) {
    graph.nodeLib[id] = { ...graph.nodeLib[id],
      ...{
        dirty: { ...(graph.nodeLib[id].dirty || {}),
          [prop]: value
        }
      }
    };
  }

  return graph;
}
function updateNodeProperty(graph, options) {
  const {
    id,
    prop
  } = options;
  let {
    value
  } = options;
  const additionalChange = {};

  if (id && prop && graph.nodeLib && graph.nodeLib[id]) {
    if (prop === nodetypes_NodeProperties.Pinned) {
      if (isFlagged(Flags.HIDE_NEW_NODES)) {
        value = false;
      }
    }

    if (NodePropertiesDirtyChain[prop]) {
      const temps = NodePropertiesDirtyChain[prop];
      temps.forEach(temp => {
        if (!graph.nodeLib[id].dirty[temp.chainProp]) {
          additionalChange[temp.chainProp] = temp.chainFunc(value, graph.nodeLib[id]);
        }
      });
    }

    graph.nodeLib[id] = { ...graph.nodeLib[id],
      ...{
        dirty: {
          [prop]: true,
          ...(graph.nodeLib[id].dirty || {})
        },
        properties: { ...(graph.nodeLib[id].properties || {}),
          [prop]: value,
          ...additionalChange
        }
      }
    };

    if (prop === nodetypes_NodeProperties.Selected) {
      graph.selected = graph.selected ? graph.selected + (value ? 1 : -1) : 0;

      if (value) {
        graph.markedSelectedNodeIds = [...(graph.markedSelectedNodeIds || []), id].unique();
      } else {
        graph.markedSelectedNodeIds = [...(graph.markedSelectedNodeIds || [])].filter(x => x !== id);
      }
    }

    if (prop === nodetypes_NodeProperties.NODEType && value === NodeTypes.Function) {
      graph.functionNodes = { ...graph.functionNodes,
        ...{
          [id]: true
        }
      };
    } else if (graph.functionNodes[id] && prop === nodetypes_NodeProperties.NODEType) {
      delete graph.functionNodes[id];
      graph.functionNodes = { ...graph.functionNodes
      };
    }

    if (prop === nodetypes_NodeProperties.NODEType && value === NodeTypes.ClassNode) {
      graph.classNodes = { ...graph.classNodes,
        ...{
          [id]: true
        }
      };
    } else if (graph.classNodes[id] && prop === nodetypes_NodeProperties.NODEType) {
      delete graph.classNodes[id];
      graph.classNodes = { ...graph.classNodes
      };
    }
  }

  return graph;
}
function updateLinkProperty(graph, options) {
  const {
    id,
    value,
    prop
  } = options;

  if (id && prop && graph.linkLib && graph.linkLib[id]) {
    graph.linkLib[id] = { ...graph.linkLib[id],
      ...{
        properties: { ...(graph.linkLib[id].properties || {}),
          [prop]: value
        }
      }
    };
  }

  return graph;
}
function updateGroupProperty(graph, options) {
  const {
    id,
    value,
    prop
  } = options;

  if (id && prop && graph.groupLib && graph.groupLib[id]) {
    graph.groupLib[id] = { ...graph.groupLib[id],
      ...{
        properties: { ...(graph.groupLib[id].properties || {}),
          [prop]: value
        }
      }
    };
  }

  return graph;
}

function noSameLink(graph, ops) {
  return !graph.links.some(x => {
    const temp = graph.linkLib[x];
    return temp && temp.source === ops.source && temp.target === ops.target;
  });
}

function createGroup() {
  return {
    id: uuidv4(),
    leaves: [],
    groups: [],
    properties: {}
  };
}

function createNode(nodeType) {
  return {
    id: uuidv4(),
    dirty: {},
    properties: {
      text: nodeType || Unknown
    }
  };
}

function createLink(target, source, properties) {
  properties = properties || {};
  return {
    id: uuidv4(),
    source,
    target,
    properties
  };
}

function copyLink(link) {
  return { ...JSON.parse(JSON.stringify(link))
  };
}

function duplicateNode(nn) {
  return { ...nn
  };
}
function duplicateLink(nn, nodes) {
  return { ...nn,
    source: nodes.indexOf(nn.source),
    target: nodes.indexOf(nn.target)
  };
}

function GetNodesInsideGroup(graph, t, seenGroups = {}) {
  let res = [...Object.keys(graph.groupsNodes[t])];

  for (const i in graph.childGroups[t]) {
    if (!seenGroups[i]) {
      seenGroups = { ...seenGroups,
        [i]: true
      };
      res = [...res, ...GetNodesInsideGroup(graph, i, seenGroups)];
    }
  }

  return res;
}

const GroupImportanceOrder = {
  [NodeTypes.Model]: 1,
  [NodeTypes.Function]: 1,
  [NodeTypes.Method]: 1,
  [NodeTypes.Property]: 4,
  [NodeTypes.ValidationList]: 5,
  [NodeTypes.OptionList]: 6,
  [NodeTypes.Parameter]: 4,
  [NodeTypes.Permission]: 4,
  [NodeTypes.Attribute]: 8,
  [NodeTypes.ValidationList]: 10,
  [NodeTypes.ValidationListItem]: 12,
  [NodeTypes.ModelItemFilter]: 13
};
function SetVisible(graph) {
  graph.visibleNodes = {};
  graph.nodes.map(t => {
    if (uiactions_GetNodeProp(GetNode(graph, t), nodetypes_NodeProperties.Pinned)) {
      graph.visibleNodes[t] = true;
    }
  });

  if (graph.depth) {
    [].interpolate(0, graph.depth, x => {
      Object.keys(graph.visibleNodes).map(t => {
        for (const h in graph.nodeLinks[t]) {
          if (x > 1 && !graph.visibleNodes[h]) {
            graph.visibleNodes[h] = 2;
          } else {
            graph.visibleNodes[h] = true;
          }
        }
      });
    });
  }

  return graph;
}

function getDepth(groupId, graph) {
  let res = 0;

  if (graph.groupLib[groupId]) {
    if (graph.parentGroup[groupId]) {
      const parent = Object.keys(graph.parentGroup[groupId])[0];

      if (parent) {
        res += getDepth(parent, graph);
      }
    }

    res += 1;
  }

  return res;
}

function FilterGraph(graph) {
  const filteredGraph = createGraph();
  filteredGraph.id = graph.id;
  filteredGraph.linkLib = { ...graph.linkLib
  };
  filteredGraph.nodesGroups = { ...graph.nodesGroups
  };
  filteredGraph.groupsNodes = { ...graph.groupsNodes
  };
  filteredGraph.groups = [...graph.groups];
  filteredGraph.groupLib = { ...graph.groupLib
  };
  filteredGraph.childGroups = { ...graph.childGroups
  };
  filteredGraph.parentGroup = { ...graph.parentGroup
  };
  filteredGraph.links = [...graph.links.filter(linkId => {
    const {
      target,
      source
    } = graph.linkLib[linkId];

    if (graph.visibleNodes[target] && graph.visibleNodes[source]) {
      return true;
    }

    delete filteredGraph.linkLib[linkId];
    return false;
  })];
  Object.keys(graph.nodesGroups).map(nodeId => {
    if (!graph.visibleNodes[nodeId]) {
      const temp = graph.nodesGroups[nodeId];

      for (const i in temp) {
        filteredGraph.groupsNodes[i] = { ...filteredGraph.groupsNodes[i]
        };
        delete filteredGraph.groupsNodes[i][nodeId];

        if (Object.keys(filteredGraph.groupsNodes[i]).length === 0) {
          delete filteredGraph.groupsNodes[i];
        }
      }

      delete filteredGraph.nodesGroups[nodeId];
    }
  });
  Object.keys(filteredGraph.groupLib).sort((b, a) => getDepth(a, graph) - getDepth(b, graph)).map(group => {
    if (filteredGraph.groupLib[group].leaves) {
      filteredGraph.groupLib[group] = { ...filteredGraph.groupLib[group]
      };
      filteredGraph.groupLib[group].leaves = [...filteredGraph.groupLib[group].leaves.filter(x => graph.visibleNodes[x])];
      filteredGraph.groupLib[group].groups = [...filteredGraph.groupLib[group].groups.filter(x => filteredGraph.groupLib[x])];

      if (!filteredGraph.groupLib[group].leaves.length && !filteredGraph.groupLib[group].groups.length) {
        filteredGraph.groups = [...filteredGraph.groups.filter(x => x !== group)];
        delete filteredGraph.groupLib[group];
      }
    }
  });
  Object.keys(graph.childGroups).map(group => {
    if (!filteredGraph.groupsNodes[group]) {
      delete filteredGraph.childGroups[group];
    } else {
      for (const t in filteredGraph.childGroups[group]) {
        if (!filteredGraph.groupsNodes[t]) {
          filteredGraph.childGroups[group] = { ...filteredGraph.childGroups[group]
          };
          delete filteredGraph.childGroups[group][t];
        }
      }
    }
  });
  Object.keys(graph.parentGroup).map(group => {
    if (!filteredGraph.groupsNodes[group]) {
      delete filteredGraph.parentGroup[group];
    } else {
      for (const t in filteredGraph.parentGroup[group]) {
        if (!filteredGraph.groupsNodes[t]) {
          filteredGraph.parentGroup[group] = { ...filteredGraph.parentGroup[group]
          };
          delete filteredGraph.parentGroup[group][t];
        }
      }
    }
  });
  Object.keys(graph.visibleNodes).map(nodeId => {
    filteredGraph.nodeLib[nodeId] = graph.nodeLib[nodeId];
    filteredGraph.nodes.push(nodeId);
    filteredGraph.nodeConnections[nodeId] = { ...graph.nodeConnections[nodeId]
    };
    filteredGraph.nodeLinks[nodeId] = { ...graph.nodeLinks[nodeId]
    };
    Object.keys(graph.nodeLinks[nodeId] || {}).map(t => {
      if (!filteredGraph.linkLib[t]) {
        filteredGraph.nodeLinks[nodeId] = { ...filteredGraph.nodeLinks[nodeId]
        };
        delete filteredGraph.nodeLinks[nodeId][t];
      }
    });
  });
  return filteredGraph;
}
function VisualProcess(graph) {
  const vgraph = createGraph();
  vgraph.id = graph.id;
  graph = SetVisible(graph);
  vgraph.visibleNodes = { ...graph.visibleNodes
  };
  graph = FilterGraph(graph);
  const collapsedNodes = graph.nodes.filter(node => uiactions_GetNodeProp(graph.nodeLib[node], nodetypes_NodeProperties.Collapsed));
  const collapsingGroups = {};
  collapsedNodes.map(t => {
    if (graph.nodesGroups[t]) {
      const t_importance = GroupImportanceOrder[uiactions_GetNodeProp(graph.nodeLib[t], nodetypes_NodeProperties.NODEType)] || 1000;
      const sortedGroups = Object.keys(graph.nodesGroups[t]).filter(nodeGroupKey => {
        const nodesInGroup = GetNodesInsideGroup(graph, nodeGroupKey);
        const moreImportantNode = nodesInGroup.find(n => {
          if (n === t) {
            return false;
          }

          const _type = uiactions_GetNodeProp(graph.nodeLib[n], nodetypes_NodeProperties.NODEType);

          const n_importance = GroupImportanceOrder[_type] || 1000;

          if (n_importance > t_importance) {
            return false;
          }

          return true;
        });

        if (moreImportantNode) {
          return false;
        }

        return true;
      }).sort((b, a) => Object.keys(graph.groupsNodes[a]).length - Object.keys(graph.groupsNodes[b]).length);

      if (sortedGroups.length) {
        collapsingGroups[sortedGroups[0]] = true;
      }
    }
  });
  const smallestsNonCrossingGroups = Object.keys(collapsingGroups).filter(cg => {
    for (const g_ in graph.parentGroup[cg]) {
      if (collapsingGroups[g_]) {
        return false;
      }
    }

    return true;
  });
  let disappearingNodes = {};
  smallestsNonCrossingGroups.map(t => {
    const dt = {};
    let head = null;
    let mostimportant = 10000;

    const _nodes = GetNodesInsideGroup(graph, t);

    _nodes.filter(t => {
      const type = GetGroupProperty(graph.nodeLib[t], nodetypes_NodeProperties.NODEType);
      dt[t] = true;

      if (GroupImportanceOrder[type] < mostimportant) {
        head = t;
        mostimportant = GroupImportanceOrder[type];
      }
    });

    delete dt[head];

    for (const i in dt) {
      dt[i] = head;
    }

    disappearingNodes = { ...disappearingNodes,
      ...dt
    };
  });
  vgraph.nodes = [...graph.nodes.filter(x => !disappearingNodes[x])];
  vgraph.nodeLib = {};
  vgraph.nodes.map(t => {
    vgraph.nodeLib[t] = graph.nodeLib[t];
  });
  vgraph.links = graph.links.map(x => {
    // Find any link that should be disappearing, and make it go away
    const {
      source,
      target
    } = graph.linkLib[x];
    let dupLink;

    if (disappearingNodes[source] && disappearingNodes[target]) {
      // the link is going totally away;
      return false;
    }

    if (disappearingNodes[source]) {
      dupLink = copyLink(graph.linkLib[x]);
      dupLink.source = disappearingNodes[source];
      dupLink.id = `${dupLink.source}${dupLink.target}`;
      vgraph.linkLib[`${dupLink.source}${dupLink.target}`] = dupLink;
    } else if (disappearingNodes[target]) {
      dupLink = copyLink(graph.linkLib[x]);
      dupLink.target = disappearingNodes[target];
      dupLink.id = `${dupLink.source}${dupLink.target}`;
      vgraph.linkLib[`${dupLink.source}${dupLink.target}`] = dupLink;
    } else {
      dupLink = copyLink(graph.linkLib[x]);
      dupLink.id = `${dupLink.source}${dupLink.target}`;
      vgraph.linkLib[`${dupLink.source}${dupLink.target}`] = dupLink;
    }

    if (dupLink.source === dupLink.target) {
      return false;
    }

    return dupLink.id;
  }).filter(x => x);
  const vgroups = graph.groups.map((group, groupIndex) => {
    const oldgroup = graph.groupLib[group];
    const newgroup = createGroup();
    newgroup.id = `${oldgroup.id}`;

    if (oldgroup && oldgroup.leaves) {
      oldgroup.leaves.map(leaf => {
        if (vgraph.nodeLib[leaf]) {
          newgroup.leaves.push(leaf);
        }
      });
    }

    if (newgroup.leaves.length) {
      vgraph.groupLib[newgroup.id] = newgroup;
      return newgroup.id;
    }

    return null;
  }).filter(x => x);
  vgroups.map(group => {
    vgraph.groupLib[group].groups = (graph.groupLib[group].groups || []).filter(og => {
      if (vgraph.groupLib[og]) {
        return true;
      }

      return false;
    });
  });
  vgraph.groups = vgroups;
  return vgraph;
}
// CONCATENATED MODULE: ./app/constants/datachain.js



const DataChainFunctionKeys = {
  ModelProperty: "Model - Property",
  Required: "Required",
  Not: "Not",
  CollectResults: "Collect values",
  Selector: "Selector",
  EmailValidation: "Email validation",
  GreaterThan: "Greater Than",
  LessThan: "Less Than",
  MaxLength: "Max Length",
  MinLength: "Min Length",
  EqualsLength: "Equals Length",
  GreaterThanOrEqualTo: "Greater than or equal to",
  AlphaNumericLike: "Alphanumeric like",
  AlphaNumeric: "Alphanumeric",
  AlphaOnly: "Alpha only",
  LessThanOrEqualTo: "Less than or equal to",
  Equals: "Are Equal",
  BooleanAnd: "Boolean And",
  BooleanOr: "Boolean Or",
  Property: "Property",
  IfTrue: "IfTrue",
  Title: "Title",
  NumericalDefault: "Default (number)",
  IfFalse: "IfFalse",
  IfThanElse: "IfThanElse",
  Model: "Model",
  Models: "Models",
  // Gets an array of models of a type
  Subset: "Subset",
  //Gets a subset of an array
  Sort: "Sort",
  //Sorts an array,
  Filter: "Filter",
  //Filters an array.
  Pass: "Pass",
  SetBearerAccessToken: "SetBearerAccessToken",
  ReferenceDataChain: "Data Chain Ref.",
  Merge: "Merge",
  Map: "Map",
  ArrayLength: "Array Length",
  ListReference: "List Reference",
  DataChainReferences: "DataChainReferences",
  StringConcat: "String Concat {0} {1}",
  SaveModelArrayToState: "Save Model Array To State",
  Navigate: "Navigate",
  StateKey: "StateKey",
  ModelKey: "ModelKey",
  ViewModelKey: "ViewModelKey",
  Lambda: "Lambda",
  MethodBaseValidation: "MethodBaseValidation",
  ModelMethodMenu: 'ModelMethodMenu',
  Validation: "Validation",
  NavigateTo: "Navigate To",
  GetModelIds: "Get Model Ids",
  // Get an array of model ids from an array
  SaveModelIdsToState: "Save Model Array Ids to State Under Key",
  GetStateKeyValue: "Get Values Under State Key",
  NewRedGraph: "New Red Graph",
  AddUrlsToGraph: "Add Urls to Graph"
};
const DataChainFunctions = {
  [DataChainFunctionKeys.Not]: {
    ui: {},
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "Not"
  },
  [DataChainFunctionKeys.Title]: {
    ui: {
      value: nodetypes_NodeProperties.Value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "Title"
  },
  [DataChainFunctionKeys.Selector]: {
    ui: {
      selectorProperty: nodetypes_NodeProperties.SelectorProperty,
      selector: nodetypes_NodeProperties.Selector
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "Selector"
  },
  [DataChainFunctionKeys.MethodBaseValidation]: {
    ui: {
      method: nodetypes_NodeProperties.Method,
      model: nodetypes_NodeProperties.UIModelType,
      property: nodetypes_NodeProperties.Property
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: DataChainFunctionKeys.MethodBaseValidation
  },
  [DataChainFunctionKeys.Navigate]: {
    ui: {
      screen: nodetypes_NodeProperties.Screen,
      navigateMethod: nodetypes_NodeProperties.NavigationAction,
      useParams: nodetypes_NodeProperties.UseNavigationParams
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "Navigate"
  },
  [DataChainFunctionKeys.NavigateTo]: {
    ui: {
      navigateMethod: nodetypes_NodeProperties.NavigationAction
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "NavigateTo"
  },
  [DataChainFunctionKeys.ListReference]: {
    ui: {
      list: nodetypes_NodeProperties.List
    },
    filter: {},
    value: DataChainFunctionKeys.ListReference
  },
  [DataChainFunctionKeys.Map]: {
    ui: {
      lambda: nodetypes_NodeProperties.Lambda
    },
    filter: {},
    value: DataChainFunctionKeys.Map
  },
  [DataChainFunctionKeys.Merge]: {
    ui: {
      lambda: nodetypes_NodeProperties.Lambda,
      datareferences: nodetypes_NodeProperties.DataChainReferences
    },
    filter: {},
    value: DataChainFunctionKeys.Merge
  },
  [DataChainFunctionKeys.Lambda]: {
    ui: {
      lambda: nodetypes_NodeProperties.Lambda
    },
    filter: {},
    value: DataChainFunctionKeys.Lambda
  },
  [DataChainFunctionKeys.Validation]: {
    ui: {},
    filter: {},
    value: DataChainFunctionKeys.Validation
  },
  [DataChainFunctionKeys.IfTrue]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      value: nodetypes_NodeProperties.Value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "IfTrue"
  },
  [DataChainFunctionKeys.IfFalse]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      value: nodetypes_NodeProperties.Value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "IfFalse"
  },
  [DataChainFunctionKeys.Required]: {
    ui: {},
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "Required"
  },
  [DataChainFunctionKeys.Property]: {
    ui: {
      model: nodetypes_NodeProperties.UIModelType,
      property: nodetypes_NodeProperties.Property
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "Property"
  },
  [DataChainFunctionKeys.BooleanAnd]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      node_2: nodetypes_NodeProperties.ChainNodeInput2
    },
    merge: true,
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "BooleanAnd"
  },
  [DataChainFunctionKeys.Equals]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      node_2: nodetypes_NodeProperties.ChainNodeInput2
    },
    merge: true,
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "AreEquals"
  },
  [DataChainFunctionKeys.IfThanElse]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      node_2: nodetypes_NodeProperties.ChainNodeInput2
    },
    merge: true,
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: DataChainFunctionKeys.IfThanElse
  },
  [DataChainFunctionKeys.BooleanOr]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      node_2: nodetypes_NodeProperties.ChainNodeInput2
    },
    merge: true,
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "BooleanOr"
  },
  [DataChainFunctionKeys.AlphaNumericLike]: {
    ui: {
      value: nodetypes_NodeProperties.value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "AlphaNumericLike"
  },
  [DataChainFunctionKeys.AlphaNumeric]: {
    ui: {
      value: nodetypes_NodeProperties.value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "AlphaNumeric"
  },
  [DataChainFunctionKeys.AlphaOnly]: {
    ui: {
      value: nodetypes_NodeProperties.value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "AlphaOnly"
  },
  [DataChainFunctionKeys.EmailValidation]: {
    ui: {
      value: nodetypes_NodeProperties.value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "email_validation"
  },
  [DataChainFunctionKeys.LessThanOrEqualTo]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "LessThanOrEqualTo"
  },
  [DataChainFunctionKeys.ArrayLength]: {
    ui: {
      value: nodetypes_NodeProperties.value
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "ArrayLength"
  },
  [DataChainFunctionKeys.NumericalDefault]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "NumericalDefault"
  },
  [DataChainFunctionKeys.GreaterThanOrEqualTo]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "GreaterThanOrEqualTo"
  },
  [DataChainFunctionKeys.EqualsLength]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "EqualsLength"
  },
  [DataChainFunctionKeys.MinLength]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "MinLength"
  },
  [DataChainFunctionKeys.MaxLength]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "MaxLength"
  },
  [DataChainFunctionKeys.LessThan]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "LessThan"
  },
  [DataChainFunctionKeys.GreaterThan]: {
    ui: {
      value: nodetypes_NodeProperties.value,
      number: nodetypes_NodeProperties.Number
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "greater_than_validation"
  },
  [DataChainFunctionKeys.SetBearerAccessToken]: {
    ui: {},
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "SetBearerAccessToken"
  },
  [DataChainFunctionKeys.ReferenceDataChain]: {
    ui: {
      dataref: nodetypes_NodeProperties.DataChainReference
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "reference_data_chain"
  },
  [DataChainFunctionKeys.ModelProperty]: {
    ui: {
      model: nodetypes_NodeProperties.UIModelType,
      property: nodetypes_NodeProperties.Property
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "model_property_selection"
  },
  [DataChainFunctionKeys.Model]: {
    ui: {
      model: nodetypes_NodeProperties.UIModelType,
      property: false
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "model_selection"
  },
  [DataChainFunctionKeys.Pass]: {
    ui: {},
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "pass_selection"
  },
  [DataChainFunctionKeys.NewRedGraph]: {
    ui: {},
    filter: {},
    value: DataChainFunctionKeys.NewRedGraph
  },
  [DataChainFunctionKeys.AddUrlsToGraph]: {
    ui: {},
    filter: {},
    value: DataChainFunctionKeys.AddUrlsToGraph
  },
  [DataChainFunctionKeys.Models]: {
    ui: {
      model: nodetypes_NodeProperties.UIModelType,
      property: false
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "models_selection"
  },
  [DataChainFunctionKeys.Filter]: {
    ui: {
      dataref: nodetypes_NodeProperties.DataChainReference
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "array_filter"
  },
  [DataChainFunctionKeys.Sort]: {
    ui: {
      dataref: nodetypes_NodeProperties.DataChainReference,
      compareref: nodetypes_NodeProperties.DataChainReference
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "array_sort"
  },
  [DataChainFunctionKeys.Subset]: {
    ui: {
      dataref: nodetypes_NodeProperties.DataChainReference
    },
    filter: {
      [nodetypes_NodeProperties.NODEType]: true
    },
    value: "array_subset"
  },
  [DataChainFunctionKeys.SaveModelArrayToState]: {
    ui: {
      model: nodetypes_NodeProperties.UIModelType
    },
    filter: {},
    value: DataChainFunctionKeys.SaveModelArrayToState
  },
  [DataChainFunctionKeys.GetModelIds]: {
    ui: {},
    filter: {},
    value: DataChainFunctionKeys.GetModelIds
  },
  //GetModelIds
  [DataChainFunctionKeys.SaveModelIdsToState]: {
    ui: {
      stateKey: nodetypes_NodeProperties.StateKey
    },
    filter: {},
    value: DataChainFunctionKeys.SaveModelIdsToState
  },
  [DataChainFunctionKeys.GetStateKeyValue]: {
    ui: {
      stateKey: nodetypes_NodeProperties.StateKey
    },
    filter: {},
    value: DataChainFunctionKeys.GetStateKeyValue
  },
  [DataChainFunctionKeys.ModelKey]: {
    ui: {
      modelKey: nodetypes_NodeProperties.ModelKey
    },
    filter: {},
    value: DataChainFunctionKeys.ModelKey
  },
  [DataChainFunctionKeys.StateKey]: {
    ui: {
      stateKey: nodetypes_NodeProperties.StateKey
    },
    filter: {},
    value: DataChainFunctionKeys.StateKey
  },
  [DataChainFunctionKeys.ViewModelKey]: {
    ui: {
      viewModelKey: nodetypes_NodeProperties.ViewModelKey
    },
    filter: {},
    value: DataChainFunctionKeys.ViewModelKey
  },
  [DataChainFunctionKeys.StringConcat]: {
    ui: {
      node_1: nodetypes_NodeProperties.ChainNodeInput1,
      node_2: nodetypes_NodeProperties.ChainNodeInput2
    },
    merge: true,
    filter: {
      [nodetypes_NodeProperties.MergeNode]: true
    },
    value: "string_concat_2_values"
  }
};
function connectNodeChain(prop, reverse) {
  return function (currentNode, value) {
    var id = currentNode.id;
    this.props.graphOperation(connectNodeChainCommands(prop, id, value, currentNode.properties[prop], reverse));
  };
}
function connectNodeChainCommands(prop, id, value, source, reverse) {
  return [{
    operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
    options: {
      source: reverse ? id : source,
      target: reverse ? source : id
    }
  }, {
    operation: CHANGE_NODE_PROPERTY,
    options: {
      prop,
      id,
      value
    }
  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,
    options: {
      source: reverse ? id : value,
      target: reverse ? value : id,
      properties: { ...nodetypes_LinkProperties.DataChainLink
      }
    }
  }];
}
function snipNodeFromInbetween() {
  return function (currentNode) {
    let graph = GetCurrentGraph(GetState());
    let links = getNodeLinks(graph, currentNode.id);

    if (links.length === 2) {
      let sourceNode = links.filter(v => v.target === currentNode.id).map(t => GetNodeById(t.source)).find(x => x);
      let targetNode = links.filter(v => v.source === currentNode.id).map(t => GetNodeById(t.target)).find(x => x);

      if (sourceNode && targetNode) {
        this.props.graphOperation([{
          operation: REMOVE_NODE,
          options: {
            id: currentNode.id
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            source: sourceNode.id,
            target: targetNode.id,
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          }
        }, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: nodetypes_NodeProperties.ChainParent,
            id: targetNode.id,
            value: sourceNode.id
          }
        }]);
        this.props.setVisual(SIDE_PANEL_OPEN, false);
        this.props.setVisual(SELECTED_TAB, DEFAULT_TAB);
      }
    }
  };
}
function insertNodeInbetween(_callback, graph) {
  return function (currentNode, value) {
    graph = graph || GetCurrentGraph(GetState());
    let me = this;
    let link = GetLinkBetween(currentNode.id, value, graph);

    if (link) {
      var source = GetNodeById(link.source);
      var target = GetNodeById(link.target);
      this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, { ...link
      });
      let groupParent = uiactions_GetNodeProp(source, nodetypes_NodeProperties.GroupParent);
      this.props.graphOperation(ADD_NEW_NODE, {
        nodeType: NodeTypes.DataChain,
        parent: source.id,
        groupProperties: groupParent ? {
          id: groupParent
        } : {},
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        },
        properties: {
          [nodetypes_NodeProperties.ChainParent]: source.id
        },
        links: [{
          target: link.target,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          }
        }],
        callback: node => {
          setTimeout(() => {
            me.props.graphOperation([{
              operation: uiactions_ADD_LINK_BETWEEN_NODES,
              options: {
                source: link.source,
                target: node.id,
                properties: { ...nodetypes_LinkProperties.DataChainLink
                }
              }
            }, {
              operation: CHANGE_NODE_PROPERTY,
              options: {
                id: link.target,
                value: node.id,
                prop: nodetypes_NodeProperties.ChainParent
              }
            }]);

            if (_callback) {
              _callback(node.id);
            }
          }, 100);
        }
      });
    }
  };
}
function InsertNodeInbetween(currentNode, value, graph, onCallback, properties = {}) {
  graph = graph || GetCurrentGraph(GetState());
  let me = this;
  let link = GetLinkBetween(currentNode.id, value, graph);
  let result = [];

  if (link) {
    var source = GetNodeById(link.source, graph);
    var target = GetNodeById(link.target, graph);
    result.push({
      operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
      options: { ...link
      }
    });
    let groupParent = uiactions_GetNodeProp(source, nodetypes_NodeProperties.GroupParent);
    let targetNode;
    result.push({
      operation: ADD_NEW_NODE,
      options: function () {
        return {
          nodeType: NodeTypes.DataChain,
          parent: source.id,
          groupProperties: groupParent ? {
            id: groupParent
          } : {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          },
          properties: { ...properties,
            [nodetypes_NodeProperties.ChainParent]: source.id
          },
          links: [{
            target: link.target,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.DataChainLink
              }
            }
          }],
          callback: node => {
            targetNode = node;

            if (onCallback) {
              onCallback(targetNode);
            }
          }
        };
      }
    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,
      options: function () {
        return {
          source: link.source,
          target: targetNode.id,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }
    }, {
      operation: CHANGE_NODE_PROPERTY,
      options: function () {
        return {
          id: link.target,
          value: targetNode.id,
          prop: nodetypes_NodeProperties.ChainParent
        };
      }
    });
  }

  return result;
}
function connectChain() {
  return function (currentNode, value) {
    var id = currentNode.id;
    this.props.graphOperation(ConnectChainCommand(id, value));
  };
}
function ConnectChainCommand(source, target) {
  return [{
    operation: uiactions_ADD_LINK_BETWEEN_NODES,
    options: {
      source,
      target,
      properties: { ...nodetypes_LinkProperties.DataChainLink
      }
    }
  }, {
    operation: CHANGE_NODE_PROPERTY,
    options: {
      id: target,
      prop: nodetypes_NodeProperties.ChainParent,
      value: source
    }
  }];
}
function AddChainCommand(currentNode, callback, graph, viewPackage = {}) {
  let groupProperties = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) ? {
    id: uiactions_getGroup(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent), graph).id
  } : null;
  return {
    operation: ADD_NEW_NODE,
    options: {
      parent: currentNode.id,
      nodeType: NodeTypes.DataChain,
      groupProperties,
      properties: { ...viewPackage,
        [nodetypes_NodeProperties.Pinned]: false,
        [nodetypes_NodeProperties.ChainParent]: currentNode.id
      },
      linkProperties: {
        properties: { ...nodetypes_LinkProperties.DataChainLink
        }
      },
      callback
    }
  };
}
function SplitDataCommand(currentNode, callback, viewPackage = {}, graph, links = []) {
  return {
    operation: ADD_NEW_NODE,
    options: {
      parent: currentNode.id,
      nodeType: NodeTypes.DataChain,
      groupProperties: {
        [GroupProperties.ExternalEntryNode]: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ChainParent, graph),
        [GroupProperties.GroupEntryNode]: currentNode.id,
        [GroupProperties.GroupExitNode]: currentNode.id,
        [GroupProperties.ExternalExitNode]: GetDataChainNextId(currentNode.id, graph)
      },
      properties: {
        [nodetypes_NodeProperties.Pinned]: false,
        ...viewPackage,
        [nodetypes_NodeProperties.ChainParent]: currentNode.id
      },
      linkProperties: {
        properties: { ...nodetypes_LinkProperties.DataChainLink
        }
      },
      links,
      callback
    }
  };
}
const DataChainContextMethods = {
  Input1: connectNodeChain(nodetypes_NodeProperties.ChainNodeInput1),
  List: connectNodeChain(nodetypes_NodeProperties.List),
  Selector: connectNodeChain(nodetypes_NodeProperties.Selector),
  Screen: connectNodeChain(nodetypes_NodeProperties.Screen, true),
  Method: connectNodeChain(nodetypes_NodeProperties.Method, true),
  SelectorProperty: connectNodeChain(nodetypes_NodeProperties.SelectorProperty),
  Value: connectNodeChain(nodetypes_NodeProperties.Value),
  StandardLink: connectChain(),
  InsertDataChain: insertNodeInbetween(),
  SnipDataChain: snipNodeFromInbetween(),
  SplitDataChain: function (currentNode) {
    let id = currentNode.id;
    let {
      state
    } = this.props;
    this.props.graphOperation([SplitDataCommand(currentNode)]);
  }
};
// CONCATENATED MODULE: ./app/utils/utilservice.js


function calculateContrast(c1, c2) {
  let c1_ = relativeLuminance(c1);
  let c2_ = relativeLuminance(c2);
  let L1 = Math.max(c1_, c2_);
  let L2 = Math.min(c1_, c2_);
  return (L1 + 0.05) / (L2 + 0.05);
}
function relativeLuminance(color) {
  /**
     * relative luminance
  the relative brightness of any point in a colorspace, normalized to 0 for darkest black and 1 for lightest white
  Note 1: For the sRGB colorspace, the relative luminance of a color is defined as L = 0.2126 * R + 0.7152 * G + 0.0722 * B where R, G and B are defined as:
  if RsRGB <= 0.03928 then R = RsRGB/12.92 else R = ((RsRGB+0.055)/1.055) ^ 2.4
  if GsRGB <= 0.03928 then G = GsRGB/12.92 else G = ((GsRGB+0.055)/1.055) ^ 2.4
  if BsRGB <= 0.03928 then B = BsRGB/12.92 else B = ((BsRGB+0.055)/1.055) ^ 2.4
  and RsRGB, GsRGB, and BsRGB are defined as:
  RsRGB = R8bit/255
  GsRGB = G8bit/255
  BsRGB = B8bit/255
     */
  if (color.startsWith("#")) {
    color = color.split("").subset(1).join("");
  }

  let Rs = parseInt(`${color[0]}${color[1]}`, 16) / 255;
  let Gs = parseInt(`${color[2]}${color[3]}`, 16) / 255;
  let Bs = parseInt(`${color[4]}${color[5]}`, 16) / 255;
  let r, g, b;
  let minv = 0.03928;

  function calc(c) {
    let r;

    if (c <= minv) {
      r = c / 12.92;
    } else {
      r = Math.pow((c + 0.55) / 1.055, 2.4);
    }

    return r;
  }

  r = calc(Rs);
  g = calc(Gs);
  b = calc(Bs);
  let L = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  return L;
}
function getStringInserts(str = "") {
  ///\${[a-zA-Z0-9]*}
  const regex = /\${[a-zA-Z0-9_]*}/gm;
  let m;
  let result = [];

  while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
      regex.lastIndex++;
    } // The result can be accessed through the `m`-variable.


    m.forEach((match, groupIndex) => {
      if (match) {
        result.push(match);
      }
    });
  }

  return result;
}
function getReferenceInserts(str = "") {
  ///\${[a-zA-Z0-9]*}
  const regex = /\#{[a-zA-Z0-9_@|\- ~]*}/gm;
  let m;
  let result = [];
  let regexes = [regex];
  regexes.map(regex => {
    while ((m = regex.exec(str)) !== null) {
      // This is necessary to avoid infinite loops with zero-width matches
      if (m.index === regex.lastIndex) {
        regex.lastIndex++;
      } // The result can be accessed through the `m`-variable.


      m.forEach((match, groupIndex) => {
        if (match) {
          result.push(match);
        }
      });
    }
  });
  return result;
}
function getGuids(str = "") {
  const regex = /(\{){0,1}[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}(\}){0,1}/gm;
  let m;
  let result = [];

  while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
      regex.lastIndex++;
    } // The result can be accessed through the `m`-variable.


    m.forEach((match, groupIndex) => {
      if (match) {
        result.push(match);
      }
    });
  }

  return result;
}
function getGroupGuids(str = "") {
  const regex = /group\-(\{){0,1}[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}(\}){0,1}/gm;
  let m;
  let result = [];

  while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
      regex.lastIndex++;
    } // The result can be accessed through the `m`-variable.


    m.forEach((match, groupIndex) => {
      if (match) {
        result.push(match);
      }
    });
  }

  return result.map(v => getGuids(v)).flatten().filter(x => x);
}
function getNodePropertyGuids(obj) {
  let str = JSON.stringify(obj);
  let guids = getGuids(str).unique();
  return guids;
}
function processRecording(str) {
  let guids = getGuids(str).unique();
  let groupGuids = getGroupGuids(str).unique();
  let nodeIndexes = {};
  groupGuids.map((v, index) => {
    nodeIndexes[guids.indexOf(v) - index] = index;
  });
  guids = guids.filter(v => !groupGuids.some(t => v == t));
  let commands = JSON.parse(str);
  let unaccountedGuids = [...guids];
  commands.map(command => {
    if (command.callback) {
      if (command.options) {
        if (command.callbackGroup && command.options.groupProperties) {
          command.options.callbackg = command.callback;
        } else {
          command.options.callback = command.callback;
        }
      }
    }

    if (unaccountedGuids.some(v => v === command.callback)) {
      unaccountedGuids = [...unaccountedGuids.filter(x => x !== command.callback)];
    }

    delete command.callback;
    delete command.callbackGroup;
  });
  str = JSON.stringify(commands, null, 4);
  guids.map((guid, index) => {
    var subregex = new RegExp(`"callback": "${guid}"`, "g");
    str = str.replace(subregex, `"callback": function(node) { context.node${index} = node.id; }`);
    subregex = new RegExp(`"callbackg": "${guid}"`, "g");
    str = str.replace(subregex, `"callback": function(node, graph, group) { context.node${index} = node.id;
      context.group${nodeIndexes[index]} = group;
    }`);
    subregex = new RegExp(`"${guid}":`, "g");
    str = str.replace(subregex, `[context.node${index}]:`);
    subregex = new RegExp(`"${guid}"`, "g");
    str = str.replace(subregex, `context.node${index}`);
  });
  groupGuids.map((guid, index) => {
    var subregex = new RegExp(`"${guid}":`, "g");
    str = str.replace(subregex, `[context.group${index}]:`);
    subregex = new RegExp(`"${guid}"`, "g");
    str = str.replace(subregex, `context.group${index}`);
  });
  let firstFunction$re = /\[ *\n *{/gm;
  str = str.replace(firstFunction$re, `[
      function(graph) {
      return [{
`);
  let functionStart$re = /,\n *{/gm;
  str = str.replace(functionStart$re, `,
    {
    function(graph) {
      return [{
`);
  let functionEnd$re = /},\n *{/gm;
  str = str.replace(functionEnd$re, `}]
    },
`);
  let lastFunction$re = /}\n *]/gm;
  str = str.replace(lastFunction$re, `}]
  }]
`);
  let inserts = getStringInserts(str);
  inserts.map(insert => {
    var subregex = new RegExp("\\" + insert, "g");
    str = str.replace(subregex, `" + args.${insert.substr(2, insert.length - 3)} + "`);
  });
  const regex = /context.groupundefined = group;/gm;
  str = str.replace(regex, "");
  let temp = guids.map((x, index) => {
    return `{
      operation: 'CHANGE_NODE_PROPERTY',
      options: function() {
          return {
          prop: 'Pinned',
          id: context.node${index},
          value: false
        }
      }
    }`;
  }).subset(1).join("," + nodetypes_NEW_LINE);
  return `
  import { uuidv4 } from "../utils/array";
  import { NodeProperties } from "../constants/nodetypes";
  export default function(args = {}) {
    // ${unaccountedGuids.map(v => {
    let index = guids.indexOf(v);
    return "node" + index;
  }).join()}

      // ${inserts.map(insert => insert.substr(2, insert.length - 3)).join(", ")}
      ${inserts.map(insert => {
    let temp = insert.substr(2, insert.length - 3);
    return `if(!args.${temp}){
          throw new Error('missing ${temp} argument');
        }`;
  }).join("")}
    let context = {
      ...args${unaccountedGuids.length ? "," + nodetypes_NEW_LINE + unaccountedGuids.map(v => {
    let index = guids.indexOf(v);
    return "node" + index + ": uuidv4() ";
  }).join("," + nodetypes_NEW_LINE) : ""}
    };
    let {
      viewPackages
    } = args;
    viewPackages = {
      [NodeProperties.ViewPackage]: uuidv4(),
      ...(viewPackages||{})
    };
    let result = ${str};
    let clearPinned = [${temp}];
    let applyViewPackages = [${guids.map((guid, index) => {
    if (unaccountedGuids.indexOf(guid) === -1) {
      return `{
          operation: 'UPDATE_NODE_PROPERTY',
          options : function() {
            return {
              id: context.node${index},
              properties: viewPackages
            }
          }
        }`;
    }

    return false;
  }).filter(x => x).join()}]
    return [
      ...result,
      ...clearPinned,
      ...applyViewPackages,
      function() {
        if (context.callback) {
          context.entry = context.node0;
          context.callback(context);
        }
        return [];
      }];
  }`;
}
// CONCATENATED MODULE: ./app/nodepacks/CreateDataChainGetBody.js


/* harmony default export */ var CreateDataChainGetBody = (function (args = {}) {
  // node1
  if (!args.selector) {
    throw "missing selector";
  } // model


  if (!args.model) {
    throw "missing model argument";
  }

  let context = { ...args,
    node1: args.selector
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Selector"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node0
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Selector",
        id: context.node0,
        value: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node1,
        target: context.node0,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node0
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "SelectorProperty",
        id: context.node0,
        value: "object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: "object",
        target: context.node0,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get " + args.model + " Object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function (graph) {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context, graph);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/service/validation_js_service.js
/* eslint-disable import/prefer-default-export */

/* eslint-disable prefer-const */


function buildValidation(args = {
  methodMethod
}) {
  let {
    methodMethod,
    id
  } = args;

  if (methodMethod) {
    const dataChain = GetNodeById(id);
    const property = uiactions_GetNodeProp(dataChain, nodetypes_NodeProperties.Property);
    const validationNode = uiactions_GetValidationNode(methodMethod);
    let conditions = null;

    if (validationNode) {
      conditions = GetCombinedCondition(validationNode.id, ProgrammingLanguages.JavaScript, {
        filter: {
          property
        },
        finalResult: 'valid'
      });
    }

    return `context => {
      let result = {
        errors: [],
        warnings: [],
        success: [],
        valid: true
      };
      let { object, property, validated } = (context || {});
      let model = object || {};
      let valid = true;

      ${conditions || ""};
      result.valid = valid;
      result.validated = validated;
      return result;
    }`;
  }
}
// CONCATENATED MODULE: ./app/nodepacks/method/UpdateMethodParameters.js








function UpdateMethodParameters(args = {
  methodType,
  current
}) {
  let {
    methodType,
    current
  } = args;

  if (!methodType) {
    throw "no node";
  }

  if (!current) {
    throw "no method";
  }

  let graph = GetCurrentGraph();
  let result = [];
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let toRemove = [];
  GetNodesLinkedTo(graph, {
    id: current
  }).filter(t => {
    return uiactions_GetNodeProp(t, nodetypes_NodeProperties.NODEType) === NodeTypes.MethodApiParameters;
  }).map(t => {
    toRemove.push(t.id);
    let viewPackageId = uiactions_GetNodeProp(t, nodetypes_NodeProperties.ViewPackage);
    if (viewPackageId) GetNodesByProperties({
      [nodetypes_NodeProperties.ViewPackage]: viewPackageId
    }).map(v => {
      toRemove.push(v.id);
    });
    GetNodesLinkedTo(graph, {
      id: t.id
    }).filter(w => {
      return uiactions_GetNodeProp(w, nodetypes_NodeProperties.NODEType) === NodeTypes.MethodApiParameters;
    }).map(v => {
      toRemove.push(v.id);
    });
  });
  result.push(...toRemove.map(v => {
    return {
      operation: REMOVE_NODE,
      options: function () {
        return {
          id: v
        };
      }
    };
  }));

  if (MethodFunctions[methodType]) {
    let {
      parameters
    } = MethodFunctions[methodType];
    let newGroupId = uuidv4();

    if (parameters) {
      let {
        body
      } = parameters;
      let params = parameters.parameters;
      let operations = [body ? {
        operation: ADD_NEW_NODE,
        options: function () {
          return {
            nodeType: NodeTypes.MethodApiParameters,
            properties: { ...viewPackages,
              [nodetypes_NodeProperties.UIText]: Body,
              [nodetypes_NodeProperties.UriBody]: true
            },
            links: [{
              target: current,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.MethodApiParameters,
                  body: !!body
                }
              }
            }]
          };
        }
      } : false].filter(x => x);

      if (params) {
        let {
          query,
          template
        } = params;

        if (query) {
          let queryNodeId = null;
          operations.push({
            operation: ADD_NEW_NODE,
            options: function () {
              return {
                nodeType: NodeTypes.MethodApiParameters,
                properties: { ...viewPackages,
                  [nodetypes_NodeProperties.UIText]: "Query",
                  [nodetypes_NodeProperties.QueryParameterObject]: true
                },
                callback: function (queryNode) {
                  queryNodeId = queryNode.id;
                },
                links: [{
                  target: current,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.MethodApiParameters,
                      params: true,
                      query: true
                    }
                  }
                }]
              };
            }
          }, ...Object.keys(query).map(q => {
            return {
              operation: ADD_NEW_NODE,
              options: function () {
                return {
                  nodeType: NodeTypes.MethodApiParameters,
                  groupProperties: {},
                  parent: queryNodeId,
                  properties: { ...viewPackages,
                    [nodetypes_NodeProperties.UIText]: q,
                    [nodetypes_NodeProperties.QueryParameterParam]: true,
                    [nodetypes_NodeProperties.QueryParameterParamType]: q
                  },
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.MethodApiParameters,
                      parameter: q
                    }
                  }
                };
              }
            };
          }));
        }

        if (template) {
          let templateParameterId = null;
          operations.push({
            operation: ADD_NEW_NODE,
            options: function () {
              return {
                nodeType: NodeTypes.MethodApiParameters,
                properties: { ...viewPackages,
                  [nodetypes_NodeProperties.UIText]: "TemplateParameters",
                  [nodetypes_NodeProperties.TemplateParameter]: true
                },
                callback: function (queryNode) {
                  templateParameterId = queryNode.id;
                },
                links: [{
                  target: current,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.MethodApiParameters,
                      params: true,
                      template: true
                    }
                  }
                }]
              };
            }
          }, ...Object.keys(template).map(q => {
            return {
              operation: ADD_NEW_NODE,
              options: function () {
                return {
                  nodeType: NodeTypes.MethodApiParameters,
                  groupProperties: {},
                  parent: templateParameterId,
                  properties: { ...viewPackages,
                    [nodetypes_NodeProperties.UIText]: q,
                    [nodetypes_NodeProperties.TemplateParameter]: true,
                    [nodetypes_NodeProperties.TemplateParameterType]: q
                  },
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.MethodApiParameters,
                      parameter: q
                    }
                  }
                };
              }
            };
          }));
        }
      }

      result.push(...operations);
    }
  }

  return result;
}
// CONCATENATED MODULE: ./app/components/ConnectLifecycleMethod.js




/* harmony default export */ var ConnectLifecycleMethod = (function (args = {}) {
  const {
    target,
    source,
    graph
  } = args;
  let {
    viewPackages,
    selectorNode,
    dataChain
  } = args;
  const state = GetState();
  viewPackages = viewPackages || {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const apiConnectors = GetConnectedNodesByType(state, source, NodeTypes.ComponentApiConnector, null, graph).map(x => ({
    operation: REMOVE_NODE,
    options: {
      id: x.id
    }
  }));
  const lifeCycleMethod = GetConnectedNodeByType(state, source, [NodeTypes.LifeCylceMethod, NodeTypes.EventMethod], null, graph);
  const model = GetConnectedNodeByType(state, lifeCycleMethod.id, [NodeTypes.Model], null, graph);
  dataChain = dataChain || (model ? GetConnectedNodeByType(state, model.id, [NodeTypes.DataChain], null, graph) : null);
  selectorNode = selectorNode || (model ? GetConnectedNodeByType(state, model.id, [NodeTypes.Selector], null, graph) : null);
  const componentNode = GetConnectedNodeByType(state, lifeCycleMethod.id, [NodeTypes.ComponentNode, NodeTypes.Screen, NodeTypes.ScreenOption], null, graph);
  const context = {
    apiEndPoints: [],
    lifeCycleMethod
  };
  const apiEndpoints = [];
  GetConnectedNodesByType(state, target, NodeTypes.MethodApiParameters, null, graph).filter(x => {
    if (uiactions_GetNodeProp(x, nodetypes_NodeProperties.QueryParameterObject)) {
      return true;
    }

    if (uiactions_GetNodeProp(x, nodetypes_NodeProperties.UriBody)) {
      apiEndpoints.push(x);
      return false;
    }

    return true;
  }).map(queryObj => {
    GetConnectedNodesByType(state, queryObj.id, NodeTypes.MethodApiParameters, null, graph).map(queryParam => {
      if (uiactions_GetNodeProp(queryParam, nodetypes_NodeProperties.QueryParameterParam)) {
        apiEndpoints.push(queryParam);
      } else if (uiactions_GetNodeProp(queryParam, nodetypes_NodeProperties.TemplateParameter)) {
        apiEndpoints.push(queryParam);
      }
    });
  });
  const result = [...apiConnectors, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        target,
        source,
        properties: { ...nodetypes_LinkProperties.MethodCall
        }
      };
    }

  }, ...apiEndpoints.map(ae => {
    return {
      operation: ADD_NEW_NODE,

      options() {
        const skipOrTake = GetNodeByProperties({
          [nodetypes_NodeProperties.QueryParameterType]: uiactions_GetNodeProp(ae, nodetypes_NodeProperties.QueryParameterParamType),
          [nodetypes_NodeProperties.NODEType]: NodeTypes.DataChain,
          [nodetypes_NodeProperties.Component]: componentNode.id,
          [nodetypes_NodeProperties.IsPaging]: true
        });
        return {
          nodeType: NodeTypes.ComponentApiConnector,
          groupProperties: {},
          parent: source,
          properties: {
            [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(ae)} Parameter`,
            ...viewPackages
          },
          callback: newNode => {
            context.apiEndPoints.push(newNode);
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ComponentApiConnector
            }
          },
          links: [args.connectToParameter ? args.connectToParameter(ae) : false, {
            target: ae.id,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.ComponentApiConnection
              }
            }
          }, skipOrTake ? {
            target: skipOrTake.id,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.ComponentApiConnection
              }
            }
          } : null, dataChain ? {
            target: typeof dataChain === 'function' ? dataChain() : dataChain.id,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.ComponentApiConnection
              }
            }
          } : null, selectorNode ? {
            target: typeof selectorNode === 'function' ? selectorNode() : selectorNode.id,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.ComponentApiConnection
              }
            }
          } : null].filter(x => x)
        };
      }

    };
  }), {
    operation: NO_OP,

    options(currentGraph) {
      if (args.callback) {
        args.callback(context, currentGraph);
      }
    }

  }];
  return [...result];
});
// CONCATENATED MODULE: ./app/actions/uiactions.js


/* eslint-disable default-case */

/* eslint-disable func-names */















const fs = __webpack_require__("fs");

const VISUAL = "VISUAL";
const MINIMIZED = "MINIMIZED";
const HIDDEN = "HIDDEN";
const APPLICATION = "APPLICATION";
const GRAPHS = "GRAPHS";
const VISUAL_GRAPH = "VISUAL_GRAPH";
const DASHBOARD_MENU = "DASHBOARD_MENU";
const SELECTED_NODE_BB = "SELECTED_NODE_BB";
const GROUPS_ENABLED = "GROUPS_ENABLED";
const SIDE_PANEL_EXTRA_WIDTH = "SIDE_PANEL_EXTRA_WIDTH";
const uiactions_NodeTypes = NodeTypes;
const uiactions_NodeTypeColors = NodeTypeColors;
const uiactions_NodeProperties = nodetypes_NodeProperties;
const uiactions_LinkProperties = nodetypes_LinkProperties;
const uiactions_NodeAttributePropertyTypes = NodeAttributePropertyTypes;
const uiactions_NodePropertyTypes = NodePropertyTypes;
const uiactions_ValidationRules = ValidationRules;
const uiactions_OptionsTypes = OptionsTypes;
const NODE_COST = "NODE_COST";
const NODE_CONNECTION_COST = "NODE_CONNECTION_COST";
const BATCH_MODEL = "BATCH_MODEL";
const BATCH_AGENT = "BATCH_AGENT";
const BATCH_PARENT = "BATCH_PARENT";
const BATCH_FUNCTION_NAME = "BATCH_FUNCTION_NAME";
const RECORDING = "RECORDING";
const BATCH_FUNCTION_TYPE = "BATCH_FUNCTION_TYPE"; // export const ViewTypes = {
//   Update: "Update",
//   Delete: "Delete",
//   Create: "Create",
//   Get: "Get",
//   GetAll: "GetAll"
// };

function GetScreenUrl(op, language = UITypes.ElectronIO, overrideText = null) {
  const params = GetComponentExternalApiNodes(op.id).filter(externaApiNodes => {
    return uiactions_GetNodeProp(externaApiNodes, uiactions_NodeProperties.IsUrlParameter);
  }).map(v => `:${GetCodeName(v)}`).join("/");
  const route = `${overrideText || uiactions_GetNodeProp(op, uiactions_NodeProperties.UIText)}${params ? `/${params}` : ""}`;
  return convertToURLRoute(route);
}
function convertToURLRoute(x) {
  return [...x.split(" ")].filter(x => x).join("/").toLowerCase();
}
const UI_UPDATE = "UI_UPDATE";
function GetC(state, section, item) {
  if (state && state.uiReducer && state.uiReducer[section]) {
    return state.uiReducer[section][item];
  }

  return null;
}
function Get(state, section) {
  if (state && state.uiReducer) {
    return state.uiReducer[section];
  }

  return null;
}
function generateDataSeed(node) {
  const dataSeed = _generateDataSeed(node);

  return JSON.stringify(dataSeed, null, 4);
}

function _generateDataSeed(node) {
  const state = _getState();

  const properties = {};
  getPropertyNodes(GetRootGraph(state), node.id).map(t => {
    properties[t.id] = {
      name: GetCodeName(t),
      jsName: GetCodeName(t).toJavascriptName(),
      type: uiactions_GetNodeProp(t, uiactions_NodeProperties.DataGenerationType)
    };
  });
  GetLogicalChildren(node.id).map(t => {
    properties[t.id] = {
      name: GetCodeName(t),
      jsName: GetCodeName(t).toJavascriptName(),
      type: "Id"
    };
  });
  const dataSeed = {
    name: GetCodeName(node),
    properties
  };
  return dataSeed;
}

function generateDataSeeds() {
  return JSON.stringify(uiactions_NodesByType(_getState(), uiactions_NodeTypes.Model).map(t => _generateDataSeed(t)));
}
function Visual(state, key) {
  return GetC(state, VISUAL, key);
}
function ChoseModel(id) {
  return `choson model ${id}`;
}
function Minimized(state, key) {
  if (!key) {
    return Get(state, MINIMIZED);
  }

  return GetC(state, MINIMIZED, key);
}
function Hidden(state, key) {
  if (!key) {
    return Get(state, HIDDEN);
  }

  return GetC(state, HIDDEN, key);
}
function CopyKey(key) {
  return `Copy ${key}`;
}
function IsCurrentNodeA(state, type) {
  const currentNode = Node(state, Visual(state, SELECTED_NODE));

  if (!Array.isArray(type)) {
    type = [type];
  }

  return currentNode && currentNode.properties && type.some(v => v === currentNode.properties.nodeType);
}
function Use(node, prop) {
  return node && node.properties && node.properties[prop];
}
function uiactions_GetManyToManyNodes(ids) {
  return GetManyToManyNodes(GetCurrentGraph(_getState()), ids) || [];
}
function uiactions_GetNodeProp(node, prop, currentGraph) {
  if (typeof node === "string") {
    node = GetNodeById(node, currentGraph) || node;
  }

  return node && node.properties && node.properties[prop];
}
function GetNodeType(node, graph) {
  return uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType, graph);
}
function GetNodePropDirty(node, prop, currentGraph) {
  if (typeof node === "string") {
    node = GetNodeById(node, currentGraph) || node;
  }

  return node && node.dirty && node.dirty[prop];
}
function GetGroupProp(id, prop) {
  const group = GetGroup(GetCurrentGraph(_getState()), id);

  if (group) {
    return group && group.properties && group.properties[prop];
  }

  return null;
}
function GetSharedComponentFor(viewType, modelProperty, currentNodeId, isSharedProperty) {
  const graph = GetCurrentGraph(GetState());
  let viewTypeNodes = GetNodesLinkedTo(graph, {
    id: modelProperty.id
  });
  let isPluralComponent;
  const propertyNode = GetNodeById(modelProperty.id);

  if (propertyNode && uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Model) {
    isPluralComponent = true;
  }

  if (isSharedProperty) {
    viewType = isPluralComponent ? viewtypes_ViewTypes.GetAll : viewtypes_ViewTypes.Get;
  }

  viewTypeNodes = viewTypeNodes.filter(x => {
    let result = uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ViewType;
    result = result && !!uiactions_GetNodeProp(x, uiactions_NodeProperties.IsPluralComponent) === !!isPluralComponent;
    return result;
  });
  viewTypeNodes = viewTypeNodes.find(x => {
    if (existsLinkBetween(graph, {
      source: x.id,
      target: currentNodeId,
      type: nodetypes_LinkType.DefaultViewType
    })) {
      const link = findLink(graph, {
        source: x.id,
        target: currentNodeId
      });

      if (GetLinkProperty(link, LinkPropertyKeys.ViewType) === viewType) {
        return true;
      }
    }

    return false;
  });

  if (viewTypeNodes) {
    return viewTypeNodes.id;
  }

  switch (viewType) {
    case viewtypes_ViewTypes.Get:
      return uiactions_GetNodeProp(modelProperty, uiactions_NodeProperties.DefaultViewTypeGet);

    case viewtypes_ViewTypes.Create:
      return uiactions_GetNodeProp(modelProperty, uiactions_NodeProperties.DefaultViewTypeCreate);

    case viewtypes_ViewTypes.Delete:
      return uiactions_GetNodeProp(modelProperty, uiactions_NodeProperties.DefaultViewTypeDelete);

    case viewtypes_ViewTypes.GetAll:
      return uiactions_GetNodeProp(modelProperty, uiactions_NodeProperties.DefaultViewTypeGetAll);

    case viewtypes_ViewTypes.Update:
      return uiactions_GetNodeProp(modelProperty, uiactions_NodeProperties.DefaultViewTypeUpdate);
  }
}
function getViewTypeEndpointsForDefaults(viewType, currentGraph, id) {
  currentGraph = currentGraph || GetCurrentGraph(_getState());
  const currentNode = GetNodeById(id, currentGraph);
  const connectto = GetNodesByProperties({
    [uiactions_NodeProperties.NODEType]: uiactions_NodeTypes.ViewType,
    [uiactions_NodeProperties.ViewType]: viewType
  }, currentGraph).filter(_x => {
    const res = existsLinkBetween(currentGraph, {
      source: _x.id,
      type: nodetypes_LinkType.DefaultViewType,
      target: currentNode.id
    });

    if (res) {
      const link = GetLinkBetween(_x.id, currentNode.id, currentGraph);

      if (link && link.properties && link.properties.target === currentNode.id) {
        return true;
      }
    }

    return false;
  });
  return connectto;
}
function setSharedComponent(args) {
  const {
    properties,
    target,
    source,
    viewType,
    uiType,
    isPluralComponent
  } = args;
  return (dispatch, getState) => {
    const state = getState();
    const graph = GetCurrentGraph(getState());

    if (!existsLinkBetween(graph, {
      target,
      source,
      type: nodetypes_LinkType.SharedComponent,
      properties: {
        viewType
      }
    }) && uiactions_GetNodeProp(target, uiactions_NodeProperties.SharedComponent) && uiactions_GetNodeProp(target, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentNode) {
      const connections = GetConnectedNodesByType(state, source, uiactions_NodeTypes.ComponentNode).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.ViewType) === viewType).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.UIType) === uiType).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsPluralComponent) === isPluralComponent).map(x => {
        return {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            source,
            target: x.id
          }
        };
      });
      PerformGraphOperation([...connections, {
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: {
          source,
          target,
          properties: { ...properties
          }
        }
      }])(dispatch, getState);
    }
  };
}
function setComponentApiConnection(args) {
  const {
    properties,
    target,
    source
  } = args;
  return (dispatch, getState) => {
    const state = getState();
    const graph = GetCurrentGraph(state);

    if ([uiactions_NodeTypes.EventMethod, uiactions_NodeTypes.LifeCylceMethod, uiactions_NodeTypes.MethodApiParameters, uiactions_NodeTypes.DataChain, uiactions_NodeTypes.Selector].some(t => t === uiactions_GetNodeProp(target, uiactions_NodeProperties.NODEType))) {
      if (!existsLinkBetween(graph, {
        target,
        source,
        type: nodetypes_LinkType.ComponentApiConnection
      })) {
        const connections = GetConnectedNodesByType(state, source, uiactions_GetNodeProp(target, uiactions_NodeProperties.NODEType)).map(x => {
          return {
            operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
            options: {
              source,
              target: x.id
            }
          };
        });
        PerformGraphOperation([...connections, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            source,
            target,
            properties: { ...properties
            }
          }
        }])(dispatch, getState);
      }
    }
  };
}
function addQueryMethodParameter() {
  return (dispatch, getState) => {
    const state = getState();
    const graph = GetCurrentGraph(state);
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const operations = [];
    operations.push({
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: uiactions_NodeTypes.MethodApiParameters,
          properties: {
            [uiactions_NodeProperties.UIText]: "Query Parameter",
            [uiactions_NodeProperties.QueryParameterParam]: true
          },
          parent: currentNode.id,
          groupProperties: {},
          linkProperties: {
            properties: { ...uiactions_LinkProperties.MethodApiParameters,
              params: true,
              query: true
            }
          }
        };
      }

    });
    PerformGraphOperation(operations)(dispatch, getState);
  };
}
function addQueryMethodApi() {
  return (dispatch, getState) => {
    const state = getState();
    const graph = GetCurrentGraph(state);
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const queryObjects = GetConnectedNodesByType(state, currentNode.id, uiactions_NodeTypes.MethodApiParameters).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.QueryParameterObject));

    if (queryObjects.length === 0) {
      const operations = [];
      operations.push({
        operation: ADD_NEW_NODE,

        options() {
          return {
            nodeType: uiactions_NodeTypes.MethodApiParameters,
            properties: {
              [uiactions_NodeProperties.UIText]: "Query",
              [uiactions_NodeProperties.QueryParameterObject]: true,
              [uiactions_NodeProperties.QueryParameterObjectExtendible]: true
            },
            links: [{
              target: currentNode.id,
              linkProperties: {
                properties: { ...uiactions_LinkProperties.MethodApiParameters,
                  params: true,
                  query: true
                }
              }
            }]
          };
        }

      });
      PerformGraphOperation(operations)(dispatch, getState);
    }
  };
}
function connectLifeCycleMethod(args) {
  const {
    properties,
    target,
    source
  } = args;
  return (dispatch, getState) => {
    setTimeout(() => {
      const state = getState();
      const graph = GetCurrentGraph(state);
      graphOperation(ConnectLifecycleMethod({
        target,
        source,
        graph
      }))(dispatch, getState);
    }, 100);
  };
}
function addComponentEventTo(node, apiName) {
  return (dispatch, getState) => {
    graphOperation([ComponentEventTo(node, apiName)])(dispatch, getState);
  };
}
function ComponentEventTo(node, apiName, callback) {
  return {
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: uiactions_NodeTypes.EventMethod,
        callback,
        properties: {
          [uiactions_NodeProperties.EventType]: apiName,
          [uiactions_NodeProperties.UIText]: `${apiName}`
        },
        links: [{
          target: node,
          linkProperties: {
            properties: { ...uiactions_LinkProperties.EventMethod
            }
          }
        }]
      };
    }

  };
}
function GetTitleService(graph) {
  graph = GetCurrentGraph();
  return uiactions_NodesByType(GetState(), uiactions_NodeTypes.TitleService).find(x => x);
}
function AgentHasExecutor(model) {
  const state = GetState();
  const graphRoot = GetCurrentGraph();
  return uiactions_NodesByType(state, uiactions_NodeTypes.Executor).find(x => existsLinkBetween(graphRoot, {
    source: x.id,
    target: model.id
  }));
}
function setupDefaultViewType(args) {
  const {
    properties,
    target,
    source
  } = args;
  return (dispatch, getState) => {
    const graph = GetCurrentGraph(getState());
    let is_property_link = false;

    if (existsLinkBetween(graph, {
      target,
      source,
      type: nodetypes_LinkType.ModelTypeLink
    })) {
      const isUsedAsModelType = uiactions_GetNodeProp(source, uiactions_NodeProperties.UseModelAsType);

      if (isUsedAsModelType) {
        const targetedTypeNode = uiactions_GetNodeProp(source, uiactions_NodeProperties.UIModelType);

        if (targetedTypeNode === target) {
          is_property_link = true;
        }
      }
    }

    const right_link = is_property_link || existsLinkBetween(graph, {
      target,
      source,
      type: nodetypes_LinkType.LogicalChildren
    });

    if (right_link) {
      const useModelAsType = uiactions_GetNodeProp(target, uiactions_NodeProperties.UseModelAsType);
      const illegalViewType = false; // useModelAsType ? ViewTypes.GetAll : ViewTypes.Get;

      if (properties.all) {
        PerformGraphOperation(Object.keys(viewtypes_ViewTypes).filter(x => x !== illegalViewType).map(viewType => {
          const sibling = uuidv4();
          return {
            operation: ADD_NEW_NODE,

            options() {
              return {
                nodeType: uiactions_NodeTypes.ViewType,
                properties: {
                  [uiactions_NodeProperties.ViewType]: viewType,
                  [uiactions_NodeProperties.UIText]: `[${viewType}] ${GetNodeTitle(target)} => ${GetNodeTitle(source)}`
                },
                ...(useModelAsType ? {
                  parent: target,
                  groupProperties: {}
                } : {}),
                links: [{
                  target: target,
                  linkProperties: {
                    properties: { ...properties,
                      viewType,
                      sibling,
                      target: target
                    }
                  }
                }, {
                  target: source,
                  linkProperties: {
                    properties: { ...properties,
                      viewType,
                      sibling,
                      source: source
                    }
                  }
                }]
              };
            }

          };
        }))(dispatch, getState);
      } else {
        if (illegalViewType !== properties.viewType) {
          PerformGraphOperation([{
            operation: ADD_NEW_NODE,

            options() {
              return {
                nodeType: uiactions_NodeTypes.ViewType,
                properties: {
                  [uiactions_NodeProperties.UIText]: `[${properties.viewType}] ${GetNodeTitle(target)}:${GetNodeTitle(source)}`
                },
                links: [{
                  target: target,
                  linkProperties: {
                    properties: { ...properties,
                      sibling
                    }
                  }
                }, {
                  target: source,
                  linkProperties: {
                    properties: { ...properties,
                      sibling
                    }
                  }
                }]
              };
            }

          }])(dispatch, getState);
        }
      }
    }
  };
}
function uiactions_GetConditionNodes(id) {
  const state = _getState();

  return GetConditionNodes(state, id);
}
function uiactions_IsAgent(node) {
  return uiactions_GetNodeProp(node, uiactions_NodeProperties.IsAgent);
}
function uiactions_GetLinkChainItem(options) {
  return GetLinkChainItem(GetState(), options);
}
function GetCodeName(node, options) {
  const graph = GetCurrentGraph(GetState());

  if (typeof node === "string") {
    node = GetNode(graph, node);
  }

  if (options && options.includeNameSpace) {
    if (uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.DataChain) {
      const collections = GetNodesLinkedTo(graph, {
        id: node.id,
        link: nodetypes_LinkType.DataChainCollection,
        direction: SOURCE
      });

      if (collections && collections.length) {
        return `${computeNamespace(collections[0])}.${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}`;
      }
    }
  }

  return uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName);
}
function GetRelativeDataChainPath(node) {
  const graph = GetCurrentGraph();
  const collections = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.DataChainCollection,
    direction: SOURCE
  });

  if (collections && collections.length) {
    return [...GetRelativeDataChainPath(collections[0]), GetJSCodeName(node)];
  }

  return [GetJSCodeName(node)];
}
function computeNamespace(node) {
  const graph = GetCurrentGraph(GetState());
  const dc = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.DataChainCollection,
    direction: SOURCE
  });

  if (dc && dc.length) {
    const namesp = computeNamespace(dc[0]);

    if (namesp) {
      return `${namesp}.${GetJSCodeName(node)}`;
    }
  }

  return `${GetJSCodeName(node)}`;
}
function GetJSCodeName(node) {
  const l = GetCodeName(node);

  if (l) {
    return l.toJavascriptName();
  }

  return l;
}
function GetModelPropertyChildren(id, options = {}) {
  const {
    skipLogicalChildren
  } = options;
  const propertyNodes = GetModelPropertyNodes(id);
  const logicalChildren = skipLogicalChildren ? [] : GetLogicalChildren(id);
  let userModels = [];

  if (uiactions_GetNodeProp(id, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Model || uiactions_GetNodeProp(id, uiactions_NodeProperties.IsUser)) {
    userModels = GetUserReferenceNodes(id);
  }

  return [...userModels, ...propertyNodes, ...logicalChildren].filter(x => x.id !== id).unique(v => v.id);
}
function GetMethodParameters(methodId) {
  const method = GetNodeById(methodId);

  if (method) {
    const methodType = uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);

    if (methodType && MethodFunctions[methodType]) {
      const {
        parameters
      } = MethodFunctions[methodType];

      if (parameters) {
        return parameters;
      }
    }
  }

  return null;
}
function updateMethodParameters(current, methodType, viewPackages) {
  return (dispatch, getState) => {
    const state = getState();
    const graph = GetRootGraph(state);
    const toRemove = [];
    graphOperation(UpdateMethodParameters({
      methodType,
      current,
      viewPackages
    }))(dispatch, getState);
  };
}
function Connect(source, target, linkProperties) {
  return {
    target,
    source,
    properties: { ...(linkProperties || {})
    }
  };
}
function attachMethodToMaestro(methodNodeId, modelId, options, viewPackage) {
  return (dispatch, getState) => {
    let controller = false;
    let maestro = false;

    if (options && options.maestro) {
      PerformGraphOperation([{
        operation: uiactions_ADD_LINK_BETWEEN_NODES,

        options(graph) {
          return {
            source: options.maestro,
            target: methodNodeId,
            properties: { ...uiactions_LinkProperties.FunctionLink
            }
          };
        }

      }])(dispatch, getState);
      return;
    }

    PerformGraphOperation([{
      operation: ADD_NEW_NODE,

      options(graph) {
        const state = getState();

        const _controller = uiactions_NodesByType(state, uiactions_NodeTypes.Controller).find(x => {
          return existsLinkBetween(graph, {
            target: modelId,
            source: x.id,
            link: nodetypes_LinkType.ModelTypeLink
          });
        });

        if (!_controller) {
          return {
            nodeType: uiactions_NodeTypes.Controller,
            properties: { ...(viewPackage || {}),
              [uiactions_NodeProperties.UIText]: `${GetNodeTitle(modelId)} Controller`
            },
            links: [{
              target: modelId,
              properties: { ...uiactions_LinkProperties.ModelTypeLink
              }
            }],
            callback: _controller => {
              controller = _controller;
            }
          };
        }

        controller = _controller;
      }

    }, {
      operation: CHANGE_NODE_PROPERTY,

      options(graph) {
        return {
          id: controller.id,
          value: "systemUser",
          prop: uiactions_NodeProperties.CodeUser
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options(graph) {
        const state = getState();

        const _maestro = uiactions_NodesByType(state, uiactions_NodeTypes.Maestro).find(x => {
          return existsLinkBetween(graph, {
            target: modelId,
            source: x.id,
            link: nodetypes_LinkType.ModelTypeLink
          });
        });

        if (!_maestro) {
          return {
            nodeType: uiactions_NodeTypes.Maestro,
            properties: { ...(viewPackage || {}),
              [uiactions_NodeProperties.UIText]: `${GetNodeTitle(modelId)} Maestro`
            },
            links: [{
              target: modelId,
              properties: { ...uiactions_LinkProperties.ModelTypeLink
              }
            }],
            callback: _maestro => {
              maestro = _maestro;
            }
          };
        }

        maestro = _maestro;
      }

    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options(graph) {
        return {
          source: controller.id,
          target: maestro.id,
          properties: { ...uiactions_LinkProperties.MaestroLink
          }
        };
      }

    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options(graph) {
        return {
          source: maestro.id,
          target: methodNodeId,
          properties: { ...uiactions_LinkProperties.FunctionLink
          }
        };
      }

    }])(dispatch, getState);
  };
}
function GetMethodParametersFor(methodId, type) {
  const method = GetNodeById(methodId);

  if (method) {
    const methodType = uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);

    if (methodType && MethodFunctions[methodType]) {
      const {
        permission,
        validation
      } = MethodFunctions[methodType];

      switch (type) {
        case uiactions_NodeTypes.Permission:
          return permission ? permission.params : null;

        case uiactions_NodeTypes.Validator:
          return validation ? validation.params : null;
      }
    }
  }

  return null;
}
function GetNodeById(node, graph) {
  return GetNode(graph || GetCurrentGraph(GetState()), node);
}
function GetNodesByProperties(props, graph, state) {
  const currentGraph = graph || GetCurrentGraph(state || GetState());

  if (currentGraph) {
    return [...currentGraph.nodes.map(t => currentGraph.nodeLib[t])].filter(x => {
      for (const i in props) {
        if (props[i] !== uiactions_GetNodeProp(x, i)) {
          return false;
        }
      }

      return true;
    });
  }

  return [];
}
function GetNodeByProperties(props, graph, state) {
  return GetNodesByProperties(props, graph, state).find(x => x);
}
function uiactions_GetChildComponentAncestors(id) {
  return GetChildComponentAncestors(_getState(), id);
}
function GetMethodDefinition(id) {
  return MethodFunctions[GetMethodFunctionType(id)];
}
function GetMethodFunctionType(id) {
  const state = _getState();

  const method = GetMethodNode(state, id);
  return uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);
}
function GetMethodFunctionValidation(id) {
  const state = _getState();

  const method = GetMethodNode(state, id);
  return uiactions_GetNodeProp(method, uiactions_NodeProperties.MethodFunctionValidation);
}
function uiactions_GetPermissionNode(id) {
  const state = _getState();

  return GetPermissionNode(state, id);
}
function uiactions_GetValidationNode(id) {
  const state = _getState();

  return GetValidationNode(state, id);
}
function uiactions_GetDataSourceNode(id) {
  const state = _getState();

  return GetDataSourceNode(state, id);
}
function uiactions_GetModelItemFilter(id) {
  const state = _getState();

  return GetModelItemFilter(state, id);
}
function GetPermissionsConditions(id) {
  return _getPermissionsConditions(_getState(), id);
}
function GetServiceInterfaceMethodCalls(id) {
  const state = GetState();
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ServiceInterfaceMethod);
}
function GetServiceInterfaceCalls(id) {
  const state = GetState();
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ServiceInterface);
}
function GetValidationsConditions(id) {
  return _getValidationConditions(_getState(), id);
}
function GetModelItemConditions(id) {
  return _getValidationConditions(_getState(), id);
}
function GetConditionSetup(condition) {
  return uiactions_GetNodeProp(condition, uiactions_NodeProperties.Condition);
}
function uiactions_GetDataChainEntryNodes(cs) {
  return GetDataChainEntryNodes(_getState(), cs);
}
function GetLambdaDefinition(method) {
  const functionType = uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);
  const {
    lambda
  } = MethodFunctions[functionType];
  return lambda;
}
function GenerateDataChainArguments(id) {
  const currentNode = GetNodeById(id);
  let _arguments = "";

  if (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.CS)) {
    const methods = GetNodesLinkedTo(null, {
      id: currentNode.id,
      link: nodetypes_LinkType.DataChainLink,
      componentType: uiactions_NodeTypes.Method
    });

    if (methods.length) {
      const functionType = uiactions_GetNodeProp(methods[0], uiactions_NodeProperties.FunctionType);
      const {
        lambda
      } = MethodFunctions[functionType];

      if (lambda && lambda.default) {
        const methodProps = GetMethodProps(methods[0]);
        _arguments = Object.keys(lambda.default).filter(x => x !== "return").map(key => {
          return `${key.split(".").join("")}:${key} `;
        }).join(", ");
      }
    }
  }

  return _arguments;
}
function GenerateCSChainFunction(id) {
  const lastNodeName = GenerateCDDataChainMethod(id);
  const arbiters = GetArbitersInCSDataChainMethod(id);
  const outputType = GetOutputTypeInCSDataChainMethod(id);
  const arbiterInterfaces = arbiters.map(arb => `IRedArbiter<${GetCodeName(arb)}> _arbiter${GetCodeName(arb)}`).join(", ");
  const arbiterSets = addNewLine(arbiters.map(arb => `arbiter${GetCodeName(arb)} = _arbiter${GetCodeName(arb)};`).join(nodetypes_NEW_LINE));
  const arbiterProperties = arbiters.map(arb => `IRedArbiter<${GetCodeName(arb)}> arbiter${GetCodeName(arb)};`).join(nodetypes_NEW_LINE);
  const currentNode = GetNodeById(id);
  let _arguments = "";

  if (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.CS)) {
    const methods = GetNodesLinkedTo(null, {
      id: currentNode.id,
      link: nodetypes_LinkType.DataChainLink,
      componentType: uiactions_NodeTypes.Method
    });

    if (methods.length) {
      const functionType = uiactions_GetNodeProp(methods[0], uiactions_NodeProperties.FunctionType);
      const {
        lambda
      } = MethodFunctions[functionType];

      if (lambda && lambda.default) {
        const methodProps = GetMethodProps(methods[0]);
        _arguments = Object.keys(lambda.default).filter(x => x !== "return").map(key => {
          return `${GetCodeName(methodProps[lambda.default[key]]) || lambda.default[key]} ${key.split(".").join("")}`;
        }).join(", ");
      }
    }
  }

  const method = `public class ${GetCodeName(id)}
{
${arbiterProperties}
    public ${GetCodeName(id)}(${arbiterInterfaces}) {
${arbiterSets}
    }
    public async Task<${GetCodeName(outputType)}> Execute(${_arguments}) {
      ${lastNodeName}
    }
}`;
  return method;
}
function GenerateChainFunction(id, cs) {
  const chain = GetDataChainParts(id);
  let args = null;
  const observables = [];
  const setArgs = [];
  const subscribes = [];
  const setProcess = [];
  const funcs = chain.map((c, index) => {
    if (index === 0) {
      args = GetDataChainArgs(c);
    }

    const temp = GenerateDataChainMethod(c);
    observables.push(GenerateObservable(c, index));
    setArgs.push(GenerateArgs(c, chain));
    setProcess.push(GenerateSetProcess(c, chain));
    subscribes.push(GetSubscribes(c, chain));
    return temp;
  });
  const index = chain.indexOf(id);
  const nodeName = (GetJSCodeName(id) || "node" + index).toJavascriptName();
  const lastLink = GetLastChainLink(chain);
  const lastLinkindex = chain.indexOf(lastLink);
  const lastNodeName = (GetJSCodeName(lastLink) || "node" + lastLinkindex).toJavascriptName();
  const method = `export function  ${GetCodeName(id)}(${args.join()}) {
${observables.join(nodetypes_NEW_LINE)}
${setArgs.join(nodetypes_NEW_LINE)}
${setProcess.join(nodetypes_NEW_LINE)}
${subscribes.join(nodetypes_NEW_LINE)}
${nodeName}.update($id , '$id');

return ${lastNodeName}.value;
}`;
  return method;
}
function GenerateSetProcess(id, parts) {
  const index = parts.indexOf(id);
  const nodeName = (GetJSCodeName(id) || "node" + index).toJavascriptName();
  return `${nodeName}.setProcess(${GenerateDataChainMethod(id)})`;
}
function GetSubscribes(id, parts) {
  const node = GetNodeById(id);
  const index = parts.indexOf(id);
  const nodeName = (GetJSCodeName(id) || "node" + index).toJavascriptName();
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);

  if (functionType && DataChainFunctions[functionType] && DataChainFunctions[functionType].merge) {
    // pulls args from other nodes
    const args = Object.keys(DataChainFunctions[functionType].ui).map((key, kindex) => {
      const temp = uiactions_GetNodeProp(node, DataChainFunctions[functionType].ui[key]);
      return `${(GetJSCodeName(temp) || "node" + parts.indexOf(temp)).toJavascriptName()}`;
    });

    if (args && args.length) {
      return `${args.map(v => `${v}.subscribe(${nodeName});
`).join("")}`;
    }
  } else {
    const parent = uiactions_GetNodeProp(node, uiactions_NodeProperties.ChainParent);

    if (parent) {
      return `${GetJSCodeName(parent).toJavascriptName()}.subscribe(${nodeName})`;
    }
  }

  return "";
}
function GenerateArgs(id, parts) {
  const node = GetNodeById(id);
  const index = parts.indexOf(id);
  const nodeName = (GetJSCodeName(id) || "node" + index).toJavascriptName();
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);

  if (functionType && DataChainFunctions[functionType] && DataChainFunctions[functionType].merge) {
    // pulls args from other nodes
    const args = Object.keys(DataChainFunctions[functionType].ui).map((key, kindex) => {
      const temp = uiactions_GetNodeProp(node, DataChainFunctions[functionType].ui[key]);
      return `['${(GetJSCodeName(temp) || "node" + parts.indexOf(temp)).toJavascriptName()}']: ${kindex}`;
    });
    return `${nodeName}.setArgs({ ${args} })`;
  }

  const parent = uiactions_GetNodeProp(node, uiactions_NodeProperties.ChainParent);

  if (parent) {
    return `${nodeName}.setArgs({ ['${GetJSCodeName(parent).toJavascriptName()}']: 0 })`;
  }

  return `${nodeName}.setArgs({ $id: 0 })`;
  return "";
}
function GetLastChainLink(parts) {
  const lastLink = parts.find(id => {
    return uiactions_GetNodeProp(GetNodeById(id), uiactions_NodeProperties.AsOutput);
  });
  return lastLink;
}
function GenerateObservable(id, index) {
  const nodeName = GetJSCodeName(id);
  return `let ${nodeName} = new RedObservable('${nodeName}');`;
}
function GenerateDataChainFunc(id, chain, index) {
  const nodeName = GetCodeName(id); //Should be able to capture the args throw the link between nodes.

  return `private async Task ${nodeName}(/*define args*/) {
    throw new NotImplementedException();
  }`;
}
function GetDataChainArgs(id) {
  const node = GetNodeById(id);
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);

  if (functionType && DataChainFunctions[functionType]) {
    const {
      merge,
      ui
    } = DataChainFunctions[functionType];

    if (merge) {
      return Object.keys(ui);
    }

    return ["$id"];
  }

  return [];
}
function GenerateChainFunctions(options) {
  const {
    cs,
    language,
    collection
  } = options;
  const graph = GetCurrentGraph();
  const entryNodes = uiactions_GetDataChainEntryNodes(cs).filter(x => {
    const uiType = uiactions_GetNodeProp(x, uiactions_NodeProperties.UIType);

    if (uiType) {
      return language === uiType;
    }

    return true;
  }).map(x => x.id).filter(ct => {
    const collections = GetNodesLinkedTo(graph, {
      id: ct,
      link: nodetypes_LinkType.DataChainCollection
    });

    if (collection) {
      return collections.find(v => v.id === collection);
    }

    return !collections || !collections.length;
  });
  const temp = entryNodes.map(v => cs ? {
    node: v,
    class: GenerateCSChainFunction(v)
  } : GenerateChainFunction(v)).unique(x => x); // sorry this is bad.

  if (cs) {
    return temp;
  }

  return temp.join(nodetypes_NEW_LINE);
}
function CollectionIsInLanguage(graph, collection, language) {
  const uiTypeOfCollection = uiactions_GetNodeProp(collection, uiactions_NodeProperties.UIType);

  if (uiTypeOfCollection && uiTypeOfCollection === language) {
    return true;
  }

  if (uiTypeOfCollection) {
    return false;
  }

  const reference = GetNodeLinkedTo(graph, {
    id: collection,
    link: nodetypes_LinkType.DataChainCollectionReference
  });

  if (reference) {
    if (uiactions_GetNodeProp(reference, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Screen) {
      return true;
    }

    if (uiactions_GetNodeProp(reference, uiactions_NodeProperties.UIType) === language) {
      return true;
    }

    if (uiactions_GetNodeProp(reference, uiactions_NodeProperties.UIType)) {
      return false;
    }

    const parent = GetNodesLinkedTo(graph, {
      id: collection,
      link: nodetypes_LinkType.DataChainCollection,
      direction: graph_methods_TARGET
    }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.DataChainCollection)[0];

    if (parent) {
      return CollectionIsInLanguage(graph, parent.id, language);
    }
  } else {
    return true;
  }

  return true;
}
function GetDataChainCollections(options) {
  const {
    collection,
    language
  } = options;
  const graph = GetCurrentGraph();
  const temp = collection ? GetNodesLinkedTo(GetCurrentGraph(), {
    id: collection,
    link: nodetypes_LinkType.DataChainCollection,
    direction: graph_methods_TARGET
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.DataChainCollection && CollectionIsInLanguage(graph, x.id, language)) : [];
  return uiactions_NodesByType(null, uiactions_NodeTypes.DataChainCollection).filter(x => {
    if (collection) {
      const res = temp.some(v => v.id === x.id);

      if (res) {
        return true;
      }

      return false;
    } ///only reference the top levels in data-chain.js


    return GetNodesLinkedTo(GetCurrentGraph(), {
      id: x.id,
      link: nodetypes_LinkType.DataChainCollection,
      direction: SOURCE
    }).filter(dcc => uiactions_GetNodeProp(dcc, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.DataChainCollection).length === 0 && CollectionIsInLanguage(graph, x.id, language);
  }).map(dataChainCollection => {
    const _path = GetRelativeDataChainPath(dataChainCollection);

    return `export * as ${GetJSCodeName(dataChainCollection)} from './${collection ? "" : `datachains/`}${[..._path, GetJSCodeName(dataChainCollection)].subset(_path.length - 1).join("/")}';`;
  }).unique().join(nodetypes_NEW_LINE);
}
function GetComponentExternalApiNode(api, parent, graph) {
  graph = graph || GetCurrentGraph();
  return GetNodesLinkedTo(graph, {
    id: parent,
    link: nodetypes_LinkType.ComponentExternalApi
  }).find(v => GetNodeTitle(v) === api);
}
function GetComponentApiNode(api, parent, graph) {
  graph = graph || GetCurrentGraph();
  return GetNodesLinkedTo(graph, {
    id: parent,
    link: nodetypes_LinkType.ComponentInternalApi
  }).find(v => GetNodeTitle(v) === api);
}
function GetComponentExternalApiNodes(parent, graph) {
  graph = graph || GetCurrentGraph();
  return GetNodesLinkedTo(graph, {
    id: parent,
    link: nodetypes_LinkType.ComponentExternalApi
  });
}
function GetNodeMethodCall(id, graph) {
  graph = graph || GetCurrentGraph();
  return GetNodesLinkedTo(graph, {
    id,
    link: nodetypes_LinkType.MethodCall
  }).find(v => v);
}
function GetComponentInternalApiNode(api, parent, graph) {
  graph = graph || GetCurrentGraph();
  return GetNodesLinkedTo(graph, {
    id: parent,
    link: nodetypes_LinkType.ComponentInternalApi
  }).find(v => GetNodeTitle(v) === api);
}
function GenerateChainFunctionSpecs(options) {
  const {
    language,
    collection
  } = options;
  const result = [];
  const graph = GetCurrentGraph();
  const entryNodes = uiactions_GetDataChainEntryNodes().filter(x => {
    const uiType = uiactions_GetNodeProp(x, uiactions_NodeProperties.UIType);

    if (uiType) {
      return language === uiType;
    }

    return true;
  }).map(x => x.id).filter(ct => {
    const collections = GetNodesLinkedTo(graph, {
      id: ct,
      link: nodetypes_LinkType.DataChainCollection
    });

    if (collection) {
      return collections.find(v => v.id === collection);
    }

    return !collections || !collections.length;
  });
  const basicentryvalues = [undefined, null, 0, {}, "a string", 1.1, [], [1], ["1"], ["1", 1]];
  entryNodes.map(entryNode => {
    basicentryvalues.map(val => {
      result.push(GenerateSimpleTest(entryNode, val));
    });
  });
  return result;
}
function GenerateSimpleTest(node, val) {
  let _value = ["object", "string"].some(v => typeof val === v && val !== undefined && val !== null) ? JSON.stringify(val) : val;

  if (val === undefined) {
    _value = "undefined";
  } else if (val === null) {
    _value = "null";
  }

  const template = `it('${GetCodeName(node)} - should be able to handle a "${typeof val === "object" ? JSON.stringify(val) : val}"', () => {
    let error = undefined;
    try {
        DC.${GetCodeName(node, {
    includeNameSpace: true
  })}(${_value});
    }
    catch(e) {
        error = e;
        console.error(e);
    }
    expect(error === undefined).toBeTruthy(error);
})`;
  return template;
}
function GetDataChainNext(id, graph) {
  graph = graph || GetRootGraph(_getState());

  if (!graph) {
    throw "no graph found";
  }

  const current = id;
  const groupDaa = uiactions_GetNodeProp(GetNodeById(current), uiactions_NodeProperties.Groups);

  if (groupDaa && groupDaa.group) {
    const group = GetGroup(graph, groupDaa.group);

    if (group) {
      const entryNode = GetGroupProp(group.id, GroupProperties.GroupEntryNode);

      if (entryNode === current) {
        const exitNode = GetGroupProp(group.id, GroupProperties.ExternalExitNode);
        return GetNodeById(exitNode);
      }
    }
  }

  const next = getNodesByLinkType(graph, {
    id: current,
    type: nodetypes_LinkType.DataChainLink,
    direction: SOURCE
  }).filter(x => x.id !== current).sort((a, b) => {
    const a_ = uiactions_GetNodeProp(a, uiactions_NodeProperties.ChainParent) ? 1 : 0;
    const b_ = uiactions_GetNodeProp(b, uiactions_NodeProperties.ChainParent) ? 1 : 0;
    return a_ - b_;
  }).unique(x => x.id)[0];
  return next;
}
function GetDataChainNextId(id, graph) {
  const next = GetDataChainNext(id, graph);
  return next && next.id;
}
function GetDataChainParts(id, result) {
  result = result || [id];
  result.push(id);
  result = [...result].unique();
  const node = GetNodeById(id);
  const nodeGroup = uiactions_GetNodeProp(node, uiactions_NodeProperties.Groups) || {};
  let groups = Object.values(nodeGroup);
  const current = id;
  const dataChains = uiactions_NodesByType(_getState(), uiactions_NodeTypes.DataChain);
  let oldlength;

  do {
    oldlength = result.length;
    const dc = dataChains.filter(x => result.some(v => v === uiactions_GetNodeProp(x, uiactions_NodeProperties.ChainParent)));
    result.push(...dc.map(v => v.id));
    dc.map(_dc => {
      groups = [...groups, ...Object.values(uiactions_GetNodeProp(_dc, uiactions_NodeProperties.Groups) || {})];
    });
    groups.map(g => {
      const nodes = uiactions_GetNodesInGroup(g);
      result.push(...nodes);
    });
    result = result.unique();
  } while (result.length !== oldlength);

  return result;
}
function uiactions_GetNodesInGroup(groupId) {
  return GetNodesInGroup(GetCurrentGraph(_getState()), groupId);
}
function GetDataChainFrom(id) {
  const result = [id];
  let current = id;
  const graph = GetRootGraph(_getState());

  if (!graph) {
    throw "no graph found";
  }

  for (let i = 0; i < 10; i++) {
    const next = GetDataChainNext(current);
    current = null;

    if (next && next.id) {
      result.push(next.id);
      current = next.id;
    } else {
      break;
    }
  }

  return result;
}
function uiactions_getGroup(id, graph) {
  // return graph.groupLib[id];
  return getGroup(graph || GetCurrentGraph(_getState()), id);
}
function uiactions_hasGroup(id, graph) {
  //    return !!(graph.nodeLib[parent] && GetNodeProp(graph.nodeLib[parent], NodeProperties.Groups));
  return hasGroup(graph || GetCurrentGraph(_getState()), id);
}
function IsEndOfDataChain(id) {
  return GetDataChainFrom(id).length === 1;
}
function GetLambdaVariableNode(id, key) {
  const currentNode = GetNodeById(id);

  if (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.CS)) {
    const methods = GetNodesLinkedTo(null, {
      id: currentNode.id,
      link: nodetypes_LinkType.DataChainLink,
      componentType: uiactions_NodeTypes.Method
    });

    if (methods.length) {
      const functionType = uiactions_GetNodeProp(methods[0], uiactions_NodeProperties.FunctionType);
      const {
        lambda
      } = MethodFunctions[functionType];

      if (lambda && lambda.default) {
        const methodProps = GetMethodProps(methods[0]);
        return GetNodeById(methodProps[key]);
      }
    }
  }

  return null;
}
function GetArbitersInCSDataChainMethod(id) {
  const node = GetNodeById(id);
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);
  const lambda = uiactions_GetNodeProp(node, uiactions_NodeProperties.Lambda);
  const result = [];

  switch (functionType) {
    case DataChainFunctionKeys.Lambda:
      getReferenceInserts(lambda).map(v => v.substr(2, v.length - 3)).unique().map(_insert => {
        const temp = _insert.split("@");

        const insert = temp.length > 1 ? temp[1] : temp[0];

        if (temp.length > 1) {
          switch (temp[0]) {
            case "arbiter get":
              const lambdaNode = GetLambdaVariableNode(id, insert);
              if (lambdaNode) result.push(lambdaNode);
              break;

            default:
              break;
          }
        }
      });
  }

  return result;
}
function GetOutputTypeInCSDataChainMethod(id) {
  const node = GetNodeById(id);
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);
  const lambda = uiactions_GetNodeProp(node, uiactions_NodeProperties.Lambda);
  let result = null;

  switch (functionType) {
    case DataChainFunctionKeys.Lambda:
      getReferenceInserts(lambda).map(v => v.substr(2, v.length - 3)).unique().map(_insert => {
        const temp = _insert.split("@");

        const insert = temp.length > 1 ? temp[1] : temp[0];

        if (temp.length > 1) {
          if (temp[0].indexOf("return") === 0) {
            const vari = temp[0].split(" ").filter(x => x);
            const lambdaNode = GetLambdaVariableNode(id, vari[vari.length - 1]);
            if (lambdaNode) result = lambdaNode;
          }
        }
      });
  }

  return result;
}
function GenerateCDDataChainMethod(id) {
  const node = GetNodeById(id);
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);
  let lambda = uiactions_GetNodeProp(node, uiactions_NodeProperties.Lambda);
  const lambdaInsertArguments = uiactions_GetNodeProp(node, uiactions_NodeProperties.LambdaInsertArguments);

  switch (functionType) {
    case DataChainFunctionKeys.Lambda:
      getReferenceInserts(lambda).map(v => v.substr(2, v.length - 3)).unique().map(_insert => {
        const temp = _insert.split("@");

        const insert = temp.length > 1 ? temp[1] : temp[0];

        if (temp.length > 1) {
          let swap = temp[0];
          const args = insert.split("~");
          const model = args[0];
          const property = args[1];

          switch (temp[0]) {
            case "arbiter get":
              const lambdaNode = GetLambdaVariableNode(id, insert);
              swap = `await arbiter${GetCodeName(lambdaNode)}.Get<${GetCodeName(lambdaNode)}>`;
              break;

            default:
              if (property) {
                const lambdaNode = lambdaInsertArguments[property];
                swap = `${model}.${GetCodeName(lambdaNode)}`;
              }

              break;
          }

          lambda = lambda.replace(`#{${_insert}}`, swap);
        } else {
          const args = insert.split("~");
          const property = args[0];
          const prop = lambdaInsertArguments[property];
          const node = GetNodeById(prop);
          lambda = bindReferenceTemplate(lambda, {
            [property]: GetCodeName(node)
          });
        }
      });
      return `${lambda}`;

    default:
      throw `${GetNodeTitle(node)} ${node.id} - ${functionType} is not a defined function type.`;
  }
}
function GenerateDataChainMethod(id) {
  const node = GetNodeById(id);
  const model = uiactions_GetNodeProp(node, uiactions_NodeProperties.UIModelType);
  const stateKey = uiactions_GetNodeProp(node, uiactions_NodeProperties.StateKey);
  const modelKey = uiactions_GetNodeProp(node, uiactions_NodeProperties.ModelKey);
  const viewModelKey = uiactions_GetNodeProp(node, uiactions_NodeProperties.ViewModelKey);
  const numberParameter = uiactions_GetNodeProp(node, uiactions_NodeProperties.NumberParameter);
  const property = uiactions_GetNodeProp(node, uiactions_NodeProperties.Property);
  const functionType = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainFunctionType);
  const func = GetCodeName(uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainReference));
  const funcs = uiactions_GetNodeProp(node, uiactions_NodeProperties.DataChainReferences);
  const selectorProp = uiactions_GetNodeProp(node, uiactions_NodeProperties.SelectorProperty);
  const nodeInput1 = uiactions_GetNodeProp(node, uiactions_NodeProperties.ChainNodeInput1);
  const nodeInput2 = uiactions_GetNodeProp(node, uiactions_NodeProperties.ChainNodeInput2);
  const navigateMethod = uiactions_GetNodeProp(node, uiactions_NodeProperties.NavigationAction);
  const methodMethod = uiactions_GetNodeProp(node, uiactions_NodeProperties.Method);
  const $screen = uiactions_GetNodeProp(node, uiactions_NodeProperties.Screen);
  const useNavigationParams = uiactions_GetNodeProp(node, uiactions_NodeProperties.UseNavigationParams);
  let lambda = uiactions_GetNodeProp(node, uiactions_NodeProperties.Lambda);
  const lambdaInsertArguments = uiactions_GetNodeProp(node, uiactions_NodeProperties.LambdaInsertArguments);
  const listReference = uiactions_GetNodeProp(node, uiactions_NodeProperties.List);
  let lastpart = "return item;";

  switch (functionType) {
    case DataChainFunctionKeys.ModelProperty:
      if (property) {
        lastpart = `if(item) {
        return item.${GetJSCodeName(property) || property};
    }
    return null;`;
      }

      return `(id) => {
    let item = typeof(id) ==='object' ? id : GetItem(Models.${GetCodeName(model)}, id);
    ${lastpart}
}`;

    case DataChainFunctionKeys.Model:
      return `(id) => {
    let item = GetItem(Models.${GetCodeName(model)}, id);
    if(!item && id) {
      fetchModel(Models.${GetCodeName(model)}, id);
    }
    ${lastpart}
}`;

    case DataChainFunctionKeys.Pass:
      return `(arg) => {
    return arg;
}`;

    case DataChainFunctionKeys.NewRedGraph:
      return `() => {
        let menuData = new RedGraph();
        // for (var i = 0; i < 12; i++) {
        //   RedGraph.addNode(menuData, { title: "Menu Node " + i, id: i + 1 }, i + 1);
        //   if (i > 2) RedGraph.addLink(menuData, 2, i + 1);
        //   else RedGraph.addLink(menuData, null, i + 1);
        // }
        return menuData;
      }`;

    case DataChainFunctionKeys.AddUrlsToGraph:
      return `graph => {
        Object.keys(routes).map(route=>{
          RedGraph.addNode(graph, { title: route, id: route } , route);
          RedGraph.addLink(graph, null, route);
        });
        return graph;
      }`;

    case DataChainFunctionKeys.StringConcat:
      return `(node1, node2) => { return \`\${node1} \${node2}\` }`;

    case DataChainFunctionKeys.EmailValidation:
      return `(value) => validateEmail(value)`;

    case DataChainFunctionKeys.AlphaNumericLike:
      return `(value) => alphanumericLike(value)`;

    case DataChainFunctionKeys.AlphaNumeric:
      return `(value) => alphanumeric(value)`;

    case DataChainFunctionKeys.AlphaOnly:
      return `(value) => alpha(value)`;

    case DataChainFunctionKeys.BooleanAnd:
      return `(a, b) => a && b`;

    case DataChainFunctionKeys.BooleanOr:
      return `(a, b) => a || b`;

    case DataChainFunctionKeys.IfTrue:
      return `(a, b) => {
        if(a) {
          return b;
        }
        return undefined;
      }`;

    case DataChainFunctionKeys.IfThanElse:
      return `(a) => {
        if(a){
          return ${GetCodeName(nodeInput1)}(a);
        }
        else {
          return ${GetCodeName(nodeInput2)}(a);
        }
      }`;

    case DataChainFunctionKeys.GreaterThanOrEqualTo:
      return `(a) => greaterThanOrEqualTo(a, ${numberParameter})`;

    case DataChainFunctionKeys.Map:
      return `($a) => ($a || []).map(${lambda})`;

    case DataChainFunctionKeys.Lambda:
      getReferenceInserts(lambda).map(v => v.substr(2, v.length - 3)).unique().map(insert => {
        const args = insert.split("~");
        const property = args.length > 1 ? args[1] : args[0];
        const model = args[0];
        const prop = lambdaInsertArguments[property];
        const node = GetNodeById(prop);
        let bindValue = GetCodeName(node);

        if (args.length > 1) {
          bindValue = bindValue.toLowerCase();
        }

        lambda = bindReferenceTemplate(lambda, {
          [insert]: bindValue
        });
      });
      return `${lambda}`;

    case DataChainFunctionKeys.Merge:
      return `() => {
        ${Object.keys(funcs || {}).map(key => {
        return `let ${key} = ${GetCodeName(funcs[key])}();`;
      }).join(nodetypes_NEW_LINE)}
        ${lambda}
      }`;

    case DataChainFunctionKeys.ListReference:
      return `(a) => RedLists.${GetCodeName(listReference)}`;

    case DataChainFunctionKeys.NumericalDefault:
      return `(a) => numericalDefault(a, ${numberParameter})`;

    case DataChainFunctionKeys.ArrayLength:
      return `(a) => arrayLength(a)`;

    case DataChainFunctionKeys.LessThanOrEqualTo:
      return `(a) => lessThanOrEqualTo(a, ${numberParameter})`;

    case DataChainFunctionKeys.MaxLength:
      return `(a) => maxLength(a, ${numberParameter})`;

    case DataChainFunctionKeys.MinLength:
      return `(a) => minLength(a, ${numberParameter})`;

    case DataChainFunctionKeys.EqualsLength:
      return `(a) => equalsLength(a, ${numberParameter})`;

    case DataChainFunctionKeys.GreaterThan:
      return `(a) => greaterThan(a, ${numberParameter})`;

    case DataChainFunctionKeys.Property:
      return `(a) => a ? a.${GetJSCodeName(property) || property} : null`;

    case DataChainFunctionKeys.ReferenceDataChain:
      return `(a) => ${func}(a)`;

    case DataChainFunctionKeys.Navigate:
      let insert = "";

      if (useNavigationParams) {
        insert = `Object.keys(a).map(v=>{
          let regex =  new RegExp(\`\\:$\{v}\`, 'gm');
          route = route.replace(regex, a[v]);
        })`;
      }

      return `(a) => {
        let route = routes.${GetCodeName($screen)};
        ${insert}
        navigate.${NavigateTypes[navigateMethod]}({ route })(GetDispatch(), GetState());
        return a;
      }`;

    case DataChainFunctionKeys.NavigateTo:
      return `(a) => {
        navigate.${NavigateTypes[navigateMethod]}({ route: routes[a] })(GetDispatch(), GetState());
        return a;
      }`;

    case DataChainFunctionKeys.SetBearerAccessToken:
      return `(a) => {
        $service.setBearerAccessToken(a);
        return a;
     }`;

    case DataChainFunctionKeys.Equals:
      return `(a, b) => a === b`;

    case DataChainFunctionKeys.Required:
      return `(a) => a !== null && a !== undefined`;

    case DataChainFunctionKeys.Not:
      return `(a) => !!!a`;

    case DataChainFunctionKeys.GetModelIds:
      return `(a) => {
    if(a && a.map) {
        return a.map(item => item.id);
    }
    else {
        console.warn('"a" parameter was not an array');
    }
}`;

    case DataChainFunctionKeys.SaveModelArrayToState:
      return `(a) => { let dispatch = GetDispatch(); dispatch(UIModels(Models.${GetCodeName(model)}, a)); return a; }`;

    case DataChainFunctionKeys.SaveModelIdsToState:
      return `(a) => { let dispatch = GetDispatch(); dispatch(UIC('Data', StateKeys.${GetCodeName(stateKey)}, a)); return a; }`;

    case DataChainFunctionKeys.GetStateKeyValue:
      return `(a) =>  {
        let stateFunc = GetState();
        return GetC(stateFunc(),'Data', StateKeys.${GetCodeName(stateKey)})}`;

    case DataChainFunctionKeys.StateKey:
      return `(a) => StateKeys.${GetCodeName(stateKey)}`;

    case DataChainFunctionKeys.ModelKey:
      return `(a) => ModelKeys.${GetCodeName(modelKey)}`;

    case DataChainFunctionKeys.ViewModelKey:
      return `(a) => ViewModelKeys.${GetCodeName(viewModelKey)}`;

    case DataChainFunctionKeys.Selector:
      return `(a) => a ? a.${selectorProp} : undefined`;

    case DataChainFunctionKeys.Models:
      return `a => GetItems(Models.${GetCodeName(model)})`;

    case DataChainFunctionKeys.Validation:
      return `a => true/*TBI*/`;

    case DataChainFunctionKeys.MethodBaseValidation:
      if (methodMethod) {
        return buildValidation({
          methodMethod,
          id
        });
      }

      return `a => false`;

    case DataChainFunctionKeys.ModelMethodMenu:
      return buildModelMethodMenu();

    default:
      throw `${GetNodeTitle(node)} ${node.id} - ${functionType} is not a defined function type.`;
  }
}

function buildModelMethodMenu() {
  const listPages = uiactions_NodesByType(null, uiactions_NodeTypes.Screen).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.ViewType) === viewtypes_ViewTypes.GetAll);
  const underPages = uiactions_NodesByType(null, uiactions_NodeTypes.Screen).filter(x => [viewtypes_ViewTypes.Create, viewtypes_ViewTypes.GetAll].some(v => v === uiactions_GetNodeProp(x, uiactions_NodeProperties.ViewType)));
  const screens = listPages.map(v => `{ title: '${GetNodeTitle(v)}', name: 'top-${GetCodeName(v)}' }`);
  const subscreens = underPages.map(v => {
    const tpage = listPages.find(vt => uiactions_GetNodeProp(vt, uiactions_NodeProperties.Model) === uiactions_GetNodeProp(v, uiactions_NodeProperties.Model));
    const temp = `{title: '${GetNodeTitle(v)}',  name: '${GetCodeName(v)}', parent: 'top-${GetCodeName(tpage)}' }`;
    return temp;
  });
  return ` () => {
    let toppages = [${screens.join()}].map(v => ({ id: \`\${v.name}\` , title: titleService.get(v.title || v.name), parent: null }));
    let underpages = [${subscreens.join()}].filter(v =>v && routes[v.name] && routes[v.name].indexOf(':') === -1).map(v => ({ id: \`\${v.name}\` , title: titleService.get(v.title || v.name), parent: v.parent }));
    return [...toppages, ...underpages]
}`;
}

function GetPermissionsSortedByAgent() {
  return GetNodesSortedByAgent(uiactions_NodeTypes.Permission);
}
function GetValidationsSortedByAgent() {
  return GetNodesSortedByAgent(uiactions_NodeTypes.Validator);
}
function GetNodesSortedByAgent(type) {
  const state = _getState();

  const nodes = uiactions_NodesByType(state, type);
  return nodes.filter(node => {
    const methodNode = GetMethodNode(state, node.id);
    return methodNode;
  }).groupBy(node => {
    const methodNode = GetMethodNode(state, node.id);
    return GetMethodNodeProp(methodNode, FunctionTemplateKeys.Agent);
  });
}
function GetArbitersForNodeType(type) {
  const state = _getState();

  const permissions = uiactions_NodesByType(state, type);
  const models = [];
  permissions.map(permission => {
    const methodNode = GetMethodNode(state, permission.id);
    const methodProps = GetMethodProps(methodNode);
    Object.values(methodProps).map(id => {
      const node = GetGraphNode(id);
      const nodeType = uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType);

      if ([uiactions_NodeTypes.Model].some(v => v === nodeType)) {
        models.push(id);
      }
    });
  });
  return models.unique();
}
function GetCustomServicesForNodeType(type) {
  const state = _getState();

  const permissions = uiactions_NodesByType(state, type);
  const models = [];
  permissions.map(permission => {
    const methods = GetServiceInterfaceMethodCalls(permission.id);
    methods.map(method => {
      const services = GetServiceInterfaceCalls(method.id);
      models.push(...services.map(v => v.id));
    });
  });
  return models.unique();
}
function GetAgentNodes() {
  return uiactions_NodesByType(_getState(), uiactions_NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
}
function GetUsers() {
  return uiactions_NodesByType(_getState(), uiactions_NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsUser));
}
function GetArbitersForPermissions() {
  return GetArbitersForNodeType(uiactions_NodeTypes.Permission);
}
function GetArbitersForValidations() {
  return GetArbitersForNodeType(uiactions_NodeTypes.Validator);
}
function GetNameSpace() {
  const state = _getState();

  const graphRoot = GetRootGraph(state);
  const namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
  return namespace;
}
function GetArbiterPropertyDefinitions(tabs = 3, language = ProgrammingLanguages.CSHARP) {
  const arbiters = GetArbitersForPermissions();
  const template = `IRedArbiter<{{model}}> arbiter{{model}};`;
  const tab = [].interpolate(0, tabs, () => `   `).join("");
  const definitions = arbiters.map(arbiter => {
    return tab + bindTemplate(template, {
      model: GetCodeName(arbiter)
    });
  });
  return definitions.join(nodetypes_NEW_LINE);
}
function GetCustomServiceDefinitions(type, tabs = 3, language = ProgrammingLanguages.CSHARP) {
  const services = GetCustomServicesForNodeType(type);
  const template = `I{{model}} {{model_js}};`;
  const tab = [].interpolate(0, tabs, () => `   `).join("");
  const definitions = services.map(service => {
    return tab + bindTemplate(template, {
      model: GetCodeName(service),
      model_js: GetJSCodeName(service)
    });
  });
  return definitions.join(nodetypes_NEW_LINE);
}
function GetArbiterPropertyImplementations(tabs = 4, language = ProgrammingLanguages.CSHARP) {
  const arbiters = GetArbitersForPermissions();
  const template = `arbiter{{model}} = RedStrapper.Resolve<IRedArbiter<{{model}}>>();`;
  const tab = [].interpolate(0, tabs, () => `   `).join("");
  const definitions = arbiters.map(arbiter => {
    return tab + bindTemplate(template, {
      model: GetCodeName(arbiter)
    });
  });
  return definitions.join(nodetypes_NEW_LINE);
}
function GetCustomServiceImplementations(type, tabs = 4, language = ProgrammingLanguages.CSHARP) {
  const services = GetCustomServicesForNodeType(type);
  const template = `{{model_js}} = RedStrapper.Resolve<I{{model}}>();`;
  const tab = [].interpolate(0, tabs, () => `   `).join("");
  const definitions = services.map(service => {
    return tab + bindTemplate(template, {
      model: GetCodeName(service),
      model_js: GetJSCodeName(service)
    });
  });
  return definitions.join(nodetypes_NEW_LINE);
}
function GetCombinedCondition(id, language = ProgrammingLanguages.CSHARP, options = {}) {
  const node = GetGraphNode(id);
  let conditions = [];
  let customMethods = [];
  let finalResult = "res";
  let tabcount = 0;
  let methodNodeParameters = null;
  let ft = null;
  let methodNode = null;

  switch (uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType)) {
    case uiactions_NodeTypes.Permission:
      conditions = GetPermissionsConditions(id);
      customMethods = GetServiceInterfaceMethodCalls(id);
      methodNode = GetPermissionMethod(node);
      ft = MethodFunctions[uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.FunctionType)];

      if (ft && ft.permission && ft.permission.params) {
        methodNodeParameters = ft.permission.params.map(t => typeof t === "string" ? t : t.key);
      }

      finalResult = "result";
      tabcount = 3;
      break;

    case uiactions_NodeTypes.ModelItemFilter:
      conditions = GetModelItemConditions(id);
      break;

    case uiactions_NodeTypes.Validator:
      conditions = GetValidationsConditions(id);
      methodNode = GetNodesMethod(id);
      ft = MethodFunctions[uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.FunctionType)];

      if (ft && ft.validation && ft.validation.params) {
        methodNodeParameters = ft.validation.params.map(t => typeof t === "string" ? t : t.key);
      }

      tabcount = 3;
      finalResult = "result";
      break;

    default:
      break;
  }

  const tabs = [].interpolate(0, tabcount, () => `    `).join("");
  let clauses = [];
  conditions.map(condition => {
    const selectedConditionSetup = GetSelectedConditionSetup(id, condition);
    const res = GetConditionsClauses(id, selectedConditionSetup, language, options);
    clauses = [...clauses, ...res.map(t => t.clause)];
  });
  customMethods.map(customMethod => {
    const res = GetCustomMethodClauses(node, customMethod, methodNodeParameters, language);
    clauses = [...clauses, ...res.map(t => t.clause)];
  });
  const finalClause = clauses.map((_, index) => {
    return `res_` + index;
  }).join(" && ") || "true";

  if (options.finalResult) {
    finalResult = options.finalResult;
  }

  clauses.push(`${finalResult} = ${finalClause};`);
  return clauses.map((clause, index) => {
    return tabs + bindTemplate(clause, {
      result: `res_${index}`
    });
  }).join(nodetypes_NEW_LINE);
}
function GetCustomMethodClauses(node, customMethod, methodNodeParameters, language) {
  const result = [];

  if (methodNodeParameters) {
    const serviceInterface = GetServiceInterfaceCalls(customMethod.id).find(x => x);

    if (serviceInterface) {
      switch (language) {
        case UITypes.ElectronIO:
          break;

        default:
          result.push({
            clause: `var {{result}} = await ${GetJSCodeName(serviceInterface)}.${GetCodeName(customMethod)}(${methodNodeParameters.join()});`
          });
          break;
      }
    }
  }

  return result;
}
function GetConditionsClauses(adjacentId, clauseSetup, language, options = {}) {
  const result = [];

  if (clauseSetup) {
    Object.keys(clauseSetup).map(clauseKey => {
      const {
        properties
      } = clauseSetup[clauseKey];

      if (properties) {
        Object.keys(properties).filter(modelId => {
          if (options && options.filter && options.filter.property) {
            return options.filter.property === modelId;
          }

          return true;
        }).map(modelId => {
          const propertyName = GetCodeName(modelId);
          const {
            validators
          } = properties[modelId];

          if (validators) {
            Object.keys(validators).map(validatorId => {
              const validator = validators[validatorId];
              const res = GetConditionClause(adjacentId, clauseKey, propertyName, validator, language, options);
              result.push({
                clause: res,
                id: validatorId
              });
            });
          }
        });
      }
    });
  }

  return result;
}
function safeFormatTemplateProperty(str) {
  return str.split("-").join("_");
}
function GetConditionClause(adjacentId, clauseKey, propertyName, validator, language) {
  const method = GetNodesMethod(adjacentId);
  const clauseKeyNodeId = GetMethodNodeProp(method, clauseKey);
  let {
    type,
    template,
    templatejs,
    node,
    nodeProperty,
    many2manyProperty,
    many2many,
    many2manyMethod
  } = validator;
  const dataAccessor = "";
  const nodeNodeId = GetMethodNodeProp(method, node);
  let conditionTemplate = "";
  const condition = "";
  let properties = {};

  if (FilterUI && FilterUI[type] && FilterUI[type].template && !template) {
    template = FilterUI[type].template;
  }

  if (FilterUI && FilterUI[type] && FilterUI[type].templatejs && !templatejs) {
    templatejs = FilterUI[type].templatejs;
  }

  if (template) {
    switch (language) {
      case ProgrammingLanguages.JavaScript:
        conditionTemplate = fs.readFileSync(templatejs, "utf8");
        break;

      default:
        conditionTemplate = fs.readFileSync(template, "utf8");
        break;
    }
  } else {
    throw "no template found: " + type;
  }

  if (clauseKey === "change_parameter") {
    clauseKey = clauseKey + ".Data";
  }

  switch (type) {
    case FilterRules.IsInModelPropertyCollection:
    case FilterRules.EqualsModelProperty:
    case FilterRules.EqualsFalse:
    case FilterRules.EqualsTrue:
    case FilterRules.EqualsParent:
    case FilterRules.IsNotInModelPropertyCollection:
      properties = {
        agent: safeFormatTemplateProperty(clauseKey),
        agent_property: safeFormatTemplateProperty(propertyName),
        model: node,
        model_property: GetCodeName(nodeProperty)
      };
      break;

    case FilterRules.Many2ManyPropertyIsTrue:
      properties = {
        agent: safeFormatTemplateProperty(clauseKey),
        agent_property: safeFormatTemplateProperty(propertyName),
        agent_type: GetCodeName(clauseKeyNodeId) || "agent_type missing",
        model_type: GetCodeName(nodeNodeId) || "model_type missing",
        model: node,
        model_property: GetCodeName(nodeProperty),
        connection_type: GetCodeName(many2many),
        connection_is_true: GetConnectionClause({
          many2manyProperty,
          many2manyMethod
        }) //

      };
      break;

    case ValidationRules.OneOf:
      const listItems = GenerateConstantList(validator);
      properties = {
        agent: safeFormatTemplateProperty(clauseKey),
        agent_property: safeFormatTemplateProperty(propertyName),
        agent_type: GetCodeName(clauseKeyNodeId) || "agent_type missing",
        list: listItems
      };
      break;

    case ValidationRules.AlphaOnlyWithSpaces:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "AlphaOnlyWithSpacesAttribute"
      };
      break;

    case ValidationRules.AlphaNumericLike:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "AlphaNumericLikeAttribute"
      };
      break;

    case ValidationRules.AlphaOnly:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "AlphaOnlyAttribute"
      };
      break;

    case ValidationRules.MaxLength:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: `${validator ? validator.condition : null}`,
        validation_Func_name: "MaxLengthAttribute"
      };
      break;

    case ValidationRules.MaxLengthEqual:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: `${validator ? validator.condition : null}, true`,
        validation_Func_name: "MaxLengthAttribute"
      };
      break;

    case ValidationRules.MinLength:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: validator ? validator.condition : null,
        validation_Func_name: "MinLengthAttribute"
      };
      break;

    case ValidationRules.MinLengthEqual:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: `${validator ? validator.condition : null}, true`,
        validation_Func_name: "MinLengthAttribute"
      };
      break;

    case ValidationRules.MaxValue:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: `${validator ? validator.condition : null}`,
        validation_Func_name: "MaxAttribute"
      };
      break;

    case ValidationRules.MaxValueEqual:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: `${validator ? validator.condition : null}, true`,
        validation_Func_name: "MaxAttribute"
      };
      break;

    case ValidationRules.MinValue:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: validator ? validator.condition : null,
        validation_Func_name: "MinAttribute"
      };
      break;

    case ValidationRules.MinValueEqual:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: `${validator ? validator.condition : null}, true`,
        validation_Func_name: "MinAttribute"
      };
      break;

    case ValidationRules.IsNull:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: ``,
        validation_Func_name: "IsNullAttribute"
      };
      break;

    case ValidationRules.IsNotNull:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        parameters: ``,
        validation_Func_name: "IsNotNullAttribute"
      };
      break;

    case ValidationRules.Email:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "EmailAttribute"
      };
      break;

    case ValidationRules.EmailEmpty:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "EmailEmptyAttribute"
      };
      break;

    case ValidationRules.Zip:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "ZipAttribute"
      };
      break;

    case ValidationRules.ZipEmpty:
      properties = {
        model: clauseKey,
        model_property: propertyName,
        validation_Func_name: "ZipEmptyAttribute"
      };
      break;

    default:
      throw "Unhandled condition clause case: " + type;
  }

  return bindTemplate(conditionTemplate, {
    parameters: "",
    ...properties
  });
}

function GenerateConstantList(validator) {
  const node = GetGraphNode(validator.node);
  const {
    enumeration
  } = validator;

  switch (uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType)) {
    case uiactions_NodeTypes.Enumeration:
      var enums = uiactions_GetNodeProp(node, uiactions_NodeProperties.Enumeration) || [];
      return enums.map(enum_ => {
        if (enumeration[enum_.id || enum_]) {
          return `${GetCodeName(validator.node)}.${MakeConstant(enum_.value || enum_)}`;
        }
      }).filter(x => x).join(", ");

    default:
      throw "not implemented capturing of enums";
  }
}

function GetConnectionClause(args) {
  const {
    many2manyProperty,
    many2manyMethod
  } = args;

  switch (many2manyMethod) {
    case FilterRules.EqualsTrue:
      return bindTemplate("_x => _x.{{connection_property}} == {{connection_value}}", {
        connection_property: GetCodeName(many2manyProperty),
        connection_value: "true"
      });

    case FilterRules.EqualsFalse:
      return bindTemplate("_x => _x.{{connection_property}} == {{connection_value}}", {
        connection_property: GetCodeName(many2manyProperty),
        connection_value: "false"
      });

    default:
      throw "unhandle get connection clause : " + many2manyMethod;
  }
}
function GetSelectedConditionSetup(permissionId, condition) {
  const method = GetMethodNode(_getState(), permissionId);

  if (method) {
    const conditionSetup = GetConditionSetup(condition);

    if (conditionSetup && conditionSetup.methods) {
      return conditionSetup.methods[uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType)];
    } // console.warn('condition is improperly formed');

  } else {// console.warn('no method node found');
    }

  return null;
}
function _getPermissionsConditions(state, id) {
  return _getConditions(state, id);
}
function _getValidationConditions(state, id) {
  return _getConditions(state, id);
}
function _getConditions(state, id) {
  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Condition);
}
function GetComponentNodes() {
  const state = GetState();
  return uiactions_NodesByType(state, uiactions_NodeTypes.ComponentNode);
}
function GetComponentNodeProperties() {
  const res = GetComponentNodes().map(node => {
    const componentProperties = uiactions_GetNodeProp(node, uiactions_NodeProperties.ComponentProperties);
    const componentPropertiesList = getComponentPropertyList(componentProperties) || [];
    return {
      id: node.id,
      componentPropertiesList
    };
  }).filter(x => x.componentPropertiesList.length).groupBy(x => x.id);
  const result = [];
  Object.keys(res).map(v => {
    const componentPropertiesList = [];
    res[v].map(b => componentPropertiesList.push(...b.componentPropertiesList)).unique(x => x.id);
    result.push({
      id: v,
      componentPropertiesList
    });
  });
  return result;
}
function GetConnectedScreenOptions(id) {
  const state = _getState();

  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ScreenOption);
}
function attachToNavigateNode(currentId, action) {
  return (dispatch, getState) => {
    graphOperation(_attachToNavigateNode(currentId, action))(dispatch, getState);
  };
}
function _attachToNavigateNode(currentId, action) {
  return [{
    operation: ADD_NEW_NODE,

    options(currentGraph) {
      return {
        nodeType: uiactions_NodeTypes.NavigationAction,
        linkProperties: {
          properties: { ...uiactions_LinkProperties.NavigationMethod
          }
        },
        parent: currentId,
        properties: {
          [uiactions_NodeProperties.UIText]: action,
          [uiactions_NodeProperties.NavigationAction]: action
        }
      };
    }

  }];
}
function GetConnectedScreen(id) {
  const state = _getState();

  const graph = GetRootGraph(state);
  return GetNodesLinkedTo(graph, {
    id
  }).find(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Screen);
}
function GetModelPropertyNodes(refId) {
  const state = _getState();

  return GetLinkChain(state, {
    id: refId,
    links: [{
      type: nodetypes_LinkType.PropertyLink,
      direction: SOURCE
    }]
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Property);
}
function getTopComponent(graph, node) {
  const parent = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.Component,
    direction: TARGET
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentNode)[0];

  if (parent) {
    return getTopComponent(graph, parent);
  }

  return node;
}
function GetParentComponent(node, graph) {
  graph = graph || GetCurrentGraph();
  const parent = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.Component,
    direction: graph_methods_TARGET
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentNode)[0];
  return parent;
}
function ComponentIsViewType(component, viewType, graph) {
  graph = graph || GetCurrentGraph();
  const currentType = uiactions_GetNodeProp(component, uiactions_NodeProperties.ViewType);

  if (currentType === viewType) {
    return true;
  }

  if (currentType) {
    return false;
  }

  const parent = GetParentComponent(component, graph);

  if (parent) {
    return ComponentIsViewType(parent, viewType, graph);
  }

  return false;
}
function GetUserReferenceNodes(refId) {
  const state = _getState();

  return GetLinkChain(state, {
    id: refId,
    links: [{
      type: nodetypes_LinkType.UserLink,
      direction: graph_methods_TARGET
    }]
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Model);
}
function GetLogicalChildren(id) {
  const currentNode = GetNode(GetCurrentGraph(GetState()), id);
  const hasLogicalChildren = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.HasLogicalChildren);

  if (hasLogicalChildren) {
    return (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalChildrenTypes) || []).map(t => {
      const node = GetNode(GetCurrentGraph(_getState()), t);
      return node;
    }).filter(x => x);
  }

  return [];
}
function GetMethodNodeSelectOptions(methodProps) {
  return Object.keys(methodProps).map(val => {
    return {
      value: val,
      title: `${GetCodeName(methodProps[val])} (${val})`
    };
  });
}
function GetNodeCode(graph, id) {
  return GetCodeName(GetNode(graph, id));
}
function GetMethodPropNode(graph, node, key) {
  const methodProps = uiactions_GetNodeProp(node, uiactions_NodeProperties.MethodProps);

  if (methodProps) {
    return GetNode(graph, methodProps[key] || null);
  }

  return null;
}
function GetMethodOptions(methodProps) {
  if (!methodProps) {
    return [];
  }

  const state = _getState();

  return Object.keys(methodProps).map(t => {
    const n = GetNode(GetRootGraph(state), methodProps[t]);
    return {
      title: `${GetCodeName(n)} (${t})`,
      value: t
    };
  });
}
function GetLinkProperty(link, prop) {
  return link && link.properties && link.properties[prop];
}
function GetLink(linkId) {
  const graph = GetCurrentGraph();
  return getLink(graph, {
    id: linkId
  });
}
function GetGroupProperty(group, prop) {
  return group && group.properties && group.properties[prop];
}
function VisualEq(state, key, value) {
  return Visual(state, key) === value;
}
function Node(state, nodeId) {
  const currentGraph = GetCurrentGraph(state);

  if (currentGraph && currentGraph.nodeLib) {
    return currentGraph.nodeLib[nodeId];
  }

  return null;
}
function ModelNotConnectedToFunction(agentId, modelId, packageType, nodeType = uiactions_NodeTypes.Method) {
  const connections = uiactions_NodesByType(_getState(), nodeType).filter(x => {
    const match = uiactions_GetNodeProp(x, uiactions_NodeProperties.NodePackage) === modelId && uiactions_GetNodeProp(x, uiactions_NodeProperties.NodePackageType) === packageType && uiactions_GetNodeProp(x, uiactions_NodeProperties.NodePackageAgent) === agentId;
    return match;
  }).length;
  return !connections;
}
function Application(state, key) {
  return GetC(state, APPLICATION, key);
}
function GetVisualGraph(state) {
  const currentGraph = GetCurrentGraph(state);
  return currentGraph ? GetC(state, VISUAL_GRAPH, currentGraph.id) : null;
}
function SaveApplication(value, key, dispatch) {
  dispatch(UIC(APPLICATION, key, value));
}
function Graphs(state, key) {
  return GetC(state, GRAPHS, key);
}
function SaveGraph(graph, dispatch) {
  graph = { ...graph,
    ...{
      updated: Date.now()
    }
  };
  const visualGraph = VisualProcess(graph);
  if (visualGraph) dispatch(UIC(VISUAL_GRAPH, visualGraph.id, visualGraph));
  dispatch(UIC(GRAPHS, graph.id, graph));
}
function UIC(section, item, value) {
  return {
    type: UI_UPDATE,
    item,
    value,
    section
  };
}
function toggleVisual(key) {
  return (dispatch, getState) => {
    const state = getState();
    dispatch(UIC(VISUAL, key, !GetC(state, VISUAL, key)));
  };
}
function toggleMinimized(key) {
  return (dispatch, getState) => {
    const state = getState();
    dispatch(UIC(MINIMIZED, key, !GetC(state, MINIMIZED, key)));
  };
}
function toggleHideByTypes(key) {
  return (dispatch, getState) => {
    const state = getState();
    const newvalue = !GetC(state, HIDDEN, key);
    dispatch(UIC(HIDDEN, key, newvalue));
    PerformGraphOperation(uiactions_NodesByType(state, key).map(node => {
      return {
        operation: CHANGE_NODE_PROPERTY,
        options: {
          prop: uiactions_NodeProperties.Pinned,
          id: node.id,
          value: newvalue
        }
      };
    }))(dispatch, getState);
  };
}
function GUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = Math.random() * 16 | 0;
    const v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
function setVisual(key, value) {
  return (dispatch, getState) => {
    const state = getState();
    dispatch(UIC(VISUAL, key, value));
  };
}
function setApplication(key, value) {
  return (dispatch, getState) => {
    const state = getState();
    dispatch(UIC(APPLICATION, key, value));
  };
}
const SELECTED_LINK = "SELECTED_LINK";
const HOVERED_LINK = "HOVERED_LINK";
const SELECTED_NODE = "SELECTED_NODE";
const CONTEXT_MENU_VISIBLE = "CONTEXT_MENU_VISIBLE";
const CONTEXT_MENU_MODE = "CONTEXT_MENU_MODE";
function SelectedNode(nodeId) {
  return (dispatch, getState) => {
    dispatch(UIC(VISUAL, SELECTED_NODE, nodeId));
  };
}
function toggleDashboardMinMax() {
  return toggleVisual(DASHBOARD_MENU);
}
function GetNodeTitle(node) {
  if (typeof node === "string") {
    node = GetNode(GetCurrentGraph(GetState()), node);
  }

  if (!node) {
    return Unknown;
  }

  return node.properties ? node.properties.text || node.id : node.id;
}
function GetNodes(state) {
  const currentGraph = GetCurrentGraph(state);

  if (currentGraph) {
    return [...currentGraph.nodes.map(t => currentGraph.nodeLib[t])];
  }

  return [];
}
function CanChangeType(node) {
  const nodeType = uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType);

  switch (nodeType) {
    case uiactions_NodeTypes.ReferenceNode:
      return false;

    default:
      return true;
  }
}
function GetScreenNodes() {
  const state = _getState();

  return uiactions_NodesByType(state, uiactions_NodeTypes.Screen);
}
function addComponentApiNodes(id, apiName) {
  return (dispatch, getState) => {
    graphOperation($addComponentApiNodes(id, apiName))(dispatch, getState);
  };
}
function $addComponentApiNodes(parent, apiName = "value", externalApiId, viewPackages = {}) {
  let componentInternalValue = null;
  let componentExternalValue = null;
  return [{
    operation: ADD_NEW_NODE,

    options(currentGraph) {
      return {
        nodeType: uiactions_NodeTypes.ComponentApi,
        callback: nn => {
          componentInternalValue = nn.id;
        },
        linkProperties: {
          properties: { ...uiactions_LinkProperties.ComponentInternalApi
          }
        },
        parent,
        groupProperties: {},
        properties: { ...viewPackages,
          [uiactions_NodeProperties.UIText]: apiName,
          [uiactions_NodeProperties.Pinned]: false,
          [uiactions_NodeProperties.UseAsValue]: true // [NodeProperties.ComponentApiKey]: viewComponentType.internalApiNode || null

        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(currentGraph) {
      return {
        nodeType: uiactions_NodeTypes.ComponentExternalApi,
        callback: nn => {
          componentExternalValue = nn.id;
        },
        parent,
        linkProperties: {
          properties: { ...uiactions_LinkProperties.ComponentExternalApi
          }
        },
        groupProperties: {},
        properties: { ...viewPackages,
          [uiactions_NodeProperties.UIText]: apiName,
          [uiactions_NodeProperties.Pinned]: false // [NodeProperties.ComponentApiKey]: viewComponentType.externalApiNode || null

        }
      };
    }

  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        source: componentInternalValue,
        target: componentExternalValue,
        properties: { ...uiactions_LinkProperties.ComponentInternalConnection
        }
      };
    }

  }, externalApiId ? {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        target: externalApiId,
        source: componentExternalValue,
        properties: { ...uiactions_LinkProperties.ComponentExternalConnection
        }
      };
    }

  } : null].filter(x => x);
}
function GetScreenOptions() {
  const state = _getState();

  return uiactions_NodesByType(state, uiactions_NodeTypes.ScreenOption);
}
function GetModelNodes() {
  return uiactions_NodesByType(_getState(), uiactions_NodeTypes.Model);
}
function GetConfigurationNodes() {
  return uiactions_NodesByType(_getState(), uiactions_NodeTypes.Configuration);
}
function GetMaestroNode(id) {
  const state = _getState();

  const graph = GetRootGraph(state);
  const nodes = GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Maestro);

  if (nodes && nodes.length) {
    return nodes[0];
  }

  return null;
}
function GetControllerNode(id) {
  const state = _getState();

  const graph = GetRootGraph(state);
  const nodes = GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Controller);

  if (nodes && nodes.length) {
    return nodes[0];
  }

  return null;
}
function HasCurrentGraph(options = {}) {
  const state = _getState();

  const currentGraph = options.useRoot ? GetRootGraph(state) : GetCurrentGraph(state);
  return !!currentGraph;
}
function uiactions_NodesByType(state, nodeType, options = {}) {
  state = state || GetState();
  const currentGraph = options.useRoot ? GetRootGraph(state) : GetCurrentGraph(state);

  if (currentGraph) {
    if (!Array.isArray(nodeType)) {
      nodeType = [nodeType];
    }

    return currentGraph.nodes.filter(x => currentGraph.nodeLib && currentGraph.nodeLib[x] && currentGraph.nodeLib[x].properties && nodeType.indexOf(currentGraph.nodeLib[x].properties[uiactions_NodeProperties.NODEType]) !== -1 || !options.excludeRefs && currentGraph.nodeLib && currentGraph.nodeLib[x] && currentGraph.nodeLib[x].properties && currentGraph.nodeLib[x].properties[uiactions_NodeProperties.ReferenceType] === nodeType).map(x => currentGraph.nodeLib[x]);
  }

  return [];
}
function GetNodeFromRoot(state, id) {
  const graph = GetRootGraph(state);

  if (graph) {
    return GetNode(graph, id);
  }

  return null;
}
function NodesConnectedTo(state, nodeId) {
  const currentGraph = GetCurrentGraph(state);

  if (currentGraph) {
    return t => {
      if (currentGraph.linkLib[t.id]) {
        return currentGraph.linkLib[t.id][nodeId];
      }
    };
  }

  return () => false;
}

let _getState;

let _dispatch;

function GetState() {
  if (_getState) return _getState();
}
function GetDispatchFunc() {
  return _dispatch;
}
function GetStateFunc() {
  return _getState;
}
function setTestGetState(func) {
  _getState = func;
}
function setState() {
  return (dispatch, getState) => {
    _getState = getState;
    _dispatch = dispatch;
  };
}
function uiactions_clearPinned() {
  const state = _getState();

  _dispatch(graphOperation(GetNodes(state).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.Pinned)).map(node => {
    return {
      operation: CHANGE_NODE_PROPERTY,
      options: {
        prop: uiactions_NodeProperties.Pinned,
        id: node.id,
        value: false
      }
    };
  })));
}
function clearMarked() {
  const state = _getState();

  _dispatch(graphOperation(GetNodes(state).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.Selected)).map(node => {
    return {
      operation: CHANGE_NODE_PROPERTY,
      options: {
        prop: uiactions_NodeProperties.Selected,
        id: node.id,
        value: false
      }
    };
  })));
}
function selectProperties(model) {
  return (dispatch, getState) => {
    const state = getState();
    graphOperation(getPropertyNodes(GetRootGraph(state), model).map(t => {
      return {
        operation: CHANGE_NODE_PROPERTY,
        options: {
          prop: uiactions_NodeProperties.Pinned,
          id: t.id,
          value: true
        }
      };
    }))(dispatch, getState);
  };
}
function togglePinnedConnectedNodesByLinkType(model, linkType) {
  return (dispatch, getState) => {
    const state = getState();
    const graph = GetRootGraph(state);
    const nodes = GetNodesLinkedTo(graph, {
      id: model,
      link: linkType
    });
    const pinned = nodes.filter(x => x.id !== model).some(v => uiactions_GetNodeProp(v, uiactions_NodeProperties.Pinned));
    graphOperation(nodes.map(t => {
      return {
        operation: CHANGE_NODE_PROPERTY,
        options: {
          prop: uiactions_NodeProperties.Pinned,
          id: t.id,
          value: !pinned
        }
      };
    }))(dispatch, getState);
  };
}
function toggleNodeMark() {
  const state = _getState();

  const currentNode = Node(state, Visual(state, SELECTED_NODE));

  _dispatch(graphOperation(CHANGE_NODE_PROPERTY, {
    prop: uiactions_NodeProperties.Selected,
    id: currentNode.id,
    value: !uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Selected)
  }));
}
function setInComponentMode() {
  _dispatch(UIC(MINIMIZED, uiactions_NodeTypes.Selector, true));

  _dispatch(UIC(MINIMIZED, uiactions_NodeTypes.ViewModel, true));

  _dispatch(UIC(MINIMIZED, uiactions_NodeTypes.ViewType, true));
}
function removeCurrentNode() {
  graphOperation(REMOVE_NODE, {
    id: Visual(_getState(), SELECTED_NODE)
  })(_dispatch, _getState);
}
function togglePinned() {
  const state = _getState();

  const currentNode = Node(state, Visual(state, SELECTED_NODE));

  _dispatch(graphOperation(CHANGE_NODE_PROPERTY, {
    prop: uiactions_NodeProperties.Pinned,
    id: currentNode.id,
    value: !uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Pinned)
  }));
}
function GetGraphNode(id) {
  const state = _getState();

  return GetNode(GetRootGraph(state), id);
}
function GetFunctionType(methodNode) {
  return uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.FunctionType);
}
function uiactions_GetMethodNode(id) {
  return GetMethodNode(_getState(), id);
}
function GetMethodNodeProp(methodNode, key) {
  const methodProps = uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.MethodProps) || {};
  if (typeof key === "string") return methodProps[key];
  if (!key) return null;
  const {
    template
  } = key;
  const temp = {};
  Object.keys(methodProps).map(t => {
    temp[t] = GetCodeName(methodProps[t]);
  });
  return bindTemplate(template, temp);
}
function GetMethodProps(methodNode) {
  return uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.MethodProps) || {};
}
function GetMethodsProperties(id) {
  const state = _getState();

  const method = GetMethodNode(state, id);
  const methodProps = GetMethodProps(method);
  return methodProps;
}
function GetMethodsProperty(id, prop) {
  const methodProps = GetMethodsProperties(id);

  if (methodProps) {
    return methodProps[prop];
  }

  return null;
}
function GetMethodFilterParameters(id, all) {
  return GetMethod_Parameters(id, "filter", all);
}
function GetMethodFilterMetaParameters(id, all) {
  return GetMethod_MetaParameters(id, "filter");
}

function GetMethod_MetaParameters(id, key) {
  const state = _getState();

  const method = GetMethodNode(state, id);
  const methodProps = GetMethodProps(method);
  const methodType = uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);

  if (methodType) {
    const setup = MethodFunctions[methodType];

    if (setup && setup[key] && setup[key].params && methodProps) {
      return setup[key].params.filter(x => typeof x === "object" || x.metaparameter).map(x => {
        const _x = x.key;
        const nodeName = GetNodeTitle(methodProps[_x]);
        const nodeClass = GetCodeName(methodProps[_x]);
        return {
          title: nodeName,
          value: _x,
          paramClass: nodeClass,
          paramName: _x
        };
      });
    }
  }

  return [];
}

function GetMethod_Parameters(id, key, all) {
  const state = _getState();

  const method = GetMethodNode(state, id);
  const methodProps = GetMethodProps(method);
  const methodType = uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);

  if (methodType) {
    const setup = MethodFunctions[methodType];

    if (setup && setup[key] && setup[key].params && methodProps) {
      return setup[key].params.filter(x => all || typeof x === "string" || !x.metaparameter).map(x => !x.metaparameter ? x : x.metaparameter).map(_x => {
        const nodeName = GetNodeTitle(methodProps[_x]);
        const nodeClass = GetCodeName(methodProps[_x]);
        return {
          title: nodeName,
          value: _x,
          paramClass: nodeClass,
          paramName: _x
        };
      });
    }
  }

  return [];
}

function GetMethodPermissionParameters(id, all) {
  return GetMethod_Parameters(id, "permission", all);
}
function GetMethodValidationParameters(id, all) {
  return GetMethod_Parameters(id, "validation", all);
}
function GetPermissionMethod(permission) {
  if (permission) return uiactions_GetLinkChainItem({
    id: permission.id,
    links: [{
      type: nodetypes_LinkType.FunctionOperator,
      direction: graph_methods_TARGET
    }]
  });
  return null;
}
function GetPermissionMethodModel(permission) {
  const method = permission ? GetPermissionMethod(permission) : null;

  if (method) {
    const props = GetMethodProps(method);
    return props ? props[FunctionTemplateKeys.Model] : null;
  }

  return null;
}
function GetValidatorMethod(permission) {
  if (permission) return uiactions_GetLinkChainItem({
    id: permission.id,
    links: [{
      type: nodetypes_LinkType.FunctionOperator,
      direction: graph_methods_TARGET
    }]
  });
  return null;
}
function GetFunctionMethodKey(validation, templateKey = FunctionTemplateKeys.Model) {
  const method = validation ? GetValidatorMethod(validation) : null;

  if (method) {
    const props = GetMethodProps(method);
    return props ? props[templateKey] : null;
  }

  return null;
}
function GetNodesMethod(id) {
  return GetPermissionMethod(GetNodeById(id));
}
function GetAppSettings(graph) {
  if (graph) {
    if (graph.appConfig) {
      return graph.appConfig.AppSettings;
    }
  }

  return null;
}
function GetCurrentGraph(state) {
  const scopedGraph = GetCurrentScopedGraph(state);
  return scopedGraph; // if (currentGraph) {
  //     currentGraph = Graphs(state, currentGraph);
  // }
  // return currentGraph;
}
function GetCurrentTheme(state) {
  const graph = GetCurrentGraph(state);
  const {
    themeColors = {},
    themeColorUses = {},
    themeOtherUses = {},
    themeGridPlacements = {
      grids: []
    },
    themeFonts = {
      fonts: []
    },
    themeVariables = {
      variables: []
    }
  } = graph;
  return {
    themeColors,
    themeColorUses,
    themeOtherUses,
    themeGridPlacements,
    themeFonts,
    themeVariables
  };
}
function GetRootGraph(state, dispatch) {
  let currentGraph = Application(state, CURRENT_GRAPH);

  if (currentGraph) {
    currentGraph = Graphs(state, currentGraph);
  } else if (dispatch) {
    currentGraph = createGraph();
    SaveApplication(currentGraph.id, CURRENT_GRAPH, dispatch);
  }

  return currentGraph;
}
function GetSubGraphs(state) {
  let currentGraph = Application(state, CURRENT_GRAPH);

  if (currentGraph) {
    currentGraph = Graphs(state, currentGraph);
    const subgraphs = getSubGraphs(currentGraph);
    return subgraphs;
  }

  return null;
}
function uiactions_addNewSubGraph() {
  return (dispatch, getState) => {
    let rootGraph = GetRootGraph(getState(), dispatch);
    rootGraph = addNewSubGraph(rootGraph);
    SaveGraph(rootGraph, dispatch);
  };
}
function setRootGraph(key, value) {
  return (dispatch, getState) => {
    let rootGraph = GetRootGraph(getState(), dispatch);
    rootGraph = { ...rootGraph,
      ...{
        [key]: value
      }
    };
    SaveGraph(rootGraph, dispatch);
  };
}
function setAppsettingsAssemblyPrefixes(prefixes) {
  return (dispatch, getState) => {
    const rootGraph = GetRootGraph(getState(), dispatch);
    rootGraph.appConfig.AppSettings.AssemblyPrefixes = ["RedQuick", prefixes].unique(x => x).join(";");
    rootGraph.appConfig.AppSettings.DatabaseId = [prefixes].unique(x => x).join(";");
    SaveGraph(rootGraph, dispatch);
  };
}
function GetCurrentScopedGraph(state, dispatch) {
  state = state || GetState();
  let currentGraph = Application(state, CURRENT_GRAPH);
  const scope = Application(state, GRAPH_SCOPE) || [];

  if (!currentGraph) {
    if (dispatch) {
      currentGraph = createGraph();
      SaveApplication(currentGraph.id, CURRENT_GRAPH, dispatch);
    }
  } else {
    currentGraph = Graphs(state, currentGraph);

    if (scope.length) {
      currentGraph = getScopedGraph(currentGraph, {
        scope
      });
    }
  }

  return currentGraph;
}
const SELECTED_TAB = "SELECTED_TAB";
const DEFAULT_TAB = "DEFAULT_TAB";
const SIDE_PANEL_OPEN = "side-panel-open";
const PARAMETER_TAB = "PARAMETER_TAB";
const SCOPE_TAB = "SCOPE_TAB";
const QUICK_MENU = "QUICK_MENU";
function uiactions_newNode() {
  graphOperation(NEW_NODE)(_dispatch, _getState);
  setVisual(SIDE_PANEL_OPEN, true)(_dispatch, _getState);
  setVisual(SELECTED_TAB, DEFAULT_TAB)(_dispatch, _getState);
}
function GetSelectedSubgraph(state) {
  const root = GetRootGraph(state);

  if (root) {
    const scope = Application(state, GRAPH_SCOPE);

    if (scope && scope.length) {
      return getSubGraph(root, scope);
    }
  }

  return null;
}
function GetViewTypeModel(node) {
  const models = GetNodesLinkedTo(GetCurrentGraph(), {
    id: node,
    link: nodetypes_LinkType.DefaultViewType
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.Model);
  return models[0] || null;
}
function BuildPackage(model, _package) {
  const {
    id
  } = model;
  const methodFunctionDefinition = MethodFunctions[_package.methodType];

  if (methodFunctionDefinition) {
    const {
      constraints
    } = methodFunctionDefinition;
    Object.keys(constraints).values(_const => {
      const {
        key
      } = _const;
    });
  }
}
const ComponentApiKeys = {
  DATA: "data",
  Value: "value",
  Item: "item",
  ViewModel: 'viewModel',
  Index: "index",
  Separators: "separators",
  Error: "error"
};
const UPDATE_GRAPH_TITLE = "UPDATE_GRAPH_TITLE";
const NEW_NODE = "NEW_NODE";
const REMOVE_NODE = "REMOVE_NODE";
const NEW_LINK = "NEW_LINK";
const CHANGE_NODE_TEXT = "CHANGE_NODE_TEXT";
const CURRENT_GRAPH = "CURRENT_GRAPH";
const GRAPH_SCOPE = "GRAPH_SCOPE";
const ADD_DEFAULT_PROPERTIES = "ADD_DEFAULT_PROPERTIES";
const CHANGE_APP_SETTINGS = "CHANGE_APP_SETTINGS";
const CHANGE_NODE_PROPERTY = "CHANGE_NODE_PROPERTY";
const NEW_PROPERTY_NODE = "NEW_PROPERTY_NODE";
const NEW_PERMISSION_NODE = "NEW_PERMISSION_NODE";
const NEW_ATTRIBUTE_NODE = "NEW_ATTRIBUTE_NODE";
const uiactions_ADD_LINK_BETWEEN_NODES = "ADD_LINK_BETWEEN_NODES";
const ADD_TO_GROUP = 'ADD_TO_GROUP';
const ESTABLISH_SCOPE = "ESTABLISH_SCOPE";
const ADD_LINKS_BETWEEN_NODES = "ADD_LINKS_BETWEEN_NODES";
const UPDATE_NODE_DIRTY = "UPDATE_NODE_DIRTY";
const NEW_CONDITION_NODE = "NEW_CONDITION_NODE";
const ADD_NEW_NODE = "ADD_NEW_NODE";
const uiactions_REMOVE_LINK_BETWEEN_NODES = "REMOVE_LINK_BETWEEN_NODES";
const REMOVE_LINK = "REMOVE_LINK";
const NEW_CHOICE_ITEM_NODE = "NEW_CHOICE_ITEM_NODE";
const NO_OP = "NO_OP";
const NEW_PARAMETER_NODE = "NEW_PARAMETER_NODE";
const NEW_FUNCTION_OUTPUT_NODE = "NEW_FUNCTION_OUTPUT_NODE";
const NEW_MODEL_ITEM_FILTER = "NEW_MODEL_ITEM_FILTER";
const NEW_AFTER_METHOD = "NEW_AFTER_METHOD";
const NEW_VALIDATION_ITEM_NODE = "NEW_VALIDATION_ITEM_NODE";
const NEW_CHOICE_TYPE = "NEW_CHOICE_TYPE";
const NEW_VALIDATION_TYPE = "NEW_VALIDATION_TYPE";
const NEW_OPTION_ITEM_NODE = "NEW_OPTION_ITEM_NODE";
const NEW_OPTION_NODE = "NEW_OPTION_NODE";
const NEW_CUSTOM_OPTION = "NEW_CUSTOM_OPTION";
const UPDATE_NODE_PROPERTY = "UPDATE_NODE_PROPERTY";
const UPDATE_GROUP_PROPERTY = "UPDATE_GROUP_PROPERTY";
const CONNECT_TO_TITLE_SERVICE = "CONNECT_TO_TITLE_SERVICE";
const NEW_DATA_SOURCE = "NEW_DATA_SOURCE";
const NEW_COMPONENT_NODE = "NEW_COMPONENT_NODE";
const NEW_PERMISSION_PROPERTY_DEPENDENCY_NODE = "NEW_PERMISSION_PROPERTY_DEPENDENCY_NODE";
const NEW_EXTENSION_LIST_NODE = "NEW_EXTENSION_LIST_NODE";
const NEW_EXTENTION_NODE = "NEW_EXTENTION_NODE";
const NEW_SCREEN_OPTIONS = "NEW_SCREEN_OPTIONS";
const ADD_EXTENSION_DEFINITION_CONFIG_PROPERTY = "ADD_EXTENSION_DEFINITION_CONFIG_PROPERTY";
const APPLY_FUNCTION_CONSTRAINTS = "APPLY_FUNCTION_CONSTRAINTS";
const ADD_NEW_REFERENCE_NODE = "ADD_NEW_REFERENCE_NODE;";
const UPDATE_LINK_PROPERTY = "UPDATE_LINK_PROPERTY";
const SET_DEPTH = "SET_DEPTH";
function PerformGraphOperation(commands) {
  return graphOperation(commands);
}
function executeGraphOperation(model, op, args = {}) {
  return (dispatch, getState) => {
    op.method({
      model,
      dispatch,
      getState,
      ...args
    });
  };
} // export function executeGraphOperations(model, ops, args = {}) {
//     return (dispatch, getState) => {
//         var promise = Promise.resolve();
//         ops.map(op => {
//             promise = promise.then(() => {
//                 return op.method({ model, dispatch, getState, ...args });
//             })
//         });
//     }
// }

function GetNodesLinkTypes(id) {
  return getNodesLinkTypes(GetCurrentGraph(GetState()), {
    id
  });
}
function addInstanceFunc(node, callback, viewPackages, option = {}) {
  viewPackages = viewPackages || {};
  return function () {
    if (typeof node === 'function') {
      node = node();
    }

    if (option.lifeCycle) {
      return {
        nodeType: uiactions_NodeTypes.LifeCylceMethodInstance,
        parent: node.id,
        linkProperties: {
          properties: uiactions_LinkProperties.LifeCylceMethodInstance
        },
        callback,
        groupProperties: {},
        properties: {
          [uiactions_NodeProperties.UIText]: `${GetNodeTitle(node)} Instance`,
          [uiactions_NodeProperties.AutoDelete]: {
            properties: {
              [uiactions_NodeProperties.NODEType]: uiactions_NodeTypes.ComponentApiConnector
            }
          }
        }
      };
    }

    return {
      nodeType: uiactions_NodeTypes.EventMethodInstance,
      parent: node.id,
      groupProperties: {},
      linkProperties: {
        properties: { ...uiactions_LinkProperties.EventMethodInstance
        }
      },
      properties: {
        [uiactions_NodeProperties.UIText]: `${GetNodeTitle(node)} Instance`,
        [uiactions_NodeProperties.Pinned]: false,
        ...viewPackages,
        [uiactions_NodeProperties.AutoDelete]: {
          properties: {
            [uiactions_NodeProperties.NODEType]: uiactions_NodeTypes.ComponentApiConnector
          }
        }
      },
      callback
    };
  };
}
function executeGraphOperations(operations) {
  return (dispatch, getState) => {
    operations.map(t => {
      const {
        node,
        method,
        options
      } = t;
      method.method({
        model: node,
        dispatch,
        getState,
        ...options
      });
    });
  };
}
function selectAllConnected(id) {
  return (dispatch, getState) => {
    const nodes = GetNodesLinkedTo(GetCurrentGraph(getState()), {
      id
    });
    graphOperation([...[...nodes, GetNodeById(id)].map(t => {
      return {
        operation: CHANGE_NODE_PROPERTY,

        options() {
          return {
            prop: uiactions_NodeProperties.Selected,
            value: true,
            id: t.id
          };
        }

      };
    })])(dispatch, getState);
  };
}
function selectAllInViewPackage(id) {
  return (dispatch, getState) => {
    const node = GetNodeById(id);
    const nodes = GetNodesByProperties({
      [uiactions_NodeProperties.ViewPackage]: uiactions_GetNodeProp(node, uiactions_NodeProperties.ViewPackage)
    });
    graphOperation([...[...nodes].map(t => {
      return {
        operation: CHANGE_NODE_PROPERTY,

        options() {
          return {
            prop: uiactions_NodeProperties.Selected,
            value: true,
            id: t.id
          };
        }

      };
    })])(dispatch, getState);
  };
}
function pinSelected() {
  return (dispatch, getState) => {
    const nodes = GetNodesByProperties({
      [uiactions_NodeProperties.Selected]: true
    });
    graphOperation(nodes.map(t => {
      return {
        operation: CHANGE_NODE_PROPERTY,

        options() {
          return {
            prop: uiactions_NodeProperties.Pinned,
            value: true,
            id: t.id
          };
        }

      };
    }))(dispatch, getState);
  };
}
function addAllOfType(args) {
  return (dispatch, getState) => {
    const {
      properties,
      target,
      source
    } = args;
    const nodes = uiactions_NodesByType(getState(), uiactions_GetNodeProp(target, uiactions_NodeProperties.NODEType));
    graphOperation(nodes.map(v => {
      return {
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: {
          target: v.id,
          source,
          properties
        }
      };
    }))(dispatch, getState);
  };
}
function unPinSelected() {
  return (dispatch, getState) => {
    const nodes = GetNodesByProperties({
      [uiactions_NodeProperties.Selected]: true
    });
    graphOperation(nodes.map(t => {
      return {
        operation: CHANGE_NODE_PROPERTY,

        options() {
          return {
            prop: uiactions_NodeProperties.Pinned,
            value: false,
            id: t.id
          };
        }

      };
    }))(dispatch, getState);
  };
}
function deleteAllSelected() {
  return (dispatch, getState) => {
    graphOperation(GetNodesByProperties({
      [uiactions_NodeProperties.Selected]: true
    }).map(t => ({
      operation: REMOVE_NODE,
      options: {
        id: t.id
      }
    })))(dispatch, getState);
  };
}
function uiactions_setViewPackageStamp(viewPackage) {
  setViewPackageStamp(viewPackage);
}
function graphOperation(operation, options, stamp) {
  return (dispatch, getState) => {
    if (stamp) {
      const viewPackage = {
        [uiactions_NodeProperties.ViewPackage]: uuidv4()
      };
      uiactions_setViewPackageStamp(viewPackage, stamp);
    }

    const state = getState();
    let rootGraph = null;
    let currentGraph = Application(state, CURRENT_GRAPH);
    const scope = Application(state, GRAPH_SCOPE) || [];

    if (!currentGraph) {
      currentGraph = createGraph();
      SaveApplication(currentGraph.id, CURRENT_GRAPH, dispatch);
      rootGraph = currentGraph;
    } else {
      currentGraph = Graphs(state, currentGraph);
      rootGraph = currentGraph;

      if (scope.length) {
        currentGraph = getScopedGraph(currentGraph, {
          scope
        });
      }
    }

    let operations = operation;

    if (!Array.isArray(operation)) {
      operations = [{
        operation,
        options
      }];
    }

    operations.filter(x => x).forEach(_op => {
      if (typeof _op === "function") {
        _op = _op(currentGraph);
      }

      if (!Array.isArray(_op) && _op) {
        _op = [_op];
      }

      if (_op) _op.filter(x => x).forEach(opSecondLevel => {
        if (typeof opSecondLevel === "function") {
          opSecondLevel = opSecondLevel() || {};
        }

        let deepOp = opSecondLevel;

        if (!Array.isArray(opSecondLevel)) {
          deepOp = [opSecondLevel];
        }

        deepOp.filter(x => x).forEach(op => {
          let {
            operation,
            options
          } = op;

          if (typeof options === "function") {
            options = options(currentGraph);
          }

          if (options) {
            const currentLastNode = currentGraph.nodes && currentGraph.nodes.length ? currentGraph.nodes[currentGraph.nodes.length - 1] : null;
            const currentLastGroup = currentGraph.groups && currentGraph.groups.length ? currentGraph.groups[currentGraph.groups.length - 1] : null;

            switch (operation) {
              case NO_OP:
                break;

              case SET_DEPTH:
                currentGraph = setDepth(currentGraph, options);
                break;

              case NEW_NODE:
                currentGraph = graph_methods_newNode(currentGraph, options);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case REMOVE_NODE:
                currentGraph = removeNode(currentGraph, options);
                break;

              case UPDATE_GRAPH_TITLE:
                currentGraph = updateGraphTitle(currentGraph, options);
                break;

              case UPDATE_NODE_DIRTY:
                currentGraph = updateNodePropertyDirty(currentGraph, options);
                break;

              case NEW_LINK:
                currentGraph = newLink(currentGraph, options);
                break;

              case uiactions_ADD_LINK_BETWEEN_NODES:
                currentGraph = addLinkBetweenNodes(currentGraph, options);
                break;

              case ADD_TO_GROUP:
                currentGraph = updateNodeGroup(currentGraph, options);
                break;

              case ADD_LINKS_BETWEEN_NODES:
                currentGraph = addLinksBetweenNodes(currentGraph, options);
                break;

              case CONNECT_TO_TITLE_SERVICE:
                const titleService = GetTitleService(currentGraph);

                if (titleService) {
                  currentGraph = addLinkBetweenNodes(currentGraph, {
                    source: options.id,
                    target: titleService.id,
                    properties: { ...uiactions_LinkProperties.TitleServiceLink,
                      singleLink: true,
                      nodeTypes: [uiactions_NodeTypes.TitleService]
                    }
                  });
                }

                break;

              case uiactions_REMOVE_LINK_BETWEEN_NODES:
                currentGraph = removeLinkBetweenNodes(currentGraph, options);
                break;

              case REMOVE_LINK:
                currentGraph = removeLinkById(currentGraph, options);
                break;

              case UPDATE_GROUP_PROPERTY:
                currentGraph = updateGroupProperty(currentGraph, options);
                break;

              case CHANGE_NODE_TEXT:
                currentGraph = updateNodeProperty(currentGraph, { ...options,
                  prop: "text"
                });
                break;

              case CHANGE_NODE_PROPERTY:
                currentGraph = updateNodeProperty(currentGraph, options);
                break;

              case CHANGE_APP_SETTINGS:
                currentGraph = updateAppSettings(currentGraph, options);
                break;

              case NEW_PROPERTY_NODE:
                currentGraph = addNewPropertyNode(currentGraph, options);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case ADD_DEFAULT_PROPERTIES:
                currentGraph = addDefaultProperties(currentGraph, options);
                break;

              case NEW_ATTRIBUTE_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.Attribute);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case UPDATE_NODE_PROPERTY:
                currentGraph = updateNodeProperties(currentGraph, options);
                break;

              case NEW_CONDITION_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.Condition);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case ADD_NEW_NODE:
                if (options && options.nodeType) {
                  currentGraph = addNewNodeOfType(currentGraph, options, options.nodeType, options.callback);
                  setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                }

                break;

              case NEW_MODEL_ITEM_FILTER:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ModelItemFilter);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_AFTER_METHOD:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.AfterEffect);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_COMPONENT_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ComponentNode);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_DATA_SOURCE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.DataSource);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_VALIDATION_TYPE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ValidationList);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_PERMISSION_PROPERTY_DEPENDENCY_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.PermissionDependency);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case UPDATE_LINK_PROPERTY:
                currentGraph = updateLinkProperty(currentGraph, options);
                break;

              case NEW_CHOICE_TYPE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ChoiceList);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_PARAMETER_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.Parameter);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_FUNCTION_OUTPUT_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.FunctionOutput);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_PERMISSION_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.Permission);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_OPTION_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.OptionList);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_CUSTOM_OPTION:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.OptionCustom);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_SCREEN_OPTIONS:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ScreenOption);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case ADD_NEW_REFERENCE_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ReferenceNode);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_EXTENSION_LIST_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ExtensionTypeList);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_VALIDATION_ITEM_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ValidationListItem);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_EXTENTION_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.ExtensionType);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case NEW_OPTION_ITEM_NODE:
                currentGraph = addNewNodeOfType(currentGraph, options, uiactions_NodeTypes.OptionListItem);
                setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);
                break;

              case APPLY_FUNCTION_CONSTRAINTS:
                currentGraph = applyFunctionConstraints(currentGraph, options); // setVisual(SELECTED_NODE, currentGraph.nodes[currentGraph.nodes.length - 1])(dispatch, getState);

                break;

              case ADD_EXTENSION_DEFINITION_CONFIG_PROPERTY:
                break;

              default:
                break;
            }

            if (uiactions_recording && Visual(state, RECORDING)) {
              uiactions_recording.push({
                operation,
                options,
                callbackGroup: `group-${currentLastGroup !== currentGraph.groups[currentGraph.groups.length - 1] ? currentGraph.groups[currentGraph.groups.length - 1] : null}`,
                callback: currentLastNode !== currentGraph.nodes[currentGraph.nodes.length - 1] ? currentGraph.nodes[currentGraph.nodes.length - 1] : null
              });
            }
          }

          currentGraph = applyConstraints(currentGraph);
          currentGraph = constraintSideEffects(currentGraph);
        });
      });
    });

    if (scope.length) {
      rootGraph = setScopedGraph(rootGraph, {
        scope,
        graph: currentGraph
      });
    } else {
      rootGraph = currentGraph;
    }

    rootGraph = updateReferenceNodes(rootGraph);
    if (stamp) uiactions_setViewPackageStamp(null, stamp);
    SaveGraph(rootGraph, dispatch);
  };
}
function updateGraph(property, value) {
  return dispatch => {
    let graph = GetCurrentGraph();
    graph = updateGraphProperty({ ...graph
    }, {
      prop: property,
      value
    });
    SaveGraph(graph, dispatch);
  };
}
let uiactions_recording = [];
function GetRecording() {
  return uiactions_recording;
}
function clearRecording() {
  return (dispatch, getState) => {
    uiactions_recording = [];
  };
}
const Colors = {
  SelectedNode: "#f39c12",
  MarkedNode: "#af10fe"
};

(array => {
  if (!array.toNodeSelect) {
    Object.defineProperty(array, "toNodeSelect", {
      enumerable: false,
      writable: true,
      configurable: true,

      value() {
        const collection = this;
        return collection.map(node => {
          return {
            value: node.id,
            id: node.id,
            title: GetNodeTitle(node)
          };
        });
      }

    });
  }
})(Array.prototype);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__("path");
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);

// CONCATENATED MODULE: ./app/generators/namespacegenerator.js





const NAME_SPACE_TEMPLATE = './app/templates/namespace.tpl';
class namespacegenerator_NamespaceGenerator {
  static Generate(options) {
    var {
      template,
      namespace,
      space,
      usings
    } = options;
    let namespaceTemplate = external_fs_default.a.readFileSync(NAME_SPACE_TEMPLATE, 'utf8');
    let ext_nodes = uiactions_NodesByType(GetState(), [uiactions_NodeTypes.ExtensionType, uiactions_NodeTypes.ExtensionTypeList]);

    if (!ext_nodes.length) {
      usings = (usings || []).filter(x => x.indexOf(`${namespace}${nodetypes_NameSpace.Extensions}`) === -1);
    }

    namespaceTemplate = bindTemplate(namespaceTemplate, {
      namespace,
      space,
      imports: usings ? usings.map(x => `using ${x};`).unique(x => x).join('\r\n') : null,
      body: template
    });
    return namespaceTemplate;
  }

}
// CONCATENATED MODULE: ./app/generators/controllergenerator.js






const CONTROLLER_CLASS_TEMPLATE = "./app/templates/controller/controller.tpl";
const CONTROLLER_CLASS_FUNCTION_TEMPLATE = "./app/templates/controller/controller_functions.tpl";
const CONTROLLER_CLASS_FUNCTION_GET_TEMPLATE = "./app/templates/controller/controller_functions_get.tpl";
const PROPERTY_TABS = 6;
class controllergenerator_ControllerGenerator {
  static Tabs(c) {
    let res = "";

    for (var i = 0; i < c; i++) {
      res += TAB;
    }

    return res;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let controllers = uiactions_NodesByType(state, uiactions_NodeTypes.Controller).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration));

    let _controllerTemplateClass = external_fs_default.a.readFileSync(CONTROLLER_CLASS_TEMPLATE, "utf8");

    let _controllerTemplateFunction = external_fs_default.a.readFileSync(CONTROLLER_CLASS_FUNCTION_TEMPLATE, "utf8");

    let _controllerTemplateFunctionGet = external_fs_default.a.readFileSync(CONTROLLER_CLASS_FUNCTION_GET_TEMPLATE, "utf8");

    let root = GetRootGraph(state);
    let result = {};
    controllers.map(controller => {
      let controllerTemplateClass = _controllerTemplateClass;
      let functions = "";
      let statics = "";
      let codeName = `${uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName)}`;
      let userNode = uiactions_NodesByType(state, uiactions_NodeTypes.Model).find(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsUser));
      let maestro_functions = [];
      let maestros = getNodesByLinkType(root, {
        id: controller.id,
        type: nodetypes_LinkType.MaestroLink,
        direction: SOURCE
      }).map(maestro => {
        let tempfunctions = getNodesByLinkType(root, {
          id: maestro.id,
          type: nodetypes_LinkType.FunctionLink,
          direction: SOURCE
        });
        let maestroName = uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName);
        maestro_functions = tempfunctions;

        if (maestro_functions.length) {
          maestro_functions.filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.NotIncludedInController)).map(maestro_function => {
            var ft = MethodFunctions[uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.FunctionType)];

            if (ft) {
              let tempFunction = ft.controller || _controllerTemplateFunction;
              let parameters = "";
              let parameter_route = "";
              let parameter_values = ""; //If the function is a get then, use the get template.

              if (!ft.controller) if ([nodetypes_Methods.Get, nodetypes_Methods.GetAll].some(v => v === uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.MethodType))) {
                tempFunction = _controllerTemplateFunctionGet;
                let paramName = "modelId";

                if (ft.parentGet) {
                  paramName = "parentId";
                }

                parameters = `string ${paramName}`;
                parameter_route = `/{${paramName}}`;
                parameter_values = `${paramName}`;
              }

              if (ft.controller_parameters) {
                let methodprops = GetMethodProps(maestro_function);
                parameters = ft.controller_parameters.params.map(cp => {
                  return `${GetCodeName(methodprops[cp])} ${cp}`;
                }).join();
                parameter_route = "";
                parameter_values = ft.controller_parameters.params.map(cp => {
                  return `${cp}`;
                }).join();
              }

              let codeNode = uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.CodeName);
              let tempfunctions = getNodesByLinkType(root, {
                id: maestro_function.id,
                type: nodetypes_LinkType.FunctionConstraintLink,
                direction: SOURCE
              });
              let functionName = `${uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.CodeName)}`;
              let httpMethod = `${uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.HttpMethod)}`;
              let httpRoute = `${uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.HttpRoute)}`;
              let methodProperties = uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.MethodProps);
              if (!methodProperties) return;
              let modelNode = GetNode(root, methodProperties.model);
              let fetch_parameter = GetNode(root, methodProperties.fetch_parameter);
              let compositeInput = GetNode(graphRoot, methodProperties[FunctionTemplateKeys.CompositeInput]);
              let output_type = "{controller_generator_missing_model}";

              if (modelNode) {
                output_type = uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName) || output_type;

                if (ft.isList) {
                  output_type = `IList<${output_type}>`;
                }
              }

              tempFunction = bindTemplate(tempFunction, {
                functionName: functionName,
                maestro_function: functionName,
                parameters,
                parameter_values,
                parameter_route,
                http_route: httpRoute || "{controller_generator_http_method",
                http_method: httpMethod || "{controller_generator_http_method",
                user_instance: controller ? uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeUser) : "{controller_generator_code_name}",
                output_type: output_type,
                fetch_parameter: GetCodeName(fetch_parameter),
                maestro_interface: ToInterface(maestroName),
                input_type: compositeInput || modelNode ? GetCodeName(compositeInput || modelNode) : "{controller_generator_missing_model}"
              }); // let template = ft.template;
              // if (ft.template_keys) {
              //     for (var template_key in template_key) {
              //         for (var modifiers in TEMPLATE_KEY_MODIFIERS) {
              //         }
              //     }
              // }

              functions += jNL + tempFunction;
            }
          });
        }

        controllerTemplateClass = bindTemplate(controllerTemplateClass, {
          codeName: codeName,
          "codeName#alllower": codeName.toLowerCase(),
          user_instance: controller ? uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeUser) : "{controller_generator_code_name}",
          user: userNode ? uiactions_GetNodeProp(userNode, uiactions_NodeProperties.CodeName) : "{controller_generator_code_name}",
          functions
        });
      });
      result[uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName),
        name: uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName),
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: controllerTemplateClass,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, "Microsoft.AspNetCore.Mvc"],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
const NL = `
                    `;
const jNL = `
`;
const TAB = `   `;
// CONCATENATED MODULE: ./app/generators/modelgenerators.js


/* eslint-disable no-underscore-dangle */






const MODEL_TEMPLATE = "./app/templates/models/model.tpl";
const MODEL_PROPERTY_TEMPLATE = "./app/templates/models/model_property.tpl";
const MODEL_STATIC_TEMPLATES = "./app/templates/models/model_statics.tpl";
const MODEL_ATTRIBUTE_TEMPLATE = "./app/templates/models/model_attributes.tpl";
class modelgenerators_ModelGenerator {
  static Generate(options) {
    const {
      state
    } = options;
    const graphRoot = GetRootGraph(state);
    const models = uiactions_NodesByType(state, NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration));
    const result = {};
    models.map(model => {
      const res = modelgenerators_ModelGenerator.GenerateModel({
        graph: graphRoot,
        nodeId: model.id,
        state
      });
      result[res.id] = res;
    });
    return result;
  }

  static GenerateModel(options) {
    const {
      state,
      graph,
      nodeId
    } = options;
    const usings = [];
    const templateSwapDictionary = {};
    const graphRoot = GetRootGraph(state);
    const namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    const node = GetNode(graph, nodeId);

    if (!node) {
      return null;
    }

    templateSwapDictionary.model = uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName);
    templateSwapDictionary.base_model = uiactions_GetNodeProp(node, uiactions_NodeProperties.IsUser) ? "RedUser" : "DBaseData";
    templateSwapDictionary.account_enabling_func = "";

    if (uiactions_GetNodeProp(node, uiactions_NodeProperties.IsUser)) {
      templateSwapDictionary.account_enabling_func = `

        public static User Create(RedExternalLoginViewModel model)
        {
            return new User
            {
                Email = model.Email,
                UserName = model.UserName
            };
        }
        public static User Create(RedRegisterViewModel model)
        {
            return new User
            {
                Email = model.Email,
                UserName = model.UserName
            };
        }`;
    }

    templateSwapDictionary.attributes = "";
    let connectedProperties = GetModelPropertyChildren(node.id); //Get all properties including link to other models
    //  GraphMethods.getNodesByLinkType(graph, {
    //   id: node.id,
    //   type: LinkType.PropertyLink,
    //   direction: GraphMethods.SOURCE
    // });

    const logicalParents = []; // No more having parents referencing back.
    //  GraphMethods.getNodesByLinkType(graph, {
    //   id: node.id,
    //   type: LinkType.LogicalChildren,
    //   direction: GraphMethods.TARGET
    // }).filter(x => x.id !== node.id);

    connectedProperties = [...connectedProperties, ...logicalParents];
    const propertyTemplate = external_fs_default.a.readFileSync(MODEL_PROPERTY_TEMPLATE, "utf8");
    const attributeTemplate = external_fs_default.a.readFileSync(MODEL_ATTRIBUTE_TEMPLATE, "utf8");
    const staticFunctionTemplate = external_fs_default.a.readFileSync(MODEL_STATIC_TEMPLATES, "utf8");
    const validatorFunctions = getNodesByLinkType(graph, {
      id: nodeId,
      type: nodetypes_LinkType.ValidatorModel,
      direction: graph_methods_TARGET
    }).map(t => uiactions_GetNodeProp(t, uiactions_NodeProperties.CodeName)).map(t => modelgenerators_ModelGenerator.tabs(1) + `[${t}]` + nodetypes_NEW_LINE).join("");
    templateSwapDictionary.attributes = validatorFunctions;
    const staticFunctions = [];
    const properties = connectedProperties.filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.IsDefaultProperty)).filter(x => x.id !== nodeId).map(propNode => {
      const connectedAttributes = getNodesByLinkType(graph, {
        id: propNode.id,
        type: nodetypes_LinkType.AttributeLink,
        direction: SOURCE
      });
      let propertyInstanceTemplate = propertyTemplate;
      const np = uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UIAttributeType) || uiactions_NodePropertyTypes.STRING;

      if (Usings[ProgrammingLanguages.CSHARP][np]) {
        usings.push(...Usings[ProgrammingLanguages.CSHARP][np], `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Extensions}`);
      }

      let propType = NodePropertyTypesByLanguage[ProgrammingLanguages.CSHARP][np];

      if (uiactions_GetNodeProp(propNode, uiactions_NodeProperties.IsTypeList)) {
        const types = GetNodesLinkedTo(graph, {
          id: propNode.id,
          link: nodetypes_LinkType.ModelTypeLink
        });

        if (types && types.length) {
          propType = GetCodeName(types[0]);
          propType = `IList<${propType}>`;
        }
      } else if (uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UIModelType)) {
        propType = "string";
      } else if (uiactions_GetNodeProp(propNode, uiactions_NodeProperties.NODEType) === NodeTypes.Model) {
        let propLink = GetLinkBetween(nodeId, propNode.id, graph);

        if (propLink) {
          switch (GetLinkProperty(propLink, LinkPropertyKeys.TYPE)) {
            case nodetypes_LinkType.UserLink:
              throw new Error('unhandled');

            default:
              propType = "IList<string>"; // changed from string => ilist<string> cause we are keeping references with the model.

              break;
          }
        } else {
          propLink = GetLinkBetween(propNode.id, nodeId, graph);

          switch (GetLinkProperty(propLink, LinkPropertyKeys.TYPE)) {
            case nodetypes_LinkType.UserLink:
              propType = 'string';
              return false;

            default:
              throw new Error('unhandled');
          }
        }
      }

      if (uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UseModelAsType)) {
        if (uiactions_GetNodeProp(propNode, uiactions_NodeProperties.IsReferenceList)) {
          propType = `IList<${propType}>`;
        }
      }

      const propSwapDictionary = {
        model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        property_type: propType,
        property: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.CodeName),
        attributes: connectedAttributes.map(attr => {
          const optionLists = getNodesByLinkType(graph, {
            id: attr.id,
            type: nodetypes_LinkType.Option,
            direction: SOURCE
          });
          let optionsList = [];
          optionLists.map(ol => {
            const ols = getNodesByLinkType(graph, {
              id: ol.id,
              type: nodetypes_LinkType.OptionItem,
              direction: SOURCE
            });
            ols.map(_ols => {
              if (uiactions_GetNodeProp(_ols, uiactions_NodeProperties.UseCustomUIOption)) {
                optionsList.push(uiactions_GetNodeProp(_ols, uiactions_NodeProperties.UIOptionTypeCustom));
              } else {
                optionsList.push(uiactions_GetNodeProp(_ols, uiactions_NodeProperties.UIOptionType));
              }
            });
          });
          optionsList = optionsList.unique().map(t => `UIAttribute.${t}`);
          const ReverseRules = {};
          Object.keys(ValidationRules).forEach(ruleKey => {
            ReverseRules[ValidationRules[ruleKey]] = ruleKey;
          });
          const validations = [];

          if (uiactions_GetNodeProp(attr, uiactions_NodeProperties.UseUIValidations)) {
            getNodesByLinkType(graph, {
              id: attr.id,
              type: nodetypes_LinkType.Validation,
              direction: SOURCE
            }).map(vnode => {
              getNodesByLinkType(graph, {
                id: vnode.id,
                type: nodetypes_LinkType.ValidationItem,
                direction: SOURCE
              }).map(vnodeItem => {
                validations.push(`ValidationRules.${ReverseRules[uiactions_GetNodeProp(vnodeItem, uiactions_NodeProperties.UIValidationType)]}`);
              });
            });
          }

          let choiceName = null;

          if (uiactions_GetNodeProp(attr, uiactions_NodeProperties.UIExtensionList)) {
            getNodesByLinkType(graph, {
              id: attr.id,
              type: nodetypes_LinkType.Extension,
              direction: SOURCE
            }).map(vnode => {
              choiceName = uiactions_GetNodeProp(vnode, uiactions_NodeProperties.CodeName);
            });
          }

          const options2 = optionsList && optionsList.length ? bindTemplate(`Options = new string[] { {{options_list}} },`, {
            options_list: optionsList.map(t => `${t}`).join(", ")
          }) : "";
          const validationRules = validations && validations.length ? bindTemplate(`ValidationRules = new string[] { {{validation_list}} },`, {
            validation_list: validations.map(t => `${t}`).join(", ")
          }) : "";
          const choiceType = choiceName ? bindTemplate("ChoiceType = {{choice_type}}.Name,", {
            choice_type: choiceName
          }) : "";
          const attributeSwapDictionary = {
            property: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.CodeName),
            property_type: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UseModelAsType) ? uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UIModelType) : uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UIAttributeType),
            ui_title: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UIName),
            singular: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.UISingular) ? "true" : "false",
            options: options2,
            choice_type: choiceType,
            validation_rules: validationRules
          };
          return bindTemplate(attributeTemplate, attributeSwapDictionary);
        }).filter(x => x).join("\r\n")
      };
      propertyInstanceTemplate = bindTemplate(propertyInstanceTemplate, propSwapDictionary);
      return propertyInstanceTemplate;
    }).filter(x => x);

    if (uiactions_GetNodeProp(node, uiactions_NodeProperties.HasLogicalChildren) && uiactions_GetNodeProp(node, uiactions_NodeProperties.ManyToManyNexus)) {
      (uiactions_GetNodeProp(node, uiactions_NodeProperties.LogicalChildrenTypes) || []).map(t => {
        const propNode = GetNode(GetCurrentGraph(state), t);
        const propSwapDictionary = {
          property_type: NodePropertyTypesByLanguage[ProgrammingLanguages.CSHARP][uiactions_NodePropertyTypes.STRING],
          property: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.CodeName),
          attributes: ""
        };
        properties.push(bindTemplate(propertyTemplate, propSwapDictionary));
      });
    }

    const staticDic = {
      model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)
    };

    const _properties = GetModelPropertyChildren(node.id, {
      skipLogicalChildren: false // now we are switching to references being held with the object.

    }).map(v => {
      const propType = uiactions_GetNodeProp(v, uiactions_NodeProperties.UIAttributeType);
      const nodeType = GetNodeType(v);

      if (nodeType === NodeTypes.Model) {
        const modelLink = GetLinkBetween(v.id, node.id, graph) || GetLinkBetween(node.id, v.id, graph);

        if (GetLinkProperty(modelLink, LinkPropertyKeys.TYPE) === nodetypes_LinkType.UserLink) {
          return `if(a.${GetCodeName(v)} == null) {
              model.${GetCodeName(v)} = b.${GetCodeName(v)};
            }`;
        }

        return `if(a.${GetCodeName(v)} == null || a.${GetCodeName(v)}.Count == 0) {
            model.${GetCodeName(v)} = b.${GetCodeName(v)};
          }`;
      }

      switch (propType) {
        case uiactions_NodePropertyTypes.STRING:
          return `if(string.IsNullOrEmpty(a.${GetCodeName(v)})){
            model.${GetCodeName(v)} = b.${GetCodeName(v)};
          }`;

        case uiactions_NodePropertyTypes.LISTOFSTRINGS:
        case uiactions_NodePropertyTypes.PHONENUMBER:
        case uiactions_NodePropertyTypes.EMAIL:
        case uiactions_NodePropertyTypes.DATETIME:
          return `if(a.${GetCodeName(v)} == null){
              model.${GetCodeName(v)} = b.${GetCodeName(v)};
            }`;

        case uiactions_NodePropertyTypes.BOOLEAN:
          return `if(!a.${GetCodeName(v)}){
              model.${GetCodeName(v)} = b.${GetCodeName(v)};
            }`;

        case uiactions_NodePropertyTypes.DOUBLE:
        case uiactions_NodePropertyTypes.FLOAT:
        case uiactions_NodePropertyTypes.INT:
          return `if(a.${GetCodeName(v)} == 0){
                  model.${GetCodeName(v)} = b.${GetCodeName(v)};
                }`;

        default:
          break;
      }

      return null;
    }).filter(x => x).join(nodetypes_NEW_LINE);

    staticDic.property_set_merge = _properties;
    staticFunctions.push(bindTemplate(staticFunctionTemplate, staticDic));

    if (uiactions_GetNodeProp(node, uiactions_NodeProperties.IsUser)) {
      const agenNodes = uiactions_NodesByType(state, NodeTypes.Model).filter(x => x.id !== node.id && uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
      agenNodes.map(agent => {
        let propertyInstanceTemplate = propertyTemplate;
        const propSwapDictionary = {
          property_type: NodePropertyTypesByLanguage[ProgrammingLanguages.CSHARP][uiactions_NodePropertyTypes.STRING],
          property: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          attributes: ""
        };
        propertyInstanceTemplate = bindTemplate(propertyInstanceTemplate, propSwapDictionary);
        properties.push(propertyInstanceTemplate);
      });
    }

    templateSwapDictionary.properties = properties.join("");
    templateSwapDictionary.staticFunctions = staticFunctions.unique(x => x).join("\n");
    let modelTemplate = external_fs_default.a.readFileSync(MODEL_TEMPLATE, "utf8");
    modelTemplate = bindTemplate(modelTemplate, templateSwapDictionary);
    const result = {
      id: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
      name: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
      template: namespacegenerator_NamespaceGenerator.Generate({
        template: modelTemplate,
        usings: [...usings, `RedQuickCore.Identity`, ...STANDARD_CONTROLLER_USING],
        namespace,
        space: nodetypes_NameSpace.Model
      })
    };
    return result;
  }

  static tabs(c) {
    let res = "";
    const TAB = "\t";

    for (let i = 0; i < c; i++) {
      res += TAB;
    }

    return res;
  }

}
// CONCATENATED MODULE: ./app/generators/extensiongenerator.js







const EXTENSION_CLASS_TEMPLATE = './app/templates/extensions/extensions.tpl';
const EXTENSION_PROPERTY_TEMPLATE = './app/templates/extensions/extension_properties.tpl';
const EXTENSION_NEW_INSTANCE = './app/templates/extensions/extension_new_instance.tpl';
const EXTENSION_NEW_PROPERTY = './app/templates/extensions/extension_new_instance_properties.tpl';
const EXTENSION_NEW_INSTANCE_LIST = './app/templates/extensions/extension_new_instance_list.tpl';
const EXTENSION_NEW_INSTANCE_LIST_ADD = './app/templates/extensions/extension_new_instance_list_add.tpl';
const EXTENSION_NEW_INSTANCE_DICTIONARY = './app/templates/extensions/extension_new_instance_dictionary.tpl';
const EXTENSION_NEW_INSTANCE_DICTIONARY_ADD = './app/templates/extensions/extension_new_instance_dictionary_add.tpl';
const EXTENSION_NEW_TEMPLATE_LIST = './app/templates/extensions/create_new_list_instance.tpl';
const extensiongenerator_PROPERTY_TABS = 6;
class extensiongenerator_ExtensionGenerator {
  static Tabs(c) {
    let res = '';

    for (var i = 0; i < c; i++) {
      res += extensiongenerator_TAB;
    }

    return res;
  }

  static GetExtensionNodeValues(extensionNode) {
    var def = uiactions_GetNodeProp(extensionNode, uiactions_NodeProperties.UIExtensionDefinition);

    if (def && def.config) {
      if (def.config.isEnumeration) {
        var extensionValues = def.config.list.map(t => {
          return def.config.keyField ? t[def.config.keyField] : t[Object.keys(t)[0]];
        });
        return extensionValues;
      }
    }

    throw new Error("unhandled - getting extensions nodes not as an enumeration");
  }

  static CreateListInstanceTemplate(options) {
    let {
      node,
      name
    } = options;

    let _newTemplateList = external_fs_default.a.readFileSync(EXTENSION_NEW_TEMPLATE_LIST, 'utf8');

    return bindTemplate(_newTemplateList, {
      name,
      model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)
    });
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let extensions = uiactions_NodesByType(state, uiactions_NodeTypes.ExtensionType);
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _extensionClassTemplate = external_fs_default.a.readFileSync(EXTENSION_CLASS_TEMPLATE, 'utf8');

    let _extensionPropertyTemplate = external_fs_default.a.readFileSync(EXTENSION_PROPERTY_TEMPLATE, 'utf8');

    let _extensionNewInstance = external_fs_default.a.readFileSync(EXTENSION_NEW_INSTANCE, 'utf8');

    let _extensionNewProperty = external_fs_default.a.readFileSync(EXTENSION_NEW_PROPERTY, 'utf8');

    let _extensionNewInstanceList = external_fs_default.a.readFileSync(EXTENSION_NEW_INSTANCE_LIST, 'utf8');

    let _extensionNewInstanceListAdd = external_fs_default.a.readFileSync(EXTENSION_NEW_INSTANCE_LIST_ADD, 'utf8');

    let _extensionNewInstanceDictionary = external_fs_default.a.readFileSync(EXTENSION_NEW_INSTANCE_DICTIONARY, 'utf8');

    let _extensionNewInstanceDictionaryAdd = external_fs_default.a.readFileSync(EXTENSION_NEW_INSTANCE_DICTIONARY_ADD, 'utf8');

    let result = {};
    extensions.map(extension => {
      let extensionClassTemplate = _extensionClassTemplate;
      let properties = '';
      let statics = '';
      var constants = [];
      let uiExtensionDefinition = uiactions_GetNodeProp(extension, uiactions_NodeProperties.UIExtensionDefinition);

      if (uiExtensionDefinition) {
        let modelName = uiactions_GetNodeProp(extension, uiactions_NodeProperties.CodeName);
        let {
          config,
          definition
        } = uiExtensionDefinition;

        if (definition) {
          definition = { ...definition,
            Value: 'string'
          };
          properties = Object.keys(definition).map(e => {
            var extensionPropertyTemplate = _extensionPropertyTemplate;
            extensionPropertyTemplate = bindTemplate(extensionPropertyTemplate, {
              name: modelName,
              property: e,
              type: definition[e]
            });
            return extensionPropertyTemplate;
          }).join('');

          if (config) {
            var instances = [];
            let instance = '';

            if (config.isEnumeration) {
              instances = config.list.map((item, item_index) => {
                item = { ...item,
                  Value: item_index + 1
                };
                let temp;
                let props = Object.keys(item).map(key => {
                  let temp = _extensionNewProperty;
                  temp = bindTemplate(temp, {
                    property: key,
                    value: MakeConstant(item[key])
                  });
                  if (isNaN(item[key])) constants.push({
                    name: MakeConstant(item[key]),
                    value: `"${item[key]}"`
                  });
                  return temp;
                }).join(`,${extensiongenerator_NL}`);
                temp = _extensionNewInstance;
                temp = bindTemplate(temp, {
                  properties: extensiongenerator_jNL + extensiongenerator_ExtensionGenerator.Tabs(extensiongenerator_PROPERTY_TABS) + props,
                  model: modelName
                });
                return temp;
              });
            } else {
              let temp;
              let props = Object.keys(config.dictionary).map(key => {
                let temp = _extensionNewProperty;
                let item = { ...config.dictionary
                };
                temp = bindTemplate(temp, {
                  property: key,
                  value: MakeConstant(item[key])
                });
                if (isNaN(item[key])) constants.push({
                  name: MakeConstant(item[key]),
                  value: `"${item[key]}"`
                });
                return temp;
              }).join(`,${extensiongenerator_NL}`);
              temp = _extensionNewInstance;
              temp = bindTemplate(temp, {
                properties: extensiongenerator_jNL + extensiongenerator_ExtensionGenerator.Tabs(extensiongenerator_PROPERTY_TABS) + props,
                model: modelName
              });
              instance = temp;
              let temp_instance = _extensionNewInstanceDictionary;
              temp_instance = bindTemplate(temp_instance, {
                instance,
                model: modelName
              });
              instance = temp_instance;
            }

            instances = instances.map(inst => {
              let temp = _extensionNewInstanceListAdd;
              temp = bindTemplate(temp, {
                instance: inst
              });
              return temp;
            });
            let templist = _extensionNewInstanceList;
            statics = bindTemplate(templist, {
              addings: instances.join(''),
              model: modelName
            }) + extensiongenerator_jNL + instance;
          }
        }
      }

      extensionClassTemplate = bindTemplate(extensionClassTemplate, {
        name: uiactions_GetNodeProp(extension, uiactions_NodeProperties.CodeName),
        properties,
        statics: statics,
        constants: constants.unique(x => x).map(co => extensiongenerator_jNL + extensiongenerator_ExtensionGenerator.Tabs(3) + ConstantsDeclaration(co)).join('')
      });
      result[uiactions_GetNodeProp(extension, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(extension, uiactions_NodeProperties.CodeName),
        name: uiactions_GetNodeProp(extension, uiactions_NodeProperties.CodeName),
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: extensionClassTemplate,
          usings: [...STANDARD_CONTROLLER_USING],
          namespace,
          space: nodetypes_NameSpace.Extensions
        })
      };
    });
    return result;
  }

}
const extensiongenerator_NL = `
                    `;
const extensiongenerator_jNL = `
`;
const extensiongenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/generators/permissiongenerator.js










const TEST_CASE = './app/templates/permissions/tests/test_case.tpl';
const TEST_CLASS = './app/templates/tests/tests.tpl';
const TEST_CASE_PROPERTY = './app/templates/permissions/tests/test_case_property.tpl';
const PERMISSIONS_INTERFACE = './app/templates/permissions/permissions_interface.tpl';
const PERMISSIONS_CASE_EXTENSION = './app/templates/permissions/permissions_case.tpl';
const PERMISSIONS_CASE_ENUMERATION = './app/templates/permissions/permissions_case_enumeration.tpl';
const PERMISSIONS_CASE_INCLUDED_IN_LIST = './app/templates/permissions/permissions_case_included_in_list.tpl';
const PERMISSIONS_METHODS = './app/templates/permissions/permissions_method.tpl';
const PERMISSIONS_ARBITER_PROP = './app/templates/permissions/permissions_arbiter_prop.tpl';
const PERMISSIONS_IMPL = './app/templates/permissions/permissions_impl.tpl';
const PERMISSIONS_INTERFACE_METHODS = './app/templates/permissions/permissions_interface_methods.tpl';
const MATCH_TO_MANY_REFERENCE_PARAMETER = './app/templates/permissions/match-many-reference-parameter.tpl';
const MANY_TO_MANY_CONSTRUCTOR = './app/templates/permissions/tests/many_to_many_constructor.tpl';
const MATCH_REFERENCE = './app/templates/permissions/match-reference.tpl';
const permissiongenerator_PROPERTY_TABS = 6;
class permissiongenerator_PermissionGenerator {
  static PermissionMatches(permission, agent, model) {
    var methodNode = GetPermissionMethod(permission);

    if (methodNode) {
      let function_type = GetFunctionType(methodNode);

      switch (function_type) {
        //Add more cases as required.
        case functiontypes_FunctionTypes.Get_Parent$Child_Agent_Value__IListChild:
        case functiontypes_FunctionTypes.Get_ManyToMany_Agent_Value__IListChild:
          var result = GetMethodNodeProp(methodNode, FunctionTemplateKeys.Agent) === agent.id && GetMethodNodeProp(methodNode, FunctionTemplateKeys.Parent) === model.id;
          return result;

        default:
          var result = GetMethodNodeProp(methodNode, FunctionTemplateKeys.Agent) === agent.id && (GetMethodNodeProp(methodNode, FunctionTemplateKeys.Model) === model.id || GetMethodNodeProp(methodNode, FunctionTemplateKeys.CompositeInput) === model.id);
          return result;
      }
    }

    return false;
  }

  static createInstanceEnumerationListName(dNode, enu, method, type = 'Enums') {
    return `list${type}${uiactions_GetNodeProp(dNode, uiactions_NodeProperties.CodeName) || dNode}${uiactions_GetNodeProp(enu, uiactions_NodeProperties.CodeName) || enu}${method}`;
  }

  static _createConstantList(name, constants) {
    let result = constants.map(ea => {
      return `${name}.${MakeConstant(ea)}`;
    });
    return result;
  } //Deprecated


  static _createEnumerationInstanceList(dpNode, enumerationNode, method) {
    var ext_allowed = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.AllowedEnumValues) || [];
    let enumerationName = uiactions_GetNodeProp(enumerationNode, uiactions_NodeProperties.CodeName);
    let constants_allowed = ext_allowed.map(ea => {
      return `${enumerationName}.${MakeConstant(ea)}`;
    });
    return constants_allowed;
  }

  static _getNotAllowedConstances(dpNode, enumerationNode, method) {
    var ext_disallowed = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.DisallowedEnumValues) || [];
    let enumerationName = uiactions_GetNodeProp(enumerationNode, uiactions_NodeProperties.CodeName);
    let constants_notallowed = ext_disallowed.map(ea => {
      return `${enumerationName}.${MakeConstant(ea)}`;
    });
    return constants_notallowed;
  }

  static createEnumerationInstanceList(dpNode, enumerationNode, method) {
    let name = permissiongenerator_PermissionGenerator.createInstanceEnumerationListName(dpNode, enumerationNode, method);

    let constants_allowed = permissiongenerator_PermissionGenerator._createEnumerationInstanceList(dpNode, enumerationNode, method); // var ext_allowed = GetNodeProp(dpNode, NodeProperties.AllowedEnumValues) || [];
    // let enumerationName = GetNodeProp(enumerationNode, NodeProperties.CodeName);
    // let constants_allowed = ext_allowed.map(ea => {
    //     return `${enumerationName}.${MakeConstant(ea)}`
    // })


    return `var ${name} = new List<string> { ${constants_allowed.map(t => permissiongenerator_jNL + permissiongenerator_Tabs(5) + t).join()} ${permissiongenerator_jNL + permissiongenerator_Tabs(5)}};${permissiongenerator_jNL}`;
  }

  static createStringList(options) {
    var {
      name,
      constants_allowed,
      enumerationName
    } = options;
    constants_allowed = constants_allowed.map(ea => {
      return `${enumerationName}.${MakeConstant(ea)}`;
    });
    return `var ${name} = new List<string> { ${constants_allowed.map(t => permissiongenerator_jNL + permissiongenerator_Tabs(5) + t).join()} ${permissiongenerator_jNL + permissiongenerator_Tabs(5)}};${permissiongenerator_jNL}`;
  }

  static _createExtensionInstanceList(dpNode, extensionNode, method, type = 'Enums') {
    var ext_allowed = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.AllowedExtensionValues) || [];
    let extensionName = uiactions_GetNodeProp(extensionNode, uiactions_NodeProperties.CodeName);
    let constants_allowed = ext_allowed.map(ea => {
      return `${extensionName}.${MakeConstant(ea)}`;
    });
    return constants_allowed;
  }

  static _getNotAllowedExtectionConstances(dpNode, extensionNode, method, type = 'Enums') {
    var ext_disallowed = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.DisallowedExtensionValues) || [];
    let extensionName = uiactions_GetNodeProp(extensionNode, uiactions_NodeProperties.CodeName);
    let constants_disallowed = ext_disallowed.map(ea => {
      return `${extensionName}.${MakeConstant(ea)}`;
    });
    return constants_disallowed;
  }

  static createExtensionInstanceList(dpNode, extensionNode, method, type = 'Enums') {
    let name = permissiongenerator_PermissionGenerator.createInstanceEnumerationListName(dpNode, extensionNode, method, 'Extensions');

    let constants_allowed = permissiongenerator_PermissionGenerator._createExtensionInstanceList(dpNode, extensionNode, method, type);

    return `var ${name} = new List<string> { ${constants_allowed.map(t => permissiongenerator_jNL + permissiongenerator_Tabs(5) + t).join()} ${permissiongenerator_jNL + permissiongenerator_Tabs(5)}};${permissiongenerator_jNL}`;
  }

  static IsRequestor(graph, model, permission) {
    var requestorNodes = getNodesByLinkType(graph, {
      id: permission.id,
      type: nodetypes_LinkType.RequestorPermissionLink
    });
    return !!requestorNodes.find(node => {
      return node.id === model.id;
    });
  }

  static GetExtensionNodeValues(graph, permission, method, agent, model) {
    const value_string = 'value';
    var dependingPermissionNodes = getNodesByLinkType(graph, {
      id: permission.id,
      type: nodetypes_LinkType.PermissionPropertyDependency
    });
    let listOfCases = [];
    dependingPermissionNodes.map(dpNode => {
      let propertyNodeLinkedToByDependencyPermissionNodes = getNodesByLinkType(graph, {
        id: dpNode.id,
        type: nodetypes_LinkType.PermissionPropertyDependency
      });
      let propertyNodeLinkedToByDependencyPermissionNode = propertyNodeLinkedToByDependencyPermissionNodes[0];

      if (!propertyNodeLinkedToByDependencyPermissionNode) {
        return;
      }

      let propertyNodes = getNodesByLinkType(graph, {
        id: propertyNodeLinkedToByDependencyPermissionNode.id,
        type: nodetypes_LinkType.PermissionDependencyProperty
      });
      let propertyNode = null;

      if (propertyNodes.length === 1) {
        propertyNode = propertyNodes[0];
      } else {
        return;
      }

      var agentLinkExists = existsLinkBetween(graph, {
        target: propertyNode.id,
        source: agent.id,
        type: nodetypes_LinkType.PropertyLink
      });
      let enumerationNode = GetNode(graph, uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.Enumeration));
      let extentionNode = GetNode(graph, uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.UIExtension));
      let useEnumeration = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.UseEnumeration);
      let useExtension = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.UseExtension);
      let useIncludedInList = uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.IncludedInList);

      if (useIncludedInList) {
        let permissionCaseIncludedInList = external_fs_default.a.readFileSync(PERMISSIONS_CASE_INCLUDED_IN_LIST, 'utf8');
        var tempBindingValues = {
          method,
          // It currently happens to be that this is correct, but maybe in the future this needs to be more general.
          parent: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || 'agent'}`.toLowerCase(),
          parent_property: 'Id',
          ///////////////////////////////////////////////////////////////////////////////////////////////////////////
          value: `${agentLinkExists ? 'value' : 'data'}`.toLowerCase(),
          value_property: uiactions_GetNodeProp(propertyNodeLinkedToByDependencyPermissionNode, uiactions_NodeProperties.CodeName),
          model: 'data',
          casename: uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.CodeName),
          extension: uiactions_GetNodeProp(extentionNode, uiactions_NodeProperties.CodeName),
          instance_list: ''
        };
        let temp = bindTemplate(permissionCaseIncludedInList, tempBindingValues);
        listOfCases.push({
          variable: `can${tempBindingValues.method}${tempBindingValues.model}${tempBindingValues.casename}`,
          template: temp
        });
      }

      if (useEnumeration) {
        let permissionCaseEnumerationTemplate = external_fs_default.a.readFileSync(PERMISSIONS_CASE_ENUMERATION, 'utf8');
        let enumInstance = permissiongenerator_PermissionGenerator.createEnumerationInstanceList(dpNode, enumerationNode, method);
        let name = permissiongenerator_PermissionGenerator.createInstanceEnumerationListName(dpNode, enumerationNode, method);
        var tempBindingValues = {
          method,
          value: `${agentLinkExists ? 'value' : 'data'}`.toLowerCase(),
          value_property: uiactions_GetNodeProp(propertyNodeLinkedToByDependencyPermissionNode, uiactions_NodeProperties.CodeName),
          model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
          casename: uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.CodeName),
          'allowed-values-list': name,
          extension: uiactions_GetNodeProp(extentionNode, uiactions_NodeProperties.CodeName),
          instance_list: enumInstance
        };
        let temp = bindTemplate(permissionCaseEnumerationTemplate, tempBindingValues);
        listOfCases.push({
          variable: `can${tempBindingValues.method}${tempBindingValues.model}${tempBindingValues.casename}`,
          template: temp
        });
      }

      if (useExtension) {
        let definition = uiactions_GetNodeProp(extentionNode, uiactions_NodeProperties.UIExtensionDefinition);
        let permissionCaseExtensionTemplate = external_fs_default.a.readFileSync(PERMISSIONS_CASE_EXTENSION, 'utf8');
        let extensionInstance = permissiongenerator_PermissionGenerator.createExtensionInstanceList(dpNode, extentionNode, method);
        let name = permissiongenerator_PermissionGenerator.createInstanceEnumerationListName(dpNode, extentionNode, method, 'Extensions');
        let tempBindingValues = {
          method,
          value: `value`,
          value_property: uiactions_GetNodeProp(propertyNodeLinkedToByDependencyPermissionNode, uiactions_NodeProperties.CodeName),
          model: 'data',
          casename: uiactions_GetNodeProp(dpNode, uiactions_NodeProperties.CodeName),
          extension_propery_key: definition && definition.config ? definition.config.keyField : null,
          extension_value_property: 'Value',
          'allowed-values-list': name,
          extension: uiactions_GetNodeProp(extentionNode, uiactions_NodeProperties.CodeName),
          instance_list: extensionInstance
        };
        let temp = bindTemplate(permissionCaseExtensionTemplate, tempBindingValues);
        listOfCases.push({
          variable: `can${tempBindingValues.method}${tempBindingValues.model}${tempBindingValues.casename}`,
          template: temp
        });
      }
    });
    return listOfCases;
  }

  static IsAppliedPermission(graph, permission, propertyNode) {
    let appliedPermissionLinks = getNodesByLinkType(graph, {
      id: permission.id,
      type: nodetypes_LinkType.AppliedPermissionLink
    }); //

    if (appliedPermissionLinks && appliedPermissionLinks.length) {
      var link = GetLinkByNodes(graph, {
        source: appliedPermissionLinks[0].id,
        target: propertyNode.id
      });

      if (link) {
        return true;
      }
    }

    return false;
  }

  static GetTestExtensionNodeValues(graph, permission, method, agent, model) {
    return [];
    const value_string = 'value';
    var conditionNodes = getNodesByLinkType(graph, {
      id: permission.id,
      type: nodetypes_LinkType.Condition
    });
    let listOfCases = [];
    conditionNodes.map(conditionNode => {
      // let isAppliedPermission = PermissionGenerator.IsAppliedPermission(graph, permission, propertyNode);
      // let enumerationNode = GraphMethods.GetNode(graph, GetNodeProp(conditionNode, NodeProperties.Enumeration));
      // let extentionNode = GraphMethods.GetNode(graph, GetNodeProp(conditionNode, NodeProperties.UIExtension));
      let conditionType = uiactions_GetNodeProp(conditionNode, uiactions_NodeProperties.ConditionType);

      switch (conditionType) {
        case ConditionTypes.MatchReference:
          var mmrp = uiactions_GetNodeProp(conditionNode, uiactions_NodeProperties.MatchReference);
          listOfCases.push({
            type: conditionType,
            values: [ConditionCases[ConditionTypes.MatchReference].$matching],
            neg: [ConditionCases[ConditionTypes.MatchReference].notmatching],
            options: { ...mmrp
            }
          });
          break;

        case ConditionTypes.MatchManyReferenceParameter:
          var mmrp = uiactions_GetNodeProp(conditionNode, uiactions_NodeProperties.MatchManyReferenceParameter);
          listOfCases.push({
            type: conditionType,
            values: [ConditionCases[ConditionTypes.MatchManyReferenceParameter].$matching],
            neg: [ConditionCases[ConditionTypes.MatchManyReferenceParameter].notmatching],
            options: { ...mmrp
            }
          });
          break;

        case ConditionTypes.InEnumerable:
          var enumRef = uiactions_GetNodeProp(conditionNode, uiactions_NodeProperties.EnumerationReference);
          var enumerationNodeName = permissiongenerator_PermissionGenerator.getReferencedNodeName(graph, enumRef, uiactions_NodeProperties.Enumeration);
          var constList = permissiongenerator_PermissionGenerator.getReference(enumRef, uiactions_NodeProperties.AllowedEnumValues);
          var disAllowedConstList = permissiongenerator_PermissionGenerator.getReference(enumRef, uiactions_NodeProperties.DisallowedEnumValues);

          let enumInstance = permissiongenerator_PermissionGenerator._createConstantList(enumerationNodeName, constList);

          let enumNotAllowed = permissiongenerator_PermissionGenerator._createConstantList(enumerationNodeName, disAllowedConstList);

          ;
          let nameEnum = permissiongenerator_PermissionGenerator.createInstanceEnumerationListName(conditionNode, enumerationNodeName, method);
          let propertyEnum = permissiongenerator_PermissionGenerator.getReferencedNodeName(graph, enumRef, ConditionTypeParameters.Ref1Property);
          listOfCases.push({
            type: conditionType,
            name: nameEnum,
            ref: enumRef[ConditionTypeParameters.Ref1],
            property: propertyEnum,
            values: enumInstance,
            neg: enumNotAllowed,
            options: { ...enumRef
            }
          });
          break;

        case ConditionTypes.InExtension:
          let definition = uiactions_GetNodeProp(conditionNode, uiactions_NodeProperties.UIExtensionDefinition);

          let extensionInstance = permissiongenerator_PermissionGenerator._createExtensionInstanceList(conditionNode, extentionNode, method);

          let extensionsNotAllowed = permissiongenerator_PermissionGenerator._getNotAllowedExtectionConstances(conditionNode, extentionNode, method);

          let nameExt = permissiongenerator_PermissionGenerator.createInstanceEnumerationListName(conditionNode, extentionNode, method, 'Extensions');
          let propertyExt = uiactions_GetNodeProp(propertyNodeLinkedToByDependencyPermissionNode, uiactions_NodeProperties.CodeName); // definition && definition.config ? definition.config.keyField : null;

          listOfCases.push({
            type: conditionType,
            name: nameExt,
            property: propertyExt,
            values: extensionInstance,
            neg: extensionsNotAllowed,
            options: { ...definition
            }
          });
          break;

        default:
          throw 'not handled [permissiongenerator]';
      }
    });
    return listOfCases;
  }

  static getReferencedNodeName(graph, enumRef, type) {
    return uiactions_GetNodeProp(permissiongenerator_PermissionGenerator.getReferencedValue(graph, enumRef, type), uiactions_NodeProperties.CodeName);
  }

  static getReferencedValue(graph, enumRef, type) {
    return GetNode(graph, enumRef[type]);
  }

  static getReference(enumRef, type) {
    return enumRef[type];
  }

  static GenerateCases(state, permission, agent, model) {
    var graph = GetCurrentGraph(state);

    let _manyToManyMatchCondition = external_fs_default.a.readFileSync(MATCH_TO_MANY_REFERENCE_PARAMETER, 'utf8');

    let _matchReferenceCondition = external_fs_default.a.readFileSync(MATCH_REFERENCE, 'utf8');

    let result = {};

    if (permission) {
      for (var method in nodetypes_Methods) {
        var permissionsEnabledFor = uiactions_GetNodeProp(permission, uiactions_NodeProperties.UIPermissions);

        if (permissionsEnabledFor && permissionsEnabledFor[method]) {
          let cases = [];
          let conditions = GetLinkChain(state, {
            id: permission.id,
            links: [{
              type: nodetypes_LinkType.Condition,
              direction: SOURCE
            }]
          });

          if (conditions && conditions.length) {
            conditions.map((t, index) => {
              var variable = 'variable_' + index;

              switch (uiactions_GetNodeProp(t, uiactions_NodeProperties.ConditionType)) {
                case ConditionTypes.MatchReference:
                  var mmrp = uiactions_GetNodeProp(t, uiactions_NodeProperties.MatchReference);

                  if (mmrp) {
                    var propNode = GetNode(graph, mmrp[ConditionTypeParameters.Ref1]);
                    var methods = GetLinkChain(state, {
                      id: permission.id,
                      links: [{
                        type: nodetypes_LinkType.Condition,
                        direction: graph_methods_TARGET
                      }, {
                        type: nodetypes_LinkType.FunctionOperator,
                        direction: graph_methods_TARGET
                      }]
                    });
                    let method = methods.find(x => x);

                    if (method) {
                      let methodProps = uiactions_GetNodeProp(method, uiactions_NodeProperties.MethodProps);

                      if (methodProps) {
                        var ref1UseId = mmrp[ConditionTypeParameters.Ref1UseId]; // GraphMethods.GetNode(graph, methodProps[mmrp[ConditionTypeParameters.Ref1UseId]]);

                        var ref2UseId = mmrp[ConditionTypeParameters.Ref2UseId]; // GraphMethods.GetNode(graph, methodProps[mmrp[ConditionTypeParameters.Ref2UseId]]);

                        cases.push({
                          template: bindTemplate(_matchReferenceCondition, {
                            variable,
                            value_property: ref1UseId ? 'Id' : GetNodeCode(graph, mmrp[ConditionTypeParameters.Ref1Property]),
                            data_property: ref2UseId ? 'Id' : GetNodeCode(graph, mmrp[ConditionTypeParameters.Ref2Property]),
                            relationship: uiactions_GetNodeProp(relationship, uiactions_NodeProperties.CodeName),
                            property: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.CodeName)
                          }),
                          options: mmrp,
                          methodProps,
                          sameInstance: !!(methodProps[mmrp[ConditionTypeParameters.Ref1]] && methodProps[mmrp[ConditionTypeParameters.Ref2]]),
                          variable
                        });
                      }
                    }
                  }

                  break;

                case ConditionTypes.MatchManyReferenceParameter:
                  var mmrp = uiactions_GetNodeProp(t, uiactions_NodeProperties.MatchManyReferenceParameter);

                  if (mmrp) {
                    var propNode = GetNode(graph, mmrp[ConditionTypeParameters.RefManyToManyProperty]);
                    var methods = GetLinkChain(state, {
                      id: permission.id,
                      links: [{
                        type: nodetypes_LinkType.Condition,
                        direction: graph_methods_TARGET
                      }, {
                        type: nodetypes_LinkType.FunctionOperator,
                        direction: graph_methods_TARGET
                      }]
                    });
                    let method = methods.find(x => x);

                    if (method) {
                      let methodProps = uiactions_GetNodeProp(method, uiactions_NodeProperties.MethodProps);

                      if (methodProps) {
                        let parms = [ConditionTypeParameters.Ref1, ConditionTypeParameters.Ref2];
                        var relationship = GetNode(graph, methodProps[mmrp[ConditionTypeParameters.RefManyToMany]]);
                        let use_parent = parms.find(p => mmrp[p] === INTERNAL_TEMPLATE_REQUIREMENTS.PARENT && methodProps.model && methodProps.model !== methodProps.parent);
                        cases.push({
                          arbiter: uiactions_GetNodeProp(relationship, uiactions_NodeProperties.CodeName),
                          template: bindTemplate(_manyToManyMatchCondition, {
                            variable,
                            data: use_parent ? INTERNAL_TEMPLATE_REQUIREMENTS.PARENT : 'data',
                            relationship: uiactions_GetNodeProp(relationship, uiactions_NodeProperties.CodeName),
                            property: uiactions_GetNodeProp(propNode, uiactions_NodeProperties.CodeName)
                          }),
                          methodProps,
                          options: mmrp,
                          variable
                        });
                      }
                    }
                  }

                  break;

                case ConditionTypes.InEnumerable:
                  var ine = uiactions_GetNodeProp(t, uiactions_NodeProperties.EnumerationReference);

                  if (ine) {
                    let ref1 = ine[ConditionTypeParameters.Ref1];
                    let enumerationNode = GetNode(graph, ine[uiactions_NodeProperties.Enumeration]);

                    if (enumerationNode) {
                      let casename = uiactions_GetNodeProp(t, uiactions_NodeProperties.CodeName) || uiactions_GetNodeProp(t, uiactions_NodeProperties.NODEType);
                      let name = `${casename}_valid_items`;
                      let permissionCaseEnumerationTemplate = external_fs_default.a.readFileSync(PERMISSIONS_CASE_ENUMERATION, 'utf8');
                      let enumInstance = permissiongenerator_PermissionGenerator.createStringList({
                        name,
                        constants_allowed: ine[uiactions_NodeProperties.AllowedEnumValues],
                        enumerationName: uiactions_GetNodeProp(enumerationNode, uiactions_NodeProperties.CodeName)
                      });
                      let propertyNodeLinkedToByDependencyPermissionNode = GetNode(graph, ine[ConditionTypeParameters.Ref1Property]);
                      var tempBindingValues = {
                        method,
                        value: `${ref1 !== 'model' ? 'value' : 'data'}`.toLowerCase(),
                        value_property: uiactions_GetNodeProp(propertyNodeLinkedToByDependencyPermissionNode, uiactions_NodeProperties.CodeName),
                        model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName) || uiactions_GetNodeProp(model, uiactions_NodeProperties.NODEType),
                        casename,
                        'allowed-values-list': name,
                        instance_list: enumInstance
                      };
                      let temp = bindTemplate(permissionCaseEnumerationTemplate, tempBindingValues);
                      cases.push({
                        variable: `can${tempBindingValues.method}${tempBindingValues.model}${tempBindingValues.casename}`,
                        template: temp
                      });
                    }
                  }

                  break;
              }
            });
          }

          result[method] = cases;
        }
      }
    }

    return result;
  }

  static EnumerateCases(cases) {
    let vects = cases.map(x => {
      return (x && x.values ? x.values.length : 0) + (x && x.neg ? x.neg.length : 0);
    });
    return enumerate(vects);
  }

  static EnumeratePermissionCases(graph, permission, method, agent, model) {
    if (!permission || !method || !agent || !model) {
      return [];
    }

    let cases = permissiongenerator_PermissionGenerator.GetTestExtensionNodeValues(graph, permission, method, agent, model);
    let enums = permissiongenerator_PermissionGenerator.EnumerateCases(cases);
    let testCaseProperty = external_fs_default.a.readFileSync(TEST_CASE_PROPERTY, 'utf8');
    let methodNode = uiactions_GetLinkChainItem({
      id: permission.id,
      links: [{
        type: nodetypes_LinkType.FunctionOperator,
        direction: graph_methods_TARGET
      }]
    });
    let methodProps = uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.MethodProps);
    let res = enums.map(_enum => {
      let props = [];
      let properties = [];
      let setup_cases = [];
      let ispositive = true;

      _enum.map((which, index) => {
        let _case = cases[index];
        ispositive = ispositive && _case.values.length > which;
        let is_model_parameter;

        switch (_case.type) {
          case ConditionTypes.MatchManyReferenceParameter:
            if (_case.options && _case.options[ConditionTypeParameters.Ref1] && _case.options[ConditionTypeParameters.Ref2] && methodProps && methodProps[_case.options[ConditionTypeParameters.Ref1]] && methodProps[_case.options[ConditionTypeParameters.Ref2]] && _case.options[ConditionTypeParameters.Ref1] !== _case.options[ConditionTypeParameters.Ref2]) {
              let ref2Model = _case.options[ConditionTypeParameters.Ref2];

              switch (_case.options[ConditionTypeParameters.Ref2]) {
                case FunctionTemplateKeys.AgentType:
                  throw 'this should be agent now';
              }

              if (ref2Model) {
                let ref1Property = 'Id';

                if (!_case.options[ConditionTypeParameters.Ref1UseId]) {
                  ref1Property = _case.options[ConditionTypeParameters.Ref1Property];
                }

                let template;
                let propType = _case.options[ConditionTypeParameters.Ref1];

                switch (propType) {
                  case FunctionTemplateKeys.Agent:
                  case FunctionTemplateKeys.Model:
                  case FunctionTemplateKeys.Parent:
                    template = bindTemplate(testCaseProperty, {
                      model: propType,
                      property: `.${ref1Property}`,
                      value: `"wrong"`
                    });
                    props.push({
                      props: ispositive ? '' : template,
                      type: _case.type
                    });
                    properties.push({
                      property: `.${ref1Property}`,
                      value: `${ref2Model}.Id`
                    });
                    break;

                  case FunctionTemplateKeys.AgentType:
                    throw 'This should be agent now';

                  default:
                    throw 'this hasnt been defined yet';
                }
              }
            }

            break;

          case ConditionTypes.MatchReference:
            if (_case.options && _case.options[ConditionTypeParameters.Ref1] && _case.options[ConditionTypeParameters.Ref2] && _case.options[ConditionTypeParameters.Ref1] !== _case.options[ConditionTypeParameters.Ref2]) {
              let ref2Model = _case.options[ConditionTypeParameters.Ref2];
              let mmrp = _case.options;

              switch (_case.options[ConditionTypeParameters.Ref2]) {
                case FunctionTemplateKeys.AgentType:
                  throw 'this should be agent now';
              }

              if (ref2Model) {
                let ref1Property = 'Id';

                if (!_case.options[ConditionTypeParameters.Ref1UseId]) {
                  ref1Property = _case.options[ConditionTypeParameters.Ref1Property];
                  ref1Property = GetCodeName(ref1Property);
                }

                let ref2Property = 'Id';

                if (!_case.options[ConditionTypeParameters.Ref2UseId]) {
                  ref2Property = _case.options[ConditionTypeParameters.Ref2Property];
                  ref2Property = GetCodeName(ref2Property);
                }

                let template;
                let propType = _case.options[ConditionTypeParameters.Ref1];
                let propType2 = _case.options[ConditionTypeParameters.Ref2];

                switch (propType) {
                  case FunctionTemplateKeys.Agent:
                  case FunctionTemplateKeys.Model:
                  case FunctionTemplateKeys.Parent:
                    template = bindTemplate(testCaseProperty, {
                      model: propType,
                      property: `.${ref1Property}`,
                      value: !ispositive ? '"wrong"' : `${ref2Model}.${ref2Property}`
                    });
                    setup_cases.push(template);
                    props.push({
                      setup_cases: ['asdf'],
                      props: template,
                      sameInstance: !!(methodProps[mmrp[ConditionTypeParameters.Ref1]] && methodProps[mmrp[ConditionTypeParameters.Ref2]]),
                      type: ConditionTypes.MatchReference
                    });
                    properties.push({
                      props: {
                        property: `.${ref1Property}`,
                        value: `${ref2Model}.${ref2Property}`
                      },
                      type: propType
                    });
                    break;

                  case FunctionTemplateKeys.AgentType:
                    throw 'This should be agent now';

                  default:
                    throw 'this hasnt been defined yet';
                }
              }
            }

            break;

          default:
            is_model_parameter = _case.ref === 'model';
            let value = _case.values.length <= which ? _case.neg[which - _case.values.length] : _case.values[which];
            let temp = bindTemplate(testCaseProperty, {
              model: is_model_parameter ? 'model' : 'agent',
              // THis may need to expand
              property: `.${_case.property}`,
              value: value
            });

            if (is_model_parameter) {
              props.push({
                props: temp,
                type: FunctionTemplateKeys.Model
              });
              properties.push({
                props: {
                  property: _case.property,
                  value
                },
                type: FunctionTemplateKeys.Model
              });
            } else {
              props.push({
                props: temp,
                type: FunctionTemplateKeys.Agent
              });
              properties.push({
                props: {
                  property: _case.property,
                  value
                },
                type: FunctionTemplateKeys.Agent
              });
            }

            break;
        }
      });

      return {
        setup_cases: setup_cases,
        props: [...props],
        properties: [...properties],
        resultSuccess: ispositive
      };
    });
    return res;
  }

  static GenerateTestCases(state, permission, agent, model, pindex) {
    var graph = GetCurrentGraph(state);
    let parent = null;
    let manyToMany = null;
    let many_to_many_register = '';
    let many_to_many_constructor = '';
    let testCase = external_fs_default.a.readFileSync(TEST_CASE, 'utf8');
    let result = [];
    let methodNode = permission ? uiactions_GetLinkChainItem({
      id: permission.id,
      links: [{
        type: nodetypes_LinkType.FunctionOperator,
        direction: graph_methods_TARGET
      }]
    }) : null;
    parent = GetMethodPropNode(graph, methodNode, FunctionTemplateKeys.Parent);
    manyToMany = GetMethodPropNode(graph, methodNode, FunctionTemplateKeys.ManyToManyModel);

    if (GetCodeName(parent)) {
      many_to_many_register = external_fs_default.a.readFileSync('./app/templates/permissions/tests/many_to_many_register.tpl', 'utf8');

      switch (uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.FunctionType)) {
        case functiontypes_FunctionTypes.Get_ManyToMany_Agent_Value__IListChild:
          testCase = external_fs_default.a.readFileSync('./app/templates/permissions/tests/Get_ManyToMany_Agent_Value__IListChild.tpl', 'utf8');

          if (model) {
            many_to_many_register = bindTemplate(many_to_many_register, {
              ref1type: GetCodeName(parent),
              ref1: FunctionTemplateKeys.Parent,
              ref2type: GetCodeName(model),
              ref2: FunctionTemplateKeys.Model
            });
          } else {
            many_to_many_register = '';
          }

          break;

        case functiontypes_FunctionTypes.Create_Parent$Child_Agent_Value__IListChild:
          testCase = external_fs_default.a.readFileSync('./app/templates/permissions/tests/Create_Parent$Child_Agent_Value__IListChild.tpl', 'utf8');

          if (agent) {
            many_to_many_register = bindTemplate(many_to_many_register, {
              ref1type: GetCodeName(parent),
              ref1: FunctionTemplateKeys.Parent,
              ref2type: GetCodeName(agent),
              ref2: FunctionTemplateKeys.Agent
            });
          } else {
            many_to_many_register = '';
          }

          break;

        case functiontypes_FunctionTypes.Get_Parent$Child_Agent_Value__IListChild:
          testCase = external_fs_default.a.readFileSync('./app/templates/permissions/tests/Get_Parent$Child_Agent_Value__IListChild.tpl', 'utf8');

          if (agent) {
            many_to_many_register = bindTemplate(many_to_many_register, {
              ref1type: GetCodeName(parent),
              ref1: FunctionTemplateKeys.Parent,
              ref2type: GetCodeName(agent),
              ref2: FunctionTemplateKeys.Agent
            });
          } else {
            many_to_many_register = '';
          }

          break;

        default:
          many_to_many_register = '';
          break;
      }
    }

    switch (uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.FunctionType)) {
      case functiontypes_FunctionTypes.Get_Object_Agent_Value__Object:
        many_to_many_register = external_fs_default.a.readFileSync('./app/templates/permissions/tests/many_to_many_register.tpl', 'utf8');

        if (model) {
          many_to_many_register = bindTemplate(many_to_many_register, {
            ref1type: GetCodeName(manyToMany.properties.logicalChildrenTypes[0]),
            ref1: FunctionTemplateKeys.Agent,
            ref2type: GetCodeName(manyToMany.properties.logicalChildrenTypes[1]),
            ref2: FunctionTemplateKeys.Model
          });
          many_to_many_constructor = bindTemplate(external_fs_default.a.readFileSync(MANY_TO_MANY_CONSTRUCTOR, 'utf8'), {
            many_to_many: GetCodeName(manyToMany)
          });
        } else {
          many_to_many_register = '';
        }

        break;
    }

    if (!manyToMany) {
      many_to_many_register = '';
    }

    if (methodNode) {
      for (var method in nodetypes_Methods) {
        var permissionsEnabledFor = uiactions_GetNodeProp(permission, uiactions_NodeProperties.UIPermissions);

        if (permission && permissionsEnabledFor && permissionsEnabledFor[method]) {
          let modelCodeName = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
          var permissionNode = permission;
          let permissionValueType = uiactions_GetNodeProp(permissionNode, uiactions_NodeProperties.PermissionValueType);
          let methodProps = uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.MethodProps);

          if (permissionValueType && methodProps) {
            modelCodeName = GetCodeName(methodProps[permissionValueType]);
          }

          let res = permissiongenerator_PermissionGenerator.EnumeratePermissionCases(graph, permission, method, agent, model);
          res = res.map((t, testIndex) => {
            var {
              props,
              resultSuccess,
              templates = {},
              setup_cases = []
            } = t;
            return bindTemplate(bindTemplate(testCase, {
              many_to_many_register
            }), {
              setup_cases: setup_cases.join(nodetypes_NEW_LINE),
              set_agent_properties: props.filter(x => x.type === FunctionTemplateKeys.Agent).map(t => t.props).join(nodetypes_NEW_LINE),
              set_model_properties: props.filter(x => x.type === FunctionTemplateKeys.Model).map(t => t.props).join(nodetypes_NEW_LINE),
              set_parent_properties: props.filter(x => x.type === FunctionTemplateKeys.Parent).map(t => t.props).join(nodetypes_NEW_LINE),
              set_match_reference_properties: props.filter(x => x.type === ConditionTypes.MatchReference).map(t => t.props).join(nodetypes_NEW_LINE),
              set_match_many_reference_properties: props.filter(x => x.type === ConditionTypes.MatchManyReferenceParameter).map(t => t.props).join(nodetypes_NEW_LINE),
              agent_type: GetCodeName(agent),
              parent_setup: '',
              many_to_many_constructor,
              model: modelCodeName,
              many_to_many: GetCodeName(manyToMany),
              many_to_many_arbiter_constructor: manyToMany ? bindTemplate(`var manyToManyArbiter = RedStrapper.Resolve<IRedArbiter<{{many_to_many}}>>();`, {
                many_to_many: GetCodeName(manyToMany)
              }) : '',
              parent: GetCodeName(parent),
              parent_agent_are_the_same: resultSuccess && parent && agent && parent.id && agent.id && parent.id === agent.id ? `parent = agent;` : '',
              method,
              test: `_${GetCodeName(agent)}_${GetCodeName(model)}_${method}_${testIndex}_case${pindex}`,
              result: resultSuccess ? 'true' : 'false',
              function_name: GetCodeName(permission) + method,
              ...templates
            });
          });
          result = [...result, ...res];
        }
      }
    }

    return result;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model);
    let permissions = uiactions_NodesByType(state, uiactions_NodeTypes.Permission);
    let agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _testTemplate = external_fs_default.a.readFileSync(TEST_CLASS, 'utf8');

    let _permissionInterface = external_fs_default.a.readFileSync(PERMISSIONS_INTERFACE, 'utf8');

    let _permissionImplementation = external_fs_default.a.readFileSync(PERMISSIONS_IMPL, 'utf8');

    let _permissionInterfaceMethods = external_fs_default.a.readFileSync(PERMISSIONS_INTERFACE_METHODS, 'utf8');

    let _permissionMethods = external_fs_default.a.readFileSync(PERMISSIONS_METHODS, 'utf8');

    let _permissionArbiters = external_fs_default.a.readFileSync(PERMISSIONS_ARBITER_PROP, 'utf8');

    let result = {};
    agents.map(agent => {
      let streamProcessChangeClassExtension = _permissionImplementation;
      let permissionInterface = _permissionInterface;
      let testPermission = _testTemplate;
      let methodImplementations = [];
      let methodInterfaces = [];
      let testMethodPermisionCases = [];
      let arbiters = [];
      models.map(model => {
        let matchingPermissionNodes = permissions.filter(permission => permissiongenerator_PermissionGenerator.PermissionMatches(permission, agent, model));

        if (!matchingPermissionNodes || !matchingPermissionNodes.length) {
          return;
        }

        let permissionCases = [];
        let permissionCodeNames = [];
        matchingPermissionNodes.map((matchingPermissionNode, pindex) => {
          if (matchingPermissionNode) {
            permissionCodeNames.push(uiactions_GetNodeProp(matchingPermissionNode, uiactions_NodeProperties.CodeName));
            let temp = permissiongenerator_PermissionGenerator.GenerateCases(state, matchingPermissionNode, agent, model);
            let testTemp = permissiongenerator_PermissionGenerator.GenerateTestCases(state, matchingPermissionNode, agent, model, pindex);
            permissionCases.push(temp);
            testMethodPermisionCases.push(...testTemp);
          }
        });
        permissionCases.map((perms, index) => {
          for (var permKey in perms) {
            let cases = perms[permKey];
            let parent_setup = '';
            let parent_type = '';
            cases.map(t => {
              if (t && t.arbiter) {
                arbiters.push(t);
              }

              if (t && t.options && t.methodProps) {
                let parms = [ConditionTypeParameters.Ref1, ConditionTypeParameters.Ref2];
                parms.map(parm => {
                  if (t.methodProps[t.options[parm]]) {
                    let arbiter = GetCodeName(t.methodProps[t.options[parm]]);

                    if (t.options[parm] === INTERNAL_TEMPLATE_REQUIREMENTS.PARENT) {
                      if (t.methodProps.parent !== model.id) parent_type = arbiter;
                    }

                    if (arbiter) {
                      arbiters.push({
                        arbiter
                      });
                    }
                  }
                });
              }
            });
            parent_setup = parent_type ? `var parent = data.${parent_type} != null ? (await arbiter${parent_type}.Get<${parent_type}>(data.${parent_type})) : null;` : 'var parent = data;';
            let modelCodeName = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
            var permissionNode = matchingPermissionNodes[index];
            let permissionValueType = uiactions_GetNodeProp(permissionNode, uiactions_NodeProperties.PermissionValueType);
            var methodNode = permissionNode ? uiactions_GetLinkChainItem({
              id: permissionNode.id,
              links: [{
                direction: graph_methods_TARGET,
                type: nodetypes_LinkType.FunctionOperator
              }]
            }) : null;
            let methodProps = uiactions_GetNodeProp(methodNode, uiactions_NodeProperties.MethodProps);

            if (permissionValueType && methodProps) {
              modelCodeName = GetCodeName(methodProps[permissionValueType]);
            }

            let permissionMethods = _permissionMethods;
            let permissionInterfaceMethods = _permissionInterfaceMethods;
            permissionMethods = bindTemplate(permissionMethods, {
              model: modelCodeName,
              value: `data`,
              agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
              function_name: permissionCodeNames[index] + permKey,
              agent: `value`,
              parent_setup,
              method: permKey,
              cases: cases.map(c => permissiongenerator_jNL + permissiongenerator_Tabs(4) + c.template).join(''),
              case_result: permissiongenerator_jNL + permissiongenerator_Tabs(4) + `result = ${cases.map(c => c.variable).join(' && ')};`
            });
            permissionInterfaceMethods = bindTemplate(permissionInterfaceMethods, {
              model: modelCodeName,
              function_name: permissionCodeNames[index] + permKey,
              value: `data`,
              agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
              agent: `value`,
              method: permKey
            });
            methodInterfaces.push(permissionInterfaceMethods);
            methodImplementations.push(permissionMethods);
          }
        });
      }).join(permissiongenerator_jNL);
      arbiters = arbiters.map(t => t.arbiter).unique(x => x).map(t => {
        return bindTemplate(_permissionArbiters, {
          arbiter: t
        });
      }).join(permissiongenerator_jNL);
      streamProcessChangeClassExtension = bindTemplate(streamProcessChangeClassExtension, {
        agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        arbiters,
        methods: methodImplementations.unique().join(permissiongenerator_jNL + permissiongenerator_jNL)
      });
      permissionInterface = bindTemplate(permissionInterface, {
        agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        methods: methodInterfaces.unique().join(permissiongenerator_jNL + permissiongenerator_jNL)
      });
      let hasExtensions = uiactions_NodesByType(state, uiactions_NodeTypes.ExtensionType).length;
      result[uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)] = {
        name: `Permissions${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`,
        tname: `Permissions${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Tests`,
        iname: `IPermissions${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: streamProcessChangeClassExtension,
          usings: [...STANDARD_CONTROLLER_USING, hasExtensions ? `${namespace}${nodetypes_NameSpace.Extensions}` : false, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, arbiters && arbiters.length ? `${namespace}${nodetypes_NameSpace.Controllers}` : null, `${namespace}${nodetypes_NameSpace.Constants}`].filter(x => x),
          namespace,
          space: nodetypes_NameSpace.Permissions
        }),
        interface: namespacegenerator_NamespaceGenerator.Generate({
          template: permissionInterface,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Model}`],
          namespace,
          space: nodetypes_NameSpace.Interface
        }),
        test: namespacegenerator_NamespaceGenerator.Generate({
          template: bindTemplate(testPermission, {
            tests: testMethodPermisionCases.join(nodetypes_NEW_LINE),
            name: `Permissions${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`
          }),
          usings: [...STANDARD_CONTROLLER_USING, ...STANDARD_TEST_USING, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Permissions}`, hasExtensions ? `${namespace}${nodetypes_NameSpace.Extensions}` : false, `${namespace}${nodetypes_NameSpace.Constants}`, `${namespace}${nodetypes_NameSpace.Model}`],
          namespace,
          space: nodetypes_NameSpace.Tests
        })
      };
    });
    return result;
  }

}
const permissiongenerator_NL = `
                    `;
const permissiongenerator_jNL = `
`;
const permissiongenerator_TAB = `   `;

function permissiongenerator_Tabs(c) {
  let res = '';

  for (var i = 0; i < c; i++) {
    res += permissiongenerator_TAB;
  }

  return res;
}
// CONCATENATED MODULE: ./app/generators/validationrulegenerator.js








const VALIDATION_CLASS = './app/templates/validation/validation_class.tpl';
const VALIDATION_TEST = './app/templates/validation/tests/validation.tpl';
const validationrulegenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
const VALIDATION_PROPERTY = './app/templates/validation/validation_property.tpl';
class validationrulegenerator_ValidationRuleGenerator {
  static enumerateValidationTestVectors(validation_test_vectors) {
    var vects = validation_test_vectors.map(x => {
      return Object.keys(x.values.cases).length;
    });
    var enumeration = validationrulegenerator_ValidationRuleGenerator.enumerate(vects);
    return enumeration;
  }

  static enumerate(vects, j = 0) {
    var results = [];
    if (j < vects.length) for (var i = 0; i < vects[j]; i++) {
      var rest = validationrulegenerator_ValidationRuleGenerator.enumerate(vects, j + 1);
      var temp = [i];

      if (rest.length) {
        rest.map(r => {
          results.push([...temp, ...r]);
        });
      } else {
        results.push(temp);
      }
    }
    return results;
  }

  static Tabs(c) {
    let res = '';

    for (var i = 0; i < c; i++) {
      res += `    `;
    }

    return res;
  }

  static GenerateValidationCases(graph, validatorNode) {
    var model = uiactions_GetNodeProp(validatorNode, uiactions_NodeProperties.ValidatorModel);
    var validator = uiactions_GetNodeProp(validatorNode, uiactions_NodeProperties.Validator);
    let validatorProperties = getValidatorProperties(validator);
    var validation_test_vectors = [];
    Object.keys(validatorProperties || {}).map(property => {
      let propertyNode = GetNode(graph, property);
      let validatorPs = validatorProperties[property];
      return Object.keys(validatorPs.validators).map(vld => {
        let validators = validatorPs.validators[vld];
        let node = GetNode(graph, validators.node);
        let attribute_type_arguments = '';

        if (node) {
          switch (uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType)) {
            case uiactions_NodeTypes.ExtensionType:
              if (validators && validators.extension) {
                let temp = {
                  '_ _': '"__ _ __"'
                };
                attribute_type_arguments = Object.keys(validators.extension).map(ext => {
                  if (validators.extension[ext]) {
                    temp[`$${ext}`] = `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}.${MakeConstant(ext)}`;
                    return temp[`$${ext}`];
                  }
                }).filter(x => x); // attribute_type_arguments = temp.filter(x => x).join();

                validation_test_vectors.push({
                  property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
                  values: {
                    cases: temp,
                    invalid: {
                      '_ _': true
                    }
                  }
                });
                attribute_type_arguments = `new List<string> () {
                ${attribute_type_arguments.join(', ')}
            }`;
              }

              break;

            case uiactions_NodeTypes.Enumeration:
              if (validators && validators.enumeration) {
                let enumNode = GetNode(graph, validators.node);
                let enumName = uiactions_GetNodeProp(enumNode, uiactions_NodeProperties.CodeName);
                attribute_type_arguments = Object.keys(validators.enumeration).map(ext => {
                  if (validators.enumeration[ext]) {
                    return `${enumName}.${MakeConstant(ext)}`;
                  }
                }).filter(x => x); // attribute_type_arguments = temp.filter(x => x).join();

                validation_test_vectors.push({
                  property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
                  values: {
                    cases: [...attribute_type_arguments],
                    invalid: {
                      '_ _': true
                    }
                  }
                });
                attribute_type_arguments = `new List<string> () {
                    ${attribute_type_arguments.join(', ')}
                }`;
              }

              break;
          }
        }

        if (ValidationCases[validators.type]) {
          validation_test_vectors.push({
            property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
            values: ValidationCases[validators.type]
          });
        }
      });
    });
    var vectors = validationrulegenerator_ValidationRuleGenerator.enumerateValidationTestVectors(validation_test_vectors);
    let testProps = vectors.map((vector, index) => {
      let successCase = true;
      let propertyInformation = [];
      let properylines = vector.map((v, vindex) => {
        var projected_value = Object.values(validation_test_vectors[vindex].values.cases)[v];
        var _case = Object.keys(validation_test_vectors[vindex].values.cases)[v];

        if (typeof projected_value === 'function') {
          projected_value = projected_value();
        } else {
          if (validation_test_vectors[vindex] && validation_test_vectors[vindex].values && validation_test_vectors[vindex].values.invalid && !validation_test_vectors[vindex].values.invalid[_case]) {
            _case = '$$';
          }
        }

        successCase = successCase && (_case || [false])[0] === '$';
        let propline = validationrulegenerator_ValidationRuleGenerator.Tabs(3) + `{{model}}.${validation_test_vectors[vindex].property} = ${projected_value};`;
        propertyInformation.push({
          set_properties: propline,
          property: validation_test_vectors[vindex].property,
          type: uiactions_GetNodeProp(GetNode(graph, model), uiactions_NodeProperties.CodeName)
        });
        return propline;
      }).join(nodetypes_NEW_LINE);
      let temp = {
        resultSuccess: successCase,
        propertyInformation,
        set_properties: properylines,
        type: uiactions_GetNodeProp(GetNode(graph, model), uiactions_NodeProperties.CodeName)
      };
      return temp;
    });
    return testProps;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let graph = GetRootGraph(state);
    let result = {};
    let nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Validator);

    let _validation_class = external_fs_default.a.readFileSync(VALIDATION_CLASS, 'utf8');

    let _validation_property = external_fs_default.a.readFileSync(VALIDATION_PROPERTY, 'utf8');

    let _validation_test = external_fs_default.a.readFileSync(VALIDATION_TEST, 'utf8');

    let _testClass = external_fs_default.a.readFileSync(validationrulegenerator_TEST_CLASS, 'utf8');

    nodes.map(node => {
      var agent = uiactions_GetNodeProp(node, uiactions_NodeProperties.ValidatorAgent);
      var model = uiactions_GetNodeProp(node, uiactions_NodeProperties.ValidatorModel);
      var modelNode = GetNode(graph, model);
      var funct = uiactions_GetNodeProp(node, uiactions_NodeProperties.ValidatorFunction);
      var functNode = GetNode(graph, funct);
      var validator = uiactions_GetNodeProp(node, uiactions_NodeProperties.Validator);
      let validatorProperties = getValidatorProperties(validator);
      var validation_test_vectors = [];
      let propertyValidationStatements = Object.keys(validatorProperties).map(property => {
        let propertyNode = GetNode(graph, property);
        let validatorPs = validatorProperties[property];
        return Object.keys(validatorPs.validators).map(vld => {
          let validators = validatorPs.validators[vld];
          let node = GetNode(graph, validators.node);
          let attribute_type_arguments = '';

          if (node) {
            switch (uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType)) {
              case uiactions_NodeTypes.ExtensionType:
                if (validators && validators.extension) {
                  let temp = {
                    '_ _': '"__ _ __"'
                  };
                  attribute_type_arguments = Object.keys(validators.extension).map(ext => {
                    if (validators.extension[ext]) {
                      temp[`$${ext}`] = `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}.${MakeConstant(ext)}`;
                      return temp[`$${ext}`];
                    }
                  }).filter(x => x); // attribute_type_arguments = temp.filter(x => x).join();

                  validation_test_vectors.push({
                    property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
                    values: {
                      cases: temp,
                      invalid: {
                        '_ _': true
                      }
                    }
                  });
                  attribute_type_arguments = `new List<string> () {
                ${attribute_type_arguments.join(', ')}
            }`;
                }

                break;

              case uiactions_NodeTypes.Enumeration:
                if (validators && validators.enumeration) {
                  let enumNode = GetNode(graph, validators.node);
                  let enumName = uiactions_GetNodeProp(enumNode, uiactions_NodeProperties.CodeName);
                  attribute_type_arguments = Object.keys(validators.enumeration).map(ext => {
                    if (validators.enumeration[ext]) {
                      return `${enumName}.${MakeConstant(ext)}`;
                    }
                  }).filter(x => x); // attribute_type_arguments = temp.filter(x => x).join();

                  validation_test_vectors.push({
                    property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
                    values: {
                      cases: [...attribute_type_arguments],
                      invalid: {
                        '_ _': true
                      }
                    }
                  });
                  attribute_type_arguments = `new List<string> () {
                    ${attribute_type_arguments.join(', ')}
                }`;
                }

                break;
            }
          }

          if (ValidationCases[validators.type]) {
            validation_test_vectors.push({
              property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
              values: ValidationCases[validators.type]
            });
          }

          var templateRes = bindTemplate(_validation_property, {
            attribute_type: validators.code[ProgrammingLanguages.CSHARP],
            attribute_type_arguments,
            model_property: `.${uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName)}`
          });
          return templateRes + nodetypes_NEW_LINE;
        }).join('');
      }).join('');
      var vectors = validationrulegenerator_ValidationRuleGenerator.enumerateValidationTestVectors(validation_test_vectors);
      let testProps = vectors.map((vector, index) => {
        let validation_test = _validation_test;
        let successCase = true;
        let properylines = vector.map((v, vindex) => {
          var projected_value = Object.values(validation_test_vectors[vindex].values.cases)[v];
          var _case = Object.keys(validation_test_vectors[vindex].values.cases)[v];

          if (typeof projected_value === 'function') {
            projected_value = projected_value();
          } else {
            if (validation_test_vectors[vindex] && validation_test_vectors[vindex].values && validation_test_vectors[vindex].values.invalid && !validation_test_vectors[vindex].values.invalid[_case]) {
              _case = '$$';
            }
          }

          successCase = successCase && (_case || [false])[0] === '$';
          return validationrulegenerator_ValidationRuleGenerator.Tabs(3) + `model.${validation_test_vectors[vindex].property} = ${projected_value};`;
        }).join(nodetypes_NEW_LINE);
        let temp = bindTemplate(_validation_test, {
          model: uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName),
          test_name: `Test${index}`,
          attribute_parameters: "",
          expected_value: successCase ? 'true' : 'false',
          set_properties: properylines,
          attribute_type: `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}Attribute`,
          properties: propertyValidationStatements,
          type: uiactions_GetNodeProp(GetNode(graph, model), uiactions_NodeProperties.CodeName)
        });
        return temp;
      });
      var templateRes = bindTemplate(_validation_class, {
        model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        function_name: uiactions_GetNodeProp(functNode, uiactions_NodeProperties.CodeName),
        properties: propertyValidationStatements,
        type: uiactions_GetNodeProp(GetNode(graph, model), uiactions_NodeProperties.CodeName)
      });
      var testTemplate = bindTemplate(_testClass, {
        name: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        tests: testProps.join(nodetypes_NEW_LINE)
      });
      templateRes = bindTemplate(_validation_class, {
        model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        function_name: uiactions_GetNodeProp(functNode, uiactions_NodeProperties.CodeName),
        properties: propertyValidationStatements,
        type: uiactions_GetNodeProp(GetNode(graph, model), uiactions_NodeProperties.CodeName)
      });
      let hasExtensions = uiactions_NodesByType(state, uiactions_NodeTypes.ExtensionType).length;
      result[uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}Attribute`,
        tname: `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}AttributeTests`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: templateRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, hasExtensions ? `${namespace}${nodetypes_NameSpace.Extensions}` : false, `${namespace}${nodetypes_NameSpace.Constants}`].filter(x => x),
          namespace,
          space: nodetypes_NameSpace.Validations
        }),
        test: namespacegenerator_NamespaceGenerator.Generate({
          template: testTemplate,
          usings: [...STANDARD_CONTROLLER_USING, ...STANDARD_TEST_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Validations}`, hasExtensions ? `${namespace}${nodetypes_NameSpace.Extensions}` : false, `${namespace}${nodetypes_NameSpace.Constants}`].filter(x => x),
          namespace,
          space: nodetypes_NameSpace.Tests
        })
      };
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/streamprocessorchestrationgenerator.js










const STREAM_PROCESS_ORCHESTRATION_TEMPLATE = './app/templates/stream_process/stream_process_orchestration.tpl';
const STREAM_PROCESS_ORCHESTRATION_ROOT_TEMPLATE = './app/templates/stream_process/stream_process_orchestration_root.tpl';
const STREAM_PROCESS_ORCHESTRATION_TEMPLATE_INTERFACE = './app/templates/stream_process/stream_process_orchestration_interface.tpl';
const STREAM_PROCESS_ORCHESTRATION_AGENT_METHODS = './app/templates/stream_process/stream_process_orchestration_agenttype_methods.tpl';
const STREAM_PROCESS_AGENT_CRUD_UPDATE = './app/templates/stream_process/agent_methods/update.tpl';
const STREAM_PROCESS_AGENT_CRUD_CREATE = './app/templates/stream_process/agent_methods/create.tpl';
const STREAM_PROCESS_AGENT_CRUD_DELETE = './app/templates/stream_process/agent_methods/delete.tpl';
const STREAM_PROCESS_ORCHESTRATION_AGENT_METHODS_INTERFACE = './app/templates/stream_process/stream_process_orchestration_agenttype_methods_interface.tpl';
const STREAM_PROCESS_ORCHESTRATION_STAGED_CHANGES = './app/templates/stream_process/stream_process_orchestration_selected_staged_changes.tpl';
const STREAM_METHOD_TESTS = './app/templates/stream_process/tests/stream_process_execution_tests.tpl';
const CREATE_MODEL_TESTS = './app/templates/stream_process/tests/create_model_tests.tpl';
const streamprocessorchestrationgenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
class streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator {
  static GenerateStaticMethods(models) {
    let _streamProcessFunctionTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_STAGED_CHANGES, 'utf8');

    let staticMethods = models.map(model => {
      let streamProcessFunctionTemplate = _streamProcessFunctionTemplate;
      let modelCode = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
      let res = bindTemplate(streamProcessFunctionTemplate, {
        model: modelCode,
        [`model#allupper`]: modelCode.toUpperCase(),
        [`model#lower`]: modelCode.toLowerCase()
      });
      return res + streamprocessorchestrationgenerator_jNL;
    });
    return staticMethods;
  }

  static GenerateAgentMethods(state, agent) {
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model);
    let methods = uiactions_NodesByType(state, uiactions_NodeTypes.Method);
    let agents = [agent]; // models.filter(model => GetNodeProp(model, NodeProperties.IsAgent));

    let _streamAgentMethods = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_AGENT_METHODS, 'utf8');

    models = models.filter(model => {
      return methods.find(method => {
        var props = GetMethodProps(method);
        return props[FunctionTemplateKeys.Agent] === agent.id && (props[FunctionTemplateKeys.Model] === model.id || props[FunctionTemplateKeys.CompositeInput] === model.id);
      });
    });
    let result = [];
    let modelexecution = [];
    let executors = uiactions_NodesByType(state, uiactions_NodeTypes.Executor).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.ExecutorAgent) === agent.id);
    agents.map(agent => {
      models.filter(model => {
        return executors.find(executor => uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModel) === model.id);
      }).map(model => {
        modelexecution.push(streamprocessorchestrationgenerator_Tabs(4) + `await Process${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)}ChangesBy${GetCodeName(agent)}();` + streamprocessorchestrationgenerator_jNL);
      });
    });
    result.push(`       public async Task ProcessStagedChanges(Distribution distribution = null) {
${modelexecution.join('')}
        }
`); // agents.map(agent => {

    let groupedExecutors = executors.groupBy(executor => {
      return `${uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorAgent)} && ${uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModel)}`;
    });
    Object.keys(groupedExecutors).map(ge => {
      let executors = groupedExecutors[ge];
      let update_method = '';
      let update_call = '';
      let delete_method = '';
      let delete_call = '';
      let create_method = '';
      let create_call = '';
      let bind_params = null;
      let ae_functions = [];
      executors.map(executor => {
        let agent = GetGraphNode(uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorAgent));
        let model = GetGraphNode(uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModel));
        let model_output = GetGraphNode(uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModelOutput));
        let methodNode = GetMethodNode(state, executor.id, nodetypes_LinkType.ExecutorFunction, SOURCE);
        let methodProps = GetMethodProps(methodNode);
        let afterEffectMethods = GetLinkChain(state, {
          id: methodNode.id,
          links: [{
            type: nodetypes_LinkType.AfterMethod,
            direction: SOURCE
          }]
        });
        let ae_calls = [];
        afterEffectMethods.map(afterEffectMethod => {
          var ae_type = uiactions_GetNodeProp(afterEffectMethod, uiactions_NodeProperties.AfterMethod);
          var ae_setup = uiactions_GetNodeProp(afterEffectMethod, uiactions_NodeProperties.AfterMethodSetup);

          if (AFTER_EFFECTS[ae_type] && ae_setup && ae_setup[ae_type]) {
            let {
              templateKeys,
              template_call,
              template
            } = AFTER_EFFECTS[ae_type];
            let templateString = external_fs_default.a.readFileSync(template, 'utf8');
            Object.keys(templateKeys).map(key => {
              if (ae_setup[ae_type][key]) {
                let key_val = ae_setup[ae_type][key] || '';
                var name = key_val.startsWith('#') ? key_val.split('#').join('') : GetCodeName(methodProps[key_val] || key_val) || key_val;
                templateString = bindTemplate(templateString, {
                  [key]: name,
                  [`${key}#lower`]: `${name}`.toLowerCase()
                });
                template_call = bindTemplate(template_call, {
                  [key]: name,
                  [`${key}#lower`]: `${name}`.toLowerCase()
                });
              }
            });
            templateString = bindTemplate(templateString, {
              function_name: GetCodeName(afterEffectMethod)
            });
            template_call = bindTemplate(template_call, {
              function_name: GetCodeName(afterEffectMethod)
            });
            ae_calls.push(template_call);
            ae_functions.push(templateString);
          }
        });
        bind_params = {
          'model_output#lower': `${GetCodeName(model_output, uiactions_NodeProperties.CodeName)}`.toLowerCase(),
          model: GetCodeName(model, uiactions_NodeProperties.CodeName),
          'model#lower': uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName).toLowerCase(),
          agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          'agent_type#lower': uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName).toLowerCase(),
          update_method,
          create_method,
          delete_method,
          create_call,
          update_call,
          delete_call
        };
        ae_calls = ae_calls.unique().join(nodetypes_NEW_LINE);

        if (uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorFunctionType) === nodetypes_Methods.Update && uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorAgent) === agent.id && uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModel) === model.id) {
          update_method = bindTemplate(external_fs_default.a.readFileSync(STREAM_PROCESS_AGENT_CRUD_UPDATE, 'utf8'), { ...bind_params,
            ae_calls
          });
          update_call = `case Methods.Update:
                        await Update(change);
                        break;`;
        } else if (uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorFunctionType) === nodetypes_Methods.Create && uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorAgent) === agent.id && uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModel) === model.id) {
          create_method = bindTemplate(external_fs_default.a.readFileSync(STREAM_PROCESS_AGENT_CRUD_CREATE, 'utf8'), { ...bind_params,
            ae_calls
          });
          create_call = `case Methods.Create:
                        await Create(change);
                        break;`;
        } else if (uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorFunctionType) === nodetypes_Methods.Delete && uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorAgent) === agent.id && uiactions_GetNodeProp(executor, uiactions_NodeProperties.ExecutorModel) === model.id) {
          delete_method = bindTemplate(external_fs_default.a.readFileSync(STREAM_PROCESS_AGENT_CRUD_DELETE, 'utf8'), { ...bind_params,
            ae_calls
          });
          delete_call = `
                        case Methods.Delete:
                            await Delete(change);
                            break;`;
        } //   });

      });
      var res = bindTemplate(_streamAgentMethods, { ...bind_params,
        update_method,
        update_call,
        create_method,
        create_call,
        delete_method,
        delete_call,
        ae_functions: ae_functions.unique().join('')
      });
      result.push(res);
      result = result.unique();
    });
    return result.unique().join('');
  }

  static GenerateAgentInterfaceMethods(state, agent) {
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model);
    let methods = uiactions_NodesByType(state, uiactions_NodeTypes.Method);
    let agents = [agent]; //models.filter(model => GetNodeProp(model, NodeProperties.IsAgent));

    let _streamAgentMethods = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_AGENT_METHODS_INTERFACE, 'utf8');

    models = models.filter(model => {
      return methods.find(method => {
        var props = GetMethodProps(method);
        return props[FunctionTemplateKeys.Agent] === agent.id && (props[FunctionTemplateKeys.Model] === model.id || props[FunctionTemplateKeys.CompositeInput] === model.id);
      });
    });
    let result = [];
    let executors = uiactions_NodesByType(state, uiactions_NodeTypes.Executor).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.ExecutorAgent) === agent.id);
    let methods_interface = []; // agents.map(agent => {

    executors.map(_ex => {
      let agent = GetGraphNode(uiactions_GetNodeProp(_ex, uiactions_NodeProperties.ExecutorAgent));
      let model = GetGraphNode(uiactions_GetNodeProp(_ex, uiactions_NodeProperties.ExecutorModel));
      let model_output = GetGraphNode(uiactions_GetNodeProp(_ex, uiactions_NodeProperties.ExecutorModelOutput));

      if (uiactions_GetNodeProp(_ex, uiactions_NodeProperties.ExecutorFunctionType)) {
        methods_interface.push(bindTemplate(`
                Task {{method}}({{model}}ChangeBy{{agent_type}} change);
`, {
          method: uiactions_GetNodeProp(_ex, uiactions_NodeProperties.ExecutorFunctionType),
          model: GetCodeName(model),
          agent_type: GetCodeName(agent)
        }));
      }

      var res = bindTemplate(_streamAgentMethods, {
        model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
        model_output: GetCodeName(model_output),
        'model#lower': uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName).toLowerCase(),
        agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        'agent_type#lower': uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName).toLowerCase(),
        update_method: 'here interface ok'
      });
      result.push(...methods_interface);
      result.push(res);
    }); // });

    return result.unique().join('');
  }

  static GenerateStrappers(models, agent) {
    let result = [];
    var sortedValidations = GetValidationsSortedByAgent();

    if (sortedValidations && agent && sortedValidations[agent.id]) {
      result.push(streamprocessorchestrationgenerator_Tabs(4) + bindTemplate(`validator = RedStrapper.Resolve<I{{agent}}Validations>();`, {
        agent: GetCodeName(agent)
      }) + streamprocessorchestrationgenerator_jNL);
    }

    var agents = [agent]; // models.filter(x => GetNodeProp(x, NodeProperties.IsAgent));

    models.map(model => {
      let modelName = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
      result.push(streamprocessorchestrationgenerator_Tabs(4) + `${modelName.toLowerCase()}Arbiter = RedStrapper.Resolve<IRedArbiter<${modelName}>>();` + streamprocessorchestrationgenerator_jNL);
      agents.map(agent => {
        var agentName = GetCodeName(agent);
        result.push(streamprocessorchestrationgenerator_Tabs(4) + `${modelName.toLowerCase()}ChangeBy${agentName}Arbiter = RedStrapper.Resolve<IRedArbiter<${modelName}ChangeBy${agentName}>>();` + streamprocessorchestrationgenerator_jNL);
      });

      if (uiactions_GetNodeProp(model, uiactions_NodeProperties.IsAgent)) {
        result.push(streamprocessorchestrationgenerator_Tabs(4) + `${modelName.toLowerCase()}ResponseArbiter = RedStrapper.Resolve<IRedArbiter<${modelName}Response>>();` + streamprocessorchestrationgenerator_jNL);

        if (AgentHasExecutor(agent)) {
          result.push(streamprocessorchestrationgenerator_Tabs(4) + `${modelName.toLowerCase()}Executor = RedStrapper.Resolve<I${modelName}Executor>();` + streamprocessorchestrationgenerator_jNL);
        }
      }
    });
    return result.unique().join('');
  }

  static GenerateStrappersInstances(models, agent) {
    let result = [];
    var sortedValidations = GetValidationsSortedByAgent();

    if (sortedValidations && agent && sortedValidations[agent.id]) {
      result.push(streamprocessorchestrationgenerator_Tabs(3) + bindTemplate(`public I{{agent}}Validations validator;`, {
        agent: GetCodeName(agent)
      }) + streamprocessorchestrationgenerator_jNL);
    }

    var agents = [agent]; // models.filter(x => GetNodeProp(x, NodeProperties.IsAgent));

    models.map(model => {
      let modelName = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
      result.push(streamprocessorchestrationgenerator_Tabs(3) + `public IRedArbiter<${modelName}> ${modelName.toLowerCase()}Arbiter;` + streamprocessorchestrationgenerator_jNL);
      agents.map(agent => {
        var agentName = GetCodeName(agent);
        result.push(streamprocessorchestrationgenerator_Tabs(3) + `public IRedArbiter<${modelName}ChangeBy${agentName}> ${modelName.toLowerCase()}ChangeBy${agentName}Arbiter;` + streamprocessorchestrationgenerator_jNL);
      });

      if (uiactions_GetNodeProp(model, uiactions_NodeProperties.IsAgent)) {
        result.push(streamprocessorchestrationgenerator_Tabs(3) + `public IRedArbiter<${modelName}Response> ${modelName.toLowerCase()}ResponseArbiter;` + streamprocessorchestrationgenerator_jNL);
        let state = GetState();
        let graphRoot = GetCurrentGraph();

        if (AgentHasExecutor(agent)) {
          result.push(streamprocessorchestrationgenerator_Tabs(3) + `public I${modelName}Executor ${modelName.toLowerCase()}Executor;` + streamprocessorchestrationgenerator_jNL);
        }
      }
    });
    return result.unique().join('');
  }

  static GenerateStreamOrchestrations(models) {
    let result = [];
    var agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    agents.map(model => {
      let modelName = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
      result.push(streamprocessorchestrationgenerator_Tabs(4) + `${modelName.toLowerCase()}StreamProcessOrchestration = RedStrapper.Resolve<I${modelName}StreamProcessOrchestration>();` + streamprocessorchestrationgenerator_jNL);
    });
    return result.join('');
  }

  static GenerateStreamOrchestrationInstances(models) {
    let result = [];
    const StreamProcessOrchestration = 'StreamProcessOrchestration';
    var agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    agents.map(model => {
      let modelName = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
      result.push(`public I${modelName}${StreamProcessOrchestration} ${modelName.toLowerCase()}StreamProcessOrchestration;`);
    });
    return result.unique().map(v => streamprocessorchestrationgenerator_Tabs(3) + v + streamprocessorchestrationgenerator_jNL).join('');
  }

  static GenerateProcessTests(state) {
    let graph = GetRootGraph(state);
    let functions = uiactions_NodesByType(state, uiactions_NodeTypes.Method).filter(x => ![nodetypes_Methods.Get, nodetypes_Methods.GetAll].some(t => t === uiactions_GetNodeProp(x, uiactions_NodeProperties.MethodType)));
    let res = ''; // STREAM_METHOD_TESTS

    let _stramMethodTests = external_fs_default.a.readFileSync(STREAM_METHOD_TESTS, 'utf8');

    let _createModelTests = external_fs_default.a.readFileSync(CREATE_MODEL_TESTS, 'utf8');

    let agent_process_orchestration_mocks = `           builder.RegisterType<{{agent_type}}StreamProcessOrchestration>().As<I{{agent_type}}StreamProcessOrchestration>();
`;
    let agent_process_orc_mocks = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => {
      var isAgent = uiactions_IsAgent(x);
      return isAgent;
    }).map(t => bindTemplate(agent_process_orchestration_mocks, {
      agent_type: GetCodeName(t)
    })).join('');
    res = functions.map((func, index) => {
      let methodProps = uiactions_GetNodeProp(func, uiactions_NodeProperties.MethodProps);
      let method = uiactions_GetNodeProp(func, uiactions_NodeProperties.MethodType); //      let cases = null;

      if (methodProps) {
        var agentTypeNode = GetNode(graph, methodProps[FunctionTemplateKeys.AgentType]);
        var modelNode = GetNode(graph, methodProps[FunctionTemplateKeys.Model]);
        var userTypeNode = GetNode(graph, methodProps[FunctionTemplateKeys.User]);
        var permissionNode = GetNode(graph, methodProps[FunctionTemplateKeys.Permission]);

        if (graph && permissionNode && method && agentTypeNode && modelNode) {//   cases = PermissionGenerator.EnumeratePermissionCases(graph, permissionNode, method, agentTypeNode, modelNode);
        }
      }

      if (modelNode && agentTypeNode && func) {
        return bindTemplate(_stramMethodTests, {
          model: uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName),
          agent_type: uiactions_GetNodeProp(agentTypeNode, uiactions_NodeProperties.CodeName),
          function_name: uiactions_GetNodeProp(func, uiactions_NodeProperties.CodeName),
          test_name: `${uiactions_GetNodeProp(func, uiactions_NodeProperties.CodeName)}Test`,
          stream_process_orchestration_mocks: agent_process_orc_mocks
        });
      }
    }).filter(x => x).join(nodetypes_NEW_LINE);
    let func_Cases = [];
    functions.map((func, index) => {
      let methodProps = uiactions_GetNodeProp(func, uiactions_NodeProperties.MethodProps);
      let method = uiactions_GetNodeProp(func, uiactions_NodeProperties.MethodType);
      let cases = null;

      if (methodProps) {
        var agentTypeNode = GetNode(graph, methodProps[FunctionTemplateKeys.AgentType]);
        var modelNode = GetNode(graph, methodProps[FunctionTemplateKeys.Model]);
        var permissionNode = GetNode(graph, methodProps[FunctionTemplateKeys.Permission]);

        if (graph && permissionNode && method && agentTypeNode && modelNode) {
          let validators = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GetFunctionValidators(state, func);
          let validatorCases = null;

          if (validators && validators.length) {
            validatorCases = validators.map(validator => {
              return {
                cases: validationrulegenerator_ValidationRuleGenerator.GenerateValidationCases(graph, validator),
                isModel: uiactions_GetNodeProp(validator, uiactions_NodeProperties.ValidatorModel) === methodProps[FunctionTemplateKeys.Model]
              };
            });
          }

          if (validatorCases) enumerate(validatorCases.map(x => x.cases.length)).map((_enum, caseindex) => {
            let v1 = validatorCases[0].cases[_enum[0]];
            let v2 = validatorCases[1].cases[_enum[1]];
            let agent_properties = '';
            let model_properties = '';

            if (!validatorCases[1].isModel) {
              agent_properties = bindTemplate(v2.set_properties, {
                model: "agent"
              });
              model_properties = bindTemplate(v1.set_properties, {
                model: "model"
              });
            } else {
              agent_properties = bindTemplate(v2.set_properties, {
                model: "model"
              });
              model_properties = bindTemplate(v1.set_properties, {
                model: "agent"
              });
            } // cases.map((_case, caseindex) => {


            func_Cases.push(bindTemplate(_createModelTests, {
              model: uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName),
              agent_type: uiactions_GetNodeProp(agentTypeNode, uiactions_NodeProperties.CodeName),
              set_agent_propeties: agent_properties,
              set_model_properties: model_properties,
              function_name: uiactions_GetNodeProp(func, uiactions_NodeProperties.CodeName),
              test_result: !(v1.resultSuccess && v2.resultSuccess),
              test_name: `${uiactions_GetNodeProp(func, uiactions_NodeProperties.CodeName)}${caseindex}Test`
            }));
          }); //  });
        }
      }
    }).join(nodetypes_NEW_LINE);
    return res + nodetypes_NEW_LINE + func_Cases.unique().join(nodetypes_NEW_LINE);
  }

  static EnumerateFunctionValidators(state, func) {
    let graph = GetRootGraph(state);
    let methodProps = uiactions_GetNodeProp(func, uiactions_NodeProperties.MethodProps);
    let validators = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GetFunctionValidators(state, func);
    let validatorCases = null;

    if (validators && validators.length) {
      validatorCases = validators.map(validator => {
        return {
          cases: validationrulegenerator_ValidationRuleGenerator.GenerateValidationCases(graph, validator),
          isModel: uiactions_GetNodeProp(validator, uiactions_NodeProperties.ValidatorModel) === methodProps[FunctionTemplateKeys.Model]
        };
      });
    }

    return enumerate((validatorCases || []).map(x => x.cases.length)).map((_enum, caseindex) => {
      let v1 = validatorCases[0].cases[_enum[0]];
      let v2 = validatorCases[1].cases[_enum[1]];
      let agent_properties = '';
      let model_properties = '';

      if (!validatorCases[1].isModel) {
        agent_properties = bindTemplate(v2.set_properties, {
          model: "agent"
        });
        model_properties = bindTemplate(v1.set_properties, {
          model: "model"
        });
        v2.propertyInformation.map(t => t.set_properties = bindTemplate(t.set_properties, {
          model: "agent"
        }));
        v1.propertyInformation.map(t => t.set_properties = bindTemplate(t.set_properties, {
          model: "model"
        }));
        return {
          agent: v2,
          model: v1
        };
      } else {
        agent_properties = bindTemplate(v2.set_properties, {
          model: "model"
        });
        model_properties = bindTemplate(v1.set_properties, {
          model: "agent"
        });
        v2.propertyInformation.map(t => t.set_properties = bindTemplate(t.set_properties, {
          model: "model"
        }));
        v1.propertyInformation.map(t => t.set_properties = bindTemplate(t.set_properties, {
          model: "agent"
        }));
        return {
          model: v2,
          agent: v1
        };
      }
    });
  }

  static GetFunctionValidators(state, funct) {
    return uiactions_NodesByType(state, uiactions_NodeTypes.Validator).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.ValidatorFunction) === funct.id);
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _streamProcessTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_ROOT_TEMPLATE, 'utf8');

    let _testClass = external_fs_default.a.readFileSync(streamprocessorchestrationgenerator_TEST_CLASS, 'utf8');

    let _streamProcessInterfaceTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_TEMPLATE_INTERFACE, 'utf8');

    const StreamProcessOrchestration = 'StreamProcessOrchestration';
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration));
    let agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    let result = {};
    agents.map(agent => {
      var temp = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateAgent({
        state,
        key,
        agent
      });
      result = { ...result,
        ...temp
      };
    });
    let strappers = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateStreamOrchestrations(models);
    let strapperInstances = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateStreamOrchestrationInstances(models);
    _streamProcessTemplate = bindTemplate(_streamProcessTemplate, {
      agent_type_methods: `

        public async Task ProcessStagedChanges(Distribution distribution = null)
        {
${agents.map(agent => {
        return `await ${GetCodeName(agent).toLowerCase()}StreamProcessOrchestration.ProcessStagedChanges(distribution);`;
      }).map(v => streamprocessorchestrationgenerator_Tabs(4) + v + streamprocessorchestrationgenerator_jNL).join('')}
        }
        `,
      arbiters_strappers: strappers,
      arbiter_instances: strapperInstances
    });
    let stream_process_tests = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateProcessTests(state);
    let testTemplate = bindTemplate(_testClass, {
      name: StreamProcessOrchestration,
      tests: stream_process_tests
    });
    _streamProcessInterfaceTemplate = bindTemplate(_streamProcessInterfaceTemplate, {
      agent_type_methods: '',
      agent_type: ''
    });
    let usings = [...STANDARD_CONTROLLER_USING];

    if (agents.find(agent => uiactions_NodesByType(state, uiactions_NodeTypes.Executor).find(x => existsLinkBetween(graphRoot, {
      source: x.id,
      target: agent.id
    })))) {
      usings = [...usings, `${namespace}${nodetypes_NameSpace.Executors}`];
    }

    let streamOrchestration = {
      [StreamProcessOrchestration]: {
        id: StreamProcessOrchestration,
        name: StreamProcessOrchestration,
        iname: `I${StreamProcessOrchestration}`,
        //  tname: `${StreamProcessOrchestration}Tests`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: _streamProcessTemplate,
          usings: [...usings, 'System.Linq.Expressions', `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.StreamProcess
        }),
        interface: namespacegenerator_NamespaceGenerator.Generate({
          template: _streamProcessInterfaceTemplate,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.StreamProcess
        }) // test: NamespaceGenerator.Generate({
        //     template: testTemplate,
        //     usings: [
        //         ...STANDARD_CONTROLLER_USING,
        //         ...STANDARD_TEST_USING,
        //         `${namespace}${NameSpace.Model}`,
        //         `${namespace}${NameSpace.Parameters}`,
        //         `${namespace}${NameSpace.Interface}`,
        //         `${namespace}${NameSpace.StreamProcess}`,
        //         `${namespace}${NameSpace.Executors}`,
        //         `${namespace}${NameSpace.Extensions}`,
        //         `${namespace}${NameSpace.Constants}`],
        //     namespace,
        //     space: NameSpace.Tests
        // })

      }
    };
    result = { ...result,
      ...streamOrchestration
    };
    return result;
  }

  static GenerateAgent(options) {
    var {
      state,
      key,
      agent
    } = options;
    const StreamProcessOrchestration = 'StreamProcessOrchestration';
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration));
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _streamProcessTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_TEMPLATE, 'utf8');

    let _streamProcessInterfaceTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_ORCHESTRATION_TEMPLATE_INTERFACE, 'utf8');

    let _testClass = external_fs_default.a.readFileSync(streamprocessorchestrationgenerator_TEST_CLASS, 'utf8');

    let agent_methods = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateAgentMethods(state, agent);
    let agent_methods_interface = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateAgentInterfaceMethods(state, agent);
    let statics = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateStaticMethods(models, agent);
    let strappers = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateStrappers(models, agent);
    let strapperInstances = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateStrappersInstances(models, agent);
    _streamProcessTemplate = bindTemplate(_streamProcessTemplate, {
      static_methods: statics.join(''),
      agent_type_methods: agent_methods,
      agent_type: GetCodeName(agent),
      agent: GetCodeName(agent),
      arbiters_strappers: strappers,
      arbiter_instances: strapperInstances
    });
    let stream_process_tests = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.GenerateProcessTests(state, agent);
    let testTemplate = bindTemplate(_testClass, {
      name: `${GetCodeName(agent)}${StreamProcessOrchestration}`,
      agent_type: GetCodeName(agent),
      tests: stream_process_tests
    });
    _streamProcessInterfaceTemplate = bindTemplate(_streamProcessInterfaceTemplate, {
      agent_type: GetCodeName(agent),
      agent_type_methods: agent_methods_interface
    });
    let usings = [...STANDARD_CONTROLLER_USING];

    if (uiactions_NodesByType(state, uiactions_NodeTypes.Executor).find(x => existsLinkBetween(graphRoot, {
      source: x.id,
      target: agent.id
    }))) {
      usings = [...usings, `${namespace}${nodetypes_NameSpace.Executors}`];
    }

    return {
      [`${GetCodeName(agent) + StreamProcessOrchestration}`]: {
        id: StreamProcessOrchestration,
        name: `${GetCodeName(agent)}${StreamProcessOrchestration}`,
        iname: `I${GetCodeName(agent)}${StreamProcessOrchestration}`,
        // tname: `${GetCodeName(agent)}${StreamProcessOrchestration}Tests`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: _streamProcessTemplate,
          usings: [...usings, 'System.Linq.Expressions', `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.StreamProcess
        }),
        interface: namespacegenerator_NamespaceGenerator.Generate({
          template: _streamProcessInterfaceTemplate,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.StreamProcess
        }) // test: NamespaceGenerator.Generate({
        //     template: testTemplate,
        //     usings: [
        //         ...STANDARD_CONTROLLER_USING,
        //         ...STANDARD_TEST_USING,
        //         `${namespace}${NameSpace.Model}`,
        //         `${namespace}${NameSpace.Parameters}`,
        //         `${namespace}${NameSpace.Interface}`,
        //         `${namespace}${NameSpace.StreamProcess}`,
        //         `${namespace}${NameSpace.Executors}`,
        //         `${namespace}${NameSpace.Extensions}`,
        //         `${namespace}${NameSpace.Constants}`],
        //     namespace,
        //     space: NameSpace.Tests
        // })

      }
    };
  }

}
const streamprocessorchestrationgenerator_NL = `
`;
const streamprocessorchestrationgenerator_jNL = `
`;
const streamprocessorchestrationgenerator_TAB = `   `;

function streamprocessorchestrationgenerator_Tabs(c) {
  let res = '';

  for (var i = 0; i < c; i++) {
    res += streamprocessorchestrationgenerator_TAB;
  }

  return res;
}
// CONCATENATED MODULE: ./app/generators/modelitemfiltergenerator.js









const RETURN_GET_CLASS = './app/templates/models/itemfilters/item_filter.tpl';
const FILTER_PROPERTY_FUNCTION_VALUE = './app/templates/models/itemfilters/filter_property_function_value.tpl';
const FILTER_PROPERTY_FUNCTION_VALUE_EQUALS = './app/templates/models/itemfilters/filter_property_function_value_equals.tpl';
const modelitemfiltergenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
class modelitemfiltergenerator_ModelItemFilterGenerator {
  static predicates(nodes, out_ = {}) {
    return nodes.map(x => {
      let validator = uiactions_GetNodeProp(x, uiactions_NodeProperties.FilterModel);
      let params = [];
      let filterModelParams = GetMethodFilterParameters(x.id);

      if (filterModelParams && filterModelParams.length) {
        params = filterModelParams.map(x => `${x.paramName}`);
      } else if (validator) {
        Object.values(validator.properties).map(t => Object.values(t.validators).map(v => {
          if (v && v.type === FilterRules.EqualsModelRef) {
            out_[v.node] = true;
            params.push(v.node);
          }
        }));
        params = params.filter(x => x).unique().sort();
      }

      let text = `${GetCodeName(x)}.Filter({{predicate_parameters}})`;
      return bindTemplate(text, {
        predicate_parameters: params.join(', ')
      });
    });
  }

  static GetFilterModel(graph, methodNode) {
    var node = null;
    var methodProps = GetMethodProps(methodNode);

    if (methodProps) {
      switch (GetFunctionType(methodNode)) {
        case functiontypes_FunctionTypes.Get_ManyToMany_Agent_Value__IListChild:
          node = GetNode(graph, methodProps[FunctionTemplateKeys.ManyToManyModel]);
          break;

        case functiontypes_FunctionTypes.Create_Object_Agent_Value__IListObject:
        case functiontypes_FunctionTypes.Get_Parent$Child_Agent_Value__IListChild:
        case functiontypes_FunctionTypes.Create_Parent$Child_Agent_Value__IListChild:
        case functiontypes_FunctionTypes.Create_Parent_Child_Agent_Value__Child:
        default:
          node = GetNode(graph, methodProps[FunctionTemplateKeys.ModelOutput] || methodProps[FunctionTemplateKeys.Model]);
          break;
      }
    }

    return node;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let graph = GetRootGraph(state);
    let result = {};

    let _return_get_class = external_fs_default.a.readFileSync(RETURN_GET_CLASS, 'utf8');

    let allfilters = uiactions_NodesByType(state, uiactions_NodeTypes.ModelFilter);
    let modelitemfilters = uiactions_NodesByType(state, uiactions_NodeTypes.ModelItemFilter);
    modelitemfilters.map(modelitemfilter => {
      var method = GetMethodNode(state, modelitemfilter.id);
      var methodProps = null;
      let filterModelNode = null;

      if (method) {
        methodProps = GetMethodProps(method);
        filterModelNode = modelitemfiltergenerator_ModelItemFilterGenerator.GetFilterModel(graphRoot, method);
      }

      let itemFilter = uiactions_GetNodeProp(modelitemfilter, uiactions_NodeProperties.ModelItemFilter) || (filterModelNode ? filterModelNode.id : null);
      let filterModel = uiactions_GetNodeProp(modelitemfilter, uiactions_NodeProperties.FilterModel);
      let conditions = uiactions_GetConditionNodes(modelitemfilter.id);
      let filterMethodParameters = GetMethodFilterParameters(modelitemfilter.id);
      let meta_parameters = GetMethodFilterMetaParameters(modelitemfilter.id);
      let funcs = [];
      let parameters = [];

      if (true) {
        let filterPropFunction = external_fs_default.a.readFileSync(FILTER_PROPERTY_FUNCTION_VALUE, 'utf8');
        let filters = [];
        parameters = parameters.filter(x => x).unique().sort();

        if (filterMethodParameters && filterMethodParameters.length) {
          parameters = filterMethodParameters.map(item => {
            return `${item.paramClass} ${item.paramName}`;
          });
        }

        if (meta_parameters && meta_parameters.length) {
          meta_parameters = meta_parameters.map(item => {
            return `${item.paramName}`;
          });
        }

        if (conditions && conditions.length) {
          filters = GetCombinedCondition(modelitemfilter.id);
        } else {
          filters = filters.join('');
        }

        funcs.push(bindTemplate(filterPropFunction, {
          filter: filters,
          model: GetCodeName(itemFilter),
          model_output: GetCodeName(itemFilter),
          meta_parameter: meta_parameters.join(', '),
          parameters: parameters.join(', ')
        }));
      }

      let templateRes = bindTemplate(_return_get_class, {
        code_name: uiactions_GetNodeProp(modelitemfilter, uiactions_NodeProperties.CodeName),
        filter: funcs
      });
      result[uiactions_GetNodeProp(modelitemfilter, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(modelitemfilter, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(modelitemfilter, uiactions_NodeProperties.CodeName)}`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: templateRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/maestrogenerator.js










const MAESTRO_CLASS_TEMPLATE = "./app/templates/maestro/maestro.tpl";
const MAESTRO_INTERFACE_TEMPLATE = "./app/templates/maestro/imaestro.tpl";
const maestrogenerator_CONTROLLER_CLASS_FUNCTION_TEMPLATE = "./app/templates/controller/controller_functions.tpl";
const maestrogenerator_TEST_CLASS = "./app/templates/tests/tests.tpl";
const MAESTRO_FUNCTION_TESTS = "./app/templates/maestro/tests/maestro.tpl";
const MAESTRO_FUNCTION_SAME_AGENT_MODEL_TESTS = "./app/templates/maestro/tests/maestro_same_agent_model.tpl";
const get_agent_manytomany_listchild_interface = "./app/templates/maestro/tests/get_agent_manytomany_listchild_interface.tpl";
const MAESTRO_FUNCTION_GET_TESTS = "./app/templates/maestro/tests/maestro_get.tpl";
const maestrogenerator_PROPERTY_TABS = 6;
class maestrogenerator_MaestroGenerator {
  static Tabs(c) {
    let res = "";

    for (var i = 0; i < c; i++) {
      res += maestrogenerator_TAB;
    }

    return res;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let maestros = uiactions_NodesByType(state, uiactions_NodeTypes.Maestro).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration));

    let _maestroTemplateClass = external_fs_default.a.readFileSync(MAESTRO_CLASS_TEMPLATE, "utf8");

    let _MAESTRO_INTERFACE_TEMPLATE = external_fs_default.a.readFileSync(MAESTRO_INTERFACE_TEMPLATE, "utf8");

    let _testClass = external_fs_default.a.readFileSync(maestrogenerator_TEST_CLASS, "utf8");

    let testFunctionTemplate = external_fs_default.a.readFileSync(MAESTRO_FUNCTION_TESTS, "utf8");
    let testFunctionGetSameParentTemplate = external_fs_default.a.readFileSync(MAESTRO_FUNCTION_SAME_AGENT_MODEL_TESTS, "utf8");
    let testFunctionGetTemplate = external_fs_default.a.readFileSync(MAESTRO_FUNCTION_GET_TESTS, "utf8");
    let root = GetRootGraph(state);
    let graph = GetCurrentGraph(state);
    let result = {};
    maestros.map(maestro => {
      let maestroTemplateClass = _maestroTemplateClass;
      let functions = "";
      let functionsInterface = "";
      let statics = "";
      let codeName = `${uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName)}`;
      let maestro_functions = [];
      let tempfunctions = getNodesByLinkType(root, {
        id: maestro.id,
        type: nodetypes_LinkType.FunctionLink,
        direction: SOURCE
      });
      let arbiters = [];
      let permissions = [];
      let maestroName = uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName);
      maestro_functions = tempfunctions;
      let permissionValidationCases = [];

      if (maestro_functions.length) {
        maestro_functions.filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.NotIncludedInController)).map(maestro_function => {
          let function_type = uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.FunctionType);
          var ft = MethodFunctions[function_type];

          if (ft) {
            let tempFunction = ft.template;
            let interfaceFunction = ft.interface;
            let testFunction = ft.test;
            let value_type = "";
            let parent_type = "";

            if (ft.parentGet) {
              value_type = "string";
            }

            let functionName = `${uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.CodeName)}`;
            let httpMethod = `${uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.HttpMethod)}`;
            let httpRoute = `${uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.HttpRoute)}`;
            let datachainoptions = {
              "lambda.default": ""
            };
            let dataChainNodes = GetNodesLinkedTo(null, {
              id: maestro_function.id,
              link: nodetypes_LinkType.DataChainLink,
              direction: SOURCE
            });
            dataChainNodes.map(dataChainNode => {
              let lambda = GetLambdaDefinition(maestro_function);

              if (lambda) {
                if (dataChainNode) {
                  let dataChainArgs = GenerateDataChainArguments(dataChainNode.id);
                  let link = GetLinkBetween(maestro_function.id, dataChainNode.id, GetCurrentGraph());
                  datachainoptions["lambda.default"] = `
        var ${GetCodeName(dataChainNode).toLowerCase()} = RedStrapper.Resolve<${GetCodeName(dataChainNode)}>();
        return await ${GetCodeName(dataChainNode).toLowerCase()}.Execute(${dataChainArgs});`;
                } else if (lambda.default) {
                  datachainoptions = {
                    "lambda.default": `return ${lambda.default.return};`
                  };
                }
              }
            });

            if (!datachainoptions["lambda.default"] && ft.lambda && ft.lambda.default) {
              datachainoptions["lambda.default"] = `return ${ft.lambda.default.return};`;
            }

            let agentTypeNode = null;
            let fetchTypeNode = null;
            let userTypeNode = null;
            let parentNode = null;
            let permissionNode = null;
            let modelFilterNode = null;
            let compositeInput = null;
            let manyToManyNode = null;
            let connectingNode = null;
            let parent_setup = "";
            let modelNode = null;
            let parent = null;
            let model_output = null;
            let methodProps = uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.MethodProps);
            let predicates = "";

            if (methodProps) {
              agentTypeNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.AgentType] || methodProps[FunctionTemplateKeys.Agent]);
              modelNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.Model]);
              userTypeNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.User]);
              fetchTypeNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.FetchParameter]);
              permissionNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.Permission]);
              modelFilterNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.ModelFilter]);
              compositeInput = GetNode(graphRoot, methodProps[FunctionTemplateKeys.CompositeInput]);
              manyToManyNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.ManyToManyModel]);
              connectingNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.ConnectionType]);
              model_output = GetCodeName(methodProps[FunctionTemplateKeys.ModelOutput]);
              parentNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.Parent]);
              parent_type = parentNode ? uiactions_GetNodeProp(parentNode, uiactions_NodeProperties.CodeName) : "{missing parent name}";
              manyToManyNode = GetNode(graphRoot, methodProps[FunctionTemplateKeys.ManyToManyModel]);
              var modelItemFilters = GetLinkChain(state, {
                id: maestro_function.id,
                links: [{
                  type: nodetypes_LinkType.ModelItemFilter,
                  direction: SOURCE
                }]
              });
              var out_predicate = {};
              predicates = modelitemfiltergenerator_ModelItemFilterGenerator.predicates(modelItemFilters, out_predicate);

              if (predicates.length) {
                predicates = predicates.join(", ");
              } else {
                predicates = "";
              }

              if (out_predicate.parent) {
                parent_setup = `var parent = await arbiter${parent_type}.Get<${parent_type}>(model.${parent_type});`;
              }
            }

            let agent = agentTypeNode ? `${uiactions_GetNodeProp(agentTypeNode, uiactions_NodeProperties.CodeName)}` : `{maestro_generator_mising_agentTypeNode}`;
            let model_type = modelNode ? uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName) : `{maestro_generator_mising_model}`;
            let agent_type = agentTypeNode ? `${uiactions_GetNodeProp(agentTypeNode, uiactions_NodeProperties.CodeName)}` : `{maestro_generator_mising_agentTypeNode}`;
            let methodType = uiactions_GetNodeProp(maestro_function, uiactions_NodeProperties.MethodType);
            let connect_type = connectingNode ? GetCodeName(connectingNode) : "{maestro_connection_type_missing}";
            if (parentNode) arbiters.push(parent_type);
            let manyNodes = GetManyToManyNodes(graphRoot, [modelNode ? modelNode.id : false, agentTypeNode ? agentTypeNode.id : null].filter(x => x)) || [];
            arbiters.push(...manyNodes.map(manyNode => {
              return uiactions_GetNodeProp(manyNode, uiactions_NodeProperties.CodeName);
            }));
            arbiters.push(agent_type, model_type);
            permissions.push({
              agent_type,
              model_type
            });
            let value = "";
            let agentAndModelIsTheSame = false;

            if (ft.parentGet) {
              value = parentNode ? `${uiactions_GetNodeProp(parentNode, uiactions_NodeProperties.CodeName)}`.toLowerCase() : "{missing parent name}";

              if (agentTypeNode && parentNode) {
                agentAndModelIsTheSame = agentTypeNode.id === parentNode.id;
              }
            } else {
              value = modelNode ? `${uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName)}`.toLowerCase() : `{maestro_generator_mising_model}`;
            }

            let bindOptions = { ...datachainoptions,
              function_name: functionName,
              agent_type: agent_type,
              "agent_type#lower": `${agent_type}`.toLowerCase(),
              parent_type,
              agent: agent,
              "composite-input": GetCodeName(compositeInput) || "",
              model_input: GetCodeName(compositeInput) || model_type,
              value_type,
              value,
              parent_setup,
              model_output,
              parent: GetCodeName(parentNode),
              model: model_type,
              connect_type,
              comma: predicates.length ? "," : "",
              predicates,
              maestro_function: functionName,
              filter_function: modelFilterNode ? uiactions_GetNodeProp(modelFilterNode, uiactions_NodeProperties.CodeName) : "{missing filter node}",
              user: userTypeNode ? uiactions_GetNodeProp(userTypeNode, uiactions_NodeProperties.CodeName) : `{maestro_generator_mising_user}`,
              http_route: httpRoute || "{maestro_generator_http_method",
              http_method: httpMethod || "{maestro_generator_http_method",
              fetch_parameter: fetchTypeNode ? `${uiactions_GetNodeProp(fetchTypeNode, uiactions_NodeProperties.CodeName)}` : `{maestro_generator_mising_fetchParameter}`,
              user_instance: userTypeNode ? `${uiactions_GetNodeProp(userTypeNode, uiactions_NodeProperties.CodeName)}`.toLowerCase() : `{maestro_generator_mising_userNode}`,
              output_type: modelNode ? GetCodeName(modelNode) : "{maestro_generator_missing_model}",
              maestro_interface: ToInterface(maestroName),
              permission_function: permissionNode ? uiactions_GetNodeProp(permissionNode, uiactions_NodeProperties.CodeName) : `{MISSING_PERMISSION_FUNCTION}`,
              input_type: modelNode ? GetCodeName(modelNode) : "{maestro_generator_missing_model}"
            };
            tempFunction = bindTemplate(tempFunction, bindOptions);
            interfaceFunction = bindTemplate(interfaceFunction, bindOptions);
            functions += maestrogenerator_jNL + tempFunction;
            functionsInterface += maestrogenerator_jNL + interfaceFunction;
            var cases = permissiongenerator_PermissionGenerator.EnumeratePermissionCases(graph, permissionNode, methodType, agentTypeNode, modelNode);
            let validators = streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.EnumerateFunctionValidators(state, maestro_function);

            if (validators && cases) {
              validators.map(validator => {
                cases.map(_case => {
                  let pvc = {};
                  let pvc2 = {};

                  if (validator && validator.agent && _case.agentProperties) {
                    var temp = [...validator.agent.propertyInformation.map(t => t.set_properties), ..._case.properties.filter(x => x.type === FunctionTemplateKeys.Agent).map(t => t.props).map((t, index) => {
                      if (validator.agent.propertyInformation.findIndex(x => x.property === t.property) !== -1) {
                        return false;
                      }

                      return _case.agentProps[index];
                    }).filter(x => x)].join(nodetypes_NEW_LINE);
                    pvc.agent = temp;
                  }

                  if (validator && validator.model && _case.itemProperties) {
                    var temp = [...validator.model.propertyInformation.map(t => t.set_properties), ..._case.filter(x => x.type === FunctionTemplateKeys.Model).map(t => t.props).map((t, index) => {
                      if (validator.model.propertyInformation.findIndex(x => x.property === t.property) !== -1) {
                        return false;
                      }

                      return _case.itemProps[index];
                    }).filter(x => x)].join(nodetypes_NEW_LINE);
                    pvc.model = temp;
                  }

                  if (validator && validator.agent && _case.agentProperties) {
                    var temp = [..._case.agentProperties.map((t, index) => _case.agentProps[index]), ...validator.agent.propertyInformation.map((t, index) => {
                      if (_case.agentProperties.findIndex(x => x.property === t.property) !== -1) {
                        return false;
                      }

                      return validator.agent.propertyInformation[index].set_properties;
                    }).filter(x => x)].join(nodetypes_NEW_LINE);
                    pvc2.agent = temp;
                  }

                  if (validator && validator.model && _case.itemProperties) {
                    var temp = [..._case.itemProperties.map((t, index) => _case.itemProps[index]), ...validator.model.propertyInformation.map((t, index) => {
                      if (_case.itemProperties.findIndex(x => x.property === t.property) !== -1) {
                        return false;
                      }

                      return validator.model.propertyInformation[index].set_properties;
                    }).filter(x => x)].join(nodetypes_NEW_LINE);
                    pvc2.model = temp;
                  }

                  permissionValidationCases.push(pvc2);
                  permissionValidationCases.push(pvc);
                });
              });
              permissionValidationCases = permissionValidationCases.map((pvc, index) => {
                //Generate tests.
                let templ = testFunctionTemplate;

                switch (ft.method) {
                  case nodetypes_Methods.Get:
                  case nodetypes_Methods.GetAll:
                    templ = testFunctionGetTemplate;

                    if (agentAndModelIsTheSame) {
                      templ = testFunctionGetSameParentTemplate;
                    }

                    break;
                }

                switch (function_type) {
                  case functiontypes_FunctionTypes.Get_ManyToMany_Agent_Value__IListChild:
                    templ = external_fs_default.a.readFileSync(get_agent_manytomany_listchild_interface, "utf8");
                    break;
                }

                if (ft.test) {
                  templ = ft.test;
                }

                return bindTemplate(templ, {
                  agent: agent_type,
                  many_to_many: uiactions_GetNodeProp(manyToManyNode, uiactions_NodeProperties.CodeName),
                  parent: uiactions_GetNodeProp(parentNode, uiactions_NodeProperties.CodeName),
                  set_many_to_many_properties: "//{not set yet}",
                  value: modelNode ? `${uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName)}`.toLowerCase() : `{maestro_generator_mising_model}`,
                  model: model_type,
                  model_input: GetCodeName(compositeInput) || model_type,
                  function_name: functionName,
                  maestro: maestroName,
                  set_agent_properties: pvc.agent,
                  user: userTypeNode ? uiactions_GetNodeProp(userTypeNode, uiactions_NodeProperties.CodeName) : `{maestro_generator_mising_user}`,
                  set_model_properties: pvc.model,
                  testname: `${functionName}Test${index}`
                });
              }); // Do analysis on whether these validations are completely bonk.
            }
          }
        });
      }

      arbiters = arbiters.unique();
      permissions = permissions.unique(x => `${x.agent_type}`);
      var injectedServices = arbiters.map(x => `IRedArbiter<${x}> _arbiter${x}`);
      var injectedPermissionServices = permissions.map(x => `IPermissions${x.agent_type} _${x.agent_type.toLowerCase()}Permissions`);
      var set_properties = arbiters.map(x => maestrogenerator_jNL + maestrogenerator_MaestroGenerator.Tabs(4) + `arbiter${x} = _arbiter${x};`);
      var set_permissions = permissions.map(x => maestrogenerator_jNL + maestrogenerator_MaestroGenerator.Tabs(4) + `${x.agent_type.toLowerCase()}Permissions = _${x.agent_type.toLowerCase()}Permissions;`);
      var properties = arbiters.map(x => maestrogenerator_jNL + maestrogenerator_MaestroGenerator.Tabs(3) + `private readonly IRedArbiter<${x}> arbiter${x};`);
      var permissions_properties = permissions.map(x => maestrogenerator_jNL + maestrogenerator_MaestroGenerator.Tabs(3) + `private readonly IPermissions${x.agent_type} ${x.agent_type.toLowerCase()}Permissions;`);
      let testTemplate = bindTemplate(_testClass, {
        name: codeName,
        tests: permissionValidationCases.join(nodetypes_NEW_LINE)
      });
      maestroTemplateClass = bindTemplate(maestroTemplateClass, {
        codeName: codeName,
        set_properties: [...set_properties, ...set_permissions].join(maestrogenerator_jNL),
        properties: [...permissions_properties, ...properties].join(" "),
        injected_services: [...injectedServices, ...injectedPermissionServices].map((t, ti) => maestrogenerator_jNL + maestrogenerator_MaestroGenerator.Tabs(7) + t).join(","),
        "codeName#alllower": codeName.toLowerCase(),
        functions
      });
      let maestro_interface_template = bindTemplate(_MAESTRO_INTERFACE_TEMPLATE, {
        codeName: codeName,
        set_properties: [...set_properties, ...set_permissions].join(maestrogenerator_jNL),
        properties: [...permissions_properties, ...properties].join(" "),
        injected_services: [...injectedServices, ...injectedPermissionServices].map((t, ti) => maestrogenerator_jNL + maestrogenerator_MaestroGenerator.Tabs(7) + t).join(","),
        "codeName#alllower": codeName.toLowerCase(),
        functions: functionsInterface
      });
      result[uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName),
        name: uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName),
        iname: `I${uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName)}`,
        tname: `${uiactions_GetNodeProp(maestro, uiactions_NodeProperties.CodeName)}Tests`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: maestroTemplateClass,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.StreamProcess}`, `${namespace}${nodetypes_NameSpace.Constants}`, `${namespace}${nodetypes_NameSpace.Permissions}`, `${namespace}${nodetypes_NameSpace.Parameters}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        }),
        interface: namespacegenerator_NamespaceGenerator.Generate({
          template: maestro_interface_template,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        }),
        test: namespacegenerator_NamespaceGenerator.Generate({
          template: testTemplate,
          usings: [...STANDARD_CONTROLLER_USING, ...STANDARD_TEST_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.StreamProcess}`, `${namespace}${nodetypes_NameSpace.Permissions}`, `${namespace}${nodetypes_NameSpace.Controllers}`, `${namespace}${nodetypes_NameSpace.Executors}`, `${namespace}${nodetypes_NameSpace.Extensions}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Tests
        })
      };
    });
    return result;
  }

}
const maestrogenerator_NL = `
                    `;
const maestrogenerator_jNL = `
`;
const maestrogenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/generators/changeparametergenerator.js


/* eslint-disable no-underscore-dangle */






const changeparametergenerator_TEST_CLASS = "./app/templates/tests/tests.tpl";
const STREAM_PROCESS_CHANGE_CLASS_EXTENSION = "./app/templates/stream_process/stream_process_change_class_extention.tpl";
const STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR = "./app/templates/stream_process/stream_process_change_class_constructor.tpl";
const STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR_TESTS = "./app/templates/stream_process/tests/stream_process_change_class_constructor.tpl";
const changeparametergenerator_MODEL_STATIC_TEMPLATES = "./app/templates/models/model_statics.tpl";
const changeparametergenerator_PROPERTY_TABS = 6;
class changeparametergenerator_ChangeParameterGenerator {
  static Tabs(c) {
    let res = "";

    for (let i = 0; i < c; i++) {
      res += changeparametergenerator_TAB;
    }

    return res;
  }

  static Generate(options) {
    let {
      state,
      key
    } = options;
    const models = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController));
    const afterEffects = uiactions_NodesByType(state, uiactions_NodeTypes.AfterEffect);
    const agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    const graphRoot = GetRootGraph(state);
    const namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    const _testClass = external_fs_default.a.readFileSync(changeparametergenerator_TEST_CLASS, "utf8");

    const _streamProcessChangeClassExtension = external_fs_default.a.readFileSync(STREAM_PROCESS_CHANGE_CLASS_EXTENSION, "utf8");

    const _streamProcessChangeClassConstructors = external_fs_default.a.readFileSync(STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR, "utf8");

    const _streamProcessChangeClassConstrictorsTest = external_fs_default.a.readFileSync(STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR_TESTS, "utf8");

    const result = {};
    models.map(model => {
      agents.map(agent => {
        let streamProcessChangeClassExtension = _streamProcessChangeClassExtension;
        let testClass = _testClass;
        const constructors = [];
        const tests = [];
        const updates_with = [];
        const staticFunctionTemplate = external_fs_default.a.readFileSync(changeparametergenerator_MODEL_STATIC_TEMPLATES, "utf8");
        afterEffects.filter(afterEffect => {
          const functionType = uiactions_GetNodeProp(afterEffect, uiactions_NodeProperties.AfterMethod);
          const setup = uiactions_GetNodeProp(afterEffect, uiactions_NodeProperties.AfterMethodSetup);

          if (setup && functionType && setup[functionType][FunctionTemplateKeys.ModelOutput]) {
            let method = GetMethodNode(state, afterEffect.id);

            if (method) {
              let valid = GetMethodNodeProp(method, setup[functionType][FunctionTemplateKeys.Agent]) === agent.id && GetMethodNodeProp(method, setup[functionType][FunctionTemplateKeys.ModelOutput]) == model.id;
              return valid;
            }
          }

          return false;
        }).filter(afterEffect => {
          const functionType = uiactions_GetNodeProp(afterEffect, uiactions_NodeProperties.AfterMethod);
          const setup = uiactions_GetNodeProp(afterEffect, uiactions_NodeProperties.AfterMethodSetup);

          if (AFTER_EFFECTS[functionType] && AFTER_EFFECTS[functionType]) {
            const methodNode = GetMethodNode(state, afterEffect.id);
            const stream_process_change_parameter = AFTER_EFFECTS[functionType][MethodTemplateKeys.stream_process_change_parameter];

            if (stream_process_change_parameter) {
              let spcp_template = external_fs_default.a.readFileSync(stream_process_change_parameter, "utf8");
              spcp_template = bindTemplate(spcp_template, {
                model: GetCodeName(model),
                value: uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || "value",
                agent_type: GetCodeName(agent),
                model_update: GetCodeName(GetMethodNodeProp(methodNode, setup[functionType][FunctionTemplateKeys.UpdateModel])),
                agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || "agent",
                change_type: `Methods.${setup[functionType][FunctionTemplateKeys.MethodType]}`,
                method: setup[functionType][FunctionTemplateKeys.MethodType]
              });
              constructors.push(spcp_template);
            }

            const update_with = AFTER_EFFECTS[functionType][MethodTemplateKeys.update_with];

            if (update_with) {
              let spcp_template = external_fs_default.a.readFileSync(update_with, "utf8");
              spcp_template = bindTemplate(spcp_template, {
                model_update: GetCodeName(GetMethodNodeProp(methodNode, setup[functionType][FunctionTemplateKeys.UpdateModel]))
              });
              updates_with.push(spcp_template + nodetypes_NEW_LINE);
            }
          }
        });
        Object.values(nodetypes_Methods).filter(x => ![nodetypes_Methods.Get, nodetypes_Methods.GetAll].some(v => v == x)).map(method => {
          let streamProcessChangeClassConstructors = _streamProcessChangeClassConstructors;
          streamProcessChangeClassConstructors = bindTemplate(streamProcessChangeClassConstructors, {
            model: GetCodeName(model),
            value: uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || "value",
            agent_type: GetCodeName(agent),
            agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || "agent",
            change_type: `Methods.${method}`,
            method
          });
          let streamProcessChangeClassConstrictorsTest = _streamProcessChangeClassConstrictorsTest;
          streamProcessChangeClassConstrictorsTest = bindTemplate(streamProcessChangeClassConstrictorsTest, {
            model: GetCodeName(model),
            value: uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || "value",
            agent_type: GetCodeName(agent),
            agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || "agent",
            change_type: `Methods.${method}`,
            method
          });
          constructors.push(streamProcessChangeClassConstructors);
          tests.push(streamProcessChangeClassConstrictorsTest);
        });
        const staticDic = {
          property_set_merge: "",
          model: `${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`
        };
        constructors.push(bindTemplate(staticFunctionTemplate, staticDic));
        streamProcessChangeClassExtension = bindTemplate(streamProcessChangeClassExtension, {
          model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
          agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          updates_with: updates_with.unique().join(""),
          constructors: constructors.unique().join(changeparametergenerator_jNL)
        });
        testClass = bindTemplate(testClass, {
          name: `${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`,
          tests: tests.unique(x => x).join("")
        });
        const change_param_name = `${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`;
        result[change_param_name] = {
          id: change_param_name,
          name: change_param_name,
          tname: `${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Tests`,
          template: namespacegenerator_NamespaceGenerator.Generate({
            template: streamProcessChangeClassExtension,
            usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Constants}`, `${namespace}${nodetypes_NameSpace.Model}`],
            namespace,
            space: nodetypes_NameSpace.Parameters
          }),
          test: namespacegenerator_NamespaceGenerator.Generate({
            template: testClass,
            usings: [...STANDARD_CONTROLLER_USING, ...STANDARD_TEST_USING, `${namespace}${nodetypes_NameSpace.Constants}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Model}`],
            namespace,
            space: nodetypes_NameSpace.Tests
          })
        };
      });
    });
    return result;
  }

}
const changeparametergenerator_NL = `
                    `;
const changeparametergenerator_jNL = `
`;
const changeparametergenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/generators/constantsgenerator.js







const CONSTANTS_CLASS = './app/templates/constants.tpl';
class constantsgenerator_ConstantsGenerator {
  static Tabs(c) {
    let res = '';

    for (var i = 0; i < c; i++) {
      res += constantsgenerator_TAB;
    }

    return res;
  }

  static Generate(options) {
    var {
      values = [],
      state
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _constantsClass = external_fs_default.a.readFileSync(CONSTANTS_CLASS, 'utf8');

    let result = {};
    values.map(value => {
      let {
        model,
        name
      } = value;
      let constantsClass = _constantsClass;
      let constructors = [];
      var consts = Object.keys(model).map(key => {
        let template = `public const string {{name}} = "{{value}}";`;
        let temp = bindTemplate(template, {
          name: key,
          value: model[key]
        });
        return constantsgenerator_ConstantsGenerator.Tabs(3) + temp;
      }).join(constantsgenerator_jNL);
      constantsClass = bindTemplate(constantsClass, {
        constants: consts,
        constants_type: name
      });
      result[name] = {
        id: name,
        name: name,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: constantsClass,
          usings: [...STANDARD_CONTROLLER_USING],
          namespace,
          space: nodetypes_NameSpace.Constants
        })
      };
    });
    return result;
  }

}
const constantsgenerator_NL = `
                    `;
const constantsgenerator_jNL = `
`;
const constantsgenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/service/permissionservice.js






function GetMethodDefinitionPermissionSection(id) {
  let methodDefinition = GetMethodDefinition(id);

  if (methodDefinition && methodDefinition.permission) {
    return methodDefinition.permission;
  }

  console.warn('doesnt define a permission for method type ');
  return false;
}

function GetPermissionMethodImplementation(id, language = ProgrammingLanguages.CSHARP) {
  let permissionSection = GetMethodDefinitionPermissionSection(id);
  let {
    implementation
  } = permissionSection;
  let implementation_template = external_fs_default.a.readFileSync(implementation, 'utf8');
  let parameters = GetPermissionMethodParametersImplementation(id, language);
  let conditions = GetCombinedCondition(id, language);
  return bindTemplate(implementation_template, {
    parameters,
    conditions,
    function_name: GetCodeName(id)
  });
}
function GetPermissionMethodInterface(id, language = ProgrammingLanguages.CSHARP) {
  let permissionSection = GetMethodDefinitionPermissionSection(id);

  if (!permissionSection) {
    return false;
  }

  let {
    interface_
  } = permissionSection;
  let interface_template = external_fs_default.a.readFileSync(interface_, 'utf8');
  let parameters = GetPermissionMethodParametersImplementation(id, language);
  return bindTemplate(interface_template, {
    parameters,
    function_name: GetCodeName(id)
  });
}
function GetAgentPermissionInterface(agentId) {
  let dictionary = GetPermissionsSortedByAgent(); //    if (dictionary && dictionary[agentId]) {

  let namespace = GetNameSpace();
  let interface_ = BuildAgentPermissionInterface(agentId, (dictionary[agentId] || []).map(t => t.id));
  return namespacegenerator_NamespaceGenerator.Generate({
    template: interface_,
    usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Model}`],
    namespace,
    space: nodetypes_NameSpace.Interface
  }); // }
  // else {
  //     throw 'agent doesnt have any permissions';
  // }
}
function GenerateAgentPermissionInterfacesAndImplementations() {
  var agents = GetAgentNodes();
  let result = {};
  agents.map(agent => {
    let agentName = GetCodeName(agent.id);
    let temp = {
      name: `Permissions${agentName}`,
      iname: `IPermissions${agentName}`,
      template: GetAgentPermissionImplementation(agent.id),
      interface: GetAgentPermissionInterface(agent.id)
    };
    result[agentName] = temp;
  });
  return result;
}
function GetAgentPermissionImplementation(agentId) {
  let dictionary = GetPermissionsSortedByAgent(); //if (dictionary && dictionary[agentId]) {

  let namespace = GetNameSpace();
  let implementation = BuildAgentPermissionImplementation(agentId, (dictionary[agentId] || []).map(t => t.id));
  return namespacegenerator_NamespaceGenerator.Generate({
    template: implementation,
    usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Extensions}`, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Controllers}`, `${namespace}${nodetypes_NameSpace.Constants}`].filter(x => x),
    namespace,
    space: nodetypes_NameSpace.Permissions
  }); // }
  // else {
  //     throw 'agent doesnt have any permissions';
  // }
}
function BuildAgentPermissionInterface(agentId, permissions, language = ProgrammingLanguages.CSHARP) {
  let methods = permissions.map(permission => {
    return GetPermissionMethodInterface(permission, language);
  }).filter(x => x).join(nodetypes_NEW_LINE);
  let template = external_fs_default.a.readFileSync('./app/templates/permissions/permissions_interface.tpl', 'utf8');
  return bindTemplate(template, {
    agent_type: GetCodeName(agentId),
    methods
  });
}
function BuildAgentPermissionImplementation(agentId, permissions, language = ProgrammingLanguages.CSHARP) {
  let methods = permissions.map(permission => {
    return GetPermissionMethodImplementation(permission, language);
  }).filter(x => x).join(nodetypes_NEW_LINE);
  let template = external_fs_default.a.readFileSync('./app/templates/permissions/permissions_impl.tpl', 'utf8');

  let _constructTemplate = external_fs_default.a.readFileSync('./app/templates/permissions/constructor.tpl', 'utf8');

  let customService = GetCustomServiceImplementations(uiactions_NodeTypes.Permission) || '';
  let constructor = bindTemplate(_constructTemplate, {
    agent_type: `${GetCodeName(agentId)}`,
    arbiters: [GetArbiterPropertyImplementations(4, language), customService].join(nodetypes_NEW_LINE)
  });
  return bindTemplate(template, {
    agent_type: GetCodeName(agentId),
    arbiters: [GetArbiterPropertyDefinitions(), GetCustomServiceDefinitions(uiactions_NodeTypes.Permission)].join(nodetypes_NEW_LINE),
    constructor,
    methods
  });
}
function GetPermissionMethodParameters(id) {
  let permissionSection = GetMethodDefinitionPermissionSection(id);
  let {
    params
  } = permissionSection;
  let methodNode = uiactions_GetMethodNode(id);
  return params.map(param => {
    return {
      paramClass: GetMethodNodeProp(methodNode, param),
      paramProperty: safeFormatTemplateProperty(param)
    };
  });
}
function GetPermissionMethodParametersImplementation(id, language = ProgrammingLanguages.CSHARP) {
  let parameters = GetPermissionMethodParameters(id);

  switch (language) {
    case ProgrammingLanguages.CSHARP:
      return parameters.map(t => `${GetCodeName(t.paramClass)} ${t.paramProperty}`).join(', ');
  }
}
// CONCATENATED MODULE: ./app/generators/permission_conditiongenerator.js

class permission_conditiongenerator_PermissionGenerator {
  static Generate(options) {
    let result = GenerateAgentPermissionInterfacesAndImplementations();
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/streamprocessgenerator.js






const streamprocessgenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
const STREAM_PROCESS_TEMPLATE = './app/templates/stream_process/stream_process.tpl';
const STREAM_PROCESS_TEMPLATE_TESTS = './app/templates/stream_process/tests/stream_process.tpl';
const STREAM_PROCESS_FUNCTION_TEMPLATE = './app/templates/stream_process/stream_process_function.tpl';
class streamprocessgenerator_StreamProcessGenerator {
  static GenerateStaticMethods(models) {
    let agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));

    let _streamProcessFunctionTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_FUNCTION_TEMPLATE, 'utf8');

    let staticMethods = [];
    agents.map(agent => {
      models.map(model => {
        let streamProcessFunctionTemplate = _streamProcessFunctionTemplate;
        let modelCode = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
        let res = bindTemplate(streamProcessFunctionTemplate, {
          model: modelCode,
          agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          [`model#allupper`]: modelCode.toUpperCase()
        });
        staticMethods.push(res + streamprocessgenerator_jNL);
      });
    });
    return staticMethods;
  }

  static GenerateStaticMethodTests(models) {
    let agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));

    let _streamProcessTemplateTests = external_fs_default.a.readFileSync(STREAM_PROCESS_TEMPLATE_TESTS, 'utf8');

    let _streamProcessFunctionTemplate = _streamProcessTemplateTests;
    let staticMethods = [];
    agents.map(agent => {
      models.map(model => {
        let streamProcessFunctionTemplate = _streamProcessFunctionTemplate;
        let modelCode = uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName);
        let res = bindTemplate(streamProcessFunctionTemplate, {
          model: modelCode,
          agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          [`model#allupper`]: modelCode.toUpperCase()
        });
        staticMethods.push(res + streamprocessgenerator_jNL);
      });
    });
    return staticMethods.unique(x => x);
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration));
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _streamProcessTemplate = external_fs_default.a.readFileSync(STREAM_PROCESS_TEMPLATE, 'utf8');

    let _streamProcessTemplateTests = external_fs_default.a.readFileSync(streamprocessgenerator_TEST_CLASS, 'utf8');

    let statics = streamprocessgenerator_StreamProcessGenerator.GenerateStaticMethods(models);
    let staticTests = streamprocessgenerator_StreamProcessGenerator.GenerateStaticMethodTests(models);
    _streamProcessTemplate = bindTemplate(_streamProcessTemplate, {
      static_methods: statics.unique(x => x).join('')
    });
    _streamProcessTemplateTests = bindTemplate(_streamProcessTemplateTests, {
      tests: staticTests.unique(x => x).join(''),
      name: 'StreamProcess'
    });
    return {
      'StreamProcess': {
        id: 'StreamProcess',
        name: 'StreamProcess',
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: _streamProcessTemplate,
          usings: [...STANDARD_CONTROLLER_USING, 'System.Threading', `${namespace}${nodetypes_NameSpace.Constants}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Model}`],
          namespace,
          space: nodetypes_NameSpace.StreamProcess
        }) // test: NamespaceGenerator.Generate({
        //     template: _streamProcessTemplateTests,
        //     usings: [
        //         ...STANDARD_CONTROLLER_USING,
        //         ...STANDARD_TEST_USING,
        //         'System.Threading',
        //         `${namespace}${NameSpace.Constants}`,
        //         `${namespace}${NameSpace.StreamProcess}`,
        //         `${namespace}${NameSpace.Parameters}`,
        //         `${namespace}${NameSpace.Model}`],
        //     namespace,
        //     space: NameSpace.Tests
        // })

      }
    };
  }

}
const streamprocessgenerator_NL = `
`;
const streamprocessgenerator_jNL = `
`;
const streamprocessgenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/generators/changeresponsegenerator.js







const changeresponsegenerator_STREAM_PROCESS_CHANGE_CLASS_EXTENSION = './app/templates/stream_process/stream_process_response_class_extention.tpl';
const changeresponsegenerator_STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR = './app/templates/stream_process/stream_process_response_class_extention_constructor.tpl';
const STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR_TEST = './app/templates/stream_process/tests/stream_process_response_class_extention_constructor.tpl';
const STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR_FAILED = './app/templates/stream_process/stream_process_response_class_extention_constructor_failed.tpl';
const changeresponsegenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
const changeresponsegenerator_PROPERTY_TABS = 6;
class changeresponsegenerator_ChangeResponseGenerator {
  static Tabs(c) {
    let res = '';

    for (var i = 0; i < c; i++) {
      res += changeresponsegenerator_TAB;
    }

    return res;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let models = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController));
    let agents = models.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;

    let _streamProcessChangeClassExtension = external_fs_default.a.readFileSync(changeresponsegenerator_STREAM_PROCESS_CHANGE_CLASS_EXTENSION, 'utf8');

    let _streamProcessChangeClassConstructors = external_fs_default.a.readFileSync(changeresponsegenerator_STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR, 'utf8');

    let _streamProcessChangeClassConstructorsTest = external_fs_default.a.readFileSync(STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR_TEST, 'utf8');

    let _streamProcessChangeClassConstructorsFailed = external_fs_default.a.readFileSync(STREAM_PROCESS_CHANGE_CLASS_CONSTRUCTOR_FAILED, 'utf8');

    let _test = external_fs_default.a.readFileSync(changeresponsegenerator_TEST_CLASS, 'utf8');

    let result = {};
    agents.map(agent => {
      let constructors = [];
      let tests = [];
      let properties = '';
      let statics = '';
      let streamProcessChangeClassExtension = _streamProcessChangeClassExtension;
      let test = _test;
      models.map(model2 => {
        models.map(model => {
          Object.values(nodetypes_Methods).filter(x => x !== nodetypes_Methods.Get && x !== nodetypes_Methods.GetAll).map(method => {
            let streamProcessChangeClassConstructors = _streamProcessChangeClassConstructors;
            let streamProcessChangeClassConstructorsFailed = _streamProcessChangeClassConstructorsFailed;
            let streamProcessChangeClassConstructorsTest = _streamProcessChangeClassConstructorsTest;
            let parameterTemplate = null;
            let arrange = '';
            let changeParameterName = `${uiactions_GetNodeProp(model2, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}`;

            if (method === nodetypes_Methods.Delete) {
              parameterTemplate = `${changeParameterName} change, bool res`;
              arrange = `
            var change = ${changeParameterName}.Create();
            var res = true;
                            `;
            } else {
              parameterTemplate = `${changeParameterName} change, ${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)} ${(uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || '').toLowerCase()}`;
              arrange = `
            var change = ${changeParameterName}.Create();
            var res =  ${uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)}.Create();
            change.Response = "response";
            change.ChangeType = "changeType";
                            `;
            }

            let parameter_properties = `
            ${method === nodetypes_Methods.Delete ? '' : `
            result.IdValue = ${(uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || '').toLowerCase()}.Id;`}
            result.Response = change.Response;
            result.ChangeType = change.ChangeType;
            `;
            let act = `
            var response = ${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Response.${method}(change, res);
`;
            let assert = `
            Assert.AreEqual(response.Response, change.Response);
            Assert.AreEqual(response.ChangeType, change.ChangeType);
`;
            streamProcessChangeClassConstructors = bindTemplate(streamProcessChangeClassConstructors, {
              model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
              value: uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || 'value',
              agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
              agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || 'agent',
              change_type: `Methods.${method} `,
              method,
              parameters: parameterTemplate,
              parameters_property: parameter_properties
            });
            streamProcessChangeClassConstructorsTest = bindTemplate(streamProcessChangeClassConstructorsTest, {
              model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
              model2: uiactions_GetNodeProp(model2, uiactions_NodeProperties.CodeName),
              value: uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || 'value',
              agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
              agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || 'agent',
              change_type: `Methods.${method} `,
              method,
              assert,
              act,
              arrange,
              parameters: parameterTemplate,
              parameters_property: parameter_properties
            });
            streamProcessChangeClassConstructorsFailed = bindTemplate(streamProcessChangeClassConstructorsFailed, {
              model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
              value: uiactions_GetNodeProp(model, uiactions_NodeProperties.ValueName) || 'value',
              agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
              agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.AgentName) || 'agent',
              change_type: `Methods.${method} `,
              method,
              parameters: parameterTemplate,
              parameters_property: parameter_properties
            });

            if (!tests.some(x => x === streamProcessChangeClassConstructorsTest)) {
              tests.push(streamProcessChangeClassConstructorsTest);
            }

            if (constructors.indexOf(streamProcessChangeClassConstructors) === -1) constructors.push(streamProcessChangeClassConstructors);
            if (constructors.indexOf(streamProcessChangeClassConstructorsFailed) === -1) constructors.push(streamProcessChangeClassConstructorsFailed);
          });
        });
      });
      streamProcessChangeClassExtension = bindTemplate(streamProcessChangeClassExtension, {
        model: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        constructors: constructors.join(changeresponsegenerator_jNL),
        properties: ''
      });
      test = bindTemplate(test, {
        model: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        constructors: constructors.join(changeresponsegenerator_jNL),
        name: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Response`,
        properties: '',
        tests: tests.join(changeresponsegenerator_jNL)
      });
      result[uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Response`,
        tname: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}ResponseTests`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: streamProcessChangeClassExtension,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace} ${nodetypes_NameSpace.Constants} `, `${namespace} ${nodetypes_NameSpace.Model} `],
          namespace,
          space: nodetypes_NameSpace.Parameters
        }),
        test: namespacegenerator_NamespaceGenerator.Generate({
          template: test,
          usings: [...STANDARD_CONTROLLER_USING, ...STANDARD_TEST_USING, `${namespace} ${nodetypes_NameSpace.Parameters} `, `${namespace} ${nodetypes_NameSpace.Constants} `, `${namespace} ${nodetypes_NameSpace.Model} `],
          namespace,
          space: nodetypes_NameSpace.Parameters
        })
      };
    });
    return result;
  }

}
const changeresponsegenerator_NL = `
                `;
const changeresponsegenerator_jNL = `
                `;
const changeresponsegenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/generators/executiongenerator.js









const EXECUTOR_CLASS = './app/templates/executor/executor_class.tpl';
const EXECUTOR_INTERFACE = './app/templates/executor/executor_class_interface.tpl';
const EXECUTOR_CREATE = './app/templates/executor/create.tpl';
const EXECUTOR_CREATE_COMPOSITE_INPUT = './app/templates/executor/create_composite_input.tpl';
const EXECUTOR_ENTRY_METHODS = './app/templates/executor/executor_entry_methods.tpl';
const EXECUTOR_ENTRY_METHODS_INTERFACE = './app/templates/executor/executor_entry_methods_interface.tpl';
const EXECUTOR_METHOD_CASE = './app/templates/executor/entry_method_case.tpl';
const EXECUTOR_UPDATE = './app/templates/executor/update.tpl';
const EXECUTOR_GET = './app/templates/executor/get.tpl';
const executiongenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
const EXECUTOR_METHOD_COMPOSITE_INPUT = './app/templates/executor/executor_method_composite_input.tpl';
const EXECUTOR_METHODS = './app/templates/executor/executor_methods.tpl';
const EXECUTOR_METHODS_INTERFACE = './app/templates/executor/executor_methods_interface.tpl';
class executiongenerator_ExecutorGenerator {
  static enumerateValidationTestVectors(validation_test_vectors) {
    var vects = validation_test_vectors.map(x => Object.keys(x.values.cases).length);
    var enumeration = executiongenerator_ExecutorGenerator.EnumerateCases(vects);
    return enumeration;
  }

  static GetParameters(executor_node) {
    let graph = GetCurrentGraph(GetState());
    let methodNode = uiactions_GetMethodNode(executor_node.id);
    var agent = GetMethodNodeProp(methodNode, FunctionTemplateKeys.Agent);
    var model = GetMethodNodeProp(methodNode, FunctionTemplateKeys.Model);
    var modelOutput = GetMethodNodeProp(methodNode, FunctionTemplateKeys.ModelOutput);
    var modelNode = GetNode(graph, model);
    var agentNode = GetNode(graph, agent); // var vectors = ExecutorGenerator.enumerateValidationTestVectors(validation_test_vectors);

    let agent_parameter = GetCodeName(agentNode);
    agent_parameter = agent_parameter ? `${agent_parameter} agent` : false;
    let data_parameter = GetCodeName(modelNode);
    data_parameter = data_parameter ? `${data_parameter} data` : false;
    let change_parameter = !agent_parameter ? false : `${uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agentNode, uiactions_NodeProperties.CodeName)}`;
    change_parameter = change_parameter ? `${change_parameter} change` : false;
    let parameters = [data_parameter, agent_parameter, change_parameter].filter(x => x).join(', ');
    return parameters;
  }

  static GetOutput(executor_node) {
    let methodNode = uiactions_GetMethodNode(executor_node.id);
    var modelOutput = GetMethodNodeProp(methodNode, FunctionTemplateKeys.ModelOutput);
    return modelOutput;
  }

  static EnumerateCases(vects, j = 0) {
    return enumerate(vects, j);
  }

  static Tabs(c) {
    let res = '';

    for (var i = 0; i < c; i++) {
      res += `    `;
    }

    return res;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let graph = GetRootGraph(state);
    let result = {};
    let executor_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Executor);

    let _executor_class = external_fs_default.a.readFileSync(EXECUTOR_CLASS, 'utf8');

    let _executor_class_interface = external_fs_default.a.readFileSync(EXECUTOR_INTERFACE, 'utf8');

    let _executor_methods = external_fs_default.a.readFileSync(EXECUTOR_METHODS, 'utf8');

    let _executor_methods_composite_input = external_fs_default.a.readFileSync(EXECUTOR_METHOD_COMPOSITE_INPUT, 'utf8');

    let _executor_methods_interface = external_fs_default.a.readFileSync(EXECUTOR_METHODS_INTERFACE, 'utf8');

    let _executor_create = external_fs_default.a.readFileSync(EXECUTOR_CREATE, 'utf8');

    let _executor_create_composite_input = external_fs_default.a.readFileSync(EXECUTOR_CREATE_COMPOSITE_INPUT, 'utf8');

    let _executor_update = external_fs_default.a.readFileSync(EXECUTOR_UPDATE, 'utf8');

    let _executor_get = external_fs_default.a.readFileSync(EXECUTOR_GET, 'utf8');

    let _exe_method = external_fs_default.a.readFileSync(EXECUTOR_ENTRY_METHODS, 'utf8');

    let _exe_method_interface = external_fs_default.a.readFileSync(EXECUTOR_ENTRY_METHODS_INTERFACE, 'utf8');

    let _exe_case = external_fs_default.a.readFileSync(EXECUTOR_METHOD_CASE, 'utf8');

    let _testClass = external_fs_default.a.readFileSync(executiongenerator_TEST_CLASS, 'utf8');

    let agentFunctionDic = {};
    let agentFunctionInterfaceDic = {};
    let executor_entry_methods = [];
    let agentModelDic = {};
    let agmCombos = [];
    let allmodels = uiactions_NodesByType(state, uiactions_NodeTypes.Model);
    let allagents = allmodels.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    let allfunctions = uiactions_NodesByType(state, [uiactions_NodeTypes.Function, uiactions_NodeTypes.Method]);
    allfunctions.map(fun => {
      let methodProps = GetMethodProps(fun);
      let model_output;

      if (methodProps && methodProps[FunctionTemplateKeys.CompositeInput]) {
        model_output = GetCodeName(methodProps[FunctionTemplateKeys.CompositeInput]);
      }

      let agent = methodProps[FunctionTemplateKeys.Agent];
      let model = methodProps[FunctionTemplateKeys.Model];
      agmCombos.push({
        agentId: agent,
        agent: GetCodeName(agent),
        model: model_output || GetCodeName(model),
        model_output: GetCodeName(model),
        function: GetCodeName(fun),
        method: uiactions_GetNodeProp(fun, uiactions_NodeProperties.MethodType)
      });
    });
    executor_nodes.map(executor_node => {
      var agent = uiactions_GetNodeProp(executor_node, uiactions_NodeProperties.ExecutorAgent);
      var model = uiactions_GetNodeProp(executor_node, uiactions_NodeProperties.ExecutorModel);
      var modelOutput = uiactions_GetNodeProp(executor_node, uiactions_NodeProperties.ExecutorModelOutput);
      var modelOutputNode = GetNode(graph, modelOutput);
      var modelNode = GetNode(graph, model);
      var agentNode = GetNode(graph, agent);
      var funct = uiactions_GetNodeProp(executor_node, uiactions_NodeProperties.ExecutorFunction);
      var functNode = GetNode(graph, funct);
      var functType = uiactions_GetNodeProp(executor_node, uiactions_NodeProperties.ExecutorFunctionType);
      var functionNode = GetNode(graph, funct);
      var executor = uiactions_GetNodeProp(executor_node, uiactions_NodeProperties.Executor);
      let executorProperties = getValidatorProperties(executor);
      var validation_test_vectors = [];
      let amdid = uiactions_GetNodeProp(agentNode, uiactions_NodeProperties.CodeName) + uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName) + uiactions_GetNodeProp(functionNode, uiactions_NodeProperties.MethodType);
      agentModelDic[amdid] = agentModelDic[amdid] || [];
      agentModelDic[amdid].push({
        agent: GetCodeName(agentNode),
        model: GetCodeName(modelNode),
        model_output: GetCodeName(modelOutputNode),
        functType,
        funct: GetCodeName(functNode)
      });
      let methodProps = GetMethodProps(functNode);
      let propertyValidationStatements = Object.keys(executorProperties || {}).map(property => {
        let propertyNode = GetNode(graph, property);
        let validatorPs = executorProperties[property];
        let properties = Object.keys(validatorPs.validators).map(vld => {
          let validators = validatorPs.validators[vld];
          let node = GetNode(graph, validators.node);
          let attribute_type_arguments = '';

          if (node) {
            switch (uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType)) {
              case uiactions_NodeTypes.ExtensionType:
                if (validators && validators.extension) {
                  let temp = {
                    '_ _': '"_____"'
                  };
                  attribute_type_arguments = Object.keys(validators.extension).map(ext => {
                    if (validators.extension[ext]) {
                      temp[`${ext}`] = `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}.${MakeConstant(ext)}`;
                      return temp[`${ext}`];
                    }
                  }).filter(x => x);
                  attribute_type_arguments = temp.filter(x => x).unique(x => x).join();
                  validation_test_vectors.push({
                    property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
                    values: {
                      cases: temp
                    }
                  });
                  attribute_type_arguments = `new List<string> () {
                ${attribute_type_arguments}
            }`;
                }

                break;

              case uiactions_NodeTypes.Enumeration:
                break;
            }
          }

          if (ValidationCases[validators.type]) {
            validation_test_vectors.push({
              property: uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName),
              values: ValidationCases[validators.type]
            });
          }

          let template = `result{{model_property}} = data{{model_property}};`;
          let templateBindings = {};

          switch (validators.type) {
            case ExecutorRules.AgentReference:
              template = `result{{model_property}} = agent.Id;`;
              break;

            case ExecutorRules.ParentReference:
              template = `result{{model_property}} = data{{model_property}};`;
              break;

            case ExecutorRules.Copy:
              break;

            case ExecutorRules.AddModelReference:
              template = external_fs_default.a.readFileSync(`app/templates/executor/snippets/add-model-reference.tpl`, 'utf8');
              let {
                references
              } = validators;

              if (references) {
                let methodNode = GetMethodNode(state, executor_node.id);

                if (methodNode) {
                  let methodProps = GetMethodProps(methodNode);
                  Object.keys(references).map(ref_key => {
                    templateBindings[ref_key] = GetCodeName(methodProps[references[ref_key]]);
                  });
                }
              }

              break;

            default:
              throw 'not handle [execution generator]';
          }

          var templateRes = bindTemplate(template, {
            attribute_type: validators.code[ProgrammingLanguages.CSHARP],
            attribute_type_arguments,
            model_property: `.${uiactions_GetNodeProp(propertyNode, uiactions_NodeProperties.CodeName)}`,
            ...{ ...templateBindings
            }
          });
          return executiongenerator_ExecutorGenerator.Tabs(4) + templateRes + nodetypes_NEW_LINE;
        }).unique(x => x).join('');
        return properties;
      }).unique(x => x).join('');
      let template = '{{not-defined template}}';
      let execution_method = _executor_methods;

      switch (functType) {
        case nodetypes_Methods.Create:
          template = _executor_create;

          if (methodProps[FunctionTemplateKeys.CompositeInput]) {
            execution_method = _executor_methods_composite_input;
            template = _executor_create_composite_input;
          }

          break;

        case nodetypes_Methods.Update:
          template = _executor_update;
          break;

        case nodetypes_Methods.Get:
        case nodetypes_Methods.GetAll:
          template = _executor_get;
          break;
      }

      var templateRes = bindTemplate(template, {
        property_sets: propertyValidationStatements,
        model: `${GetCodeName(modelNode)}`,
        model_output: GetCodeName(modelOutputNode)
      }); // var vectors = ExecutorGenerator.enumerateValidationTestVectors(validation_test_vectors);

      let agent_parameter = GetCodeName(agentNode);
      agent_parameter = agent_parameter ? `${agent_parameter} agent` : false;
      let data_parameter = GetCodeName(modelNode);
      data_parameter = data_parameter ? `${data_parameter} data` : false;
      let change_parameter = !agent_parameter ? false : `${uiactions_GetNodeProp(modelNode, uiactions_NodeProperties.CodeName)}ChangeBy${uiactions_GetNodeProp(agentNode, uiactions_NodeProperties.CodeName)}`;
      change_parameter = change_parameter ? `${change_parameter} change` : false;
      let parameters = [data_parameter, agent_parameter, change_parameter].filter(x => x).join(', ');
      var templateRes = bindTemplate(execution_method, {
        model: GetCodeName(modelNode),
        model_output: GetCodeName(modelOutputNode) || GetCodeName(modelNode),
        method_name: GetCodeName(functionNode),
        parameters,
        data: GetCodeName(modelNode),
        agent: GetCodeName(agentNode),
        change: `${GetCodeName(modelNode)}Change`,
        method_guts: templateRes
      });
      var templateResInterface = bindTemplate(_executor_methods_interface, {
        model: GetCodeName(modelNode),
        model_output: GetCodeName(modelOutputNode) || GetCodeName(modelNode),
        method_name: GetCodeName(functionNode),
        parameters,
        data: GetCodeName(modelNode),
        agent: GetCodeName(agentNode),
        change: `${GetCodeName(modelNode)}Change`,
        method_guts: templateRes
      }); // var testTemplate = bindTemplate(_testClass, {
      //     name: GetNodeProp(node, NodeProperties.CodeName),
      //     tests: testProps.join(NEW_LINE)
      // });

      agentFunctionInterfaceDic[agent] = agentFunctionInterfaceDic[agent] || [];
      agentFunctionDic[agent] = agentFunctionDic[agent] || [];
      agentFunctionDic[agent].push(templateRes);
      agentFunctionInterfaceDic[agent].push(templateResInterface);
    });
    let lastCase;
    let static_methods = agmCombos.map(amd => {
      var {
        agent,
        agentId,
        model,
        model_output,
        method
      } = amd;
      let cases = (agentModelDic[agent + model + amd.method] || []).map(_cases => {
        var {
          agent,
          model,
          functType,
          funct
        } = _cases;

        if (amd.agent !== agent) {
          '';
        }

        let _case = bindTemplate(_exe_case, {
          agent,
          model,
          func_name: funct
        });

        return _case + nodetypes_NEW_LINE;
      }).unique(x => x).join('');
      return {
        template: bindTemplate(_exe_method, {
          agent,
          model,
          cases,
          change: `${model}`,
          model_output: model_output || model,
          method
        }) + nodetypes_NEW_LINE,
        agent: agentId
      };
    });
    let static_methods_interface = agmCombos.map(amd => {
      var {
        agent,
        model,
        method,
        agentId,
        model_output
      } = amd;
      return {
        template: bindTemplate(_exe_method_interface, {
          agent,
          model,
          model_output: model_output || model,
          change: `${model}`,
          method
        }) + nodetypes_NEW_LINE,
        agent: agentId
      };
    });
    Object.keys(agentFunctionDic).map(agent => {
      var node = GetNode(graph, agent);
      let templateRes = bindTemplate(_executor_class, {
        model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        methods: agentFunctionDic[agent].join(''),
        staticentry: static_methods.unique(x => x.template).filter(x => x.agent === agent).map(x => x.template).join('')
      });
      let templateInterfaceRes = bindTemplate(_executor_class_interface, {
        model: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        methods: agentFunctionInterfaceDic[agent].unique(x => x).join(''),
        staticentry: static_methods_interface.unique(x => x.template).filter(x => x.agent === agent).map(x => x.template).join('')
      });
      result[uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}Executor`,
        tname: `${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}ExecutorTests`,
        iname: `I${uiactions_GetNodeProp(node, uiactions_NodeProperties.CodeName)}Executor`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: templateRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Executors
        }),
        interface: namespacegenerator_NamespaceGenerator.Generate({
          template: templateInterfaceRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Interface
        }) // test: NamespaceGenerator.Generate({
        //     template: testTemplate,
        //     usings: [
        //         ...STANDARD_CONTROLLER_USING,
        //         ...STANDARD_TEST_USING,
        //         `${namespace}${NameSpace.Executors}`,
        //         `${namespace}${NameSpace.Model}`,
        //         `${namespace}${NameSpace.Constants}`],
        //     namespace,
        //     space: NameSpace.Tests
        // }),

      };
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/modelreturngenerator.js








const modelreturngenerator_RETURN_GET_CLASS = './app/templates/models/returns/returns_class.tpl';
const RETURN_GET_FUNCTION = './app/templates/models/returns/returns_funcs.tpl';
const modelreturngenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
class modelreturngenerator_ModelReturnGenerator {
  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let graph = GetRootGraph(state);
    let result = {};

    let _return_get_class = external_fs_default.a.readFileSync(modelreturngenerator_RETURN_GET_CLASS, 'utf8');

    let _return_get_methods = external_fs_default.a.readFileSync(RETURN_GET_FUNCTION, 'utf8');

    let allfilters = uiactions_NodesByType(state, uiactions_NodeTypes.ModelFilter);
    let allmodels = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController));
    let allagents = allmodels.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    allagents.map(agent => {
      var methods = allfilters.filter(x => {
        var methodProps = GetMethodsProperties(x.id);

        if (methodProps) {
          return methodProps[FunctionTemplateKeys.Agent] === agent.id;
        }
      }).map(filterNode => {
        var methodProps = GetMethodsProperties(filterNode.id);
        let model = GetNode(graphRoot, methodProps[FunctionTemplateKeys.ModelOutput] || methodProps[FunctionTemplateKeys.Model]);
        let properties = getNodesByLinkType(graph, {
          id: model.id,
          direction: SOURCE,
          type: nodetypes_LinkType.PropertyLink
        }).filter(x => x.id !== model.id).filter(t => uiactions_GetNodeProp(filterNode, uiactions_NodeProperties.FilterPropreties) ? uiactions_GetNodeProp(filterNode, uiactions_NodeProperties.FilterPropreties)[t.id] : '').map(t => {
          return `           result.${uiactions_GetNodeProp(t, uiactions_NodeProperties.CodeName)} = model.${uiactions_GetNodeProp(t, uiactions_NodeProperties.CodeName)};`;
        }).join(nodetypes_NEW_LINE);
        return bindTemplate(_return_get_methods, {
          function: uiactions_GetNodeProp(filterNode, uiactions_NodeProperties.CodeName),
          agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName),
          set_properties: properties
        });
      }).join(nodetypes_NEW_LINE);
      let templateRes = bindTemplate(_return_get_class, {
        agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        functions: methods
      });
      result[uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Return`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: templateRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/modelexceptiongenerator.js








const modelexceptiongenerator_RETURN_GET_CLASS = './app/templates/models/exceptions/exceptions_class.tpl';
const modelexceptiongenerator_TEST_CLASS = './app/templates/tests/tests.tpl';
class modelexceptiongenerator_ModelReturnGenerator {
  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let graph = GetRootGraph(state);
    let result = {};

    let _return_get_class = external_fs_default.a.readFileSync(modelexceptiongenerator_RETURN_GET_CLASS, 'utf8');

    let allfilters = uiactions_NodesByType(state, uiactions_NodeTypes.ModelFilter);
    let allmodels = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController));
    let allagents = allmodels.filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent));
    allagents.map(agent => {
      let templateRes = bindTemplate(_return_get_class, {
        agent: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)
      });
      result[uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Exceptions`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: templateRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
// EXTERNAL MODULE: external "net"
var external_net_ = __webpack_require__("net");

// CONCATENATED MODULE: ./app/service/validationservice.js







function GetMethodDefinitionValidationSection(id) {
  let methodDefinition = GetMethodDefinition(id);

  if (methodDefinition && methodDefinition.validation) {
    return methodDefinition.validation;
  }

  console.warn('doesnt define a validation for method type ');
  return false;
}

function GetValidationEntries(agent, as_interface, language = ProgrammingLanguages.CSHARP) {
  let dictionary = GetValidationsSortedByAgent();

  if (dictionary && dictionary[agent]) {
    let validation_entry = as_interface ? './app/templates/validation/validation_entry_interface.tpl' : './app/templates/validation/validation_entry.tpl';
    let validation_entry_template = external_fs_default.a.readFileSync(validation_entry, 'utf8');
    let validatorNodes = dictionary[agent];
    let methods = validatorNodes.map(valNode => {
      return uiactions_GetMethodNode(valNode.id);
    }).unique().groupBy(x => {
      var validationNode = uiactions_GetValidationNode(x.id);
      let validationSection = GetMethodDefinitionValidationSection(validationNode.id);

      if (validationSection.asModel) {
        return GetMethodNodeProp(x, validationSection.asModel);
      }

      return GetMethodNodeProp(x, FunctionTemplateKeys.Model);
    });
    let validation_case_template = external_fs_default.a.readFileSync('./app/templates/validation/validation_case.tpl', 'utf8');
    return Object.keys(methods).map(modelId => {
      let parameters = `${GetCodeName(modelId)} model, ${GetCodeName(agent)} agent, ${GetCodeName(modelId)}ChangeBy${GetCodeName(agent)} change_parameter`;
      let conditions = '';
      conditions = methods[modelId].map(method => {
        let validationNode = uiactions_GetValidationNode(method.id);
        if (validatorNodes.some(v => v.id === validationNode.id)) return bindTemplate(validation_case_template, {
          function_name: `FunctionName.${GetCodeName(method.id)}`,
          function: `${GetCodeName(validationNode)}`,
          parameters: `model, agent, change_parameter`
        });
      }).filter(x => x);
      return bindTemplate(validation_entry_template, {
        parameters,
        switch_parameter: 'change_parameter.FunctionName',
        conditions: conditions.join(nodetypes_NEW_LINE)
      });
    });
  }
}
function GetValidationMethodImplementation(id, language = ProgrammingLanguages.CSHARP) {
  let validationSection = GetMethodDefinitionValidationSection(id);

  if (!validationSection) {
    return false;
  }

  let {
    implementation
  } = validationSection;
  let implementation_template = external_fs_default.a.readFileSync(implementation, 'utf8');
  let parameters = GetValidationMethodParametersImplementation(id, language);
  let conditions = GetCombinedCondition(id, language);
  return bindTemplate(implementation_template, {
    parameters,
    conditions,
    function_name: GetCodeName(id)
  });
}
function GetValidationMethodInterface(id, language = ProgrammingLanguages.CSHARP) {
  let validationSection = GetMethodDefinitionValidationSection(id);

  if (!validationSection) {
    return false;
  }

  let {
    interface_
  } = validationSection;
  let interface_template = external_fs_default.a.readFileSync(interface_, 'utf8');
  let parameters = GetValidationMethodParametersImplementation(id, language);
  return bindTemplate(interface_template, {
    parameters,
    function_name: GetCodeName(id)
  });
}
function GetAgentValidationInterface(agentId) {
  let dictionary = GetValidationsSortedByAgent();

  if (dictionary && dictionary[agentId]) {
    let namespace = GetNameSpace();
    let interface_ = BuildAgentValidationInterface(agentId, dictionary[agentId].map(t => t.id));
    return namespacegenerator_NamespaceGenerator.Generate({
      template: interface_,
      usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Parameters}`],
      namespace,
      space: nodetypes_NameSpace.Interface
    });
  } else {
    return false;
  }
}
function GenerateAgentValidationInterfacesAndImplementations() {
  var agents = GetAgentNodes();
  let result = {};
  agents.map(agent => {
    let agentName = GetCodeName(agent.id);
    let template = GetAgentValidationImplementation(agent.id);

    let _interface = GetAgentValidationInterface(agent.id);

    if (!template || !_interface) {
      return;
    }

    let temp = {
      name: `${agentName}Validations`,
      iname: `I${agentName}Validations`,
      template,
      interface: _interface
    };
    result[agentName] = temp;
  });
  return result;
}
function GetAgentValidationImplementation(agentId) {
  let dictionary = GetValidationsSortedByAgent();

  if (dictionary && dictionary[agentId]) {
    let namespace = GetNameSpace();
    let implementation = BuildAgentValidationImplementation(agentId, dictionary[agentId].map(t => t.id));
    return namespacegenerator_NamespaceGenerator.Generate({
      template: implementation,
      usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Extensions}`, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Controllers}`, `${namespace}${nodetypes_NameSpace.Constants}`].filter(x => x),
      namespace,
      space: nodetypes_NameSpace.Validations
    });
  } else {
    return false;
  }
}
function BuildAgentValidationInterface(agentId, validations, language = ProgrammingLanguages.CSHARP) {
  let methods = validations.map(Validation => {
    return GetValidationMethodInterface(Validation, language);
  }).filter(x => x).join(nodetypes_NEW_LINE);
  let template = external_fs_default.a.readFileSync('./app/templates/validation/validation_interface.tpl', 'utf8');
  let validation_entries = GetValidationEntries(agentId, true, language);
  return bindTemplate(template, {
    agent_type: GetCodeName(agentId),
    validations: validation_entries.join(nodetypes_NEW_LINE),
    methods
  });
}
function BuildAgentValidationImplementation(agentId, validations, language = ProgrammingLanguages.CSHARP) {
  let methods = validations.map(validation_ => {
    return GetValidationMethodImplementation(validation_, language);
  }).filter(x => x).join(nodetypes_NEW_LINE);
  let validation_entries = GetValidationEntries(agentId, false, language);
  let template = external_fs_default.a.readFileSync('./app/templates/validation/validations_impl.tpl', 'utf8');

  let _constructTemplate = external_fs_default.a.readFileSync('./app/templates/validation/constructor.tpl', 'utf8');

  let constructor = bindTemplate(_constructTemplate, {
    agent_type: `${GetCodeName(agentId)}`,
    arbiters: GetArbiterPropertyImplementations(4, language)
  });
  return bindTemplate(template, {
    agent_type: GetCodeName(agentId),
    arbiters: GetArbiterPropertyDefinitions(),
    validations: validation_entries.join(nodetypes_NEW_LINE),
    constructor,
    methods
  });
}
function GetValidationMethodParameters(id) {
  let validationSection = GetMethodDefinitionValidationSection(id);
  let {
    params
  } = validationSection;
  let methodNode = uiactions_GetMethodNode(id);
  return (params || []).map(param => {
    return {
      paramClass: GetMethodNodeProp(methodNode, param),
      paramProperty: param
    };
  });
}
function GetValidationMethodParametersImplementation(id, language = ProgrammingLanguages.CSHARP) {
  let parameters = GetValidationMethodParameters(id);

  switch (language) {
    case ProgrammingLanguages.CSHARP:
      return parameters.map(t => `${GetCodeName(t.paramClass) || t.paramClass} ${safeFormatTemplateProperty(t.paramProperty && t.paramProperty.key ? t.paramProperty.key : t.paramProperty)}`).join(', ');
  }
}
// CONCATENATED MODULE: ./app/service/customservice.js









let customservice_interface_template = `
    public interface I{{class}} {
{{methods}}
    }
`;
function GenerateServiceInterface(serviceInterface, language) {
  let methodCalls = GetServiceInterfaceMethodCalls(serviceInterface ? serviceInterface.id : null);
  let methods = [];
  let graph = GetCurrentGraph(GetState());
  methodCalls.map(mc => {
    let connectedNodes = GetNodesLinkedTo(graph, {
      id: mc.id
    }).filter(x => [NodeTypes.Permission, NodeTypes.Validator, NodeTypes.Executor].some(t => t === uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType)));

    if (connectedNodes && connectedNodes.length) {
      connectedNodes.map(cn => {
        let parameters = '';
        let output = '';

        switch (uiactions_GetNodeProp(cn, nodetypes_NodeProperties.NODEType)) {
          case NodeTypes.Permission:
            parameters = GetPermissionMethodParametersImplementation(cn.id, language);
            output = 'bool';
            break;

          case NodeTypes.Validator:
            parameters = GetValidationMethodParametersImplementation(cn.id, language);
            output = 'bool';
            break;

          case NodeTypes.Executor:
            parameters = executiongenerator_ExecutorGenerator.GetParameters(cn);
            output = GetCodeName(executiongenerator_ExecutorGenerator.GetOutput(cn));
            break;
        }

        methods.push(bindTemplate(`Task<{{output}}> ${GetCodeName(mc)}({{parameters}});`, {
          parameters,
          output
        }));
      });
    }
  });
  return bindTemplate(customservice_interface_template, {
    class: GetCodeName(serviceInterface),
    methods: addNewLine(methods.unique().join(nodetypes_NEW_LINE))
  });
}
// CONCATENATED MODULE: ./app/generators/customservicegenerator.js









const customservicegenerator_RETURN_GET_CLASS = "./app/templates/models/exceptions/exceptions_class.tpl";
const customservicegenerator_TEST_CLASS = "./app/templates/tests/tests.tpl";
class customservicegenerator_CustomServiceGenerator {
  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let serviceInterfaces = uiactions_NodesByType(GetState(), uiactions_NodeTypes.ServiceInterface);
    let result = {};
    serviceInterfaces.map(serviceInterface => {
      let _interface = GenerateServiceInterface(serviceInterface);

      result[uiactions_GetNodeProp(serviceInterface, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(serviceInterface, uiactions_NodeProperties.CodeName),
        iname: `I${uiactions_GetNodeProp(serviceInterface, uiactions_NodeProperties.CodeName)}`,
        interface: namespacegenerator_NamespaceGenerator.Generate({
          template: _interface,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Parameters}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/modelgetgenerators.js


/* eslint-disable no-underscore-dangle */

/* eslint-disable camelcase */








const MODEL_GET_CLASS = './app/templates/models/gets/model_get_class.tpl';
const MODEL_GET_FUNCTION = './app/templates/models/gets/model_get_function.tpl';
const MODEL_GET_MANY_TO_MANY_FUNCTION = './app/templates/models/gets/model_get_many_to_many_function.tpl';
const MODEL_GET_MANY_TO_MANY_FUNCTION_GET_CHILD = './app/templates/models/gets/model_get_many_to_many_function_get_child.tpl';
const modelgetgenerators_TEST_CLASS = './app/templates/tests/tests.tpl';
class modelgetgenerators_ModelGetGenerator {
  static enumerateValidationTestVectors(validation_test_vectors) {
    const vects = validation_test_vectors.map(x => Object.keys(x.values.cases).length);
    const enumeration = modelgetgenerators_ModelGetGenerator.EnumerateCases(vects);
    return enumeration;
  }

  static EnumerateCases(vects, j = 0) {
    return enumerate(vects, j);
  }

  static Tabs(c) {
    let res = '';

    for (let i = 0; i < c; i++) {
      res += `    `;
    }

    return res;
  }

  static Generate(options) {
    const {
      state,
      key
    } = options;
    const graphRoot = GetRootGraph(state);
    const namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    const graph = GetRootGraph(state);
    const result = {};

    const _get_class = external_fs_default.a.readFileSync(MODEL_GET_CLASS, 'utf8');

    const _get_methods = external_fs_default.a.readFileSync(MODEL_GET_FUNCTION, 'utf8');

    const _get_methods_many_to_many = external_fs_default.a.readFileSync(MODEL_GET_MANY_TO_MANY_FUNCTION, 'utf8');

    const _get_method_many_to_many_get_child = external_fs_default.a.readFileSync(MODEL_GET_MANY_TO_MANY_FUNCTION_GET_CHILD, 'utf8');

    const allmodels = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration)).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromController));
    allmodels.filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.IsCompositeInput)).map(agent => {
      const methods = allmodels.filter(x => x.id !== agent.id).filter(x => {
        if (uiactions_GetNodeProp(agent, uiactions_NodeProperties.HasLogicalChildren) && (uiactions_GetNodeProp(agent, uiactions_NodeProperties.LogicalChildrenTypes) || []).some(v => v === x.id)) {
          if (!uiactions_GetNodeProp(agent, uiactions_NodeProperties.ManyToManyNexus)) return true;
        }

        return false;
      }).map(model => {
        return bindTemplate(_get_methods, {
          item_property: uiactions_GetNodeProp(model, uiactions_NodeProperties.IsOwnedByAgents) ? 'Owner' : uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
          model: uiactions_GetNodeProp(model, uiactions_NodeProperties.CodeName)
        });
      });

      if (uiactions_GetNodeProp(agent, uiactions_NodeProperties.ManyToManyNexus)) {
        const childrenTypes = uiactions_GetNodeProp(agent, uiactions_NodeProperties.LogicalChildrenTypes) || [];

        if (childrenTypes && childrenTypes.length) {
          const namesAreUnique = childrenTypes.map(t => uiactions_GetNodeProp(GetNode(graph, t), uiactions_NodeProperties.CodeName)).unique(x => x).length === childrenTypes.length;
          childrenTypes.map(ct => {
            methods.push(bindTemplate(_get_method_many_to_many_get_child, {
              model: uiactions_GetNodeProp(GetNode(graph, ct), uiactions_NodeProperties.CodeName),
              many_to_many: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)
            }));
          });
          enumerate([].interpolate(0, childrenTypes.length, () => {
            return childrenTypes.length + 1;
          })).filter(x => x.length === x.unique(t => t).length).forEach(model => {
            const params = model.subset(0, model.length).map((t, index) => {
              if (childrenTypes.length === t) {
                return false;
              }

              let paramName = `x${index}`;

              if (namesAreUnique) {
                paramName = uiactions_GetNodeProp(GetNode(graph, childrenTypes[t]), uiactions_NodeProperties.CodeName).toLowerCase();
              }

              return bindTemplate(`{{_type}} ${paramName}`, {
                _type: uiactions_GetNodeProp(GetNode(graph, childrenTypes[t]), uiactions_NodeProperties.CodeName)
              });
            }).filter(x => x);

            if (params.length) {
              methods.push(bindTemplate(_get_methods_many_to_many, {
                parameters: params.join(', '),
                query: model.subset(0, model.length).map((t, index) => {
                  if (childrenTypes.length === t) {
                    return false;
                  }

                  let paramName = `x${index}`;

                  if (namesAreUnique) {
                    paramName = uiactions_GetNodeProp(GetNode(graph, childrenTypes[t]), uiactions_NodeProperties.CodeName).toLowerCase();
                  }

                  return bindTemplate(`item != null && ${paramName} != null && ${paramName}.{{_type}}.Any(v => v == item.Id)`, {
                    _type: uiactions_GetNodeProp(GetNode(graph, childrenTypes[t]), uiactions_NodeProperties.CodeName)
                  });
                }).filter(x => x).join(' && '),
                //
                model: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)
              }));
            }
          });
        }
      }

      const templateRes = bindTemplate(_get_class, {
        agent_type: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        functions: methods.unique(x => x).join(nodetypes_NEW_LINE)
      });
      result[uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName),
        name: `${uiactions_GetNodeProp(agent, uiactions_NodeProperties.CodeName)}Get`,
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: templateRes,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.Constants}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/constants/componenttypes.js





const StyleTags = {
  "style": "style",
  "style_input": " style_input",
  "style_label": "style_label",
  "style_item": "style_item"
};
const ComponentTags = {
  Self: "Self",
  "main-screen": "main-screen",
  "main-screen-container": "main-screen-container",
  Container: "Container",
  MainMenu: "MainMenu",
  Main: "Main",
  SideContainer: "SideContainer",
  Header: "Header",
  TopMenu: "TopMenu",
  LeftContainer: "LeftContainer",
  MainContent: "MainContent",
  SecondaryContent: "SecondaryContent",
  RightContainer: "RightContainer",
  Form: "Form",
  SecondaryMain: "SecondaryMain",
  MainButton: "MainButton",
  CancelButton: "CancelButton",
  SecondaryButton: "SecondaryButton",
  Bottom: "Bottom",
  ListItem: "ListItem",
  Footer: "Footer"
};
const NAVIGATION = "-NAVIGATION";
const APP_METHOD = "-APP_METHOD";
const ON_BLUR = "onBlur";
const ON_FOCUS = "onFocus";
const ON_CHANGE = "onChange";
const ON_CHANGE_TEXT = "onChangeText";
const ARE_HANDLERS = [ON_BLUR, ON_FOCUS, ON_CHANGE_TEXT, ON_CHANGE];
const ARE_BOOLEANS = [];
const ARE_TEXT_CHANGE = [ON_CHANGE_TEXT];
const VALUE = "value";
const SHARED_COMPONENT_API = [VALUE].map(x => ({
  property: x
}));
const GENERAL_COMPONENT_API = [VALUE].map(x => ({
  property: x
}));
const ComponentApiTypes = {
  ViewModel: "viewModel",
  Value: "value"
};
const ComponentLifeCycleEvents = {
  ComponentDidMount: "componentDidMount",
  ComponentWillUnmount: "componentWillUnmount"
};
const ComponentEvents = {
  onPress: "onPress",
  onClick: "onClick",
  onFocus: "onFocus",
  onBlur: "onBlur",
  onChange: "onChange",
  onChangeText: "onChangeText"
};
const ComponentEventStandardHandler = {
  [ComponentEvents.onChange]: `onChange={(evt)=>{
    if(this.props.onChange) {
      this.props.onChange(evt);
    }
  }}`
};
const SCREEN_COMPONENT_EVENTS = [ComponentLifeCycleEvents.ComponentDidMount, ComponentLifeCycleEvents.ComponentWillUnmount];
const PropertyApiList = ["error", "success", VALUE].map(v => ({
  value: v
}));
const ApiProperty = {
  Error: "error",
  Success: "success",
  Value: "value"
};
const INPUT_DEFAULT_API = [VALUE, ON_BLUR, ON_FOCUS, ON_CHANGE_TEXT, "inlineLabel", "floatingLabel", "stackedLabel", "fixedLabel", "success", "error"].map(x => ({
  property: x
}));
const BUTTON_DEFAULT_API = ["block", "primary", "transparent", "success", "danger", "warning", "info", "bordered", "disabled", "rounded", "large", "small", "active"].map(x => ({
  property: x
}));
const LOCAL_STATE_PROPERTY = ['error'].map(x => ({
  property: x
}));
const LABEL_DEFAULT_API = ["data"].map(x => ({
  property: x
}));
const DEFAULT_INPUT_API_PROPERTIES = {};
const DEFAULT_BUTTON_API_PROPERTIES = {};
BUTTON_DEFAULT_API.forEach(x => {
  DEFAULT_BUTTON_API_PROPERTIES[x.property] = {
    nodeProperty: x.property,
    parameterConfig: true,
    isHandler: false,
    ui: true
  };
});
LOCAL_STATE_PROPERTY.forEach(x => {
  DEFAULT_BUTTON_API_PROPERTIES[x.property] = {
    nodeProperty: x.property,
    parameterConfig: true,
    isHandler: false,
    ui: true,
    localStateProperty: true
  };
});
DEFAULT_BUTTON_API_PROPERTIES.style_button = {
  'style': 'style'
};
INPUT_DEFAULT_API.forEach(x => {
  DEFAULT_INPUT_API_PROPERTIES[x.property] = {
    nodeProperty: x.property,
    parameterConfig: true,
    isHandler: ARE_HANDLERS.indexOf(x.property) !== -1,
    ui: true
  };
});
['style_label', 'style_item', 'style_input'].map(x => ({
  property: x
})).forEach(x => {
  DEFAULT_INPUT_API_PROPERTIES[x.property] = {
    'style': 'style'
  };
});
const ComponentTypeKeys = {
  SingleSelect: "SingleSelect",
  List: "List",
  Button: "Button",
  ListItem: "ListItem",
  MultiSelectList: "MultiSelectList",
  Text: "Text",
  InfiniteList: "InfiniteList" // a list of items which maybe of unbounded length, create items and add to list, and remove and delete items, and update items

};
const ComponentTypes = {
  ReactNative: {
    Badge: {},
    Body: {},
    [ComponentTypeKeys.Button]: {
      template: "./app/templates/components/button.tpl",
      defaultApi: BUTTON_DEFAULT_API,
      eventApi: [ComponentEvents.onPress],
      properties: {
        onPress: {
          nodeProperty: "onPress",
          template: "() => { {{value}} }",
          method: true,
          nowrap: true,
          options: [NAVIGATION, APP_METHOD],
          ui: true
        },
        ...DEFAULT_BUTTON_API_PROPERTIES
      }
    },
    Card: {},
    CardItem: {},
    CheckBox: {
      template: "./app/templates/components/checkbox.tpl",
      defaultApi: INPUT_DEFAULT_API,
      eventApi: [ComponentEvents.onBlur, ComponentEvents.onFocus, ComponentEvents.onChangeText],
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          options: ["fixedLabel", "inlineLabel", "floatingLabel", "stackedLabel", "regular", "rounded", "success", "error", "disabled"],
          ui: true
        },
        ...DEFAULT_INPUT_API_PROPERTIES,
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        label: {
          nodeProperty: uiactions_NodeProperties.Label,
          template: true
        },
        placeholder: {
          nodeProperty: uiactions_NodeProperties.Placeholder,
          template: true
        },
        error: {
          nodeProperty: uiactions_NodeProperties.Error,
          template: true
        },
        success: {
          nodeProperty: uiactions_NodeProperties.Success,
          template: true
        }
      }
    },
    Container: {},
    Content: {},
    Fab: {},
    Footer: {},
    FooterTab: {},
    Form: {
      layout: true,
      template: "./app/templates/components/form.tpl",
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          parameterConfig: true,
          ui: true
        }
      }
    },
    H1: {
      template: "./app/templates/components/h1.tpl",
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        label: {
          nodeProperty: uiactions_NodeProperties.Label,
          template: true
        }
      }
    },
    H2: {
      template: "./app/templates/components/h2.tpl",
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        label: {
          nodeProperty: uiactions_NodeProperties.Label,
          template: true
        }
      }
    },
    H3: {
      template: "./app/templates/components/h3.tpl",
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        label: {
          nodeProperty: uiactions_NodeProperties.Label,
          template: true
        }
      }
    },
    Header: {
      template: "./app/templates/components/header.tpl",
      properties: {
        left: {
          nodeProperty: "HeaderLeft",
          template: "{{value}}",
          options: ["true", "false"],
          ui: true
        },
        right: {
          nodeProperty: "HeaderRight",
          template: "{{value}}",
          options: ["true", "false"],
          ui: true
        },
        title: {
          nodeProperty: "HeaderTitle",
          template: "{{value}}",
          options: ["true", "false"],
          ui: true
        }
      }
    },
    Icon: {},
    Image: {
      library: "react-native",
      template: "./app/templates/components/image.tpl",
      properties: {
        data: {
          ui: true,
          nodeProperty: "data",
          nodeTypes: [NodeTypes.DataChain],
          nodeFilter: item => uiactions_GetNodeProp(item, uiactions_NodeProperties.EntryPoint),
          template: node => {
            const func = GetCodeName(uiactions_GetNodeProp(node, "data"), {
              includeNameSpace: true
            });

            if (func) {
              return bindTemplate(`DC.{{function}}({{value}})`, {
                function: func,
                value: `this.props.data`
              });
            }

            return `this.props.data`;
          }
        }
      }
    },
    Input: {
      template: "./app/templates/components/input.tpl",
      defaultApi: INPUT_DEFAULT_API,
      eventApi: [ComponentEvents.onBlur, ComponentEvents.onFocus, ComponentEvents.onChangeText],
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          options: ["fixedLabel", "inlineLabel", "floatingLabel", "stackedLabel", "regular", "rounded", "success", "error", "disabled"],
          ui: true
        },
        ...DEFAULT_INPUT_API_PROPERTIES,
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        label: {
          nodeProperty: uiactions_NodeProperties.Label,
          template: true
        },
        placeholder: {
          nodeProperty: uiactions_NodeProperties.Placeholder,
          template: true
        },
        error: {
          nodeProperty: uiactions_NodeProperties.Error,
          template: true
        },
        success: {
          nodeProperty: uiactions_NodeProperties.Success,
          template: true
        }
      }
    },
    Generic: {
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          parameterConfig: true,
          ui: true
        }
      }
    },
    InputGroup: {},
    Item: {},
    Label: {},
    Left: {},
    [ComponentTypeKeys.List]: {
      library: "react-native",
      layout: true,
      specialLayout: true,
      eventApi: ["onEndReachedThreshold", "onEndReached"],
      template: "./app/templates/components/list.tpl",
      datasource: true,
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          component_options: [NodeTypes.ComponentNode],
          ui: true
        }
      },
      ui: true
    },
    Menu: {
      template: "./app/templates/components/menu.tpl",
      eventApi: [ComponentEvents.onPress],
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        label: {
          nodeProperty: uiactions_NodeProperties.Label,
          template: true
        }
      }
    },
    MultiViewList: {
      layout: true,
      specialLayout: true,
      eventApi: ["onEndReachedThreshold", "onEndReached"],
      template: "./app/templates/components/multiviewlist.tpl",
      datasource: true,
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          component_options: [NodeTypes.ComponentNode],
          ui: true
        }
      },
      ui: true
    },
    [ComponentTypeKeys.MultiSelectList]: {
      layout: true,
      specialLayout: true,
      eventApi: ["onEndReachedThreshold", "onEndReached"],
      template: "./app/templates/components/multiselectlist.tpl",
      datasource: true,
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          component_options: [NodeTypes.ComponentNode],
          ui: true
        }
      },
      ui: true
    },
    [ComponentTypeKeys.InfiniteList]: {
      layout: true,
      specialLayout: true,
      eventApi: ["onEndReachedThreshold", "onEndReached"],
      template: "./app/templates/components/infinitelist.tpl",
      datasource: true,
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          component_options: [NodeTypes.ComponentNode],
          ui: true
        }
      },
      ui: true
    },
    [ComponentTypeKeys.SingleSelect]: {
      layout: true,
      specialLayout: true,
      eventApi: ["onEndReachedThreshold", "onEndReached"],
      events: {
        [ComponentEvents.onChange]: true
      },
      template: "./app/templates/components/singleselect.tpl",
      datasource: true,
      properties: {
        item_attributes: {
          nodeProperty: uiactions_NodeProperties.TextType,
          template: "{{value}}",
          component_options: [NodeTypes.ComponentNode],
          ui: true
        }
      },
      ui: true
    },
    [ComponentTypeKeys.ListItem]: {
      layout: true,
      ui: true,
      [NAVIGATION]: true,
      [APP_METHOD]: true,
      properties: {
        onPress: {
          nodeProperty: "onPress",
          template: "() => { {{value}} }",
          method: true,
          options: [NAVIGATION, APP_METHOD],
          ui: true
        }
      }
    },
    Picker: {},
    Radio: {},
    Right: {},
    Segment: {},
    Separator: {},
    Spinner: {},
    Subtitle: {},
    SwipeRow: {},
    Switch: {},
    Tab: {},
    TabBar: {},
    TabContainer: {},
    TabHeader: {},
    [ComponentTypeKeys.Text]: {
      template: "./app/templates/components/text.tpl",
      defaultApi: LABEL_DEFAULT_API,
      internalApiNode: ComponentApiKeys.DATA,
      externalApiNode: ComponentApiKeys.DATA,
      properties: {
        value: {
          nodeProperty: uiactions_NodeProperties.value,
          template: true
        },
        data: {
          ui: true,
          nodeProperty: ComponentApiKeys.DATA,
          nodeTypes: [NodeTypes.DataChain],
          nodeFilter: item => uiactions_GetNodeProp(item, uiactions_NodeProperties.EntryPoint),
          template: node => {
            const func = GetCodeName(uiactions_GetNodeProp(node, ComponentApiKeys.DATA), {
              includeNameSpace: true
            });

            if (uiactions_GetNodeProp(node, "component-as-label")) {
              return `titleService.get('${uiactions_GetNodeProp(node, uiactions_NodeProperties.Label)}')`;
            }

            if (func) {
              return bindTemplate(`DC.{{function}}({{value}})`, {
                function: func,
                value: `this.props.${ComponentApiKeys.DATA}`
              });
            }

            return `this.props.${ComponentApiKeys.DATA}`;
          }
        }
      }
    },
    Textarea: {},
    Thumbnail: {
      template: "./app/templates/components/thumbnail.tpl",
      properties: {
        data: {
          ui: true,
          nodeProperty: "data",
          nodeTypes: [NodeTypes.DataChain],
          nodeFilter: item => uiactions_GetNodeProp(item, uiactions_NodeProperties.EntryPoint),
          template: node => {
            const func = GetCodeName(uiactions_GetNodeProp(node, "data"), {
              includeNameSpace: true
            });

            if (func) {
              return bindTemplate(`DC.{{function}}({{value}})`, {
                function: func,
                value: `this.props.data`
              });
            }

            return `this.props.data`;
          }
        }
      }
    },
    Title: {},
    Toast: {},
    View: {
      eventApi: ["componentDidMount"],
      layout: true
    },
    LoginSelector: {
      template: "./app/templates/components/loginselector.tpl",
      library: "./login-selector"
    }
  }
};
ComponentTypes[UITypes.ElectronIO] = { ...ComponentTypes.ReactNative
};
Object.keys(ComponentTypes.ReactNative).map(key => {
  if (ComponentTypes.ReactNative[key]) {
    ComponentTypes.ReactNative[key].library = ComponentTypes.ReactNative[key].library || "native-base";
    ComponentTypes.ReactNative[key].key = key;
    ComponentTypes.ReactNative[key].properties = ComponentTypes.ReactNative[key].properties || {};
    ComponentTypes.ReactNative[key].properties.label = ComponentTypes.ReactNative[key].properties.label || {
      nodeProperty: uiactions_NodeProperties.Label,
      template: `{titleService.get('{{value}}')}`,
      ui: true
    };
  }
});
ComponentTypes[UITypes.ElectronIO][ComponentTypeKeys.Button] = { ...ComponentTypes[UITypes.ElectronIO][ComponentTypeKeys.Button],
  eventApi: [ComponentEvents.onClick],
  properties: { ...ComponentTypes[UITypes.ElectronIO][ComponentTypeKeys.Button].properties,
    onClick: {
      nodeProperty: "onClick",
      template: "() => { {{value}} }",
      method: true,
      nowrap: true,
      options: [NAVIGATION, APP_METHOD],
      ui: true
    }
  }
};
ComponentTypes[UITypes.ElectronIO].Menu = { ...ComponentTypes[UITypes.ElectronIO].Menu,
  eventApi: [ComponentEvents.onClick],
  properties: { ...ComponentTypes[UITypes.ElectronIO].Menu.properties,
    onClick: {
      nodeProperty: "onClick",
      template: "() => { {{value}} }",
      method: true,
      nowrap: true,
      options: [NAVIGATION, APP_METHOD],
      ui: true
    }
  }
};
const HandlerTypes = {
  Blur: "blur",
  Change: "change",
  ChangeText: "changeText",
  Focus: "focus",
  Property: "property"
};
const InstanceTypes = {
  ScreenInstance: "ScreenInstance",
  ScreenInstanceBlur: "ScreenInstanceBlur",
  ScreenInstanceFocus: "ScreenInstanceFocus",
  ScreenInstanceFocused: "ScreenInstanceFocused",
  ScreenInstanceDirty: "ScreenInstanceDirty",
  ModelInstance: "ModelInstance",
  ModelInstanceBlur: "ModelInstanceBlur",
  ModelInstanceFocus: "ModelInstanceFocus",
  ModelInstanceFocused: "ModelInstanceFocused",
  ModelInstanceDirty: "ModelInstanceDirty",
  Instance: "Instance",
  AppState: "AppState",
  PropInstance: "PropInstance",
  ApiProperty: "ApiProperty",
  ScreenParam: "ScreenParam",
  Selector: "Selector",
  SelectorInstance: "SelectorInstance",
  Boolean: "Boolean",
  AddAnotherIfTheseDontMakeSense: "add another if these dont make sense"
};
const SelectorKeys = {
  screen: {
    object: InstanceTypes.ScreenInstance,
    blur: InstanceTypes.ScreenInstanceBlur,
    focus: InstanceTypes.ScreenInstanceFocus,
    focused: InstanceTypes.ScreenInstanceFocused,
    dirty: InstanceTypes.ScreenInstanceDirty
  },
  model: {
    object: InstanceTypes.ModelInstance,
    blur: InstanceTypes.ModelInstanceBlur,
    focus: InstanceTypes.ModelInstanceFocus,
    focused: InstanceTypes.ModelInstanceFocused,
    dirty: InstanceTypes.ModelInstanceDirty
  }
};
const InstanceTypeSelectorFunction = {
  [InstanceTypes.ScreenInstance]: "GetScreenInstanceObject",
  [InstanceTypes.ScreenInstanceBlur]: "GetScreenInstanceBlurObject",
  [InstanceTypes.ScreenInstanceFocus]: "GetScreenInstanceFocusObject",
  [InstanceTypes.ScreenInstanceFocused]: "GetScreenInstanceFocusedObject",
  [InstanceTypes.ScreenInstanceDirty]: "GetScreenInstanceDirtyObject",
  [InstanceTypes.AppState]: "GetAppStateObject",
  [InstanceTypes.ModelInstance]: "GetModelInstanceObject",
  [InstanceTypes.ModelInstanceBlur]: "GetModelInstanceBlurObject",
  [InstanceTypes.ModelInstanceFocus]: "GetModelInstanceFocusObject",
  [InstanceTypes.ModelInstanceFocused]: "GetModelInstanceFocusedObject",
  [InstanceTypes.ModelInstanceDirty]: "GetModelInstanceDirtyObject"
};
function GetListItemNode(id) {
  const state = GetState();
  const graph = GetRootGraph(state);
  const nodes = GetNodesLinkedTo(graph, {
    id
  }).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.NODEType) === NodeTypes.ComponentNode && uiactions_GetNodeProp(x, uiactions_NodeProperties.ComponentType) === ComponentTypes.ReactNative.ListItem.key);

  if (nodes && nodes.length) {
    return nodes[0];
  }

  return null;
}
function GetFormItemNode(id) {
  const state = GetState();
  const graph = GetRootGraph(state);
  const nodes = GetNodesLinkedTo(graph, {
    id,
    link: nodetypes_LinkType.Component,
    properties: {
      [LinkPropertyKeys.AsForm]: true
    }
  });

  if (nodes && nodes.length) {
    return nodes[0];
  }

  return null;
}
// CONCATENATED MODULE: ./app/service/layoutservice.js







function GetPropertyConsts(id, language = UITypes.ReactNative) {
  const node = GetNodeById(id);
  const layout = uiactions_GetNodeProp(node, uiactions_NodeProperties.Layout);
  const components = GetNodeComponents(layout);
  return components.map(v => ConvertViewTypeToComponentNode(v, language)).unique();
}
function GetModelConsts(id, language = UITypes.ReactNative) {
  const node = GetNodeById(id);
  const layout = uiactions_GetNodeProp(node, uiactions_NodeProperties.Layout);
  return GetNodeComponentsKeys(layout).map(cell => {
    const cellProperties = GetCellProperties(layout, cell);

    if (cellProperties && cellProperties.cellModel) {
      return cellProperties.cellModel[cell];
    }
  }).filter(x => x).map(v => ConvertViewTypeToComponentNode(v, language)).unique();
}
function GetModelPropertyConsts(id, language = UITypes.ReactNative) {
  const node = GetNodeById(id);
  const layout = uiactions_GetNodeProp(node, uiactions_NodeProperties.Layout);
  return GetNodeComponentsKeys(layout).map(cell => {
    // console.log(cell);
    const cellProperties = GetCellProperties(layout, cell); // console.log(cellProperties);

    if (cellProperties && cellProperties.cellModelProperty) {
      return cellProperties.cellModelProperty[cell];
    }
  }).filter(x => x).map(v => ConvertViewTypeToComponentNode(v, language)).unique();
}
function GetRNModelInstances(id) {
  const node = GetNodeById(id);
  const layout = uiactions_GetNodeProp(node, uiactions_NodeProperties.Layout);
  const componentProperties = uiactions_GetNodeProp(node, uiactions_NodeProperties.ComponentProperties);
  return GetNodeComponentsKeys(layout).map(cell => {
    // console.log(componentProperties);
    const cellProperties = GetCellProperties(layout, cell); // console.log(cellProperties);
    // let loginModel = GetScreenInstance(state, ScreenInstances.LoginForm, const_loginModel) || CreateDefaultLoginModel();

    if (cellProperties && cellProperties.cellModel && cellProperties.cellModel[cell]) {
      const instanceType = getComponentProperty(componentProperties, cellProperties.cellModel[cell], "instanceTypes");
      if (instanceType != InstanceTypes.PropInstance && instanceType != InstanceTypes.ScreenParam && instanceType) return `let ${cellProperties.cellModel[cell]} = Get${instanceType}(${instanceType}.${GetCodeName(id)}, const_${cellProperties.cellModel[cell]}) || {};`; // CreateDefault${GetCodeName(id)}()
    }
  }).filter(x => x).unique();
}
function GetRNConsts(id) {
  const prop_consts = []; // GetPropertyConsts(id);

  const model_consts = []; // GetModelConsts(id);

  const model_propconsts = []; // GetModelPropertyConsts(id);

  return [...prop_consts.map(x => `const const_${(GetCodeName(x) || "").toJavascriptName()} = '${(GetCodeName(x) || "").toJavascriptName()}';`), ...model_consts.map(x => GetRNModelConst(x)), ...model_propconsts.map(x => `const const_${(GetCodeName(x) || "").toJavascriptName()} = '${(GetCodeName(x) || "").toJavascriptName()}';`)];
}
function GetRNModelConst(x) {
  return `const const_${(x || "").toJavascriptName()} = '${(x || "").toJavascriptName()}';`;
}
function GetRNModelConstValue(x) {
  return `const_${(x || "").toJavascriptName()}`;
}
function GetNodeComponents(layoutObj, item, currentRoot) {
  let imports = [];

  if (!layoutObj) {
    return imports;
  }

  const {
    layout,
    properties
  } = layoutObj;

  if (!currentRoot) {
    currentRoot = layout;
  }

  Object.keys(currentRoot).map(item => {
    imports = [...imports, ...GetNodeComponents(layoutObj, item, currentRoot[item])];

    if (properties[item]) {
      const children = properties[item].children || {};
      if (children[item]) imports.push(children[item]);
    }
  });
  return imports;
}
function GetNodeComponentsKeys(layoutObj, item, currentRoot) {
  let imports = [];

  if (!layoutObj) {
    return imports;
  }

  const {
    layout,
    properties
  } = layoutObj;

  if (!currentRoot) {
    currentRoot = layout;
  }

  Object.keys(currentRoot).map(item => {
    imports = [...imports, ...GetNodeComponentsKeys(layoutObj, item, currentRoot[item])];

    if (properties[item]) {
      const children = properties[item].children || {};
      if (children[item]) imports.push(item);
    }
  });
  return imports;
}
function buildLayoutTree(args) {
  let {
    layoutObj,
    currentRoot,
    language,
    imports = [],
    node = null,
    css,
    section = "section"
  } = args;
  const result = [];
  const {
    layout,
    properties
  } = layoutObj;

  if (!currentRoot) {
    currentRoot = layout;
  }

  Object.keys(currentRoot).map((item, index) => {
    result.push(createSection({
      layoutObj,
      item,
      currentRoot: currentRoot[item],
      index: index + 1,
      css,
      language,
      imports,
      node,
      section: `${section}_${index}`
    }));

    if (section !== "section") {
      css[`${section}_${index}`].parent = section;
    }
  });

  if (css[`${section}`]) {
    css[`${section}`].children = Object.keys(currentRoot).map((_, index) => `${section}_${index}`);
  }

  return result;
}
function createSection(args) {
  const {
    layoutObj,
    item,
    currentRoot,
    index,
    language,
    imports,
    node,
    section,
    css
  } = args;
  const {
    properties
  } = layoutObj;
  const style = properties[item].style || {};
  const children = properties[item].children || {};
  const cellModel = properties[item].cellModel || {};
  const cellRoot = properties[item].cellRoot = {};
  const layoutProperties = properties[item].properties || {};
  const cellModelProperty = properties[item].cellModelProperty || {};
  let tree = Object.keys(currentRoot).length ? buildLayoutTree({
    layoutObj,
    currentRoot,
    language,
    imports,
    node,
    section,
    css
  }) : [];

  if (children && children[item]) {
    if (!imports.some(v => v === children[item])) imports.push(children[item]);
    tree = [addNewLine(GenerateMarkupTag(GetNodeById(children[item]), language, node, {
      children,
      cellModel,
      cellModelProperty,
      item
    }), 2)];
  }

  const _style = { ...style
  };
  ["borderStyle", "borderWidth", "borderColor", ...(language === UITypes.ReactNative ? [] : ['display', 'flex'])].forEach(t => {
    delete _style[t];
  });
  Object.keys(_style).map(t => {
    if (_style[t] === null) {
      delete _style[t];
    }
  });

  if (layoutProperties && layoutProperties.tags && layoutProperties.tags.length) {
    _style.gridArea = layoutProperties.tags[0];
  }

  css[section] = {
    style: { ..._style
    }
  };
  let control = "View";
  let className = "";
  let tagclasses = '';
  let tagBasedStyles = "";

  switch (language) {
    case UITypes.ReactNative:
    case UITypes.ElectronIO:
      if (Object.keys(_style).length < 2 || cellRoot[item]) {// return tree.tightenPs();
      }

      switch (uiactions_GetNodeProp(node, uiactions_NodeProperties.ComponentType)) {
        case "Form":
          control = uiactions_GetNodeProp(node, uiactions_NodeProperties.ComponentType);
          break;

        default:
          const nodeType = uiactions_GetNodeProp(node, uiactions_NodeProperties.NODEType);
          const isScreenOption = nodeType === NodeTypes.ScreenOption;

          if (isScreenOption) {
            control = "div";
          }

          break;
      }

      if (layoutProperties && layoutProperties.componentType) {
        control = layoutProperties.componentType;
      }

      if (UITypes.ReactNative !== language) {
        if (layoutProperties && layoutProperties.tags && Object.keys(layoutProperties.tags).length) {
          tagclasses = layoutProperties.tags.join(' ');
          tagBasedStyles = layoutProperties.tags.map(tag => GetStylesFor(node, tag).join(' ')).filter(x => x).join(' ');
        }

        className = `className={\`$\{styles.${section}} ${tagBasedStyles} ${tagclasses} \`}`;
      } else {
        className = `style={${JSON.stringify({ ..._style
        }, null, 4)}}`;
      }

      return `
<${control} ${className} >
${addNewLine(tree.tightenPs())}
</${control}>
            `;

    default:
      break;
  }
}
// CONCATENATED MODULE: ./app/constants/styles.js

const StyleLib = {
  style: {
    background: "background",
    "background-attachment": "backgroundAttachment",
    "background-color": "backgroundColor",
    "background-image": "backgroundImage",
    "background-position": "backgroundPosition",
    "background-repeat": "backgroundRepeat",
    border: "border",
    "border-bottom": "borderBottom",
    "border-bottom-color": "borderBottomColor",
    "border-bottom-style": "borderBottomStyle",
    "border-bottom-width": "borderBottomWidth",
    "border-color": "borderColor",
    "border-left": "borderLeft",
    "border-left-color": "borderLeftColor",
    "border-left-style": "borderLeftStyle",
    "border-left-width": "borderLeftWidth",
    "border-right": "borderRight",
    "border-radius": "borderRadius",
    cursor: "pointer",
    "border-right-color": "borderRightColor",
    "border-right-style": "borderRightStyle",
    "border-right-width": "borderRightWidth",
    "border-style": "borderStyle",
    "border-top": "borderTop",
    "border-top-color": "borderTopColor",
    "border-top-style": "borderTopStyle",
    "border-top-width": "borderTopWidth",
    "border-width": "borderWidth",
    clear: "clear",
    clip: "clip",
    color: "color",
    cursor: "cursor",
    display: "display",
    filter: "filter",
    flex: "flex",
    "flex-direction": "flexDirection",
    "flex-flow": "flexFlow",
    "justify-content": "justifyContent",
    "align-items": "alignItems",
    "align-content": "alignContents",
    float: "cssFloat",
    font: "font",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-variant": "fontVariant",
    "font-weight": "fontWeight",
    height: "height",
    left: "left",
    "grid-template-columns": "gridTemplateColumns",
    "grid-template-rows": "gridTemplateRows",
    "grid-template-areas": "gridTemplateAreas",
    "grid-template": "gridTemplate",
    "grid-column-gap": "gridColumnGap",
    "grid-row-gap": "gridRowGap",
    "grid-gap": "gridGap",
    "justify-items": "justifyItems",
    "place-items": "placeItems",
    "place-content": "placeContent",
    "grid-auto-columns": "gridAutoColumns",
    "grid-auto-rows": "gridAutoRows",
    "grid-auto-flow": "gridAutoFlow",
    grid: "grid",
    "grid-column-start": "gridColumnStart",
    "grid-column-end": "gridColumnEnd",
    "grid-row-start": "gridRowStart",
    "grid-row-end": "gridRowEnd",
    "grid-column": "gridColumn",
    "grid-row": "gridRow",
    "grid-area": "gridArea",
    "justify-self": "justifySelf",
    "align-self": "alignSelf",
    "place-self": "placeSelf",
    "letter-spacing": "letterSpacing",
    "line-height": "lineHeight",
    "list-style": "listStyle",
    "list-style-image": "listStyleImage",
    "list-style-position": "listStylePosition",
    "list-style-type": "listStyleType",
    margin: "margin",
    "margin-bottom": "marginBottom",
    "margin-left": "marginLeft",
    "margin-right": "marginRight",
    "margin-top": "marginTop",
    overflow: "overflow",
    padding: "padding",
    "padding-bottom": "paddingBottom",
    "box-shadow": "boxShadow",
    "padding-left": "paddingLeft",
    "padding-right": "paddingRight",
    "padding-top": "paddingTop",
    "page-break-after": "pageBreakAfter",
    "page-break-before": "pageBreakBefore",
    position: "position",
    "stroke-dasharray": "strokeDasharray",
    "stroke-dashoffset": "strokeDashoffset",
    "stroke-width": "strokeWidth",
    "text-align": "textAlign",
    "text-decoration": "textDecoration",
    "text-indent": "textIndent",
    "text-transform": "textTransform",
    top: "top",
    "vertical-align": "verticalAlign",
    visibility: "visibility",
    width: "width",
    transition: 'transition',
    "z-index": "zIndex"
  },
  js: {},
  css: {}
};

(function () {
  Object.keys(StyleLib.style).forEach(v => {
    StyleLib.js[StyleLib.style[v]] = v;
    let type = null;

    if (v.toLowerCase().indexOf('color') !== -1) {
      type = 'color';
    }

    StyleLib.css[StyleLib.style[v]] = {
      placeholder: v,
      label: v,
      key: v,
      type
    };
  });
})();
// CONCATENATED MODULE: ./app/service/screenservice.js


/* eslint-disable no-case-declarations */

/* eslint-disable no-param-reassign */

/* eslint-disable default-case */












function GenerateScreens(options) {
  const {
    language
  } = options;
  const temps = BindScreensToTemplate(language || UITypes.ReactNative);
  const result = {};
  temps.map(t => {
    result[external_path_default.a.join(t.relative, t.name)] = t;
  });
  return result;
}
function GenerateScreenMarkup(id, language) {
  const screen = GetNodeById(id);
  const screenOption = GetScreenOption(id, language);

  if (screenOption) {
    const imports = GetScreenImports(id, language);
    const elements = [GenerateMarkupTag(screenOption, language, screen)];
    let template = null;

    switch (language) {
      case UITypes.ElectronIO:
        template = external_fs_default.a.readFileSync("./app/templates/screens/el_screen.tpl", "utf8");
        break;

      case UITypes.ReactNative:
      default:
        template = external_fs_default.a.readFileSync("./app/templates/screens/rn_screen.tpl", "utf8");
        break;
    }

    return bindTemplate(template, {
      name: GetCodeName(screen),
      title: `"${GetNodeTitle(screen)}"`,
      imports: imports.join(nodetypes_NEW_LINE),
      elements: elements.join(nodetypes_NEW_LINE),
      component_did_update: GetComponentDidUpdate(screenOption, {
        isScreen: true
      }),
      component_did_mount: GetComponentDidMount(screenOption)
    });
  }
}
function GenerateScreenOptionSource(node, parent, language) {
  switch (language) {
    case UITypes.ReactNative:
    case UITypes.ElectronIO:
      return GenerateRNScreenOptionSource(node, null, language);
  }
}
function GetDefaultElement(language) {
  return "<View><Text>DE</Text></View>";
}
function GetItemRender(node, imports, language) {
  const listItemNode = GetListItemNode(node.id);
  imports.push(GenerateComponentImport(listItemNode, node, language));
  const properties = WriteDescribedApiProperties(listItemNode, {
    listItem: true
  });
  return `({item, index, separators, key})=>{
    let value = item;
    return  <${GetCodeName(listItemNode)} ${properties} value={value}  key={item && item.id !== undefined && item.id !== null  ? item.id : item}/>
  }`;
}
function GetFormRender(node, imports, language) {
  const listItemNode = GetFormItemNode(node.id);

  if (!listItemNode) {
    return "";
  }

  imports.push(GenerateComponentImport(listItemNode, node, language));
  const properties = WriteDescribedApiProperties(listItemNode, {
    listItem: true
  });
  return `({item, index, separators, key})=>{
    let value = item;
    return  <${GetCodeName(listItemNode)} ${properties} value={value} key={item && item.id !== undefined && item.id !== null  ? item.id : item}/>
  }`;
}
function GetItemRenderImport(node) {
  const listItemNode = GetListItemNode(node.id);
  const properties = WriteDescribedApiProperties(listItemNode, {
    listItem: true
  });
  return `({item, index, separators, key})=> <${GetCodeName(listItemNode)} ${properties} />`;
}

function getCssClassName(css, id) {
  let res = id;

  if (css[id] && css[id].parent) {
    res = `${getCssClassName(css, css[id].parent)} .${res}`;
  } else {
    res = `.${res}`;
  }

  return res;
}

function constructCssFile(css, clsName) {
  const rules = Object.keys(css).map(v => {
    const style = css[v].style;
    const props = Object.keys(style).map(key => {
      const temp = key.replace(/([a-z])([A-Z])/g, "$1-$2");
      const value = style[key];

      if (!isNaN(value)) {// value = `${value}px`;
      }

      if (![undefined, null, ''].some(v => value === v)) return `${temp.toLowerCase()}: ${value};`;
    }).filter(x => x).join(nodetypes_NEW_LINE);
    return `${getCssClassName(css, v)} {
      ${props}
    }`;
  }).join(nodetypes_NEW_LINE);
  return rules;
}
function GetStylesFor(node, tag) {
  if (typeof node === "string") {
    node = GetNodeById(node);
  }

  const graph = GetCurrentGraph();
  const styleNodes = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.Style
  }).filter(x => (uiactions_GetNodeProp(x, nodetypes_NodeProperties.GridAreas) || []).indexOf(tag) !== -1);
  const dataChainsConnectedToStyle = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.DataChain
  }).filter(x => {
    const connectedStyleNodes = GetNodesLinkedTo(graph, {
      id: x.id,
      link: nodetypes_LinkType.Style
    });
    return connectedStyleNodes.some(x => styleNodes.some(node => node.id === x.id));
  });
  return styleNodes.map(styleNode => {
    const dataChainTest = dataChainsConnectedToStyle.filter(dc => existsLinkBetween(graph, {
      source: dc.id,
      target: styleNode.id
    })).map(dc => {
      const selector = GetNodesLinkedTo(graph, {
        id: dc.id,
        link: nodetypes_LinkType.SelectorLink
      })[0];
      let input = "";

      if (selector) {
        const inputs = GetNodesLinkedTo(graph, {
          id: selector.id,
          link: nodetypes_LinkType.SelectorInputLink
        }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentApi);
        input = `S.${GetCodeName(selector)}({${inputs.map(input => `${GetCodeName(input)}: this.state.${GetCodeName(input)}`).join()}})`;
      }

      return `DC.${GetCodeName(dc, {
        includeNameSpace: true
      })}(${input})`;
    }).join(" && ");

    if (!dataChainTest) {
      return `$\{styles.${GetJSCodeName(styleNode)}}`;
    }

    return `$\{${dataChainTest} ? styles.${GetJSCodeName(styleNode)} : '' }`;
  });
}
/*
A  node that is connected to style node, will generate the guts of the style to be named elsewhere.
*/

function buildStyle(node) {
  const graph = GetCurrentGraph();

  if (typeof node === "string") {
    node = GetNodeById(node, graph);
  }

  const styleNodes = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.Style
  });
  const styleSheetRules = styleNodes.map(styleNode => {
    const style = uiactions_GetNodeProp(styleNode, nodetypes_NodeProperties.Style);
    const styleSelectors = StyleNodeProperties.filter(x => uiactions_GetNodeProp(styleNode, x)).map(styleProp => styleProp);
    const areas = uiactions_GetNodeProp(styleNode, nodetypes_NodeProperties.GridAreas);
    const gridRowCount = parseInt(uiactions_GetNodeProp(styleNode, nodetypes_NodeProperties.GridRowCount) || 1, 10);
    const gridplacement = uiactions_GetNodeProp(styleNode, nodetypes_NodeProperties.GridPlacement);
    const styleObj = uiactions_GetNodeProp(styleNode, nodetypes_NodeProperties.Style);
    const useMediaQuery = uiactions_GetNodeProp(style, nodetypes_NodeProperties.UseMediaQuery);
    let mediaquery_start = "";
    let mediaquery_end = "";

    if (useMediaQuery) {
      mediaquery_start = MediaQueries[uiactions_GetNodeProp(styleNode, nodetypes_NodeProperties.MediaQuery)];

      if (mediaquery_start) {
        mediaquery_start = `${mediaquery_start} {`;
        mediaquery_end = `}`;
      }
    }

    const styleName = GetJSCodeName(styleNode);
    const stylesSelectorsName = styleSelectors.map(styleSelector => `${styleName}${styleSelector}`).join();
    const stylesheet = `${mediaquery_start}
    .${stylesSelectorsName || styleName} {
      ${Object.keys(styleObj).map(s => `${StyleLib.js[s]}: ${styleObj[s]};`).join(nodetypes_NEW_LINE)}
    }
    ${mediaquery_end}`;
    return stylesheet;
  }).join(nodetypes_NEW_LINE);
  return styleSheetRules;
}
function GetItemData(node) {
  const dataSourceNode = uiactions_GetDataSourceNode(node.id);
  const connectedNode = uiactions_GetNodeProp(dataSourceNode, nodetypes_NodeProperties.DataChain);
  const instanceType = uiactions_GetNodeProp(dataSourceNode, nodetypes_NodeProperties.InstanceType);
  const defaultValue = GetDefaultComponentValue(node);

  if (connectedNode) {
    // data = `D.${GetJSCodeName(connectedNode)}(${data})`;
    return `(()=> {
    return DC.${GetCodeName(connectedNode, {
      includeNameSpace: true
    })}(${defaultValue});
})()`;
  }

  return `(()=> {
    return ${defaultValue};
})()`;
}
function getRelativePathPrefix(relativePath) {
  return relativePath ? relativePath.split("/").map(t => `../`).subset(2).join("") : relativePath;
}
function GenerateRNScreenOptionSource(node, relativePath, language) {
  const layoutObj = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Layout);
  const componentType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ComponentType);
  const {
    specialLayout,
    template
  } = ComponentTypes[language][componentType] ? ComponentTypes[language][componentType] : {};
  let imports = [];
  const extraimports = [];
  const css = {};
  let layoutSrc;

  if (!specialLayout) {
    // if not a List or something like that
    layoutSrc = layoutObj ? buildLayoutTree({
      layoutObj,
      currentRoot: null,
      language,
      imports,
      node,
      css
    }).join(nodetypes_NEW_LINE) : GetDefaultElement();
  } else {
    extraimports.push(`import * as Models from '${getRelativePathPrefix(relativePath)}model_keys.js';`);

    if (layoutObj) {
      buildLayoutTree({
        layoutObj,
        currentRoot: null,
        language,
        imports,
        node,
        css
      }).join(nodetypes_NEW_LINE);
    }

    const data = GetItemData(node);
    const item_render = GetItemRender(node, extraimports, language);
    const form_render = GetFormRender(node, extraimports, language);
    const apiProperties = WriteDescribedApiProperties(node);
    layoutSrc = bindTemplate(external_fs_default.a.readFileSync(template, "utf8"), {
      item_render,
      form_render,
      data,
      apiProperties
    });
  }

  if (ComponentTypes) {
    if (ComponentTypes[language]) {
      if (ComponentTypes[language][componentType]) {
        if (ComponentTypes[language][componentType].properties && ComponentTypes[language][componentType].properties) {
          const {
            onPress
          } = ComponentTypes[language][componentType].properties;

          if (onPress) {
            layoutSrc = wrapOnPress(layoutSrc, onPress, node);
          }
        }
      }
    }
  }

  let cssFile = null;
  let cssImport = null;
  let templateStr = null;
  let ending = ".js";

  switch (language) {
    case UITypes.ElectronIO:
      ending = ".tsx";
      templateStr = external_fs_default.a.readFileSync("./app/templates/screens/el_screenoption.tpl", "utf8");
      const styleRules = buildStyle(node);
      cssFile = constructCssFile(css, `.${(GetCodeName(node) || "").toJavascriptName()}`);
      cssFile += styleRules;
      cssImport = `import styles from './${(GetCodeName(node) || "").toJavascriptName()}.scss'`;
      break;

    case UITypes.ReactNative:
    default:
      templateStr = external_fs_default.a.readFileSync("./app/templates/screens/rn_screenoption.tpl", "utf8");
      break;
  }

  const results = [];
  imports.filter(x => !uiactions_GetNodeProp(GetNodeById(x), nodetypes_NodeProperties.SharedComponent)).map(t => {
    const relPath = relativePath ? `${relativePath}/${(GetCodeName(node) || "").toJavascriptName()}` : `./src/components/${(GetCodeName(node) || "").toJavascriptName()}`;
    results.push(...GenerateRNComponents(GetNodeById(t), relPath, language));
  });
  imports = imports.unique().map(t => GenerateComponentImport(t, node, language));

  const _consts = GetRNConsts(node.id ? node.id : node) || [];

  const modelInstances = GetRNModelInstances(node.id ? node.id : node) || [];
  const screen_options = addNewLine([..._consts, ...modelInstances].unique().join(nodetypes_NEW_LINE), 4);
  templateStr = bindTemplate(templateStr, {
    name: GetCodeName(node),
    title: `"${GetNodeTitle(node)}"`,
    screen_options,
    component_did_update: GetComponentDidUpdate(node),
    imports: [...imports, cssImport, ...extraimports].unique().join(nodetypes_NEW_LINE),
    elements: addNewLine(layoutSrc, 4)
  });
  templateStr = bindTemplate(templateStr, {
    relative_depth: [].interpolate(0, relativePath ? relativePath.split("/").length - 2 : 1, () => "../").join("")
  });
  return [{
    template: templateStr,
    relative: relativePath || "./src/components",
    relativeFilePath: `./${(GetCodeName(node) || "").toJavascriptName()}${ending}`,
    name: `${relativePath || "./src/components/"}${(GetCodeName(node) || "").toJavascriptName()}${ending}`
  }, cssFile ? {
    template: cssFile,
    relative: relativePath || "./src/components",
    relativeFilePath: `./${(GetCodeName(node) || "").toJavascriptName()}.scss`,
    name: `${relativePath || "./src/components/"}${(GetCodeName(node) || "").toJavascriptName()}.scss`
  } : null, ...results].filter(x => x);
}
function bindComponent(node, componentBindingDefinition) {
  if (componentBindingDefinition && componentBindingDefinition.template) {
    const template = external_fs_default.a.readFileSync(componentBindingDefinition.template, "utf8");
    const {
      properties
    } = componentBindingDefinition;
    const graph = GetCurrentGraph();
    const bindProps = {};
    Object.keys(properties).map(key => {
      if (properties[key] && properties[key].style) {
        const styles = [];
        const nodeId = typeof node === 'string' ? node : node.id; // const dataChainStyleLinks = GetNodesLinkedTo(graph, {
        //   id: node.id,
        //   link: LinkType.DataChainStyleLink
        // });

        const styleNodes = GetNodesLinkedTo(graph, {
          id: nodeId,
          link: nodetypes_LinkType.Style,
          properties: {
            [LinkPropertyKeys.ComponentTag]: ComponentTags.Self
          }
        });
        styleNodes.forEach(styleNode => {
          // const styleNodeDataChain = GetNodesLinkedTo(graph, {
          //   id: styleNode.id,
          //   link: LinkType.DataChainStyleLink
          // }).find(v => dataChainStyleLinks.find(f => v.id === f.id));
          // if (styleNodeDataChain) {
          //   styles.push(`$\{ DC.${GetCodeName(styleNodeDataChain, { includeNameSpace: true })} ? styles['${GetJSCodeName(styleNode)}'] : '' }`)
          // }
          // else {
          // }
          styles.push(`$\{styles['${GetJSCodeName(styleNode)}']}`);
        });

        if (styles.length) {
          bindProps[key] = `className={\`${styles.join(' ')}\`}`;
        }
      } else if (properties[key] && properties[key].localStateProperty) {
        bindProps[key] = `${key}={this.state.${key}}`;
      } else if (properties[key] && properties[key].nodeProperty) {
        bindProps[key] = uiactions_GetNodeProp(node, properties[key].nodeProperty);

        if (properties[key].parameterConfig) {
          const parameterConfig = uiactions_GetNodeProp(node, properties[key].nodeProperty);

          if (parameterConfig && parameterConfig[key]) {
            bindProps[key] = writeApiProperties({
              [key]: parameterConfig[key]
            });
          }
        } else if (properties[key].template) {
          bindProps[key] = GetDefaultComponentValue(node, key);
        }
      }

      if (!bindProps[key]) bindProps[key] = "";
    });
    const cevents = componentBindingDefinition.eventApi || Object.keys(ComponentEvents);
    const eventHandlers = cevents.map(t => getMethodInstancesForEvntType(node, ComponentEvents[t])).map((methodInstances, i) => {
      const invocations = methodInstances.map(methodInstanceCall => {
        let invocationDependsOnState = null;
        const temp = getMethodInvocation(methodInstanceCall, args => {
          const {
            statePropertiesThatCauseInvocation
          } = args;
          invocationDependsOnState = (statePropertiesThatCauseInvocation || []).length;
        }, {
          component: node
        });
        if (invocationDependsOnState) return false;
        return temp;
      }).filter(x => x).join(nodetypes_NEW_LINE);
      return `${ComponentEvents[cevents[i]]}={(value)=> {
        //  warning
${invocations}
    }}`;
    });

    if (eventHandlers && eventHandlers.length) {
      bindProps.events = eventHandlers.join(nodetypes_NEW_LINE);
    }

    return bindTemplate(template, bindProps);
  }
}
function wrapOnPress(elements, onPress, node, options) {
  const onpress = uiactions_GetNodeProp(node, "onPress");

  switch (onpress) {
    case APP_METHOD:
      const key = "onPress";
      const methodParams = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ClientMethodParameters) || {};
      const clientMethod = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ClientMethod);
      let bodytext = "let body = null;";
      const parameterstext = `let parameters = null;`;

      if (clientMethod) {
        const jsClientMethodName = GetJSCodeName(clientMethod);
        const methodParameters = GetMethodParameters(clientMethod);

        if (methodParameters) {
          const {
            parameters,
            body
          } = methodParameters;

          if (body) {
            const componentNodeProperties = GetComponentNodeProperties();
            const instanceType = getClientMethod(methodParams, key, "body", "instanceType");
            const componentModel = getClientMethod(methodParams, key, "body", "componentModel");
            const c_props = componentNodeProperties.find(x => x.id === getClientMethod(methodParams, key, "body", "component"));
            const c_props_options = c_props && c_props.componentPropertiesList ? c_props.componentPropertiesList : [];

            if (c_props_options.length) {
              const c_prop_option = c_props_options.find(v => v.value === componentModel);

              if (c_prop_option) {
                const componentModelName = c_prop_option.value;
                bodytext = `let body = Get${instanceType}Object('${componentModelName}');`;
              }
            }
          }

          if (parameters) {// TODO: Handle parameters;
          }

          const pressfunc = `this.props.${jsClientMethodName}({ body, parameters })`;

          if (options && options.onPress && options.onPress.nowrap) {
            elements = bindTemplate(elements, {
              onPressEvent: `onPress={() => {
${parameterstext}
${bodytext}
${pressfunc} }}`
            });
          } else {
            elements = bindTemplate(elements, {
              onPressEvent: ""
            });
            elements = `
                        <TouchableOpacity onPress={() => {
    ${parameterstext}
    ${bodytext}
    ${pressfunc} }}>
                ${elements}
                        </TouchableOpacity>`;
          }
        }
      }

      break;

    case NAVIGATION:
      const navigation = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Navigation);
      const targetScreen = GetNodeById(navigation);
      const screenParameters = uiactions_GetNodeProp(targetScreen, nodetypes_NodeProperties.ScreenParameters);
      const params = [];

      if (screenParameters) {
        const navigationProperties = uiactions_GetNodeProp(node, nodetypes_NodeProperties.NavigationParameters);
        const parameterProperty = uiactions_GetNodeProp(node, nodetypes_NodeProperties.NavigationParametersProperty) || {};
        const componentProperties = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ComponentProperties);
        screenParameters.map(sparam => {
          const {
            title,
            id
          } = sparam;
          const propName = navigationProperties[id];

          if (propName) {
            const propPropName = parameterProperty[propName];

            if (propPropName) {
              let listitem = "";

              if (uiactions_GetNodeProp(node, nodetypes_NodeProperties.ComponentType) === ComponentTypes.ReactNative.ListItem.key) {
                listitem = ".item";
              }

              const propertyNode = GetNodeById(propPropName);

              if (propertyNode) {
                params.push(`${title}: this.props.${propName}${listitem}.${GetJSCodeName(propertyNode)}`);
              } else {
                params.push(`${title}: this.props.${propName}${listitem}`);
              }
            }
          }
        });
      }

      if (navigation && params) {
        const navfunc = `navigate('${GetCodeName(navigation)}', {${params.join(", ")}})`;

        if (options && options.onPress && options.onPress.nowrap) {
          elements = bindTemplate(elements, {
            onPressEvent: `onPress={() => { ${navfunc} }}`
          });
        } else {
          elements = bindTemplate(elements, {
            onPressEvent: ""
          });
          elements = `
    <TouchableOpacity onPress={() => { ${navfunc} }}>
${elements}
    </TouchableOpacity>`;
        }
      }

      break;
  }

  return elements;
}
function GenerateRNComponents(node, relative = "./src/components", language = UITypes.ReactNative) {
  const result = [];
  const layoutObj = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Layout);
  let fileEnding = ".js";

  switch (language) {
    case UITypes.ElectronIO:
      fileEnding = ".tsx";
      break;
  }

  const componentType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ComponentType);

  if (!layoutObj && (!ComponentTypes[language] || !ComponentTypes[language][componentType] || !ComponentTypes[language][componentType].specialLayout)) {
    switch (uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType)) {
      case NodeTypes.ComponentNode:
        let template = null;

        switch (language) {
          case UITypes.ElectronIO:
            template = external_fs_default.a.readFileSync("./app/templates/screens/el_screenoption.tpl", "utf8");
            break;

          case UITypes.ReactNative:
          default:
            template = external_fs_default.a.readFileSync("./app/templates/screens/rn_screenoption.tpl", "utf8");
            break;
        }

        let elements = null;

        if (ComponentTypes[language] && ComponentTypes[language][componentType]) {
          elements = bindComponent(node, ComponentTypes[language][componentType]);

          if (ComponentTypes[language][componentType].properties && ComponentTypes[language][componentType].properties) {
            const {
              onPress,
              nowrap
            } = ComponentTypes[language][componentType].properties;

            if (onPress) {
              elements = wrapOnPress(elements, onPress, node, ComponentTypes[language][componentType].properties);
            }
          }
        }

        const css = {};
        let cssFile = '';
        let cssImport = '';
        const component_did_update = GetComponentDidUpdate(node);

        switch (language) {
          case UITypes.ElectronIO:
            const styleRules = buildStyle(node);
            cssFile = constructCssFile(css, `.${(GetCodeName(node) || "").toJavascriptName()}`);
            cssFile += styleRules;
            cssImport = `import styles from './${(GetCodeName(node) || "").toJavascriptName()}.scss'`;
            break;

          default:
            break;
        }

        template = bindTemplate(template, {
          name: GetCodeName(node),
          imports: [cssImport].join(nodetypes_NEW_LINE),
          component_did_update,
          screen_options: "",
          elements: elements || GetDefaultElement()
        });
        template = bindTemplate(template, {
          relative_depth: [].interpolate(0, relative ? relative.split("/").length - 2 : 1, () => "../").join("")
        });
        result.push(cssFile ? {
          template: cssFile,
          relative: relative || "./src/components",
          relativeFilePath: `./${(GetCodeName(node) || "").toJavascriptName()}.scss`,
          name: `${relative || "./src/components/"}${(GetCodeName(node) || "").toJavascriptName()}.scss`
        } : null, {
          relative: relative || "./src/components",
          relativeFilePath: `./${(GetCodeName(node) || "").toJavascriptName()}${fileEnding}`,
          name: `${relative || "./src/components"}/${(GetCodeName(node) || "").toJavascriptName()}${fileEnding}`,
          template
        });
        break;
    }

    return result.filter(x => x);
  }

  const src = GenerateRNScreenOptionSource(node, relative || "./src/components", language);
  if (src) result.push(...src);
  const components = GetNodeComponents(layoutObj).filter(x => !uiactions_GetNodeProp(GetNodeById(x), nodetypes_NodeProperties.SharedComponent));
  components.map(component => {
    const relPath = relative ? `${relative}/${(GetCodeName(node) || "").toJavascriptName()}` : `./src/components/${(GetCodeName(node) || "").toJavascriptName()}`;
    const temp = GenerateRNComponents(component, relPath, language);
    result.push(...temp);
  });
  return result;
}
function GenerateCss(id, language) {
  const screen = GetNodeById(id);
  const screenOption = GetScreenOption(id, language);

  if (screenOption) {
    const imports = GetScreenImports(id, language);
    const elements = [GenerateMarkupTag(screenOption, language, screen)];
    let template = null;

    switch (language) {
      case UITypes.ElectronIO:
        template = external_fs_default.a.readFileSync("./app/templates/screens/el_screen.tpl", "utf8");
        break;

      case UITypes.ReactNative:
      default:
        template = external_fs_default.a.readFileSync("./app/templates/screens/rn_screen.tpl", "utf8");
        break;
    }

    return bindTemplate(template, {
      name: GetCodeName(screen),
      title: `"${GetNodeTitle(screen)}"`,
      imports: imports.join(nodetypes_NEW_LINE),
      elements: elements.join(nodetypes_NEW_LINE),
      component_did_update: GetComponentDidUpdate(screenOption),
      component_did_mount: GetComponentDidMount(screenOption)
    });
  }
}
function ConvertViewTypeToComponentNode(node, language) {
  let wasstring = false;

  if (typeof node === "string") {
    node = GetNodeById(node);
    wasstring = true;
  }

  switch (uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType)) {
    case NodeTypes.ViewType:
      const temp = GetNodesLinkedTo(GetCurrentGraph(GetState()), {
        id: node.id,
        link: nodetypes_LinkType.DefaultViewType,
        componentType: NodeTypes.ComponentNode
      }).filter(x => {
        let temp = uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === language;
        return temp;
      }).filter(x => !!uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsPluralComponent) === !!uiactions_GetNodeProp(node, nodetypes_NodeProperties.IsPluralComponent)).find(x => x);

      if (!temp) {
        var asdf = 1;
      }

      node = temp || node;
      break;

    default:
      break;
  }

  if (wasstring) {
    return node.id;
  }

  return node;
}
function GenerateMarkupTag(node, language, parent) {
  let viewTypeNode = null;

  if (uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType) === NodeTypes.ViewType) {
    viewTypeNode = node;
  }

  node = ConvertViewTypeToComponentNode(node, language);

  switch (language) {
    case UITypes.ReactNative:
    case UITypes.ElectronIO:
      let describedApi = "";

      if (node && parent) {
        if (viewTypeNode) {
          describedApi = WriteDescribedApiProperties(viewTypeNode, {
            listitem: false,
            parent
          });
        }

        if (!describedApi) {
          describedApi = WriteDescribedApiProperties(node, {
            listItem: uiactions_GetNodeProp(node, nodetypes_NodeProperties.ComponentType) === ComponentTypeKeys.ListItem
          });
        }
      }

      return `<${GetCodeName(node)} ${describedApi} />`;
  }
}

function WriteDescribedStateUpdates(parent) {
  let result = ``;
  const graph = GetCurrentGraph(GetState());

  if (typeof parent === "string") {
    parent = GetNodeById(parent, graph);
  }

  const componentInternalApis = GetNodesLinkedTo(graph, {
    id: parent.id,
    link: nodetypes_LinkType.ComponentInternalApi
  });
  result = componentInternalApis.unique(x => GetJSCodeName(x)).map(componentInternalApi => {
    const externalApiNode = GetNodesLinkedTo(graph, {
      id: componentInternalApi.id,
      link: nodetypes_LinkType.ComponentInternalConnection
    }).find(x => x);
    const dataChain = GetNodesLinkedTo(graph, {
      id: componentInternalApi.id,
      link: nodetypes_LinkType.DataChainLink
    }).find(x => x);
    const selector = GetNodesLinkedTo(graph, {
      id: componentInternalApi.id,
      link: nodetypes_LinkType.SelectorLink
    }).find(x => x);
    let innerValue = null;
    const externalKey = GetJSCodeName(externalApiNode);
    innerValue = externalKey;

    if (innerValue) {
      if (selector) {
        const addiontionalParams = getUpdateFunctionOption(selector.id, externalApiNode.id, `, { update: true }/*s => e*/`);
        innerValue = `S.${GetJSCodeName(selector)}({{temp}}, this.state.viewModel${addiontionalParams} /* state update */)`;
      } else {
        innerValue = "{{temp}}";
      }

      if (dataChain) {
        innerValue = `DC.${GetCodeName(dataChain, {
          includeNameSpace: true
        })}(${innerValue})`;
      }

      const temp_prop = GetJSCodeName(componentInternalApi);
      result = `
            var new_${externalKey} = ${bindTemplate(innerValue, {
        temp: `this.props.${externalKey}`
      })};
            if ( new_${externalKey} !== this.state.${temp_prop}) {
          {{step}}
        }`;
      return bindTemplate(result, {
        temp: innerValue,
        step: `updated = true;
            updates = {...updates, ${GetJSCodeName(componentInternalApi)}:  new_${externalKey} };`
      });
    }
  }).filter(x => x).join(nodetypes_NEW_LINE);
  const methodInstances = getMethodInstancesForLifeCylcEvntType(parent, ComponentLifeCycleEvents.ComponentDidMount);
  const invocations = (methodInstances || []).map(methodInstanceCall => {
    let invocationDependsOnState = false;
    let dependentStateProperties = [];
    const temp = getMethodInvocation(methodInstanceCall, args => {
      const {
        statePropertiesThatCauseInvocation
      } = args;
      dependentStateProperties = statePropertiesThatCauseInvocation;
      invocationDependsOnState = (statePropertiesThatCauseInvocation || []).length;
    }, {
      component: parent
    });

    if (!invocationDependsOnState) {
      return false;
    }

    const ifstatement = dependentStateProperties.map(v => `updates.hasOwnProperty('${v}')`).join(" || ");
    return `if(${ifstatement}) {
        ${temp}
      }`;
  }).filter(x => x).join(nodetypes_NEW_LINE);
  return `
  let updated = false;
  let updates = {};
  ${result}
  if(updated) {
    this.setState((state, props) => {
        return updates;
    }, () => {
      // do stuff here;
      ${invocations}
    })
  }
  `;
}

function GetDefaultComponentValue(node, key) {
  let result = ``;
  const graph = GetCurrentGraph(GetState());

  if (typeof node === "string") {
    node = GetNodeById(node, graph);
  }

  const componentInternalApis = [GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.ComponentInternalApi
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIText) === key).find(x => x)].filter(x => x);
  result = componentInternalApis.unique(x => GetJSCodeName(x)).map(componentInternalApi => {
    const dataChain = GetNodesLinkedTo(graph, {
      id: componentInternalApi.id,
      link: nodetypes_LinkType.DataChainLink
    }).find(x => x);
    const selector = GetNodesLinkedTo(graph, {
      id: componentInternalApi.id,
      link: nodetypes_LinkType.SelectorLink
    }).find(x => x);
    let innerValue = null;
    const externalKey = GetJSCodeName(componentInternalApi);
    innerValue = externalKey;

    if (innerValue) {
      if (selector) {
        innerValue = `S.${GetJSCodeName(selector)}({{temp}}, this.state.viewModel$)`;
      } else {
        innerValue = "{{temp}}";
      }

      if (dataChain) {
        innerValue = `DC.${GetCodeName(dataChain, {
          includeNameSpace: true
        })}(${innerValue})`;
      }

      result = `${bindTemplate(innerValue, {
        temp: `this.state.${externalKey}`
      })}`;
      return result;
    }
  }).filter(x => x).join(nodetypes_NEW_LINE);
  return result;
}

function WriteDescribedApiProperties(node, options = {
  listItem: false
}) {
  let result = "";

  if (typeof node === "string") {
    node = GetNodeById(node, graph);
  }

  let graph = GetCurrentGraph(GetState());
  const componentExternalApis = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.ComponentExternalApi
  });
  const componentEventHandlers = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.EventMethod
  });
  const isViewType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType) === NodeTypes.ViewType;
  result = componentExternalApis.unique(x => GetJSCodeName(x)).map(componentExternalApi => {
    let stateKey = false;
    let noSelector = false;
    let noDataChain = false;
    let externalConnection = GetNodesLinkedTo(graph, {
      id: componentExternalApi.id,
      link: nodetypes_LinkType.ComponentExternalConnection
    }).find(x => x);

    if (isViewType && !externalConnection) {
      // If the view-type node doesn't have an external connection
      // Then conventions will be assumed.
      externalConnection = componentExternalApi;

      switch (GetNodeTitle(externalConnection)) {
        case "label":
        case "placeholder":
        case "success":
          return;

        case "viewModel":
          noSelector = true;
          noDataChain = false;
          break;

        case "error":
        default:
          stateKey = "value";
          break;
      }
    }

    const titleService = GetNodesLinkedTo(graph, {
      id: componentExternalApi.id,
      link: nodetypes_LinkType.TitleServiceLink
    }).find(x => x);
    const query = GetNodesLinkedTo(graph, {
      id: componentExternalApi.id,
      link: nodetypes_LinkType.QueryLink
    }).find(x => x);
    const dataChain = GetNodesLinkedTo(graph, {
      id: componentExternalApi.id,
      link: nodetypes_LinkType.DataChainLink
    }).find(x => x);
    const selector = GetNodesLinkedTo(graph, {
      id: componentExternalApi.id,
      link: nodetypes_LinkType.SelectorLink
    }).find(x => x);
    let innerValue = "";

    if (titleService) {
      innerValue = `titleService.get('${uiactions_GetNodeProp(node, nodetypes_NodeProperties.Label)}')`;
    } else if (externalConnection || query) {
      if (query && uiactions_GetNodeProp(query, nodetypes_NodeProperties.QueryParameterObject)) {
        innerValue = `GetScreenParam('query')`;
      } else if (options.listItem) {
        const listItemAttribute = GetJSCodeName(externalConnection);
        innerValue = !uiactions_GetNodeProp(externalConnection, nodetypes_NodeProperties.AsLocalContext) ? `this.state.${listItemAttribute}` : listItemAttribute;
      } else {
        const defaulComponentValue = uiactions_GetNodeProp(externalConnection, nodetypes_NodeProperties.DefaultComponentApiValue) || "";

        if (defaulComponentValue) {
          // Create/Update case
          innerValue = `ViewModelKeys.${defaulComponentValue}`;
        } else {
          // Get/GetAll/Delete
          innerValue = `this.state.${stateKey || GetJSCodeName(externalConnection)}`;
        }
      }
    }

    let addiontionalParams;

    if (!noSelector && selector) {
      addiontionalParams = componentExternalApi && externalConnection ? getUpdateFunctionOption(componentExternalApi.id, externalConnection.id, `, { update: true }/*c => e*/`) : "";

      if (isViewType) {
        addiontionalParams = componentExternalApi && node ? getUpdateFunctionOption(node.id, componentExternalApi.id, `, { update: true }/*n => c*/`) : "";
        innerValue = `S.${GetJSCodeName(selector)}(${innerValue}, this.state.viewModel${addiontionalParams})`;
      } else {
        // TODO: this might be able to go away;
        innerValue = `S.${GetJSCodeName(selector)}(${innerValue}, this.state.viewModel${addiontionalParams})`;
      }
    }

    if (!noDataChain && dataChain) {
      innerValue = `DC.${GetCodeName(dataChain, {
        includeNameSpace: true
      })}(${innerValue})`;
    }

    if (innerValue) {
      return `${GetJSCodeName(componentExternalApi)}={${innerValue}}`;
    }
  }).filter(x => x);
  const res = componentEventHandlers.unique(x => GetJSCodeName(x)).map(componentEventHandler => {
    const eventInstances = GetNodesLinkedTo(graph, {
      id: componentEventHandler.id,
      link: nodetypes_LinkType.EventMethodInstance
    });
    return eventInstances.map(eventInstance => {
      const eventMethodHandlers = GetNodesLinkedTo(graph, {
        id: eventInstance.id,
        link: nodetypes_LinkType.EventHandler
      });
      const method_calls = eventMethodHandlers.map(eventMethodHandler => {
        const property = GetNodesLinkedTo(graph, {
          id: eventMethodHandler.id,
          link: nodetypes_LinkType.PropertyLink
        }).find(x => x);
        const viewModel = GetNodesLinkedTo(graph, {
          id: eventMethodHandler.id,
          link: nodetypes_LinkType.ViewModelLink
        }).find(x => x);
        const eventType = uiactions_GetNodeProp(eventMethodHandler, nodetypes_NodeProperties.EventType);
        const useValue = uiactions_GetNodeProp(eventMethodHandler, nodetypes_NodeProperties.UseValue) ? "value" : "text";
        const addiontionalParams = componentEventHandler && eventInstance ? getUpdateFunctionOption(componentEventHandler.id, eventInstance.id, `, { update: true, value: this.state.value/*hard coded*/ }`) : "";
        let method_call = null;
        const modelProperty = GetJSCodeName(property);
        const screenOrModel = uiactions_GetNodeProp(eventMethodHandler, nodetypes_NodeProperties.InstanceType) ? "Model" : "Screen";

        switch (eventType) {
          case ComponentEvents.onBlur:
            method_call = `this.props.update${screenOrModel}InstanceBlur(this.state.viewModel, '${modelProperty}'${addiontionalParams})`;
            break;

          case ComponentEvents.onFocus:
            method_call = `this.props.update${screenOrModel}InstanceFocus(this.state.viewModel, '${modelProperty}'${addiontionalParams})`;
            break;

          case ComponentEvents.onChangeText:
            method_call = `this.props.update${screenOrModel}Instance(this.state.viewModel, '${modelProperty}', arg${addiontionalParams})`;
            break;

          case ComponentEvents.onChange:
            method_call = `this.props.update${screenOrModel}Instance(this.state.viewModel, '${modelProperty}', arg.nativeEvent.${useValue}${addiontionalParams})`;
            break;
        }

        return method_call;
      });

      if (method_calls && method_calls.length) {
        return `${uiactions_GetNodeProp(eventInstance, nodetypes_NodeProperties.EventType)}={arg => {
                    ${method_calls.join(nodetypes_NEW_LINE)}
                }}`;
      }
    }).filter(x => x).join(nodetypes_NEW_LINE);
  });
  const componentType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ComponentType);
  const uiType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIType);

  if (ComponentTypes[uiType] && ComponentTypes[uiType][componentType]) {
    const {
      events
    } = ComponentTypes[uiType][componentType];

    for (const _event in events) {
      switch (_event) {
        case ComponentEvents.onChange:
          result.push(ComponentEventStandardHandler[_event]);
          break;
      }
    }
  }

  result.push(...res);
  return nodetypes_NEW_LINE + result.join(nodetypes_NEW_LINE);
}

function writeApiProperties(apiConfig) {
  let result = "";
  const res = [];

  if (apiConfig) {
    for (const i in apiConfig) {
      let property = null;
      const {
        instanceType,
        model,
        selector,
        modelProperty,
        apiProperty,
        handlerType,
        isHandler,
        dataChain
      } = apiConfig[i];
      const modelJsName = GetJSCodeName(model) || model;

      switch (instanceType) {
        case InstanceTypes.ScreenInstance:
          switch (handlerType) {
            case HandlerTypes.Blur:
              property = `() => this.props.updateScreenInstanceBlur(this.state.viewModel, const_${GetJSCodeName(modelProperty)})`;
              break;

            case HandlerTypes.Focus:
              property = `() => this.props.updateScreenInstanceFocus(this.state.viewModel, const_${GetJSCodeName(modelProperty)})`;
              break;

            case HandlerTypes.ChangeText:
              property = `(v) => this.props.updateScreenInstance(this.state.viewModel, const_${GetJSCodeName(modelProperty)}, v)`;
              break;

            case HandlerTypes.Change:
              property = `(v) => this.props.updateScreenInstance(this.state.viewModel, const_${GetJSCodeName(modelProperty)}, v.nativeEvent.text)`;
              break;

            case HandlerTypes.Property:
            default:
              if (modelProperty) {
                property = `GetScreenInstance(this.state.viewModel, const_${GetJSCodeName(modelProperty)})`;
              } else {
                property = `GetScreenInstanceObject(this.state.viewModel)`;
              }

              break;
          }

          break;

        case InstanceTypes.ModelInstance:
          switch (handlerType) {
            case HandlerTypes.Blur:
              property = `() => this.props.updateModelInstanceBlur(this.state.viewModel, this.props.value, '${GetJSCodeName(modelProperty)}')`;
              break;

            case HandlerTypes.Focus:
              property = `() => this.props.updateModelInstanceFocus(this.state.viewModel, this.props.value, '${GetJSCodeName(modelProperty)}')`;
              break;

            case HandlerTypes.ChangeText:
              property = `(v) => this.props.updateModelInstance(this.state.viewModel, this.props.value, '${GetJSCodeName(modelProperty)}', v)`;
              break;

            case HandlerTypes.Change:
              property = `(v) => this.props.updateModelInstance(this.state.viewModel, this.props.value, '${GetJSCodeName(modelProperty)}', v.nativeEvent.text)`;
              break;

            case HandlerTypes.Property:
            default:
              if (modelProperty) {
                property = `GetModelInstance(this.state.viewModel, this.props.value, '${GetJSCodeName(modelProperty)}')`;
              } else {
                property = `GetModelInstanceObject(this.state.viewModel, this.props.value)`;
              }

              break;
          }

          break;

        default:
          break;
        // throw 'write api properties unhandled case ' + instanceType;
      }

      if (property) {
        if (dataChain) {
          const codeName = GetCodeName(dataChain, {
            includeNameSpace: true
          });
          property = `DC.${codeName}(${property})`;
        } // There is an opportunity to wrapp the result in a getter.


        res.push(`${nodetypes_NEW_LINE}${i}={${property}}`);
      }
    }
  }

  result = res.join(" ");
  return result;
}
function GetScreenOption(id, language) {
  const screen = GetNodeById(id);
  const screenOptions = screen ? GetConnectedScreenOptions(screen.id) : null;

  if (screenOptions && screenOptions.length) {
    const reactScreenOption = screenOptions.find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === language);

    if (reactScreenOption) {
      return reactScreenOption;
    }
  }

  return null;
}
function GetScreenImports(id, language) {
  const screen = GetNodeById(id);
  const screenOptions = screen ? GetConnectedScreenOptions(screen.id) : null;

  if (screenOptions && screenOptions.length) {
    const reactScreenOption = screenOptions.find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === language);

    if (reactScreenOption) {
      return [GenerateImport(reactScreenOption, screen, language)];
    }

    return [];
  }

  return null;
}
function getMethodInstancesForLifeCylcEvntType(node, evtType) {
  if (typeof node === "string") {
    node = GetNodeById(node);
  }

  const graph = GetCurrentGraph(GetState());
  const methods = getNodesByLinkType(graph, {
    id: node.id,
    type: nodetypes_LinkType.LifeCylceMethod,
    direction: graph_methods_TARGET,
    exist: true
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType) === evtType);
  const methodInstances = [];
  methods.map(method => {
    methodInstances.push(...getNodesLinkedTo(graph, {
      id: method.id,
      exist: true
    }).filter(x => [NodeTypes.LifeCylceMethodInstance].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType))));
  });
  return methodInstances;
}
function getMethodInstancesForEvntType(node, evtType) {
  if (typeof node === "string") {
    node = GetNodeById(node);
  }

  const graph = GetCurrentGraph(GetState());
  const methods = getNodesByLinkType(graph, {
    id: node.id,
    type: nodetypes_LinkType.EventMethod,
    direction: graph_methods_TARGET,
    exist: true
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType) === evtType);
  const methodInstances = [];
  methods.map(method => {
    methodInstances.push(...getNodesLinkedTo(graph, {
      id: method.id,
      exist: true
    }).filter(x => [NodeTypes.EventMethodInstance].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType))));
  });
  return methodInstances;
}
function getMethodInvocation(methodInstanceCall, callback = () => {}, options = {}) {
  const graph = GetCurrentGraph(GetState());
  const method = getNodesByLinkType(graph, {
    id: methodInstanceCall.id,
    type: nodetypes_LinkType.MethodCall,
    direction: SOURCE
  }).find(x => x);
  const navigationMethod = getNodesByLinkType(graph, {
    id: methodInstanceCall.id,
    type: nodetypes_LinkType.NavigationMethod,
    direction: SOURCE
  }).find(x => x);
  let dataChain = getNodesByLinkType(graph, {
    id: methodInstanceCall.id,
    type: nodetypes_LinkType.DataChainLink,
    direction: SOURCE
  }).find(x => x);
  const internalApiConnection = getNodesByLinkType(graph, {
    id: methodInstanceCall.id,
    type: nodetypes_LinkType.ComponentApi,
    direction: SOURCE
  }).find(x => x);
  const statePropertiesThatCauseInvocation = [];

  if (method) {
    const parts = [];
    const body = getNodesByLinkType(graph, {
      id: method.id,
      type: nodetypes_LinkType.MethodApiParameters,
      direction: graph_methods_TARGET
    }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UriBody));
    const queryObject = getNodesByLinkType(graph, {
      id: method.id,
      type: nodetypes_LinkType.MethodApiParameters,
      direction: graph_methods_TARGET
    }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.QueryParameterObject));
    const templateObject = getNodesByLinkType(graph, {
      id: method.id,
      type: nodetypes_LinkType.MethodApiParameters,
      direction: graph_methods_TARGET
    }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.TemplateParameter));
    dataChain = GetNodeLinkedTo(graph, {
      id: methodInstanceCall.id,
      link: nodetypes_LinkType.DataChainLink,
      componentType: NodeTypes.DataChain
    });
    const preDataChain = GetNodeLinkedTo(graph, {
      id: methodInstanceCall.id,
      link: nodetypes_LinkType.PreDataChainLink,
      componentType: NodeTypes.DataChain
    });
    const methodInstanceSource = GetNodesLinkedTo(graph, {
      id: methodInstanceCall.id,
      link: nodetypes_LinkType.EventMethodInstance
    }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.EventMethod);
    let body_input = null;

    if (body) {
      const body_param = getNodesByLinkType(graph, {
        id: body.id,
        type: nodetypes_LinkType.ComponentApiConnection,
        direction: graph_methods_TARGET
      }).find(x => x);

      if (body_param) {
        const body_selector = getNodesByLinkType(graph, {
          id: body_param.id,
          type: nodetypes_LinkType.ComponentApiConnection,
          direction: SOURCE
        }).find(x_temp => uiactions_GetNodeProp(x_temp, nodetypes_NodeProperties.NODEType) === NodeTypes.Selector);
        let innervalue = "";

        if (body_selector) {
          const addiontionalParams = getUpdateFunctionOption(methodInstanceSource ? methodInstanceSource.id : null, methodInstanceCall ? methodInstanceCall.id : null, `, { update: true }/*m => mi*/`);
          innervalue = `S.${GetJSCodeName(body_selector)}(this.state.value, this.state.viewModel${addiontionalParams})`;
        }

        const body_value = getNodesByLinkType(graph, {
          id: body_param.id,
          type: nodetypes_LinkType.ComponentApiConnection,
          direction: SOURCE
        }).find(x_temp => uiactions_GetNodeProp(x_temp, nodetypes_NodeProperties.NODEType) === NodeTypes.DataChain);

        if (body_value) {
          body_input = `body: DC.${GetCodeName(body_value, {
            includeNameSpace: true
          })}(${innervalue})`;
        }
      }

      if (body_input) {
        parts.push(`${body_input}`);
      }
    }

    if (templateObject) {
      const templateParameters = GetNodesLinkedTo(graph, {
        id: templateObject.id,
        type: nodetypes_LinkType.MethodApiParameters,
        direction: SOURCE
      }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.TemplateParameter));
      const queryParameterValues = templateParameters.map(queryParameter => extractApiJsCode({
        node: queryParameter,
        options,
        graph,
        callback: list => {
          statePropertiesThatCauseInvocation.push(...list);
        }
      })).filter(temp => temp);
      parts.push(`template: {${addNewLine(queryParameterValues.join(`, ${nodetypes_NEW_LINE}`))}}`);
    }

    if (queryObject) {
      const queryParameters = getNodesByLinkType(graph, {
        id: queryObject.id,
        type: nodetypes_LinkType.MethodApiParameters,
        direction: SOURCE
      }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.QueryParameterParam));
      const queryParameterValues = queryParameters.map(queryParameter => extractApiJsCode({
        node: queryParameter,
        graph,
        options,
        internalApiConnection,
        callback: list => {
          statePropertiesThatCauseInvocation.push(...list);
        }
      })).filter(temp => temp);
      parts.push(`query: {${addNewLine(queryParameterValues.join(`, ${nodetypes_NEW_LINE}`))}}`);
    }

    if (callback) {
      callback({
        statePropertiesThatCauseInvocation
      });
    }

    let dataChainInput = "";

    if (dataChain) {
      dataChainInput = `${parts.length ? "," : ""}dataChain: DC.${GetCodeName(dataChain, {
        includeNameSpace: true
      })}`;
    }

    let preDataChainInput = '';

    if (preDataChain) {
      preDataChainInput = `${parts.length ? ',' : ''}preChain: DC.${GetCodeName(preDataChain, {
        includeNameSpace: true
      })}`;
    }

    const query = parts.join();
    return `this.props.${GetJSCodeName(method)}({${query}${dataChainInput}${preDataChainInput}});`;
  }

  if (navigationMethod) {
    return `this.props.${uiactions_GetNodeProp(navigationMethod, nodetypes_NodeProperties.NavigationAction)}();`;
  }

  if (dataChain) {
    // Buttons need to use this.state.value, so a new property for datachains should exist.
    if (internalApiConnection) {
      return `DC.${GetCodeName(dataChain, {
        includeNameSpace: true
      })}(this.state.${GetJSCodeName(internalApiConnection)});`;
    }

    return `DC.${GetCodeName(dataChain, {
      includeNameSpace: true
    })}(value);`;
  }
}
function getUpdateFunctionOption(methodId, methodInstanceCallId, addParams) {
  let addiontionalParams = "";

  if (methodId && methodInstanceCallId) {
    const linkBetweenNodes = GetLinkBetween(methodId, methodInstanceCallId, GetCurrentGraph());

    if (linkBetweenNodes) {
      const instanceUpdate = GetLinkProperty(linkBetweenNodes, LinkPropertyKeys.InstanceUpdate);

      if (instanceUpdate) {
        addiontionalParams = addParams || `, { update: true }/*getUpdateFunctionOption*/`;
      }
    }
  }

  return addiontionalParams;
}
function GetComponentDidUpdate(parent, options = {}) {
  const {
    isScreen
  } = options;
  let describedApi = "";

  if (parent) {
    describedApi = WriteDescribedStateUpdates(parent).trim();
  }

  const componentDidMount = GetComponentDidMount(parent, {
    skipOutOfBand: true,
    skipSetGetState: true
  });
  const componentDidUpdate = `componentDidUpdate(prevProps) {
        this.captureValues(prevProps);
      }
      ${!isScreen ? componentDidMount : ""}
      captureValues(prevProps){
        ${describedApi}
      }`;
  return componentDidUpdate;
}
function GetComponentDidMount(screenOption, options = {}) {
  const events = uiactions_GetNodeProp(screenOption, nodetypes_NodeProperties.ComponentDidMountEvent);
  let outOfBandCall = "";

  if (uiactions_GetNodeProp(screenOption, nodetypes_NodeProperties.InstanceType) === InstanceTypes.ModelInstance) {
    if (uiactions_GetNodeProp(screenOption, nodetypes_NodeProperties.ViewType) === viewtypes_ViewTypes.GetAll) {
      outOfBandCall = `// fetchModelInstanceChildren(this.props.value, Models.${GetCodeName(uiactions_GetNodeProp(screenOption, nodetypes_NodeProperties.Model))});`;
    } else {
      outOfBandCall = `//  fetchModelInstance(this.props.value, Models.${GetCodeName(uiactions_GetNodeProp(screenOption, nodetypes_NodeProperties.Model))});`;
    }
  }

  const methodInstances = getMethodInstancesForLifeCylcEvntType(screenOption, ComponentLifeCycleEvents.ComponentDidMount);
  const invocations = (methodInstances || []).map(methodInstanceCall => {
    let invocationDependsOnState = false;
    const temp = getMethodInvocation(methodInstanceCall, args => {
      const {
        statePropertiesThatCauseInvocation
      } = args;
      invocationDependsOnState = (statePropertiesThatCauseInvocation || []).length;
    }, {
      screenOption
    });

    if (invocationDependsOnState) {
      return false;
    }

    return temp;
  }).filter(x => x).join(nodetypes_NEW_LINE);
  const chainInvocations = (methodInstances || []).map(mi => {
    const chains = GetNodesLinkedTo(null, {
      id: mi.id,
      link: nodetypes_LinkType.CallDataChainLink
    });
    return chains.map(chain => {
      const input = GetDataChainInputArgs(chain.id);
      return `DC.${GetCodeName(chain, {
        includeNameSpace: true
      })}(${input});`;
    }).join(nodetypes_NEW_LINE);
  });
  const componentDidMount = `componentDidMount(value) {
        ${options.skipSetGetState ? "" : `this.props.setGetState();`}
        this.captureValues({});
        ${options.skipOutOfBand ? "" : outOfBandCall}
        ${invocations}
        ${chainInvocations}
{{handles}}
}
`;
  let evntHandles = [];

  if (events && events.length) {
    evntHandles = events.map(evt => {
      const methodNode = GetNodeById(evt);
      return `this.props.${GetJSCodeName(methodNode)}();`;
    }).join(nodetypes_NEW_LINE);
  } else {
    evntHandles = "";
  }

  return addNewLine(bindTemplate(componentDidMount, {
    handles: addNewLine(evntHandles, 1)
  }), 1);
}
function GetDataChainInputArgs(id) {
  const inputs = GetNodesLinkedTo(null, {
    id,
    link: nodetypes_LinkType.DataChainInputLink
  });
  let res = '';

  if (inputs && inputs.length) {
    res = [];
    inputs.forEach(input => {
      const nodeType = uiactions_GetNodeProp(input, nodetypes_NodeProperties.NODEType);

      switch (nodeType) {
        case NodeTypes.ComponentApi:
          res.push(`${GetJSCodeName(input)}: this.state.${GetJSCodeName(input)}`);
          break;

        case NodeTypes.ComponentExternalApi:
          res.push(`${GetJSCodeName(input)}: this.props.${GetJSCodeName(input)}`);
          break;
      }
    });
    res = res.join(', ');
    res = `{${res}}`;
  }

  return res;
}
function GenerateImport(node, parentNode, language) {
  node = ConvertViewTypeToComponentNode(node, language);

  switch (language) {
    case UITypes.ReactNative:
    case UITypes.ElectronIO:
      if (node) {
        if (uiactions_GetNodeProp(node, nodetypes_NodeProperties.SharedComponent)) {
          return `import ${GetCodeName(node)} from '../shared/${(GetCodeName(node) || "").toJavascriptName()}'`;
        }

        return `import ${GetCodeName(node)} from '../components/${(GetCodeName(node) || "").toJavascriptName()}'`;
      }

  }
}
function GenerateComponentImport(node, parentNode, language) {
  node = ConvertViewTypeToComponentNode(node, language);

  switch (language) {
    case UITypes.ElectronIO:
    case UITypes.ReactNative:
      if (node) {
        if (uiactions_GetNodeProp(node, nodetypes_NodeProperties.SharedComponent)) {
          return `import ${GetCodeName(node)} from '{{relative_depth}}shared/${(GetCodeName(node) || "").toJavascriptName()}'`;
        }

        return `import ${GetCodeName(node)} from './${(GetCodeName(parentNode) || "").toJavascriptName()}/${(GetCodeName(node) || "").toJavascriptName()}'`;
      }

  }
}
function GetScreens() {
  const screens = GetScreenNodes();
  return screens;
}

function GenerateElectronIORoutes(screens) {
  const template = `<Route path={routes.{{route_name}}} render={({ match, history, location }) => {
    console.log(match.params);
    let {{{screenApiParams}}} = match.params;
    {{overrides}}
    setParameters({{{screenApiParams}}});
    return <{{component}} {{screenApi}} />}} />
  }`;
  const routefile = external_fs_default.a.readFileSync("./app/templates/electronio/routes.tpl", "utf8");
  const import_ = `import {{name}} from './screens/{{jsname}}';`;
  const routes = [];
  const _screens = [];
  screens.map(screen => {
    const screenApis = getNodesByLinkType(GetCurrentGraph(), {
      id: screen.id,
      type: nodetypes_LinkType.ComponentExternalApi,
      direction: SOURCE
    });
    const screenApi = screenApis.map(v => `${GetJSCodeName(v)}={${GetJSCodeName(v)}}`).join(" ");
    const viewModel = screenApis.find(x => GetNodeTitle(x) === "viewModel");
    let overrides = "";

    if (viewModel) {
      const viewModelDataLink = getNodesByLinkType(GetCurrentGraph(), {
        id: viewModel.id,
        type: nodetypes_LinkType.DataChainLink,
        direction: SOURCE
      }).find(x => x);

      if (viewModelDataLink) {
        overrides = `viewModel = DC.${GetCodeName(viewModelDataLink, {
          includeNameSpace: true
        })}();`;
      }
    }

    const screenApiParams = screenApis.map(v => `${GetJSCodeName(v)}`).join();
    routes.push(bindTemplate(template, {
      route_name: `${GetCodeName(screen)}`,
      overrides,
      component: GetCodeName(screen),
      screenApiParams,
      screenApi
    }));

    _screens.push(bindTemplate(import_, {
      name: GetCodeName(screen),
      jsname: GetJSCodeName(screen)
    }));
  });
  const routeFile = bindTemplate(routefile, {
    routes: routes.sort((a, b) => b.length - a.length).join(nodetypes_NEW_LINE),
    route_imports: _screens.join(nodetypes_NEW_LINE)
  });
  return {
    template: routeFile,
    relative: "./src",
    relativeFilePath: `./Routes.tsx`,
    name: `Routes.tsx`
  };
}

function BindScreensToTemplate(language = UITypes.ReactNative) {
  const screens = GetScreens();
  let template = external_fs_default.a.readFileSync("./app/templates/screens/screen.tpl", "utf8");
  const moreresults = [];
  let fileEnding = ".js";

  switch (language) {
    case UITypes.ElectronIO:
      fileEnding = ".tsx";
      break;
  }

  const result = screens.map(screen => {
    const screenOptions = GetConnectedScreenOptions(screen.id);

    if (screenOptions && screenOptions.length) {
      const reactScreenOption = screenOptions.find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === language);

      if (reactScreenOption) {
        template = GenerateScreenMarkup(screen.id, language);
        const screenOptionSrc = GenerateScreenOptionSource(reactScreenOption, screen, language);

        if (screenOptionSrc) {
          moreresults.push(...screenOptionSrc.filter(x => x));
        }
      }
    } else {
      return false;
    }

    return {
      template: bindTemplate(template, {
        name: GetCodeName(screen),
        title: `"${GetNodeTitle(screen)}"`
      }),
      relative: "./src/screens",
      relativeFilePath: `./${GetCodeName(screen).toJavascriptName()}${fileEnding}`,
      name: GetCodeName(screen)
    };
  }).filter(x => x);

  switch (language) {
    case UITypes.ElectronIO:
      moreresults.push(GenerateElectronIORoutes(screens));
      break;
  }

  const all_nodes = uiactions_NodesByType(GetState(), [NodeTypes.ComponentNode]);
  const sharedComponents = all_nodes.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.SharedComponent));
  const relPath = "./src/shared";
  sharedComponents.map(sharedComponent => {
    moreresults.push(...GenerateRNComponents(sharedComponent, relPath, language));
  });
  moreresults.push({
    template: bindTemplate(`{{source}}`, {
      source: uiactions_NodesByType(GetState(), [NodeTypes.Screen, NodeTypes.ScreenOption, NodeTypes.ComponentNode]).map(t => `export const ${GetCodeName(t)} = '${GetCodeName(t)}';`).unique().join(nodetypes_NEW_LINE)
    }),
    relative: "./src/actions",
    relativeFilePath: `./screenInstances.js`,
    name: ``
  });
  return [...result, ...moreresults];
}
/**
 * Links the api together.
 * @param {object} args
 */

function extractApiJsCode(args = {
  node,
  graph
}) {
  let {
    node,
    graph
  } = args;
  const {
    options,
    callback = () => {}
  } = args;
  const requiredChanges = [];

  const temp = queryParameter => {
    const param = getNodesByLinkType(graph, {
      id: queryParameter.id,
      type: nodetypes_LinkType.ComponentApiConnection,
      direction: graph_methods_TARGET
    }).filter(item => {
      const {
        screenOption,
        component
      } = options;
      return GetNodesLinkedTo(null, {
        id: item.id,
        link: nodetypes_LinkType.ComponentApiConnector
      }).find(instanceEvent => [...GetNodesLinkedTo(null, {
        id: instanceEvent.id,
        link: nodetypes_LinkType.LifeCylceMethodInstance
      }), ...GetNodesLinkedTo(null, {
        id: instanceEvent.id,
        link: nodetypes_LinkType.EventMethodInstance
      })].find(lifeCycleMethod => screenOption && existsLinkBetween(graph, {
        source: lifeCycleMethod.id,
        target: screenOption.id
      }) || component && existsLinkBetween(graph, {
        source: lifeCycleMethod.id,
        target: component.id
      })));
    }).filter(x => x).find(x_temp => x_temp);

    if (param) {
      const internalApiConnection = getNodesByLinkType(graph, {
        id: param.id,
        type: nodetypes_LinkType.ComponentApi,
        direction: SOURCE
      }).find(x => x);
      const value = getNodesByLinkType(graph, {
        id: param.id,
        type: nodetypes_LinkType.ComponentApiConnection,
        direction: SOURCE
      }).find(x_temp => uiactions_GetNodeProp(x_temp, nodetypes_NodeProperties.NODEType) === NodeTypes.DataChain);

      if (value) {
        let input_ = "this.props.state";

        if (internalApiConnection) {
          requiredChanges.push(GetJSCodeName(internalApiConnection));
          input_ = `this.state.${GetJSCodeName(internalApiConnection)}`;
        }

        return `${GetJSCodeName(queryParameter)}: DC.${GetCodeName(value, {
          includeNameSpace: true
        })}(${input_})`;
      }

      if (internalApiConnection) {
        requiredChanges.push(GetJSCodeName(internalApiConnection));
        const input_ = `this.state.${GetJSCodeName(internalApiConnection)}`;
        return `${GetJSCodeName(queryParameter)}:  ${input_}`;
      }
    }
  };

  const result = temp(node);
  callback(requiredChanges.unique());
  return result;
}
// CONCATENATED MODULE: ./app/generators/screengenerator.js

class screengenerator_ScreenGenerator {
  static Generate(options) {
    let result = GenerateScreens(options);
    return result;
  }

}
// CONCATENATED MODULE: ./app/service/navigatorservice.js






function navigatorservice_GenerateScreens(options) {
  let temps = navigatorservice_BindScreensToTemplate();
  let result = {};
  temps.map(t => {
    result[t.name] = t;
  });
  return result;
}
function GenerateNavigation(options) {
  let {
    language
  } = options;
  let temps = GenerateNavigationRoot();
  let result = {};
  temps.map(t => {
    result[t.name] = t;
  });

  if (language === UITypes.ElectronIO) {
    GenerateRoutes(language).map(t => {
      result[t.name] = t;
    });
    GenerateNavigationActions(language).map(t => {
      result[t.name] = t;
    });
  }

  return result;
}
function GenerateNavigationActions(language) {
  let options = GetScreenOptions().filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.UIType) === language);
  let navigationFunctions = options.map(op => {
    let screen = GetConnectedScreen(op.id);
    let template = `
  export function ${GetJSCodeName(screen)}(params = {}) {
    return (dispatch, getState) => {
      dispatch(push(routes.${GetCodeName(screen)}));
    }
  }
  `;
    return template;
  });
  let template = `import { push, replace, go, goBack, goForward } from 'connected-react-router';
import * as routes from '../constants/routes';
export function GoBack(params = {}) {
  return (dispatch, getState) => {
    dispatch(goBack());
  }
}
export function GoForward(params = {}) {
  return (dispatch, getState) => {
    dispatch(goForward());
  }
}
export function Go(params = {}) {
  return (dispatch, getState) => {
    dispatch(push(params.route));
  };
}
export function Replace(params = {}) {
  return (dispatch, getState) => {
    if(params.route) {
      dispatch(replace(params.route));
    }
    else {
      console.warn('missing route');
    }
  }
}
${navigationFunctions.unique().join(nodetypes_NEW_LINE)}
  `;
  return [{
    template,
    relative: "./src",
    relativeFilePath: "actions/navigationActions.js",
    name: "navigationActions.js"
  }];
}
function GenerateRoutes(language) {
  let options = GetScreens();
  let routes = {};
  options.map(op => {
    routes = { ...routes,
      [GetCodeName(op)]: ((language === UITypes.ElectronIO ? "/" : "") + uiactions_GetNodeProp(op, uiactions_NodeProperties.HttpRoute)).split("//").join("/")
    };
  });
  return [{
    template: JSON.stringify(routes, null, 4),
    relative: "./src",
    relativeFilePath: "constants/routes.json",
    name: "routes.json"
  }];
}
function GenerateNavigationRoot() {
  let template = navigatorservice_BindScreensToTemplate();
  return [{
    template,
    relative: "./src",
    relativeFilePath: `./navigationstack.js`,
    name: "navigationstack"
  }];
}
function navigatorservice_BindScreensToTemplate() {
  var screens = GetScreens();
  let template = external_fs_default.a.readFileSync("./app/templates/navigation/navigation.tpl", "utf8");
  let import_template = `import {{name}} from './screens/{{namejs}}';`;
  let import_property = `     {{name}} : { screen: {{name}} }`;
  let add_drawer = `const {{name}} = createDrawerNavigator(
        {
          Home: { screen: _{{name}} }
        },
        {
          contentComponent: _{{name}}.drawerContent,
          navigationOptions: _{{name}}.navigationOptions
        }
      );`;
  let importStatements = screens.sort((b, a) => {
    return (uiactions_GetNodeProp(a, uiactions_NodeProperties.Priority) || 0) - (uiactions_GetNodeProp(b, uiactions_NodeProperties.Priority) || 0);
  }).map(screen => {
    let screenOptions = GetConnectedScreenOptions(screen.id);
    let reactNativeOptions = screenOptions.find(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.UIType) === UITypes.ReactNative);
    let temp_template = import_template;

    if (uiactions_GetNodeProp(reactNativeOptions, uiactions_NodeProperties.EnabledMenu)) {
      temp_template = `import _{{name}} from './screens/{{namejs}}';`;
    }

    return bindTemplate(temp_template, {
      name: GetCodeName(screen),
      namejs: GetCodeName(screen).toJavascriptName()
    });
  });
  let combos = screens.map(screen => {
    let screenOptions = GetConnectedScreenOptions(screen.id);
    let reactNativeOptions = screenOptions.find(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.UIType) === UITypes.ReactNative);

    if (uiactions_GetNodeProp(reactNativeOptions, uiactions_NodeProperties.EnabledMenu)) {
      return bindTemplate(add_drawer, {
        name: GetCodeName(screen)
      });
    }

    return false;
  }).filter(x => x);
  let properties = screens.map(screen => {
    return bindTemplate(import_property, {
      name: GetCodeName(screen)
    });
  });
  return bindTemplate(template, {
    imports: importStatements.join(nodetypes_NEW_LINE),
    combos: combos.join(nodetypes_NEW_LINE),
    properties: properties.join("," + nodetypes_NEW_LINE)
  });
}
// CONCATENATED MODULE: ./app/generators/navigationgenerator.js

class navigationgenerator_NavigationGenerator {
  static Generate(options) {
    let result = GenerateNavigation(options);
    return result;
  }

}
// CONCATENATED MODULE: ./app/service/keyservice.js




function GenerateModelKeys(options) {
  let {
    state,
    key
  } = options;
  let models = GetModelNodes();
  let template = `export const {{name}} = '{{name}}';`;
  let templates = models.map(model => {
    return bindTemplate(template, {
      name: GetCodeName(model)
    });
  });
  let viewModelKeys = uiactions_NodesByType(state, NodeTypes.ComponentApi).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.DefaultComponentApiValue)).map(model => {
    return bindTemplate(template, {
      name: uiactions_GetNodeProp(model, nodetypes_NodeProperties.DefaultComponentApiValue)
    });
  }).unique();
  let stateKeys = uiactions_NodesByType(state, NodeTypes.StateKey);
  let stateKeyTemplates = stateKeys.map(model => {
    return bindTemplate(template, {
      name: GetCodeName(model)
    });
  }).unique();
  return [{
    template: templates.join(nodetypes_NEW_LINE),
    relative: './src',
    relativeFilePath: `./model_keys.js`,
    name: 'model_keys'
  }, {
    template: stateKeyTemplates.join(nodetypes_NEW_LINE),
    relative: './src',
    relativeFilePath: `./state_keys.js`,
    name: 'state_keys'
  }, {
    template: viewModelKeys.join(nodetypes_NEW_LINE),
    relative: './src',
    relativeFilePath: `./viewmodel_keys.js`,
    name: 'viewmodel_keys'
  }, {
    template: bindTemplate(`{
        "appName": "{{appName}}"
    }`, {
      appName: GetRootGraph(state)[GraphKeys.PROJECTNAME]
    }),
    relative: './',
    relativeFilePath: `./app.json`,
    name: 'app_json'
  }];
}
// CONCATENATED MODULE: ./app/service/uiservice.js






function GenerateUi(options) {
  let {
    state,
    key
  } = options;
  let defaultColors = {
    color1: '#3F51B5',
    color2info: '#3F57D3',
    color3success: '#5cb85c',
    color4: '#d9534f',
    color5warning: '#f0ad4e'
  };
  let alterNate = {
    color1: '#494947',
    color2info: '#35FF69',
    color3success: '#44CCFF',
    color4: '#7494EA',
    color5warning: '#D138BF'
  };
  let colors = GetRootGraph(state)[GraphKeys.COLORSCHEME] || 'e5e1ee-dffdff-90bede-68edc6-90f3ff';
  Object.keys(alterNate).map((t, _i) => {
    alterNate[t] = '#' + colors.split('-')[_i];
  });
  let template = external_fs_default.a.readFileSync('./app/templates/themes/react_variables.tpl', 'utf8');
  let templates = [bindTemplate(template, { ...defaultColors,
    ...alterNate
  })];
  return [{
    template: templates.join(nodetypes_NEW_LINE),
    relative: './native-base-theme/variables',
    relativeFilePath: `./variables.js`,
    name: 'native_base_theme_variables'
  }];
}
// CONCATENATED MODULE: ./app/generators/keygenerator.js


class keygenerator_KeyGenerator {
  static Generate(options) {
    let temp = GenerateModelKeys(options);
    let temp2 = GenerateUi(options);
    let result = {};
    temp.map(t => {
      result[t.name] = t;
    });
    temp2.map(t => {
      result[t.name] = t;
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/configurationgenerator.js





class configurationgenerator_ConfigurationGenerator {
  static Generate(options) {
    let temp = GetConfigurationNodes(options);
    let res = {};
    temp.map(node => {
      res.https = res.https || (uiactions_GetNodeProp(node, uiactions_NodeProperties.UseHttps) ? 'https' : 'http');
      Object.keys(ConfigurationProperties).map(key => {
        res[key] = res[key] || uiactions_GetNodeProp(node, key);
      });
    });
    let template = external_fs_default.a.readFileSync('./app/templates/components/configuration.tpl', 'utf8');
    template = bindTemplate(template, res);
    let temps = [{
      template,
      relative: './src',
      relativeFilePath: `./configuration.js`,
      name: 'configuration'
    }];
    let result = {};
    temps.map(t => {
      result[t.name] = t;
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/controlleractionsgenerator.js








class controlleractionsgenerator_ControllerActionGenerator {
  static GenerateService(options) {
    const {
      state,
      language
    } = options;
    let fileEnd = ".js";

    switch (language) {
      case UITypes.ElectronIO:
        fileEnd = ".ts";
        break;
    }

    let temp = uiactions_NodesByType(state, uiactions_NodeTypes.Method);
    const serviceTemplate = external_fs_default.a.readFileSync("./app/templates/screens/service.tpl", "utf8");
    const methodTemplate = `
{{methodName}}: async (params) => {
    let { template, query } = params;
    {{template_params_def}}
    return redservice().{{methodType}}(\`\${endpoints.{{methodName}}}{{template_params}}\`);
}`;
    const postMethodTemplate = `
{{methodName}}: async (params) => {
    let { body, template, query } = params;
    {{template_params_def}}
    return redservice().{{methodType}}(\`\${endpoints.{{methodName}}}{{template_params}}\`, body, {{options}});
}`;
    const endpoints = {};
    const fetchServices = uiactions_NodesByType(state, uiactions_NodeTypes.FetchService);
    let fetchServiceMethodImplementation = false;

    if (fetchServices.length) {
      const fetchService = fetchServices[0];
      endpoints[GetJSCodeName(fetchService)] = `api/fetchservice/${uiactions_GetNodeProp(fetchService, uiactions_NodeProperties.HttpRoute)}`;
      fetchServiceMethodImplementation = bindTemplate(postMethodTemplate, {
        methodName: GetJSCodeName(fetchService),
        template_params: "",
        template_params_def: "",
        methodType: `post`,
        options: `{}`
      });
    }

    temp = [fetchServiceMethodImplementation, ...temp.map(method => {
      let template_params = "";
      let template_params_def = "";
      const maestroNode = GetMaestroNode(method.id);

      if (maestroNode) {
        const controllerNode = GetControllerNode(maestroNode.id);

        if (controllerNode) {
          if (uiactions_GetNodeProp(method, uiactions_NodeProperties.NoApiPrefix)) {
            endpoints[GetJSCodeName(method)] = `${uiactions_GetNodeProp(method, uiactions_NodeProperties.HttpRoute)}`;
          } else {
            endpoints[GetJSCodeName(method)] = `api/${GetJSCodeName(controllerNode).toLowerCase()}/${uiactions_GetNodeProp(method, uiactions_NodeProperties.HttpRoute)}`;
          }

          const methodType = uiactions_GetNodeProp(method, uiactions_NodeProperties.HttpMethod);
          const functionType = uiactions_GetNodeProp(method, uiactions_NodeProperties.FunctionType);
          let asForm = "";
          let collectCookies = "";
          let asText = "";

          if (uiactions_GetNodeProp(method, uiactions_NodeProperties.AsForm)) {
            if (uiactions_GetNodeProp(method, uiactions_NodeProperties.CollectCookies)) {
              collectCookies = " collectCookies: true";
            }

            asForm = ` asForm: true`;
          }

          if (uiactions_GetNodeProp(method, uiactions_NodeProperties.AsText)) {
            asText = ` asText: true`;
          }

          const options = [asForm, collectCookies, asText].filter(x => x).join();

          if (functionType && MethodFunctions[functionType] && MethodFunctions[functionType].parameters && MethodFunctions[functionType].parameters.parameters && MethodFunctions[functionType].parameters.parameters.template) {
            const {
              modelId,
              parentId
            } = MethodFunctions[functionType].parameters.parameters.template;

            if (modelId) {
              template_params = "/${modelId}";
            } else if (parentId) {
              template_params = "/${parentId}";
            }
          }

          if (template_params) {
            template_params_def = "let { parentId, modelId } = (template || {});";
          }

          return bindTemplate(methodType === HTTP_METHODS.POST ? postMethodTemplate : methodTemplate, {
            methodName: GetJSCodeName(method),
            template_params,
            template_params_def,
            methodType: `${methodType}`.toLowerCase().split("http").join(""),
            options: `{${options} }`
          });
        }
      }
    })].filter(x => x).join("," + nodetypes_NEW_LINE);
    return {
      template: bindTemplate(serviceTemplate, {
        service_methods: addNewLine(temp, 1),
        endpoints: JSON.stringify(endpoints, null, 4)
      }),
      relative: "./src/util",
      relativeFilePath: `./controllerService${fileEnd}`,
      name: "controllerService"
    };
  }

  static GenerateFetchService(options) {
    const {
      state,
      language
    } = options;
    let fileEnd = ".js";

    switch (language) {
      case UITypes.ElectronIO:
        fileEnd = ".ts";
        break;
    }

    const fetchServices = uiactions_NodesByType(state, uiactions_NodeTypes.FetchService);

    if (fetchServices.length) {
      const fetchService = fetchServices[0];
      const datachain = GetNodesLinkedTo(GetCurrentGraph(), {
        id: fetchService.id,
        link: nodetypes_LinkType.DataChainLink
      })[0];
      const service = `
import { setFetchServiceFunction } from '../actions/redutils';
import { GetState, GetDispatch } from '../actions/uiActions';
import { ${GetCodeName(datachain)} } from '../actions/data-chain';
import * as Util from "../actions/util";
import service from './controllerService';
export const FETCH_CALL = 'FETCH_CALL';

setFetchServiceFunction(function(body) {
  return Promise.resolve().then(() => {
      let dispatch = GetDispatch();
      let getState = GetState();
      return  (Util.simple(
        service.${GetJSCodeName(fetchService)},
        { body },
        {
          loading: FETCH_CALL
        },
        result => {
          let dataChain = ${GetCodeName(datachain)};
          if (dataChain) {
            return dataChain(result);
          } else {
            console.low("missing data chain");
          }
        }
      ))(dispatch, getState);
  });
});
      `;
      return {
        template: service,
        relative: "./src/util",
        relativeFilePath: `./fetchService${fileEnd}`,
        name: "fetchService"
      };
    }
  }

  static Generate(options) {
    const {
      state,
      language
    } = options;
    let fileEnd = ".js";

    switch (language) {
      case UITypes.ElectronIO:
        fileEnd = ".ts";
        break;
    }

    const temp = uiactions_NodesByType(state, uiactions_NodeTypes.Method);
    const ControllerMethodTemplate = `export function {{methodName}}({{arguments}}){
    {{method_call}}
}
        `;
    const controllerActionTemplate = `import * as Models from '../model_keys';
import * as StateKeys from '../state_keys';
import * as ModelKeys from '../model_keys';
import service from '../util/controllerService';
import * as Util from './util';
{{body}}
        `;
    const controllerActions = temp.map(node => {
      const method_call = `return (dispatch, getState) => Util.simple(service.${GetJSCodeName(node)}, { ...parameters }, {
    loading: Models.${GetCodeName(GetMethodNodeProp(node, FunctionTemplateKeys.ModelOutput)) || Unknown},
    objectType: Models.${GetCodeName(GetMethodNodeProp(node, FunctionTemplateKeys.ModelOutput)) || Unknown}
}, (result) => {
    var { dataChain } = (parameters || {});
    if (dataChain) {
        return dataChain(result);
    }
    else {
        console.low('missing data chain');
    }
}, null, (result) => {
  var { preChain } = (parameters || {});
  if (preChain) {
      return preChain();
  }
})(dispatch, getState);`;
      return bindTemplate(ControllerMethodTemplate, {
        methodName: GetJSCodeName(node),
        method_call: addNewLine(method_call, 1),
        arguments: "parameters"
      });
    }).join(nodetypes_NEW_LINE);
    const temps = [{
      template: bindTemplate(controllerActionTemplate, {
        body: addNewLine(controllerActions, 1)
      }),
      relative: "./src/actions",
      relativeFilePath: `./controllerActions${fileEnd}`,
      name: "controllerActions"
    }, controlleractionsgenerator_ControllerActionGenerator.GenerateService(options), controlleractionsgenerator_ControllerActionGenerator.GenerateFetchService(options)].filter(x => x);
    const result = {};
    temps.map(t => {
      result[t.name] = t;
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/datachaingenerator.js


/* eslint-disable import/no-duplicates */







class datachaingenerator_DataChainGenerator {
  static GenerateCS(options) {
    const {
      state,
      language
    } = options;
    const result = {};
    const graphRoot = GetRootGraph(state);
    const namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    GenerateChainFunctions({
      cs: true,
      language
    }).forEach(f => {
      const dataChain = f.node;
      result[uiactions_GetNodeProp(dataChain, nodetypes_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(dataChain, nodetypes_NodeProperties.CodeName),
        name: uiactions_GetNodeProp(dataChain, nodetypes_NodeProperties.CodeName),
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: f.class,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, `${namespace}${nodetypes_NameSpace.Interface}`, `${namespace}${nodetypes_NameSpace.StreamProcess}`, `${namespace}${nodetypes_NameSpace.Constants}`, `${namespace}${nodetypes_NameSpace.Permissions}`, `${namespace}${nodetypes_NameSpace.Parameters}`],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

  static Generate(options) {
    const {
      state,
      language
    } = options;
    let fileEnding = ".js";

    switch (language) {
      case UITypes.ElectronIO:
        fileEnding = ".ts";
        break;

      default:
        break;
    }

    const graph = GetCurrentGraph(state);
    const funcs = GenerateChainFunctions(options);
    const collections = GetDataChainCollections(options);
    let tests = null;
    const collectionNodes = uiactions_NodesByType(null, NodeTypes.DataChainCollection);
    const temps = [...collectionNodes.map(nc => {
      const isInLanguage = datachaingenerator_CollectionIsInLanguage(graph, nc.id, language);
      const cfunc = isInLanguage ? GenerateChainFunctions({
        language,
        collection: nc.id
      }) : null;
      const collectionsInLanguage = isInLanguage ? GetDataChainCollections({
        language,
        collection: nc.id
      }) : null;

      if (!isInLanguage) {
        return false;
      }

      const chainPath = GetRelativeDataChainPath(nc);
      return {
        template: dcTemplate(collectionsInLanguage, cfunc, [].interpolate(0, chainPath.length + 1).map(() => "../").join("")),
        relative: `./src/actions/datachains/${chainPath.join("/")}${chainPath.length ? "/" : ""}`,
        relativeFilePath: `./${GetJSCodeName(nc)}${fileEnding}`,
        name: `${chainPath.join("_")}${GetJSCodeName(nc)}`
      };
    }), {
      template: dcTemplate(collections, funcs),
      relative: "./src/actions",
      relativeFilePath: `./data-chain${fileEnding}`,
      name: "data-chain"
    }, {
      template: Object(external_fs_["readFileSync"])("./app/utils/observable.js", "utf8"),
      relative: "./src/actions",
      relativeFilePath: `./observable${fileEnding}`,
      name: "observable"
    }, {
      template: Object(external_fs_["readFileSync"])("./app/utils/array.js", "utf8"),
      relative: "./src/actions",
      relativeFilePath: `./array${fileEnding}`,
      name: "array"
    }, {
      template: Object(external_fs_["readFileSync"])("./app/utils/redgraph.js", "utf8"),
      relative: "./src/actions",
      relativeFilePath: `./redgraph${fileEnding}`,
      name: "redgraph.js"
    }, // Specific for web sites
    // Need an alternative for ReactNative
    {
      template: Object(external_fs_["readFileSync"])("./app/utils/redutils.js", "utf8"),
      relative: "./src/actions",
      relativeFilePath: `./redutils${fileEnding}`,
      name: "redutils.js"
    }].filter(x => x);

    switch (language) {
      case UITypes.ElectronIO:
        tests = GenerateChainFunctionSpecs(options);
        temps.push({
          relative: "./test",
          relativeFilePath: "./data-chain.spec.js",
          name: "data-chain.spec.js",
          template: bindTemplate(Object(external_fs_["readFileSync"])("./app/templates/electronio/spec.tpl", "utf8"), {
            tests: tests.join(nodetypes_NEW_LINE)
          })
        });
        break;

      default:
        break;
    }

    const result = {};
    temps.map(t => {
      result[t.name] = t;
    });
    return result;
  }

}

let dcTemplate = (collections, funcs, rel = "") => {
  if (!funcs || !funcs.trim()) {
    return `${collections}`;
  }

  return `import {
    GetC,
    updateScreenInstanceObject,
    GetItem,
    Chain,
    UIModels, GetDispatch,
    GetState, UIC,
    GetItems,UI_MODELS,
    GetK, updateScreenInstance,
    clearScreenInstance

  } from '../${rel}actions/uiActions';
import {
    validateEmail,
    maxLength,
    minLength,
    greaterThanOrEqualTo,
    lessThanOrEqualTo,
    arrayLength,
    numericalDefault,
    equalsLength,
    alphanumericLike,
    alphanumeric,
    alpha,
    MinLengthAttribute,
    MaxLengthAttribute,
    AlphaOnlyAttribute,
    AlphaNumericLikeAttribute,
    AlphaOnlyWithSpacesAttribute,
    IsNullAttribute,
    IsNotNullAttribute,
    MaxAttribute,
    MinAttribute,
    EmailAttribute,
    EmailEmptyAttribute,
    ZipAttribute,
    ZipEmptyAttribute
} from './${rel}validation';

import * as navigate from '../${rel}actions/navigationActions';
import * as $service from '../${rel}util/service';
import routes from '../${rel}constants/routes';
import { titleService} from '../${rel}actions/util';
import * as RedLists from '../${rel}actions/lists';
import * as StateKeys from '../${rel}state_keys';
import * as ModelKeys from '../${rel}model_keys';
import * as ViewModelKeys from '../${rel}viewmodel_keys';
import * as Models from '../${rel}model_keys';
import RedObservable from '../${rel}actions/observable';
import RedGraph from '../${rel}actions/redgraph';
import { useParameters, fetchModel } from '../${rel}actions/redutils';

${collections}

${funcs}`;
};

function datachaingenerator_CollectionIsInLanguage(graph, collection, language) {
  const itsUiType = uiactions_GetNodeProp(collection, nodetypes_NodeProperties.UIType);

  if (itsUiType && itsUiType === language) {
    return true;
  }

  if (itsUiType) {
    return false;
  }

  const reference = GetNodeLinkedTo(graph, {
    id: collection,
    link: nodetypes_LinkType.DataChainCollectionReference
  });

  if (reference) {
    if (uiactions_GetNodeProp(reference, nodetypes_NodeProperties.NODEType) === NodeTypes.Screen) {
      return true;
    }

    if (uiactions_GetNodeProp(reference, nodetypes_NodeProperties.UIType) === language) {
      return true;
    }

    if (uiactions_GetNodeProp(reference, nodetypes_NodeProperties.UIType)) {
      return false;
    }

    const parent = GetNodesLinkedTo(graph, {
      id: collection,
      link: nodetypes_LinkType.DataChainCollection,
      direction: graph_methods_TARGET
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.DataChainCollection)[0];

    if (parent) {
      return datachaingenerator_CollectionIsInLanguage(graph, parent.id, language);
    }
  } else {
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./app/generators/selectorgenerator.js




class selectorgenerator_SelectorGenerator {
  static Generate(options) {
    let funcs = GenerateSelectorFunctions();
    let temps = [{
      template: `import * as UIA from './uiActions';
${funcs.join(nodetypes_NEW_LINE)}`,
      relative: "./src/actions",
      relativeFilePath: `./selector.js`,
      name: "selector"
    }];
    let result = {};
    temps.map(t => {
      result[t.name] = t;
    });
    return result;
  }

}
function GenerateSelectorFunctions() {
  let nodes = uiactions_NodesByType(GetState(), NodeTypes.Selector);
  return nodes.map(node => {
    return GenerateSelectorFunction(node);
  }).unique();
}
function GenerateSelectorFunction(node) {
  let result = null;
  let selectType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.SelectorType);

  switch (selectType) {
    case nodetypes_SelectorType.InternalProperties:
      return `export function ${GetJSCodeName(node)}(state) {
        let { value = null, viewModel = null, selected = null } = state;
        return {
          value,
          viewModel,
          selected
        }
      }`;

    default:
      break;
  }

  result = `
export function ${GetJSCodeName(node)}(value, viewModel = '${uiactions_GetNodeProp(node, nodetypes_NodeProperties.DefaultViewModel) || GetCodeName(node) || ""}', options = {}) {
    if(options){
      if(options.update){
        return  {
          dirty:UIA.GetScreenModelDirtyInstance(value, viewModel),
          focus:UIA.GetScreenModelFocusInstance(value, viewModel),
          blur: UIA.GetScreenModelBlurInstance(value, viewModel),
          focused:UIA.GetScreenModelFocusedInstance(value, viewModel),
          object:UIA.GetScreenModelInstance(value, viewModel)
        }
      }
    }
    return {
        dirty: value
            ? UIA.GetModelInstanceDirtyObject(value, viewModel)
            : UIA.GetScreenInstanceDirtyObject(viewModel),
        focus: value
            ? UIA.GetModelInstanceFocusObject(value, viewModel)
            : UIA.GetScreenInstanceFocusObject(viewModel),
        blur: value
            ? UIA.GetModelInstanceBlurObject(value, viewModel)
            : UIA.GetScreenInstanceBlurObject(viewModel),
        focused: value
            ? UIA.GetModelInstanceFocusedObject(value, viewModel)
            : UIA.GetScreenInstanceFocusedObject(viewModel),
        object: value
            ? UIA.GetModelInstanceObject(value, viewModel)
            : UIA.GetScreenInstanceObject(viewModel)
    }
}
`;
  return result;
}
// CONCATENATED MODULE: ./app/generators/listsgenerator.js





class listsgenerator_ListsGenerator {
  static Generate(options) {
    let {
      state
    } = options;
    let lists = uiactions_NodesByType(state, NodeTypes.Lists);
    let graph = GetCurrentGraph(state);
    let template = lists.map(list => {
      let connected = GetNodesLinkedTo(graph, {
        id: list.id
      }).map(v => {
        return GetCodeName(v);
      });
      return `export const ${GetCodeName(list)} = ${JSON.stringify(connected)};`;
    }).join(nodetypes_NEW_LINE);
    let temps = [{
      template: template,
      relative: "./src/actions",
      relativeFilePath: `./lists.js`,
      name: "lists"
    }];
    let result = {};
    temps.map(t => {
      result[t.name] = t;
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/validatorgenerator.js

class validatorgenerator_ValidatorGenerator {
  static Generate(options) {
    let result = GenerateAgentValidationInterfacesAndImplementations();
    return result;
  }

}
// CONCATENATED MODULE: ./app/generators/fetchservicegenerator.js






const CONTROLLER_CLASS_FETCH_FUNCTION = "./app/templates/controller/fetch_service_function.tpl";
const CONTROLLER_CLASS_FETCH_FUNCTION_Get_PROPERTY = "./app/templates/controller/fetch_service_set_property.tpl";
const fetchservicegenerator_CONTROLLER_CLASS_TEMPLATE = "./app/templates/controller/controller.tpl";
const fetchservicegenerator_PROPERTY_TABS = 6;
class fetchservicegenerator_FetchServiceGenerator {
  static Tabs(c) {
    let res = "";

    for (var i = 0; i < c; i++) {
      res += fetchservicegenerator_TAB;
    }

    return res;
  }

  static Generate(options) {
    var {
      state,
      key
    } = options;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let result = {};
    let controllers = uiactions_NodesByType(state, uiactions_NodeTypes.FetchService);
    controllers.map(controller => {
      let controllerUser = "controllerUser";
      let controllerTemplateClass = external_fs_default.a.readFileSync(fetchservicegenerator_CONTROLLER_CLASS_TEMPLATE, "utf-8");
      let fetchServiceFunction = external_fs_default.a.readFileSync(CONTROLLER_CLASS_FETCH_FUNCTION, "utf-8");
      let fetchServiceFunctionGetProperty = external_fs_default.a.readFileSync(CONTROLLER_CLASS_FETCH_FUNCTION_Get_PROPERTY, "utf-8");
      let userNode = uiactions_NodesByType(state, uiactions_NodeTypes.Model).find(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsUser));
      let outputType = GetNodesLinkedTo(GetCurrentGraph(), {
        id: controller.id,
        link: nodetypes_LinkType.FetchServiceOuput
      })[0];
      let methods = GetNodesLinkedTo(GetCurrentGraph(), {
        id: controller.id,
        link: nodetypes_LinkType.FetchService
      }).filter(x => {
        let methodType = uiactions_GetNodeProp(x, uiactions_NodeProperties.FunctionType);
        let functionType = MethodFunctions[methodType];
        return functionType.isFetchCompatible;
      });
      let functions = "";
      let set_outputs = "";
      let controllers = [];
      set_outputs = methods.map(method => {
        let methodProperties = uiactions_GetNodeProp(method, uiactions_NodeProperties.MethodProps);
        let modelNode = GetNodeById(methodProperties.model_output) || GetNodeById(methodProperties.model);
        let maestro = GetMaestroNode(method.id);
        let controller = GetControllerNode(maestro.id);
        let output_type = GetCodeName(modelNode);
        controllers.push(controller.id);
        return bindTemplate(fetchServiceFunctionGetProperty, {
          model_output: output_type,
          functionName: GetCodeName(method),
          controller: GetCodeName(controller),
          controller_user: controllerUser
        });
      }).join(nodetypes_NEW_LINE);
      controllers = controllers.unique().map(v => {
        return bindTemplate(`var {{controller#lower}} = new {{controller}}();
            {{controller#lower}}.${uiactions_GetNodeProp(v, uiactions_NodeProperties.CodeUser)} = ${controllerUser};
            `, {
          controller: GetCodeName(v)
        });
      }).join(nodetypes_NEW_LINE);
      let httpMethod = `${uiactions_GetNodeProp(controller, uiactions_NodeProperties.HttpMethod)}`;
      let httpRoute = `${uiactions_GetNodeProp(controller, uiactions_NodeProperties.HttpRoute)}`;
      let codeName = `${uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName)}`;
      functions = bindTemplate(fetchServiceFunction, {
        output_type: GetCodeName(outputType),
        functionName: "FetchItems",
        http_route: httpRoute || "{controller_generator_http_method}",
        http_method: "HttpPost",
        set_outputs,
        controllers
      });
      controllerTemplateClass = bindTemplate(controllerTemplateClass, {
        codeName: codeName,
        "codeName#alllower": codeName.toLowerCase(),
        user_instance: controllerUser,
        user: userNode ? uiactions_GetNodeProp(userNode, uiactions_NodeProperties.CodeName) : "{controller_generator_code_name}",
        functions
      });
      result[uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName)] = {
        id: uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName),
        name: uiactions_GetNodeProp(controller, uiactions_NodeProperties.CodeName),
        template: namespacegenerator_NamespaceGenerator.Generate({
          template: controllerTemplateClass,
          usings: [...STANDARD_CONTROLLER_USING, `${namespace}${nodetypes_NameSpace.Model}`, "Microsoft.AspNetCore.Mvc"],
          namespace,
          space: nodetypes_NameSpace.Controllers
        })
      };
    });
    return result;
  }

}
const fetchservicegenerator_NL = `
                    `;
const fetchservicegenerator_jNL = `
`;
const fetchservicegenerator_TAB = `   `;
// CONCATENATED MODULE: ./app/generators/titleServiceLibraryGenerator.js



class titleServiceLibraryGenerator_TitleServiceLibraryGenerator {
  static Generate(options) {
    const {
      language
    } = options;
    const graph = GetCurrentGraph();
    let fileEnding;

    switch (language) {
      case UITypes.ElectronIO:
        fileEnding = '.ts';
        break;

      default:
        fileEnding = '.js';
        break;
    }

    const {
      languageTitles = {
        titles: {}
      }
    } = graph;
    const titleJson = {};

    if (languageTitles && languageTitles.titles) {
      Object.keys(languageTitles.titles).map(v => {
        const temp = languageTitles.titles[v];
        const {
          title = uiactions_GetNodeProp(temp.id, uiactions_NodeProperties.Label),
          id = temp.id,
          properties = {}
        } = temp;

        if (title && title.trim()) {
          titleJson[title.trim()] = {
            id,
            properties
          };
        }
      });
    }

    const template = `export default ${JSON.stringify({
      lib: titleJson,
      preferred: nodetypes_Languages["US-English"]
    }, null, 4)}`;
    return {
      './actions/titleServiceLib.js': {
        template,
        relative: "./app/actions",
        relativeFilePath: `./titleServiceLib${fileEnding}`,
        name: "./actions/titleServiceLib.js"
      }
    };
  }

}
// CONCATENATED MODULE: ./app/generators/generator.js


/* eslint-disable no-case-declarations */





























class generator_Generator {
  static generate(options) {
    const {
      state,
      type,
      key,
      language
    } = options;

    switch (type) {
      case NodeTypes.Controller:
        return controllergenerator_ControllerGenerator.Generate({
          state,
          key,
          language
        });

      case NodeTypes.FetchService:
        return fetchservicegenerator_FetchServiceGenerator.Generate({
          state,
          key,
          language
        });

      case NodeTypes.Model:
        return modelgenerators_ModelGenerator.Generate({
          state,
          key,
          language
        });

      case NodeTypes.ExtensionType:
        return extensiongenerator_ExtensionGenerator.Generate({
          state,
          key,
          language
        });

      case NodeTypes.Maestro:
        return maestrogenerator_MaestroGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.ChangeParameter:
        return changeparametergenerator_ChangeParameterGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.ChangeResponse:
        return changeresponsegenerator_ChangeResponseGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.Constants:
        // Add enumerations here.
        const models = uiactions_NodesByType(state, NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExcludeFromGeneration)).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExcludeFromController));
        const functions = uiactions_NodesByType(state, [NodeTypes.Function, NodeTypes.Method]);
        const enumerations = uiactions_NodesByType(state, NodeTypes.Enumeration).map(node => {
          const enums = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Enumeration);
          const larg = {};
          enums.forEach(t => {
            larg[MakeConstant(t.value || t)] = t.value;
          });
          return {
            name: uiactions_GetNodeProp(node, nodetypes_NodeProperties.CodeName),
            model: larg
          };
        });
        const streamTypes = {};
        models.forEach(t => {
          streamTypes[uiactions_GetNodeProp(t, nodetypes_NodeProperties.CodeName).toUpperCase()] = uiactions_GetNodeProp(t, nodetypes_NodeProperties.CodeName).toUpperCase();
        });
        const functionsTypes = {};
        functions.forEach(t => {
          functionsTypes[uiactions_GetNodeProp(t, nodetypes_NodeProperties.CodeName)] = uiactions_GetNodeProp(t, nodetypes_NodeProperties.CodeName).toUpperCase();
        });
        return constantsgenerator_ConstantsGenerator.Generate({
          values: [{
            name: nodetypes_GeneratedConstants.Methods,
            model: nodetypes_Methods
          }, {
            name: nodetypes_GeneratedConstants.StreamTypes,
            model: streamTypes
          }, {
            name: nodetypes_GeneratedConstants.FunctionName,
            model: functionsTypes
          }, ...enumerations],
          state,
          key
        });

      case GeneratedTypes.Permissions:
        return permission_conditiongenerator_PermissionGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.Validators:
        return validatorgenerator_ValidatorGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.StreamProcess:
        return streamprocessgenerator_StreamProcessGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.StreamProcessOrchestration:
        return streamprocessorchestrationgenerator_StreamProcessOrchestrationGenerator.Generate({
          state,
          key,
          language
        });
      // case GeneratedTypes.ValidationRule:
      //     return ValidationRuleGenerator.Generate({ state, key, language });

      case GeneratedTypes.Executors:
        return executiongenerator_ExecutorGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.ModelGet:
        return modelgetgenerators_ModelGetGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.ModelReturn:
        return modelreturngenerator_ModelReturnGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.ModelExceptions:
        return modelexceptiongenerator_ModelReturnGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.ModelItemFilter:
        return modelitemfiltergenerator_ModelItemFilterGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.CustomService:
        return customservicegenerator_CustomServiceGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.Screens:
        return screengenerator_ScreenGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.Navigation:
        return navigationgenerator_NavigationGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.Keys:
        return keygenerator_KeyGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.Configuration:
        return configurationgenerator_ConfigurationGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.ControllerActions:
        return controlleractionsgenerator_ControllerActionGenerator.Generate({
          state,
          key,
          language
        });

      case GeneratedTypes.CSDataChain:
        return datachaingenerator_DataChainGenerator.GenerateCS({
          state,
          key,
          language
        });

      case ReactNativeTypes.DataChainFunctions:
        return datachaingenerator_DataChainGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.Selectors:
        return selectorgenerator_SelectorGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.Lists:
        return listsgenerator_ListsGenerator.Generate({
          state,
          key,
          language
        });

      case ReactNativeTypes.TitleService:
        return titleServiceLibraryGenerator_TitleServiceLibraryGenerator.Generate({
          state,
          key,
          language
        });

      default:
        console.log('unhandled generator case');
        break;
    }
  }

}
// CONCATENATED MODULE: ./app/ipc/handler-events.js
const HandlerEvents = {
  scaffold: {
    message: 'scaffold-project',
    reply: 'scaffold-project-reply'
  },
  reactnative: {
    message: 'react-project',
    reply: 'react-project-reply'
  },
  electron: {
    message: 'electron-project',
    reply: 'electron-project-reply'
  }
};
// CONCATENATED MODULE: ./app/actions/remoteActions.js


/* eslint-disable no-param-reassign */

/* eslint-disable prefer-destructuring */



const BUILDER_BACK_UP = ".builder";

const path = __webpack_require__("path");

const remoteActions_fs = __webpack_require__("fs");

const {
  ipcRenderer
} = __webpack_require__("electron");

const remote = __webpack_require__("electron").remote;

const dialog = remote.dialog;
function openGraph() {
  openRedQuickBuilderGraph()(remoteActions_dispatch, remoteActions_getState);
}
function toggleContextMenu(mode) {
  if (mode) {
    setVisual(CONTEXT_MENU_MODE, mode)(remoteActions_dispatch, remoteActions_getState);
    setVisual(CONTEXT_MENU_VISIBLE, true)(remoteActions_dispatch, remoteActions_getState);
  } else {
    toggleVisual(CONTEXT_MENU_VISIBLE)(remoteActions_dispatch, remoteActions_getState);
  }
}
function toggleVisualKey(key) {
  toggleVisual(key)(remoteActions_dispatch, remoteActions_getState);
}
const remoteActions_SELECTED_TAB = "SELECTED_TAB";
const remoteActions_DEFAULT_TAB = "DEFAULT_TAB";
const remoteActions_PARAMETER_TAB = "PARAMETER_TAB";
const remoteActions_SCOPE_TAB = "SCOPE_TAB";
const remoteActions_QUICK_MENU = "QUICK_MENU";
function setRightMenuTab(num) {
  switch (num) {
    case "1":
      setVisual(remoteActions_SELECTED_TAB, remoteActions_DEFAULT_TAB)(remoteActions_dispatch, remoteActions_getState);
      break;

    case "2":
      setVisual(remoteActions_SELECTED_TAB, remoteActions_PARAMETER_TAB)(remoteActions_dispatch, remoteActions_getState);
      break;

    case "3":
      setVisual(remoteActions_SELECTED_TAB, remoteActions_SCOPE_TAB)(remoteActions_dispatch, remoteActions_getState);
      break;

    case "4":
      setVisual(remoteActions_SELECTED_TAB, remoteActions_QUICK_MENU)(remoteActions_dispatch, remoteActions_getState);
      break;
  }
}
function openRedQuickBuilderGraph() {
  return (dispatch, getState) => {
    dialog.showOpenDialog(remote.getCurrentWindow(), {
      filters: [{
        name: "Red Quick Builder",
        extensions: [RED_QUICK_FILE_EXT$]
      }],
      properties: ["openFile"]
    }, fileName => {
      if (fileName === undefined) {
        console.log("You didn't save the file");
        return;
      }

      if (fileName.length && Array.isArray(fileName)) {
        fileName = fileName[0];
      }

      if (!fileName.endsWith(RED_QUICK_FILE_EXT)) {
        fileName = `${fileName}${RED_QUICK_FILE_EXT}`;
      }

      console.log(fileName);
      remoteActions_fs.readFile(fileName, {
        encoding: "utf8"
      }, (err, res) => {
        if (err) {
          console.error(`An error ocurred updating the file${err.message}`);
          console.log(err);
          return;
        }

        try {
          let opened_graph = JSON.parse(res);

          if (opened_graph) {
            const default_graph = createGraph();
            opened_graph = { ...default_graph,
              ...opened_graph
            };
            SaveApplication(opened_graph.id, CURRENT_GRAPH, dispatch);
            SaveGraph(opened_graph, dispatch);
          }
        } catch (e) {
          console.log(e);
        }

        console.warn("The file has been succesfully saved");
      });
    });
  };
}
function openRedQuickBuilderTheme() {
  return dispatch => {
    dialog.showOpenDialog(remote.getCurrentWindow(), {
      filters: [{
        name: "Red Quick Builder",
        extensions: [RED_QUICK_FILE_THEME_EXT$]
      }],
      properties: ["openFile"]
    }, fileName => {
      if (fileName === undefined) {
        console.log("You didn't save the file");
        return;
      }

      if (fileName.length && Array.isArray(fileName)) {
        fileName = fileName[0];
      }

      if (!fileName.endsWith(RED_QUICK_FILE_THEME_EXT)) {
        fileName = `${fileName}${RED_QUICK_FILE_THEME_EXT}`;
      }

      console.log(fileName);
      remoteActions_fs.readFile(fileName, {
        encoding: "utf8"
      }, (err, res) => {
        if (err) {
          console.error(`An error ocurred updating the file${err.message}`);
          console.log(err);
          return;
        }

        try {
          const openedTheme = JSON.parse(res);

          if (openedTheme) {
            let defaultGraph = GetCurrentGraph();
            defaultGraph = { ...defaultGraph,
              ...openedTheme
            };
            SaveApplication(defaultGraph.id, CURRENT_GRAPH, dispatch);
            SaveGraph(defaultGraph, dispatch);
          }
        } catch (e) {
          console.log(e);
        }

        console.warn("The file has been succesfully saved");
      });
    });
  };
}
function newRedQuickBuilderGraph() {
  return (dispatch, getState) => {
    const default_graph = createGraph();
    const opened_graph = { ...default_graph
    };
    SaveApplication(opened_graph.id, CURRENT_GRAPH, dispatch);
    SaveGraph(opened_graph, dispatch);
  };
}
function newGraph() {
  newRedQuickBuilderGraph()(GetDispatchFunc(), GetStateFunc());
}
ipcRenderer.on("save-graph-to-file-reply", (event, arg) => {
  console.log(arg); // prints "pong"
});
const RED_QUICK_FILE_EXT = ".rqb";
const RED_QUICK_FILE_EXT$ = "rqb";
const RED_QUICK_FILE_RECORDING_EXT = ".js";
const RED_QUICK_FILE_RECORDING_EXT$ = "js";
const RED_QUICK_FILE_THEME_EXT = ".rqbt";
const RED_QUICK_FILE_THEME_EXT$ = "rqbt";
function saveGraphToFile() {
  return (dispatch, getState) => {
    const currentGraph = GetRootGraph(getState()); // You can obviously give a direct path without use the dialog (C:/Program Files/path/myfileexample.txt)

    if (currentGraph) {
      const content = JSON.stringify(currentGraph);
      dialog.showSaveDialog(remote.getCurrentWindow(), {
        filters: [{
          name: "Red Quick Builder",
          extensions: [RED_QUICK_FILE_EXT$]
        }]
      }, fileName => {
        if (fileName === undefined) {
          console.log("You didn't save the file");
          return;
        }

        if (!fileName.endsWith(RED_QUICK_FILE_EXT)) {
          fileName = `${fileName}${RED_QUICK_FILE_EXT}`;
        }

        console.log(fileName);
        updateGraphProperty(currentGraph, {
          prop: "graphFile",
          value: fileName
        });
        remoteActions_fs.writeFile(fileName, content, err => {
          if (err) {
            console.error(`An error ocurred updating the file${err.message}`);
            console.log(err);
            return;
          }

          console.warn("The file has been succesfully saved");
        });
      });
    }
  };
}
function saveRecording(recording) {
  return (dispatch, getState) => {
    dialog.showSaveDialog(remote.getCurrentWindow(), {
      filters: [{
        name: "Red Quick Builder Recording",
        extensions: [RED_QUICK_FILE_RECORDING_EXT$]
      }]
    }, fileName => {
      if (fileName === undefined) {
        console.log("You didn't save the file");
        return;
      }

      if (!fileName.endsWith(RED_QUICK_FILE_RECORDING_EXT)) {
        fileName = `${fileName}${RED_QUICK_FILE_RECORDING_EXT}`;
      }

      console.log(fileName);
      let content = JSON.stringify(recording, null, 4);
      content = processRecording(content);
      remoteActions_fs.writeFile(fileName, content, err => {
        if (err) {
          console.error(`An error ocurred updating the file${err.message}`);
          console.log(err);
          return;
        }

        console.warn("The file has been succesfully saved");
      });
    });
  };
}
function saveTheme(theme) {
  return (dispatch, getState) => {
    dialog.showSaveDialog(remote.getCurrentWindow(), {
      filters: [{
        name: "Red Quick Builder Theme",
        extensions: [RED_QUICK_FILE_THEME_EXT$]
      }]
    }, fileName => {
      if (fileName === undefined) {
        console.log("You didn't save the file");
        return;
      }

      if (!fileName.endsWith(RED_QUICK_FILE_THEME_EXT)) {
        fileName = `${fileName}${RED_QUICK_FILE_THEME_EXT}`;
      }

      console.log(fileName);
      const content = JSON.stringify(theme, null, 4);
      remoteActions_fs.writeFile(fileName, content, err => {
        if (err) {
          console.error(`An error ocurred updating the file${err.message}`);
          console.log(err);
          return;
        }

        console.warn("The file has been succesfully saved");
      });
    });
  };
}
let lastSavedDate = null;
function saveGraph(graph) {
  return (dispatch, getState) => {
    const currentGraph = GetRootGraph(getState());

    if (currentGraph && currentGraph.graphFile) {
      if (remoteActions_fs.existsSync(currentGraph.graphFile)) {
        if (lastSavedDate !== currentGraph.updated) {
          if (remoteActions_fs.existsSync(currentGraph.graphFile)) {
            const fileFolder = path.dirname(currentGraph.graphFile);
            const backupFolder = path.join(fileFolder, BUILDER_BACK_UP);

            if (!remoteActions_fs.existsSync(backupFolder)) {
              remoteActions_fs.mkdirSync(backupFolder);
            }

            const files = remoteActions_fs.readdirSync(backupFolder);
            const fileName = path.basename(currentGraph.graphFile);
            let fileNumber = 0;
            files.forEach(function (file) {
              const split = file.split(`${fileName}.`);
              let num = split[split.length - 1];

              if (!isNaN(num)) {
                num = parseInt(num, 10);

                if (num >= fileNumber) {
                  fileNumber = num + 1;
                }
              }
            });
            remoteActions_fs.copyFileSync(currentGraph.graphFile, path.join(backupFolder, `${fileName}.${fileNumber}`));
          }
        }

        remoteActions_fs.writeFileSync(currentGraph.graphFile, JSON.stringify(currentGraph));
      }

      lastSavedDate = currentGraph.updated;
    }
  };
}
let remoteActions_dispatch = null;
let remoteActions_getState = null;
function setRemoteState() {
  return (dispatch, getState) => {
    remoteActions_dispatch = dispatch;
    remoteActions_getState = getState;
  };
}
function saveCurrentGraph() {
  const state = remoteActions_getState();

  saveGraph(GetRootGraph(state))(remoteActions_dispatch, remoteActions_getState);
}
function setWorkingDirectory() {
  return (dispatch, getState) => {
    let currentGraph = GetRootGraph(getState()); // You can obviously give a direct path without use the dialog (C:/Program Files/path/myfileexample.txt)

    if (currentGraph) {
      dialog.showOpenDialog(remote.getCurrentWindow(), {
        properties: ["openDirectory"]
      }, fileName => {
        if (fileName === undefined) {
          console.log("You didn't save the file");
          return;
        }

        console.log(fileName);
        currentGraph = updateWorkSpace(currentGraph, {
          workspace: fileName[0]
        });
        SaveGraph(currentGraph, dispatch);
      });
    }
  };
}
// CONCATENATED MODULE: ./app/constants/themes.js


/* eslint-disable import/prefer-default-export */


const themes_Themes = {
  ContactFrom_v4: {
    [UITypes.ElectronIO]: {
      location: "./app/templates/themes/ContactFrom_v4/electronio/",
      theme: "./app/templates/themes/ContactFrom_v4/theme/",
      relative: "./app",
      themerelative: "./app/theme"
    }
  },
  InputMaterialWithGradient: {
    [UITypes.ElectronIO]: {
      location: './app/templates/themes/InputMaterialWithGradient/electronio/',
      theme: './app/templates/themes/InputMaterialWithGradient/theme/',
      relative: "./app",
      themerelative: "./app/theme"
    }
  },
  BlueprintMultiLevelMenu: {
    [UITypes.ElectronIO]: {
      location: './app/templates/themes/BlueprintMultiLevelMenu/electronio/',
      theme: './app/templates/themes/BlueprintMultiLevelMenu/theme/',
      relative: "./app",
      themerelative: "./app/theme"
    }
  }
};
const SectioningRoot = {
  Body: 'Body',
  Container: 'Container',
  Content: 'Content' // Text Content

};
const ContentSectioning = {
  H1: 'H1',
  H2: 'H2',
  H3: 'H3',
  H4: 'H4',
  H5: 'H5',
  H6: 'H6',
  Input: 'Input',
  P: 'P',
  Span: 'Span',
  Label: 'Label',
  Button: 'Button',
  A: 'A',
  HR: 'Hr',
  IMG: 'Img',
  DIV: 'Div',
  Address: 'Address',
  Article: 'Article',
  Aside: 'Aside',
  Footer: 'Footer',
  Header: 'Header',
  Hgroup: 'Hgroup',
  Main: 'Main',
  Nav: 'Nav',
  Section: 'Section'
};
const TextContent = {
  Blockquote: 'Blockquote',
  DD: 'DD',
  DL: 'DL',
  DT: 'DT',
  FIGCAPTION: 'FIGCAPTION',
  FIGURE: 'FIGURE',
  LI: 'LI',
  OL: 'OL',
  PRE: 'PRE',
  UL: 'UL'
};
const InlineTextSemantics = {
  Abbr: 'Abbr',
  B: 'B',
  BDI: 'BDI',
  BDO: 'BDO',
  BR: 'BR',
  CITE: 'CITE',
  CODE: 'CODE',
  DATA: 'DATA',
  DFN: 'DFN',
  EM: 'EM',
  I: 'I',
  KBD: 'KBD',
  MARK: 'MARK',
  Q: 'Q',
  RB: 'RB',
  RP: 'RP',
  RTC: 'RTC'
};
const ImageMultiMedia = {
  AREA: 'AREA',
  IMG: 'IMG',
  AUDIO: 'AUDIO',
  MAP: 'MAP',
  TRACK: 'TRACK',
  VIDEO: 'VIDEO'
};
const EmbeddedContent = {
  EMBED: 'EMBED',
  IFRAME: 'IFRAME',
  SOURCE: 'SOURCE',
  PARAM: 'PARAM',
  OBJECT: 'OBJECT',
  PICTURE: 'PICTURE'
};
const DemarcatingEdits = {
  DEL: 'DEL',
  INS: 'INS'
};
const TableContent = {
  CAPTION: 'CAPTION',
  COL: 'COL',
  COLGROUP: 'COLGROUP',
  TABLE: 'TABLE',
  TD: 'TD',
  TBODY: 'TBODY',
  TFOOT: 'TFOOT',
  TH: 'TH',
  THEAD: 'THEAD',
  TR: 'TR'
};
const InteractiveTypes = {
  Details: 'Details',
  Summary: 'Summary'
};
const SpaceThemePropertyKeys = {};
const FormThemePropertyKeys = {};
const CssPseudoSelectors = {
  [":active"]: ":active",
  ["::before"]: "::before",
  ["::after"]: "::after",
  [":checked"]: ":checked",
  [":disabled"]: ":disabled",
  [":empty"]: ":empty",
  [":hover"]: ":hover",
  [":enabled"]: ":enabled",
  [":first-child"]: ":first-child",
  [':required']: ':required',
  [":last-child"]: ":last-child",
  [":focus"]: ":focus",
  [":read-only"]: ":read-only"
};
const cssProperties = Object.keys({ ...StyleLib.css
}).map(v => {
  if (typeof v === 'object') {
    return v;
  }

  return {
    placeholder: v,
    label: v,
    key: v
  };
});
const HTMLElementGroups = [{
  name: 'Sectioning Root',
  type: SectioningRoot,
  cssProperties
}, {
  name: 'ContentSectioning',
  type: ContentSectioning,
  cssProperties
}, {
  name: 'TextContent',
  type: TextContent,
  cssProperties
}, {
  name: 'InlineTextSemantics',
  type: InlineTextSemantics,
  cssProperties
}, {
  name: 'ImageMultiMedia',
  type: ImageMultiMedia,
  cssProperties
}, {
  name: 'EmbeddedContent',
  type: EmbeddedContent,
  cssProperties
}, {
  name: 'TableContent',
  type: TableContent,
  cssProperties
}, {
  name: 'InteractiveTypes',
  type: InteractiveTypes,
  cssProperties
}, {
  name: 'DemarcatingEdits',
  type: DemarcatingEdits,
  cssProperties
}];
const MediaSize = {
  Desktop: 'Desktop',
  Tablet: 'Tablet',
  Mobile: 'Mobile'
};
const ThemeColors = {
  primary: 'primary',
  secondary: 'secondary',
  tertiary: "tertiary",
  quanternary: "quanternary",
  quinary: "quinary",
  black: 'black',
  white: 'white',
  grey: 'grey'
};
const ColorUses = {
  inputFieldPrimary: 'inputFieldPrimary',
  inputFieldSecondary: 'inputFieldSecondary',
  inputFieldGray: 'inputFieldGray',
  navItemLinkDisabledColor: 'navItemLinkDisabledColor',
  menuActiveTextColor: 'menuActiveTextColor',
  menuNavLinkBackgroundColor: "menuNavLinkBackgroundColor",
  inputFieldWhite: 'inputFieldWhite',
  navItemLinkColor: 'navItemLinkColor'
};
const themes_OtherUses = {
  inputFieldFontFamily: 'inputFieldFontFamily',
  inputFontSize: 'inputFontSize',
  menuTransition: 'menuTransition',
  menuNavLinkBoxShadowX: 'menuNavLinkBoxShadowX',
  menuNavLinkBoxShadowY: 'menuNavLinkBoxShadowY'
};
// CONCATENATED MODULE: ./app/generators/themeservicegenerator.js






function GenerateGlobalCss(options) {
  const {
    state
  } = options;
  const graph = GetCurrentGraph(state);
  let result = {};
  let theme = '';
  let fontStyleLink = '';

  if (graph) {
    const {
      themeColors = {},
      themeColorUses = {},
      themeOtherUses = {},
      themeGridPlacements = {
        grids: []
      },
      themeFonts = {
        fonts: []
      },
      spaceTheme = {},
      themeVariables = {
        variables: []
      }
    } = graph;
    let themecolors = '';

    if (themeColors) {
      Object.keys(themeColors).forEach(v => {
        themecolors += `--${v}: ${themeColors[v]};${nodetypes_NEW_LINE}`;
      });
    }

    let themevariables = '';

    if (themeVariables && themeVariables.variables) {
      themeVariables.variables.forEach(vari => {
        const {
          variable,
          variableValue
        } = vari;
        themevariables += `${variable}: ${variableValue};${nodetypes_NEW_LINE}`;
      });
    }

    let themecoloruse = '';

    if (themeColorUses) {
      Object.keys(themeColorUses).forEach(colorUse => {
        if (themeColorUses[colorUse]) themecoloruse += `--${colorUse}: var(--${themeColorUses[colorUse]});${nodetypes_NEW_LINE}`;
      });
    }

    let cssvariables = '';

    if (themeOtherUses) {
      Object.keys(themeOtherUses).forEach(otherUse => {
        if (themeOtherUses[otherUse]) {
          let temp = themeOtherUses[otherUse];

          if (temp.indexOf('--') === 0) {
            temp = `var(${temp})`;
          }

          cssvariables += `--${otherUse}: ${temp};${nodetypes_NEW_LINE}`;
        }
      });
    }

    let fontLinks = '';
    let fontCssDef = '';

    if (themeFonts) {
      themeFonts.fonts.forEach(fontInfo => {
        const {
          font,
          fontCssVar,
          fontCss,
          fontName
        } = fontInfo;
        fontLinks += ` @import url('${font}');${nodetypes_NEW_LINE}`;
        fontStyleLink += `<link href="'${font}'" rel="stylesheet">${nodetypes_NEW_LINE}`;
        fontLinks += `@font-face {
          font-family: "${fontName}";
          src: url(${font});
        }${nodetypes_NEW_LINE}`;
        fontCssDef += `${fontCssVar}: ${fontCss};${nodetypes_NEW_LINE}`;
      });
    }

    const spaceThemeRules = {};

    if (spaceTheme) {
      Object.keys(spaceTheme).forEach(space => {
        Object.keys(spaceTheme[space]).forEach(mediaSize => {
          Object.keys(spaceTheme[space][mediaSize]).filter(x => x.indexOf(':') === -1).forEach(key => {
            let val = spaceTheme[space][mediaSize][key];

            if (val) {
              if (val.indexOf('--') === 0) {
                val = `var(${val})`;
              }

              const cssRule = `${key}: ${val};${nodetypes_NEW_LINE}`;
              spaceThemeRules[mediaSize] = spaceThemeRules[mediaSize] || {};
              spaceThemeRules[mediaSize][space] = spaceThemeRules[mediaSize][space] || '';
              spaceThemeRules[mediaSize][space] += cssRule;
            }
          });
        });
      });
    }

    const gridPlacementRules = Object.keys(MediaQueries).map(mq => {
      const selectors = [];
      const htmlselector = [];
      themeGridPlacements.grids.map(gridSetup => {
        const {
          name
        } = gridSetup;

        if (name) {
          selectors.push(name);
        }
      });

      if (spaceThemeRules[mq]) {
        Object.keys(spaceThemeRules[mq] || {}).forEach(key => {
          if (HTMLElementGroups.some(v => v.type[`${key}`.split(':')[0]])) {
            selectors.push(key.toLowerCase());
            htmlselector.push(key.toLowerCase());
          } else {
            selectors.push(key);
          }
        });
      }

      const allrules = selectors.map(selector => {
        let selectorRule = '';

        if (spaceThemeRules[mq]) {
          selectorRule += Object.keys(spaceThemeRules[mq]).map(key => {
            let res = false;

            if (HTMLElementGroups.some(v => v.type[`${key}`.split(':')[0]])) {
              if (selector === key.toLowerCase()) {
                res = `
              ${spaceThemeRules[mq][key]}
            `;
              }
            } else if (selector === key) {
              res = `
              ${spaceThemeRules[mq][key]}
            `;
            }

            return res;
          }).filter(x => x).join(nodetypes_NEW_LINE);
        }

        selectorRule += themeGridPlacements.grids.map(gridSetup => {
          const {
            gridTemplateColumns = "",
            gridTemplateRows = "",
            mediaSizes = {},
            gridPlacement,
            name = "unknown"
          } = gridSetup;

          if (selector === name) {
            if (mediaSizes[mq]) {
              const columnCount = gridTemplateColumns.split(' - ').join('-').split(' ').filter(x => x).length;
              const rowCount = gridTemplateRows.split(' - ').join('-').split(' ').filter(x => x).length;
              const areas = [].interpolate(0, rowCount, row => {
                const rowArea = [];
                [].interpolate(0, columnCount, col => {
                  let area = gridPlacement[row * columnCount + col];

                  if (!area || !area.trim()) {
                    area = '.';
                  }

                  rowArea.push(area);
                });
                return `"${rowArea.join(' ')}"${nodetypes_NEW_LINE}`;
              });
              return `
          display: grid;
          grid-template-columns: ${gridTemplateColumns};
          grid-template-rows: ${gridTemplateRows};
          grid-template-areas:
${areas.join(nodetypes_NEW_LINE)}
`;
            }
          }
        }).filter(x => x).join(nodetypes_NEW_LINE);

        if (selectorRule) {
          if (htmlselector.indexOf(selector) !== -1) {
            return `${selector} {
              ${selectorRule}
            }`;
          }

          return `.${selector} {
            ${selectorRule}
          }`;
        }
      }).filter(x => x).join(nodetypes_NEW_LINE);
      return `
      ${MediaQueries[mq]} {
        ${allrules}
      }
    `;
    }).join(nodetypes_NEW_LINE);
    const styleLinks = `
      ${fontLinks}
    `;
    const roottag = `* {
      ${fontCssDef}
      ${themecolors}
      ${themevariables}
      ${themecoloruse}
      ${cssvariables}
    }
`;
    theme += styleLinks;
    theme += roottag;
    theme += gridPlacementRules;
  }

  const appSettings = GetAppSettings(graph);

  if (appSettings) {
    fontStyleLink += `
    <script src="https://kit.fontawesome.com/84589ad5a6.js" crossorigin="anonymous"></script>
  `;
  }

  result = {
    theme,
    userDefined: true,
    relative: "./app/app.global.css",
    styleLink: fontStyleLink
  };
  return result;
}

class themeservicegenerator_ThemeServiceGenerator {
  static Generate(options) {
    const {
      state,
      language
    } = options;
    const graphRoot = GetRootGraph(state);
    const theme = graphRoot ? graphRoot[GraphKeys.THEME] : null;
    let res = {};

    if (theme) {
      if (themes_Themes[theme]) {
        if (themes_Themes[theme][language]) {
          res = { ...themes_Themes[theme][language]
          };
        }
      }
    }

    const result = [res];
    const globalCss = GenerateGlobalCss(options);
    result.push(globalCss);
    uiactions_NodesByType(state, uiactions_NodeTypes.Theme).sort((a, b) => (uiactions_GetNodeProp(a, uiactions_NodeProperties.Priority) || 0) - (uiactions_GetNodeProp(b, uiactions_NodeProperties.Priority) || 0)).forEach(node => {
      const themes = uiactions_GetNodeProp(node, uiactions_NodeProperties.Themes);

      if (themes) {
        Object.keys(themes).forEach(themme => {
          if (themes[themme]) {
            if (themes_Themes[themme]) {
              if (themes_Themes[themme][language]) {
                res = { ...themes_Themes[themme][language]
                };
                result.push(res);
              }
            }
          }
        });
      }
    });
    return result;
  }

}
// CONCATENATED MODULE: ./app/actions/ipcActions.js


/* eslint-disable no-restricted-syntax */

/* eslint-disable promise/catch-or-return */

/* eslint-disable array-callback-return */

/* eslint-disable promise/always-return */

/* eslint-disable promise/param-names */

/* eslint-disable compat/compat */














const {
  ipcRenderer: ipcActions_ipcRenderer
} = __webpack_require__("electron");

const hub = {};
ipcActions_ipcRenderer.on("message-reply", (event, arg) => {
  console.log(arg); // prints "pong"

  const reply = JSON.parse(arg);

  if (hub[reply.id]) {
    hub[reply.id].resolve(reply.msg);
  }

  delete hub[reply.id];
});
ipcActions_ipcRenderer.on("commands", (event, arg) => {
  console.log(event);
  console.log(arg);

  switch (arg.args) {
    case "w":
      uiactions_clearPinned();
      break;

    case "p":
      togglePinned();
      break;

    case "y":
      publishFiles();
      break;

    case "s":
      saveCurrentGraph();
      break;

    case "e":
      setInComponentMode();
      break;

    case "o":
      openGraph();
      break;

    case "n":
      newGraph();
      break;

    case "m":
      uiactions_newNode();
      break;

    case "l":
      toggleContextMenu("layout");
      break;

    case "g":
      toggleVisualKey("GROUPS_ENABLED");
      break;

    case "k":
      toggleContextMenu("context");
      break;

    case "x":
      removeCurrentNode();
      break;

    case "q":
      toggleNodeMark();
      break;

    case "1":
    case "2":
    case "3":
    case "4":
      setRightMenuTab(arg.args);
      break;

    default:
      break;
  }
});

function message(msg, body) {
  return {
    msg,
    body,
    id: uuidv4()
  };
}

function send(mess, body) {
  const m = message(mess, body);
  hub[m.id] = {};
  const result = Promise.resolve().then(() => new Promise((resolve, fail) => {
    hub[m.id].resolve = resolve;
    hub[m.id].fail = fail;
  }));
  ipcActions_ipcRenderer.send("message", JSON.stringify(m));
  return result;
}

function publishFiles() {
  scaffoldProject({
    filesOnly: true
  })(GetDispatchFunc(), GetStateFunc());
}
function scaffoldProject(options = {}) {
  const {
    filesOnly
  } = options;
  return (dispatch, getState) => {
    const state = getState();
    const root = GetRootGraph(state);
    const solutionName = root.title.split(" ").join(".");
    const workspace = root.workspaces ? root.workspaces[Object(external_os_["platform"])()] || root.workspace : root.workspace;
    ensureDirectory(external_path_default.a.join(workspace));
    ensureDirectory(external_path_default.a.join(workspace, root.title));
    (filesOnly ? Promise.resolve() : send(HandlerEvents.scaffold.message, {
      solutionName,
      appName: root[GraphKeys.PROJECTNAME] || "",
      workspace: external_path_default.a.join(workspace, root.title, "netcore")
    })).then(() => filesOnly ? Promise.resolve() : send(HandlerEvents.reactnative.message, {
      solutionName,
      appName: root[GraphKeys.PROJECTNAME] || "",
      workspace: external_path_default.a.join(workspace, root.title, "reactnative")
    })).then(() => filesOnly ? Promise.resolve() : send(HandlerEvents.electron.message, {
      solutionName,
      appName: root[GraphKeys.PROJECTNAME] || "",
      workspace: external_path_default.a.join(workspace, root.title, "electronio")
    })).then(() => {
      console.log("Finished Scaffolding.");
      generateFiles(external_path_default.a.join(workspace, root.title, "netcore"), solutionName, state);
    }).then(() => {
      console.log("generate react-native files");
      generateReactNative(external_path_default.a.join(workspace, root.title, "reactnative", root[GraphKeys.PROJECTNAME]), state);
    }).then(() => {
      console.log("generate electron io files");
      generateElectronIO(external_path_default.a.join(workspace, root.title, "electronio", root[GraphKeys.PROJECTNAME]), state);
    }).then(() => {
      const namespace = root ? root[GraphKeys.NAMESPACE] : null;
      const server_side_setup = root ? root[GraphKeys.SERVER_SIDE_SETUP] : null;
      const graph = root;
      const userNode = uiactions_NodesByType(state, NodeTypes.Model).find(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsUser));
      const logicalParents = GetNodesLinkedTo(graph, {
        id: userNode.id,
        link: nodetypes_LinkType.UserLink
      }).filter(x => x.id !== userNode.id);
      const logicalChildren = GetLogicalChildren(userNode.id);

      if (server_side_setup) {
        const children = [...logicalChildren, ...logicalParents, ...GetModelPropertyChildren(userNode.id).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.UIAttributeType) === NodeAttributePropertyTypes.STRING)].unique(x => x.id).filter(x => GetCodeName(x) !== "Id").filter(x => GetCodeName(x) !== "UserName").map(child => `
            if (!string.IsNullOrEmpty(user.${GetCodeName(child.id)}))
                result.Add(new Claim("${GetCodeName(child.id)}", user.${GetCodeName(child.id)}));
            `).join("");
        generateFolderStructure(external_path_default.a.join(`./app/templates/net_core_mvc/identity/${server_side_setup}`), {
          maestro_registrations: CreateRegistrations(uiactions_NodesByType(null, NodeTypes.Maestro).filter(x => !uiactions_GetNodeProp(x, uiactions_NodeProperties.ExcludeFromGeneration))),
          permission_registrations: CreateRegistrations(uiactions_NodesByType(null, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent)), v => `Permissions${GetCodeName(v)}`, v => `IPermissions${GetCodeName(v)}`),
          executor_registrations: CreateRegistrations(uiactions_NodesByType(null, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent)), v => `${GetCodeName(v)}Executor`, v => `I${GetCodeName(v)}Executor`),
          orchestration_registrations: CreateRegistrations(uiactions_NodesByType(null, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent)), v => `${GetCodeName(v)}StreamProcessOrchestration`, v => `I${GetCodeName(v)}StreamProcessOrchestration`),
          validation_registrations: CreateRegistrations(uiactions_NodesByType(null, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent)), v => `${GetCodeName(v)}Validations`, v => `I${GetCodeName(v)}Validations`),
          model: uiactions_GetNodeProp(userNode, uiactions_NodeProperties.CodeName),
          namespace
        }, null, external_path_default.a.join(external_path_default.a.join(workspace, root.title, "netcore"), solutionName + external_path_default.a.join(".Web")));
        let more_interfaces = "";
        const interface_implementations = [];
        const user_update_implementation = [];
        const post_registrations = [];
        let claim_service_interfaces = "";
        let user_node = null;
        const template_name = "ICreateAgents";
        const interfaceFunctions = uiactions_NodesByType(state, NodeTypes.ClaimService).map(claimService => {
          const authMethods = GetNodesLinkedTo(graph, {
            id: claimService.id,
            link: nodetypes_LinkType.ClaimServiceAuthorizationMethod
          });
          const userUpdateMethods = GetNodesLinkedTo(graph, {
            id: claimService.id,
            link: nodetypes_LinkType.ClaimServiceUpdateUserMethod
          });
          userUpdateMethods.map(method => {
            const parameters = GetMethodProps(method);

            if (parameters && parameters[FunctionTemplateKeys.Model]) {
              const user = GetCodeName(parameters[FunctionTemplateKeys.User]);
              const maestro = GetMaestroNode(method.id);

              if (maestro) {
                const controller = GetControllerNode(maestro.id);

                if (controller) {
                  user_node = user;
                  user_update_implementation.push(`
  var maestro = RedStrapper.Resolve<I${GetCodeName(maestro)}>();
  user = await maestro.${GetCodeName(method)}(user, user);
                      `);
                }
              }
            }
          });
          return authMethods.map(method => {
            const parameters = GetMethodProps(method);

            if (parameters && parameters[FunctionTemplateKeys.Model]) {
              const model = GetCodeName(parameters[FunctionTemplateKeys.Model]);
              const user = GetCodeName(parameters[FunctionTemplateKeys.User]);
              const maestro = GetMaestroNode(method.id);

              if (maestro) {
                const controller = GetControllerNode(maestro.id);

                if (controller) {
                  user_node = user;
                  interface_implementations.push(`
                    public async Task<${model}> Create(${user} user, ${model} model)
                    {
                      var maestro = RedStrapper.Resolve<I${GetCodeName(maestro)}>();
                      return await maestro.${GetCodeName(method)}(user, model);
                    }`);
                  post_registrations.push(`
                    var  ${model.toLowerCase()} =  ${model}.Create();
                    ${model.toLowerCase()}.Owner = user.Id;
                    ${model.toLowerCase()} = await Create(user, ${model.toLowerCase()});
                    user.${model}  = ${model.toLowerCase()}.Id;`);
                  return `Task<${model}> Create(${user} ${FunctionTemplateKeys.User}, ${model} ${FunctionTemplateKeys.Model});`;
                }
              }
            }

            return null;
          }).filter(x => x);
        }).flatten().unique();

        if (interfaceFunctions && interfaceFunctions.length) {
          interface_implementations.push(`

public async Task<User> Update(User user)
{
${user_update_implementation.join(nodetypes_NEW_LINE)}
  return user;
}

public async Task<${user_node}> PostRegistration(${user_node} user)
{
${post_registrations.join(nodetypes_NEW_LINE)}

    user = await Update(user);

    return user;
} `);
          claim_service_interfaces = `public interface ${template_name} {
${interfaceFunctions.join(nodetypes_NEW_LINE)}
}`;
          more_interfaces = `, ${template_name}`;
        }

        const props = [...logicalParents, ...GetModelPropertyChildren(userNode.id).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.UIAttributeType) === NodeAttributePropertyTypes.STRING)].map(prop => GetCodeName(prop)).unique().map(v => `if (claim.Type == "${v}")
              {
                result.${v} = claim.Value;
              }`).join(nodetypes_NEW_LINE);
        generateFolderStructure(external_path_default.a.join(`./app/templates/net_core_mvc/identity/RedQuickControllers`), {
          model: uiactions_GetNodeProp(userNode, uiactions_NodeProperties.CodeName),
          namespace,
          children,
          more_interfaces,
          interface_implementations: interface_implementations.join(nodetypes_NEW_LINE),
          claim_service_interfaces,
          create_properties: props
        }, null, external_path_default.a.join(external_path_default.a.join(workspace, root.title, "netcore"), solutionName + external_path_default.a.join(".Controllers")));
        generateFolderStructure(external_path_default.a.join(`./app/templates/net_core_mvc/identity/RedQuickTests`), {
          namespace
        }, null, external_path_default.a.join(external_path_default.a.join(workspace, root.title, "netcore"), solutionName + external_path_default.a.join(".Tests")));
      }
    }).then(() => {
      console.log("Write react-native files");
      const appName = root[GraphKeys.PROJECTNAME];
      const version = "v1";

      if (appName) {
        return generateFolderStructure(external_path_default.a.join(`./app/templates/react_native/${version}`), {}, null, external_path_default.a.join(workspace, root.title, "reactnative", appName));
      }

      console.warn("No app name given");
    }).then(() => {
      console.log("Clear electron theme");
      return clearElectronIOTheme(external_path_default.a.join(workspace, root.title, "electronio", root[GraphKeys.PROJECTNAME]), state);
    }).then(() => {
      console.log("Write electron files");
      const appName = root[GraphKeys.PROJECTNAME];
      const version = "v1";

      if (appName) {
        return generateFolderStructure(external_path_default.a.join(`./app/templates/electronio/${version}`), {}, null, external_path_default.a.join(workspace, root.title, "electronio", appName));
      }

      console.warn("No app name given");
    }).then(() => {
      console.log("Write electron theme");
      return generateElectronIOTheme(external_path_default.a.join(workspace, root.title, "electronio", root[GraphKeys.PROJECTNAME]), state);
    });
  };
}

function generateFolderStructure(dir, lib, relative, target_dir) {
  const directories = external_fs_default.a.readdirSync(dir);
  relative = relative || dir;
  directories.map(item => {
    const dirPath = external_path_default.a.join(dir, item);

    if (external_fs_default.a.existsSync(dirPath) && external_fs_default.a.lstatSync(dirPath).isDirectory()) {
      const reldir = dir.substr(relative.length);
      ensureDirectory(external_path_default.a.join(target_dir, reldir, item));
      generateFolderStructure(dirPath, lib, relative, target_dir);
    } else if (external_fs_default.a.existsSync(dirPath)) {
      let file = external_fs_default.a.readFileSync(dirPath, "utf8");
      const reldir = dir.substr(relative.length);
      file = bindTemplate(file, lib);
      external_fs_default.a.writeFileSync(external_path_default.a.join(target_dir, reldir, item), file, "utf8");
    }
  });
}

function generateReactNative(workspace, state) {
  const code_types = [...Object.values(ReactNativeTypes)];
  code_types.map(code_type => {
    const temp = generator_Generator.generate({
      type: code_type,
      language: UITypes.ReactNative,
      state
    });

    for (const fileName in temp) {
      ensureDirectory(external_path_default.a.join(workspace, temp[fileName].relative));
      Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, temp[fileName].relative, `${temp[fileName].relativeFilePath}`), temp[fileName].template);
    }
  });
}

function generateElectronIO(workspace, state) {
  const codeTypes = [...Object.values(ReactNativeTypes)];
  codeTypes.map(codeType => {
    const temp = generator_Generator.generate({
      type: codeType,
      language: UITypes.ElectronIO,
      state
    });
    Object.keys(temp).map(fileName => {
      let {
        relative
      } = temp[fileName];
      relative = relative.replace("src", "app");
      ensureDirectory(external_path_default.a.join(workspace, relative));
      console.log(external_path_default.a.join(workspace, relative, `${temp[fileName].relativeFilePath}`));
      Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, relative, `${temp[fileName].relativeFilePath}`), temp[fileName].template);
    });
  });
}

function clearElectronIOTheme(workspace, state) {
  const results = themeservicegenerator_ThemeServiceGenerator.Generate({
    state,
    language: UITypes.ElectronIO
  });
  const toClear = [];
  results.filter(x => !x.userDefined).forEach(result => {
    if (result.theme) {
      toClear.push(external_path_default.a.join(workspace, result.themerelative || result.relative));
    }
  });
  toClear.forEach(dir => {
    deleteAll(dir);
  });
}

function handleLinkStyles(result, workspace) {
  let appHtml = Object(external_fs_["readFileSync"])(external_path_default.a.join(workspace, './app/app.html'), 'utf8');
  const linkInsert = '<!-- link-insert -->';
  const linkInsertEnd = '<!-- link-insert-end -->';
  let inserHtml = `${linkInsert}${result.styleLink}${linkInsertEnd}</head>`;

  if (appHtml.indexOf(linkInsert) === -1) {
    appHtml = appHtml.replace('</head>', inserHtml);
  } else {
    inserHtml = `${linkInsert}${result.styleLink}${linkInsertEnd}`;
    const start = appHtml.indexOf(linkInsert);
    const end = appHtml.indexOf(linkInsertEnd) + linkInsertEnd.length;

    if (start !== -1 && end !== linkInsertEnd.length - 1) {
      appHtml = appHtml.slice(0, start) + inserHtml + appHtml.slice(end);
    }
  }

  Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, './app/app.html'), appHtml, 'utf8');
}

function generateElectronIOTheme(workspace, state) {
  const results = themeservicegenerator_ThemeServiceGenerator.Generate({
    state,
    language: UITypes.ElectronIO
  });
  results.forEach(result => {
    if (result.userDefined) {
      Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, result.relative), result.theme);
      handleLinkStyles(result, workspace);
    } else {
      if (result.location) {
        generateFolderStructure(external_path_default.a.join(`${result.location}`), {}, null, external_path_default.a.join(workspace, result.relative));
      }

      if (result.theme) {
        generateFolderStructure(external_path_default.a.join(`${result.theme}`), {}, null, external_path_default.a.join(workspace, result.themerelative || result.relative));
      }
    }
  });
}

function generateFiles(workspace, solutionName, state) {
  const code_types = [NodeTypes.Controller, NodeTypes.Model, NodeTypes.ExtensionType, NodeTypes.Maestro, NodeTypes.FetchService, ...Object.values(GeneratedTypes)];
  const root = GetRootGraph(state);
  code_types.map(code_type => {
    const temp = generator_Generator.generate({
      type: code_type,
      state
    });
    const area = CodeTypeToArea[code_type];

    for (const fileName in temp) {
      ensureDirectory(external_path_default.a.join(workspace, solutionName + area));

      if (temp[fileName].template) {
        Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, solutionName + area, `${temp[fileName].name}.cs`), temp[fileName].template);
      }

      if (temp[fileName].interface) {
        ensureDirectory(external_path_default.a.join(workspace, `${solutionName}.Interfaces`));
        Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, `${solutionName}.Interfaces`, `${temp[fileName].iname || fileName}.cs`), temp[fileName].interface);
      }

      if (temp[fileName].test) {
        ensureDirectory(external_path_default.a.join(workspace, `${solutionName}.Tests`));
        Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, `${solutionName}.Tests`, `${temp[fileName].tname || fileName}.cs`), temp[fileName].test);
      }
    }
  });

  if (root) {
    ensureDirectory(external_path_default.a.join(workspace, `${solutionName}.Tests`));
    Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, `${solutionName}.Tests`, `appsettings.json`), JSON.stringify(root.appConfig, null, 4));
    ensureDirectory(external_path_default.a.join(workspace, `${solutionName}.Web`));
    Object(external_fs_["writeFileSync"])(external_path_default.a.join(workspace, `${solutionName}.Web`, `appsettings.json`), JSON.stringify(root.appConfig, null, 4));
  }
}

function CreateRegistrations(nodes, namefunc = null, interfacefunc = null) {
  namefunc = namefunc || function (v) {
    return GetCodeName(v);
  };

  interfacefunc = interfacefunc || function (v) {
    return `I${GetCodeName(v)}`;
  };

  return nodes.map(v => `builder.RegisterType<${namefunc(v)}>().As<${interfacefunc(v)}>();`).join(nodetypes_NEW_LINE);
}

function ensureDirectory(dir) {
  if (!external_fs_default.a.existsSync(dir)) {
    console.log(`doesnt exist : ${dir}`);
  } else {}

  const _dir_parts = dir.split(external_path_default.a.sep);

  _dir_parts.map((_, i) => {
    if (i > 1 || _dir_parts.length - 1 === i) {
      let tempDir = external_path_default.a.join(..._dir_parts.subset(0, i + 1));

      if (dir.startsWith(external_path_default.a.sep)) {
        tempDir = `${external_path_default.a.sep}${tempDir}`;
      }

      if (!external_fs_default.a.existsSync(tempDir)) {
        external_fs_default.a.mkdirSync(tempDir);
      }
    }
  });
}

const CodeTypeToArea = {
  [NodeTypes.Controller]: external_path_default.a.join(".Web", "Controllers"),
  [NodeTypes.Model]: ".Models",
  [NodeTypes.ExtensionType]: ".Models",
  [NodeTypes.FetchService]: external_path_default.a.join(".Web", "Controllers"),
  [NodeTypes.Maestro]: ".Controllers",
  [GeneratedTypes.ChangeParameter]: ".Models",
  [GeneratedTypes.ChangeResponse]: ".Models",
  [GeneratedTypes.ValidationRule]: ".Models",
  [GeneratedTypes.Executors]: ".Controllers",
  [GeneratedTypes.ModelGet]: ".Controllers",
  [GeneratedTypes.ModelReturn]: ".Controllers",
  [GeneratedTypes.ModelExceptions]: ".Controllers",
  [GeneratedTypes.Constants]: ".Models",
  [GeneratedTypes.Permissions]: ".Controllers",
  [GeneratedTypes.Validators]: ".Controllers",
  [GeneratedTypes.CSDataChain]: ".Controllers",
  [GeneratedTypes.ModelItemFilter]: ".Controllers",
  [GeneratedTypes.StreamProcess]: ".Controllers",
  [GeneratedTypes.StreamProcessOrchestration]: ".Controllers"
};

function deleteAll(directory) {
  if (external_fs_default.a.existsSync(directory) && external_fs_default.a.lstatSync(directory).isDirectory()) {
    const files = external_fs_default.a.readdirSync(directory);
    files.forEach(file => {
      const dirPath = external_path_default.a.join(directory, file);

      if (external_fs_default.a.existsSync(dirPath) && external_fs_default.a.lstatSync(dirPath).isDirectory()) {
        deleteAll(dirPath);
      } else {
        external_fs_default.a.unlinkSync(external_path_default.a.join(directory, file));
      }
    });
    external_fs_default.a.rmdirSync(directory);
  }
}
// CONCATENATED MODULE: ./app/utils/utils.js






function mapStateToProps(state) {
  return {
    state
  };
}
function mapDispatchToProps(dispatch) {
  return Object(external_redux_["bindActionCreators"])({ ...uiactions_namespaceObject,
    ...ipcActions_namespaceObject,
    ...remoteActions_namespaceObject
  }, dispatch);
}
function UIConnect(component) {
  return Object(external_react_redux_["connect"])(mapStateToProps, mapDispatchToProps)(component);
}

String.prototype.padding = function (n, c) {
  var val = this.valueOf();

  if (Math.abs(n) <= val.length) {
    return val;
  }

  var m = Math.max(Math.abs(n) - this.length || 0, 0);
  var pad = Array(m + 1).join(String(c || ' ').charAt(0)); //      var pad = String(c || ' ').charAt(0).repeat(Math.abs(n) - this.length);

  return n < 0 ? pad + val : val + pad; //      return (n < 0) ? val + pad : pad + val;
};

String.prototype.unCamelCase = function () {
  var str = this || '';
  return str // insert a space between lower & upper
  .replace(/([a-z])([A-Z])/g, '$1 $2') // space before last upper in a sequence followed by lower
  .replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3') // uppercase the first character
  .replace(/^./, function (str) {
    return str.toUpperCase();
  }).trim();
};

function enumerate(vects, j = 0) {
  var results = [];
  if (j < vects.length) for (var i = 0; i < vects[j]; i++) {
    var rest = enumerate(vects, j + 1);
    var temp = [i];

    if (rest.length) {
      rest.map(r => {
        results.push([...temp, ...r]);
      });
    } else {
      results.push(temp);
    }
  }
  return results;
}
// CONCATENATED MODULE: ./app/components/dashboardlogo.js
var dashboardlogo_REACT_ELEMENT_TYPE;

function dashboardlogo_jsx(type, props, key, children) { if (!dashboardlogo_REACT_ELEMENT_TYPE) { dashboardlogo_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: dashboardlogo_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



var _ref =
/*#__PURE__*/
dashboardlogo_jsx("a", {
  className: "logo"
}, void 0, dashboardlogo_jsx("span", {
  className: "logo-mini"
}, void 0, dashboardlogo_jsx("b", {}, void 0, "R"), "QB"), dashboardlogo_jsx("span", {
  className: "logo-lg"
}, void 0, dashboardlogo_jsx("b", {}, void 0, "Red"), "QuickBuilder"));

class dashboardlogo_Header extends external_react_["Component"] {
  render() {
    return _ref;
  }

}
// CONCATENATED MODULE: ./app/components/header.js
var header_REACT_ELEMENT_TYPE;

function header_jsx(type, props, key, children) { if (!header_REACT_ELEMENT_TYPE) { header_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: header_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class header_Header extends external_react_["Component"] {
  render() {
    return header_jsx("header", {
      className: "main-header"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/dashboardnavbar.js
var dashboardnavbar_REACT_ELEMENT_TYPE;

function dashboardnavbar_jsx(type, props, key, children) { if (!dashboardnavbar_REACT_ELEMENT_TYPE) { dashboardnavbar_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: dashboardnavbar_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class dashboardnavbar_Header extends external_react_["Component"] {
  render() {
    return dashboardnavbar_jsx("nav", {
      className: "navbar navbar-static-top"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/sidebartoggle.js
var sidebartoggle_REACT_ELEMENT_TYPE;

function sidebartoggle_jsx(type, props, key, children) { if (!sidebartoggle_REACT_ELEMENT_TYPE) { sidebartoggle_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebartoggle_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




var sidebartoggle_ref =
/*#__PURE__*/
sidebartoggle_jsx("span", {
  className: "sr-only"
}, void 0, "Toggle navigation");

class sidebartoggle_SidebarToggle extends external_react_["Component"] {
  render() {
    var me = this;
    return sidebartoggle_jsx("a", {
      onClick: () => {
        me.props.toggleDashboardMinMax();
      },
      className: "sidebar-toggle",
      "data-toggle": "push-menu",
      role: "button"
    }, void 0, sidebartoggle_ref);
  }

}

/* harmony default export */ var sidebartoggle = (UIConnect(sidebartoggle_SidebarToggle));
// CONCATENATED MODULE: ./app/components/navbarmenu.js
var navbarmenu_REACT_ELEMENT_TYPE;

function navbarmenu_jsx(type, props, key, children) { if (!navbarmenu_REACT_ELEMENT_TYPE) { navbarmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: navbarmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class navbarmenu_NavBarMenu extends external_react_["Component"] {
  render() {
    let style = {};

    if (this.props.paddingRight) {
      style.paddingRight = this.props.paddingRight;
    }

    if (this.props.style) {
      style = { ...style,
        ...this.props.style
      };
    }

    return navbarmenu_jsx("div", {
      className: "navbar-custom-menu",
      style: style
    }, void 0, navbarmenu_jsx("ul", {
      className: "nav navbar-nav"
    }, void 0, this.props.children));
  }

}
// CONCATENATED MODULE: ./app/constants/visual.js
const GraphOperationMenu = 'GraphOperationMenu';
const visual_GraphPropertiesMenu = 'GraphPropertiesMenu';
const ApplicationMenu = 'ApplicationMenu';
const RelativeMenuCss = {
  position: 'relative',
  zIndex: 'auto',
  width: 'auto',
  minheight: 'auto',
  top: 'auto',
  left: 'auto',
  paddingTop: 0,
  display: 'block'
};
const PaddingTopZero = {
  paddingTop: 0
};
const SecondaryOptions = {
  LayoutOptions: 'LayoutOptions'
};
// CONCATENATED MODULE: ./app/components/mainsidebar.js
var mainsidebar_REACT_ELEMENT_TYPE;

function mainsidebar_jsx(type, props, key, children) { if (!mainsidebar_REACT_ELEMENT_TYPE) { mainsidebar_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: mainsidebar_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




var mainsidebar_ref =
/*#__PURE__*/
mainsidebar_jsx("div", {});

class mainsidebar_Header extends external_react_["Component"] {
  relative() {
    return this.props.relative ? RelativeMenuCss : {};
  }

  overflow() {
    return this.props.overflow ? {
      maxHeight: "100vh",
      overflowY: "auto"
    } : {};
  }

  render() {
    if (this.props.notactive) {
      return mainsidebar_ref;
    }

    return mainsidebar_jsx("aside", {
      className: `main-sidebar`,
      style: {
        minHeight: 0,
        ...this.relative(),
        ...this.overflow()
      }
    }, void 0, mainsidebar_jsx("section", {
      className: "sidebar",
      style: {
        height: "auto"
      }
    }, void 0, this.props.children));
  }

}
// CONCATENATED MODULE: ./app/components/controlsidebarmenu.js
var controlsidebarmenu_REACT_ELEMENT_TYPE;

function controlsidebarmenu_jsx(type, props, key, children) { if (!controlsidebarmenu_REACT_ELEMENT_TYPE) { controlsidebarmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: controlsidebarmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class controlsidebarmenu_ControlSideBarMenu extends external_react_["Component"] {
  render() {
    return controlsidebarmenu_jsx("ul", {
      className: "control-sidebar-menu"
    }, void 0, this.props.children);
  }

}
class controlsidebarmenu_ControlSideBarMenuItem extends external_react_["Component"] {
  icon() {
    return this.props.icon || 'fa fa-birthday-cake';
  }

  render() {
    return controlsidebarmenu_jsx("li", {}, void 0, controlsidebarmenu_jsx("a", {
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      }
    }, void 0, controlsidebarmenu_jsx("i", {
      className: `menu-icon ${this.icon()} bg-red`
    }), controlsidebarmenu_jsx("div", {
      className: "menu-info"
    }, void 0, controlsidebarmenu_jsx("h4", {
      className: "control-sidebar-subheading"
    }, void 0, this.props.title || ''), controlsidebarmenu_jsx("p", {}, void 0, this.props.description || ''))));
  }

}
class controlsidebarmenu_ControlSideBarMenuHeader extends external_react_["Component"] {
  render() {
    return controlsidebarmenu_jsx("h3", {
      className: "control-sidebar-heading"
    }, void 0, this.props.title);
  }

}
// CONCATENATED MODULE: ./app/components/tabpane.js
var tabpane_REACT_ELEMENT_TYPE;

function tabpane_jsx(type, props, key, children) { if (!tabpane_REACT_ELEMENT_TYPE) { tabpane_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: tabpane_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class tabpane_TabPane extends external_react_["Component"] {
  active() {
    return this.props.active ? 'active' : '';
  }

  render() {
    let style = this.props.style || {};
    return tabpane_jsx("div", {
      className: `tab-pane ${this.active()}`,
      style: { ...style
      }
    }, void 0, this.props.active ? this.props.children : null);
  }

}
// CONCATENATED MODULE: ./app/components/formcontrol.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }


class formcontrol_FormControl extends external_react_["Component"] {
  _class() {
    return this.props.sidebarform ? 'sidebar-form' : '';
  }

  render() {
    return external_react_default.a.createElement("form", _extends({
      role: "form",
      className: this._class()
    }, {
      style: {
        paddingRight: 10,
        ...(this.props.style || {})
      }
    }), this.props.children);
  }

}
// EXTERNAL MODULE: ./app/components/selectinput.css
var selectinput = __webpack_require__("./app/components/selectinput.css");

// CONCATENATED MODULE: ./app/components/selectinput.js
var selectinput_REACT_ELEMENT_TYPE;

function selectinput_jsx(type, props, key, children) { if (!selectinput_REACT_ELEMENT_TYPE) { selectinput_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: selectinput_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




class selectinput_SelectInput extends external_react_["Component"] {
  label() {
    return this.props.label || '{label}';
  }

  value() {
    return this.props.value || '';
  }

  options() {
    if (this.props.options) {
      return this.props.options.map((t, index) => selectinput_jsx("option", {
        value: t.value
      }, `option-${index}`, t.title));
    }

    return [];
  }

  disabled() {
    return this.props.disabled ? 'disabled' : '';
  }

  render() {
    let extra = {};

    if (this.props.color) {
      extra.color = this.props.color;
      extra.style = {
        '--color': this.props.color
      };
    }

    return selectinput_jsx("div", {
      className: "form-group"
    }, void 0, external_react_default.a.createElement("label", extra, this.label()), selectinput_jsx("select", {
      className: "form-control",
      disabled: this.disabled(),
      onSelect: evt => {
        if (this.props.onChange) {
          this.props.onChange(evt.target.value);
        }
      },
      onChange: evt => {
        if (this.props.onChange) {
          this.props.onChange(evt.target.value);
        }
      },
      value: this.value()
    }, void 0, selectinput_jsx("option", {
      value: ""
    }, void 0, this.props.defaultSelectText || Select), this.options()));
  }

}
// CONCATENATED MODULE: ./app/components/textinput.js
var textinput_REACT_ELEMENT_TYPE;

function textinput_jsx(type, props, key, children) { if (!textinput_REACT_ELEMENT_TYPE) { textinput_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: textinput_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



var textinput_ref =
/*#__PURE__*/
textinput_jsx("i", {
  className: "fa fa-edit"
});

var _ref2 =
/*#__PURE__*/
textinput_jsx("i", {
  className: "fa fa-edit"
});

class textinput_TextInput extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  label() {
    return this.props.label || "{label}";
  }

  immediate() {
    return this.props.immediate || false;
  }

  value() {
    if (this.immediate()) {
      return this.props.value || "";
    }

    return this.state.value || "";
  }

  placeholder() {
    return this.props.placeholder || "";
  }

  disabled() {
    return this.props.disabled ? "disabled" : "";
  }

  componentDidMount() {
    if (!this.immediate()) {
      this.setState({
        value: this.props.value
      });
    }
  }

  componentDidUpdate(prevProps) {
    if (!this.immediate()) {
      if (!this.state.focused) if (this.state.value !== this.props.value) {
        this.setState({
          value: this.props.value
        });
      }
    }
  }

  render() {
    var handleKeyPress = event => {
      if (!this.immediate()) {
        if (event.key === "Enter") {
          if (this.props.onChange) {
            this.props.onChange(this.state.value || "");
          }
        }
      }
    };

    if (this.props.textarea) {
      return textinput_jsx("div", {
        className: this.props.inputgroup ? "input-group" : "form-group"
      }, void 0, this.props.inputgroup ? null : textinput_jsx("label", {}, void 0, this.label()), textinput_jsx("textarea", {
        type: "text",
        disabled: this.disabled(),
        className: "form-control",
        onBlur: () => {
          if (this.props.onBlur) {
            this.props.onBlur();
          }

          if (!this.immediate()) {
            if (this.props.onChange) {
              if (this.state.value !== this.props.value) this.props.onChange(this.state.value || "");
            }
          }

          if (this.props.onChanged) {
            this.props.onChanged(this.state.value || "");
          }

          this.setState({
            focused: false
          });
        },
        onFocus: () => {
          if (this.props.onFocus) {
            this.props.onFocus();
          }

          this.setState({
            focused: true
          });
        },
        value: this.value(),
        onKeyPress: handleKeyPress,
        onChange: v => {
          if (this.props.onChangeText) {
            this.props.onChangeText(v.target.value);
          }

          if (this.immediate()) {
            if (this.props.onChange) {
              this.props.onChange(v.target.value);
            }
          } else {
            this.setState({
              value: v.target.value
            });
          }
        },
        placeholder: this.placeholder()
      }), this.props.inputgroup ? textinput_jsx("span", {
        className: "input-group-btn"
      }, void 0, textinput_jsx("button", {
        onClick: () => {
          if (this.props.onClick) {
            this.props.onClick();
          }
        },
        name: "search",
        id: "search-btn",
        className: "btn btn-flat"
      }, void 0, textinput_ref)) : null);
    }

    return textinput_jsx("div", {
      className: this.props.inputgroup ? "input-group" : "form-group"
    }, void 0, this.props.inputgroup || this.props.slim ? null : textinput_jsx("label", {}, void 0, this.label()), textinput_jsx("input", {
      type: this.inputType || "text",
      disabled: this.disabled(),
      className: "form-control",
      onBlur: () => {
        if (this.props.onBlur) {
          this.props.onBlur();
        }

        if (!this.immediate()) {
          if (this.props.onChange) {
            if (this.state.value !== this.props.value) this.props.onChange(this.state.value || "");
          }
        }

        if (this.props.onChanged) {
          this.props.onChanged(this.props.value || "");
        }

        this.setState({
          focused: false
        });
      },
      onFocus: () => {
        if (this.props.onFocus) {
          this.props.onFocus();
        }

        this.setState({
          focused: true
        });
      },
      value: this.value(),
      onKeyPress: handleKeyPress,
      onChange: v => {
        if (this.props.onChangeText) {
          this.props.onChangeText(v.target.value);
        }

        if (this.immediate()) {
          if (this.props.onChange) {
            this.props.onChange(v.target.value);
          }
        } else {
          this.setState({
            value: v.target.value
          });
        }
      },
      placeholder: this.placeholder()
    }), this.props.inputgroup ? textinput_jsx("span", {
      className: "input-group-btn"
    }, void 0, textinput_jsx("button", {
      onClick: e => {
        if (this.props.onClick) {
          this.props.onClick();
        }

        if (this.props.onChange) {
          this.props.onChange(this.state.value);
        }

        e.stopPropagation();
        e.preventDefault();
      },
      className: "btn btn-flat"
    }, void 0, _ref2)) : null);
  }

}
// CONCATENATED MODULE: ./app/components/batchmenu.js

var batchmenu_REACT_ELEMENT_TYPE;

function batchmenu_jsx(type, props, key, children) { if (!batchmenu_REACT_ELEMENT_TYPE) { batchmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: batchmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













var batchmenu_ref =
/*#__PURE__*/
batchmenu_jsx("div", {});

class batchmenu_BatchMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;

    if (!state || !HasCurrentGraph()) {
      return batchmenu_ref;
    }

    return batchmenu_jsx(tabpane_TabPane, {
      active: true
    }, void 0, batchmenu_jsx(formcontrol_FormControl, {}, void 0, batchmenu_jsx("h3", {}, void 0, titles_QuickMethods), batchmenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).toNodeSelect(),
      label: Models,
      onChange: value => {
        this.props.setVisual(BATCH_MODEL, value);
      },
      value: Visual(state, BATCH_MODEL)
    }), batchmenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).filter(t => uiactions_GetNodeProp(t, nodetypes_NodeProperties.IsAgent)).toNodeSelect(),
      label: Agents,
      onChange: value => {
        this.props.setVisual(BATCH_AGENT, value);
      },
      value: Visual(state, BATCH_AGENT)
    }), batchmenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).toNodeSelect(),
      label: Parents,
      onChange: value => {
        this.props.setVisual(BATCH_PARENT, value);
      },
      value: Visual(state, BATCH_PARENT)
    }), batchmenu_jsx(selectinput_SelectInput, {
      options: Object.keys(MethodFunctions).map(t => {
        return {
          title: MethodFunctions[t] && MethodFunctions[t].title ? MethodFunctions[t].title : t,
          value: t
        };
      }),
      label: FunctionTypes,
      onChange: value => {
        this.props.setVisual(BATCH_FUNCTION_TYPE, value);
      },
      value: Visual(state, BATCH_FUNCTION_TYPE)
    }), batchmenu_jsx(textinput_TextInput, {
      label: MethodName,
      value: Visual(state, BATCH_FUNCTION_NAME),
      onChange: value => {
        this.props.setVisual(BATCH_FUNCTION_NAME, value);
      }
    })));
  }

}

/* harmony default export */ var batchmenu = (UIConnect(batchmenu_BatchMenu));
// CONCATENATED MODULE: ./app/components/checkbox.js
var checkbox_REACT_ELEMENT_TYPE;

function checkbox_jsx(type, props, key, children) { if (!checkbox_REACT_ELEMENT_TYPE) { checkbox_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: checkbox_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class checkbox_CheckBox extends external_react_["Component"] {
  label() {
    return this.props.label || '{label}';
  }

  value() {
    return this.props.value || '';
  }

  title() {
    return this.props.title || '';
  }

  render() {
    return checkbox_jsx("div", {
      className: "form-group"
    }, void 0, checkbox_jsx("div", {
      className: "checkbox"
    }, void 0, checkbox_jsx("label", {
      title: this.title()
    }, void 0, checkbox_jsx("input", {
      type: "checkbox",
      checked: this.value(),
      onChange: v => {
        if (this.props.onChange) {
          this.props.onChange(v.target.checked);
        }
      }
    }), this.label())));
  }

}
// CONCATENATED MODULE: ./app/components/selectproperty.js
var selectproperty_REACT_ELEMENT_TYPE;

function selectproperty_jsx(type, props, key, children) { if (!selectproperty_REACT_ELEMENT_TYPE) { selectproperty_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: selectproperty_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }







class selectproperty_SelectProperty extends external_react_["Component"] {
  render() {
    let currentNode = this.props.node;
    return selectproperty_jsx(selectinput_SelectInput, {
      label: this.props.title,
      title: this.props.title,
      options: this.props.options,
      value: uiactions_GetNodeProp(currentNode, this.props.property),
      onChange: value => {
        let ops = [];

        if (this.props.link) {
          let oldprop = uiactions_GetNodeProp(currentNode, this.props.property);

          if (oldprop) {
            ops.push({
              operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
              options: {
                source: currentNode.id,
                target: oldprop
              }
            });
          }

          ops.push({
            operation: uiactions_ADD_LINK_BETWEEN_NODES,
            options: {
              source: currentNode.id,
              target: value,
              properties: { ...this.props.link
              }
            }
          });
        }

        this.props.graphOperation([...ops, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: this.props.property,
            id: currentNode.id,
            value: value
          }
        }]);
      }
    });
  }

}

/* harmony default export */ var selectproperty = (UIConnect(selectproperty_SelectProperty));
// CONCATENATED MODULE: ./app/components/textproperty.js
var textproperty_REACT_ELEMENT_TYPE;

function textproperty_jsx(type, props, key, children) { if (!textproperty_REACT_ELEMENT_TYPE) { textproperty_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: textproperty_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }






class textproperty_TextProperty extends external_react_["Component"] {
  render() {
    let currentNode = this.props.node;
    return textproperty_jsx(textinput_TextInput, {
      label: this.props.label,
      title: this.props.title,
      immediate: this.props.immediate,
      value: currentNode.properties ? currentNode.properties[this.props.property] : "",
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: this.props.property,
          id: currentNode.id,
          value
        });
      }
    });
  }

}

/* harmony default export */ var textproperty = (UIConnect(textproperty_TextProperty));
// EXTERNAL MODULE: external "webcola"
var external_webcola_ = __webpack_require__("webcola");

// CONCATENATED MODULE: ./app/constants/servicetypes.js
const ServiceTypes = {
  Facebook: 'Facebook',
  Twitter: 'Twitter',
  Google: 'Google',
  Microsoft: 'Microsoft'
};
const ServiceTypeSetups = {
  [ServiceTypes.Facebook]: {
    properties: {
      UseFacebook: {
        type: 'boolean'
      },
      FacebookAppId: {
        type: 'string'
      },
      FacebookAppSecret: {
        type: 'string'
      }
    }
  },
  [ServiceTypes.Microsoft]: {
    properties: {
      UseMicrosoftAccount: {
        type: 'boolean'
      },
      MicrosoftClientId: {
        type: 'string'
      },
      MicrosoftClientSecret: {
        type: 'string'
      }
    }
  },
  [ServiceTypes.Google]: {
    properties: {
      UseGoogle: {
        type: 'boolean'
      },
      GoogleClientId: {
        type: 'string'
      },
      GoogleClientSecret: {
        type: 'string'
      }
    }
  },
  [ServiceTypes.Twitter]: {
    properties: {
      UseTwitter: {
        type: 'boolean'
      },
      TwitterConsumerKey: {
        type: 'string'
      },
      TwitterConsumerSecret: {
        type: 'string'
      }
    }
  }
};
const SystemSettings = {
  Domain: 'Domain'
};
// CONCATENATED MODULE: ./app/components/selectoractivitymenu.js

var selectoractivitymenu_REACT_ELEMENT_TYPE;

function selectoractivitymenu_jsx(type, props, key, children) { if (!selectoractivitymenu_REACT_ELEMENT_TYPE) { selectoractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: selectoractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













class selectoractivitymenu_SelectorActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Selector);
    var currentNode = active ? Node(state, Visual(state, SELECTED_NODE)) : null;
    let componentNodeProperties = active ? GetComponentNodeProperties() : null;
    return selectoractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, selectoractivitymenu_jsx(selectproperty, {
      title: SelectorType,
      options: Object.keys(nodetypes_SelectorType).map(v => ({
        title: v,
        id: v,
        value: v
      })),
      node: currentNode,
      property: nodetypes_NodeProperties.SelectorType
    }), selectoractivitymenu_jsx(textproperty, {
      title: DefaultViewModel,
      label: DefaultViewModel,
      node: currentNode,
      property: nodetypes_NodeProperties.DefaultViewModel
    }));
  }

}

/* harmony default export */ var selectoractivitymenu = (UIConnect(selectoractivitymenu_SelectorActivityMenu));
// CONCATENATED MODULE: ./app/components/sidebarheader.js
var sidebarheader_REACT_ELEMENT_TYPE;

function sidebarheader_jsx(type, props, key, children) { if (!sidebarheader_REACT_ELEMENT_TYPE) { sidebarheader_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebarheader_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class sidebarheader_SideBarHeader extends external_react_["Component"] {
  render() {
    return sidebarheader_jsx("li", {
      className: "header",
      style: {
        cursor: "pointer"
      },
      onClick: this.props.onClick
    }, void 0, this.props.title);
  }

}
// CONCATENATED MODULE: ./app/components/viewmodelactivitymenu.js

var viewmodelactivitymenu_REACT_ELEMENT_TYPE;

function viewmodelactivitymenu_jsx(type, props, key, children) { if (!viewmodelactivitymenu_REACT_ELEMENT_TYPE) { viewmodelactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: viewmodelactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }
















class viewmodelactivitymenu_ViewModelActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ViewModel);
    var currentNode = active ? Node(state, Visual(state, SELECTED_NODE)) : null;
    let models = uiactions_NodesByType(state, NodeTypes.Model).toNodeSelect();
    return viewmodelactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, viewmodelactivitymenu_jsx(formcontrol_FormControl, {}, void 0, viewmodelactivitymenu_jsx(selectinput_SelectInput, {
      label: Models,
      options: models,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Model),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.Model],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Model,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ViewModelLink
          }
        });
      }
    }), viewmodelactivitymenu_jsx(selectinput_SelectInput, {
      label: InstanceType,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.InstanceType),
      options: Object.keys(InstanceTypes).map(t => ({
        title: t,
        value: InstanceTypes[t]
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: nodetypes_NodeProperties.InstanceType,
          id: currentNode.id,
          value
        });
      }
    })));
  }

}

/* harmony default export */ var viewmodelactivitymenu = (UIConnect(viewmodelactivitymenu_ViewModelActivityMenu));
// CONCATENATED MODULE: ./app/components/buttonlist.js
var buttonlist_REACT_ELEMENT_TYPE;

function buttonlist_jsx(type, props, key, children) { if (!buttonlist_REACT_ELEMENT_TYPE) { buttonlist_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: buttonlist_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/destructuring-assignment */


class buttonlist_ButtonList extends external_react_["Component"] {
  render() {
    let tabPaneStyle = this.props.tabPaneStyle || {};
    return buttonlist_jsx(tabpane_TabPane, {
      active: this.props.active,
      style: { ...tabPaneStyle
      }
    }, void 0, (this.props.items || []).map(item => {
      return buttonlist_jsx("div", {
        title: item.title,
        className: `external-event ${this.props.isSelected && this.props.isSelected(item) ? 'bg-red' : 'bg-green'}`,
        style: {
          cursor: 'pointer',
          overflow: 'hidden',
          whiteSpace: 'nowrap',
          textOverflow: 'ellipsis'
        },
        onClick: () => {
          if (this.props.onClick) {
            this.props.onClick(item);
          }
        }
      }, `allowed-${item.id}`, " ", this.props.renderItem ? this.props.renderItem(item) : item.title);
    }));
  }

}
// CONCATENATED MODULE: ./app/nodepacks/PostRegister.js
/* harmony default export */ var PostRegister = (function (args = {}) {
  // node0
  let context = {
    node2: args.screen,
    name: args.name,
    node3: args.clickInstance,
    node5: args.pressInstance,
    ...args
  };
  return [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Post Authenticate"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Navigate"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Screen",
        id: context.node1,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node1,
        target: context.node2,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: context.name || "Post Register"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "NavigationAction",
        id: context.node1,
        value: "Replace"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Navigate to Authenticate Screen"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, context.node3 ? function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node3,
        source: context.node0,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  } : false, context.node5 ? function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node5,
        source: context.node0,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  } : false, ...[].interpolate(0, 6, x => {
    if (x !== 2) {
      return {
        operation: "CHANGE_NODE_PROPERTY",
        options: function () {
          return {
            prop: "Pinned",
            id: context["node" + x],
            value: false
          };
        }
      };
    }

    return null;
  }).filter(x => x)].filter(x => x);
});
// CONCATENATED MODULE: ./app/methods/component_api_methods.js


function createComponentApi() {
  return {
    properties: {},
    instanceTypes: {}
  };
}
function getComponentApiList(props) {
  if (props && props.properties) {
    return Object.values(props.properties).map(v => ({
      title: v.property,
      id: v.id,
      value: v.property
    }));
  }

  return [];
}
function addComponentApi(props, ops) {
  let {
    modelProp
  } = ops;

  if (props && props.properties) {
    if (!props.properties[modelProp]) props.properties[modelProp] = {
      property: modelProp,
      id: uuidv4()
    };else {
      props.properties[modelProp].property = modelProp;
    }
  }

  return props;
}
function removeComponentApi(props, ops) {
  let {
    modelProp
  } = ops;

  if (props && props.properties) {
    delete props.properties[modelProp];
  }

  return props;
}
// CONCATENATED MODULE: ./app/nodepacks/postAuthenticate_.js

/* harmony default export */ var postAuthenticate_ = (function (args = {}) {
  // node0,node1,node2
  //
  let context = null;
  let {
    viewPackages = {}
  } = args;
  let result = [function () {
    context = { ...args,
      node0: uuidv4(),
      node1: args.head(),
      node2: args.tail()
    };
    return [];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node1,
        target: context.node2,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "data-chain",
        parent: context.node1,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        properties: {
          ChainParent: context.node1
        },
        links: [function (graph) {
          return [{
            target: context.node2,
            linkProperties: {
              properties: {
                type: "data-chain-link",
                "data-chain-link": {}
              }
            }
          }];
        }],
        callback: function (node, graph, group) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node1,
        target: context.node3,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node2,
        value: context.node3,
        prop: "ChainParent"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node3,
        value: "SetBearerAccessToken"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node3,
        value: "set bearer token"
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/PostAuthenticate.js

/* harmony default export */ var PostAuthenticate = (function (args = {}) {
  // node0
  let context = {
    node2: args.screen,
    node3: args.clickInstance,
    node5: args.pressInstance,
    ...args
  };
  return [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: context.functionName || "Post Authenticate"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Navigate"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Screen",
        id: context.node1,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node1,
        target: context.node2,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "NavigationAction",
        id: context.node1,
        value: "Replace"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "[Select Target Screen]"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, context.node3 ? function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node3,
        source: context.node0,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  } : false, context.node5 ? function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node5,
        source: context.node0,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  } : false, ...postAuthenticate_({
    head: () => {
      return context.node0;
    },
    tail: () => {
      return context.node1;
    }
  }), ...[].interpolate(0, 4, x => {
    if (x !== 2) {
      return {
        operation: "CHANGE_NODE_PROPERTY",
        options: function () {
          return {
            prop: "Pinned",
            id: context["node" + x],
            value: false
          };
        }
      };
    }

    return null;
  }).filter(x => x)].filter(x => x);
});
// CONCATENATED MODULE: ./app/nodepacks/HomeView.js

/* harmony default export */ var HomeView = (function (args = {}) {
  // node3,node6,node7,node8,node11,node16,node19
  let context = {
    node3: uuidv4(),
    node6: uuidv4(),
    node7: uuidv4(),
    node8: uuidv4(),
    node11: args.titleService,
    node16: args.registerForm,
    node19: args.authenticateForm,
    ...args
  };
  return [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Home View "
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node0,
        value: "/",
        prop: "HttpRoute"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "screen"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_SCREEN_OPTIONS",
      options: {
        parent: context.node0,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "screen-options",
            "screen-options": {}
          }
        },
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "UIType",
        id: context.node1,
        value: "ElectronIO"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Home View Container"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node1,
        value: "/",
        prop: "HttpRoute"
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node1,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO"
        },
        linkProperties: {
          properties: {
            type: "component",
            stroke: "#B7245C",
            component: {}
          }
        },
        callback: function (node) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "Home View Component"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node2,
        value: "View"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {}
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {
                [context.node3]: context.node2
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {}
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {
                [context.node3]: context.node2
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node2,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO"
        },
        linkProperties: {
          properties: {
            type: "component",
            stroke: "#B7245C",
            component: {}
          }
        },
        callback: function (node) {
          context.node4 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node4,
        value: "Authenticate Butto"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node4,
        value: "NavigationAction"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node4,
        value: "Register"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node4,
        value: "component-node"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node4,
        value: "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node2,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO"
        },
        linkProperties: {
          properties: {
            type: "component",
            stroke: "#B7245C",
            component: {}
          }
        },
        callback: function (node) {
          context.node5 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node5,
        value: "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node5,
        value: "Authenticate"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node2,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {}
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node7]: context.node4
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                justifyContent: "center",
                alignItems: "center"
              },
              children: {
                [context.node8]: context.node5
              },
              cellModel: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentApi",
        linkProperties: {
          properties: {
            type: "component-internal-api",
            "component-internal-api": {}
          }
        },
        parent: context.node5,
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false,
          UseAsValue: true
        },
        callback: function (node) {
          context.node9 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentExternalApi",
        parent: context.node5,
        linkProperties: {
          properties: {
            type: "component-external-api",
            "component-external-api": {}
          }
        },
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false
        },
        callback: function (node) {
          context.node10 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node9,
        target: context.node10,
        properties: {
          type: "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node10,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node11,
        source: context.node10,
        properties: {
          type: "title-service-link",
          "title-service-link": {},
          singleLink: true,
          nodeTypes: ["titleService"]
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentApi",
        linkProperties: {
          properties: {
            type: "component-internal-api",
            "component-internal-api": {}
          }
        },
        parent: context.node4,
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false,
          UseAsValue: true
        },
        callback: function (node) {
          context.node12 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentExternalApi",
        parent: context.node4,
        linkProperties: {
          properties: {
            type: "component-external-api",
            "component-external-api": {}
          }
        },
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false
        },
        callback: function (node) {
          context.node13 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node12,
        target: context.node13,
        properties: {
          type: "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node13,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node11,
        source: context.node13,
        properties: {
          type: "title-service-link",
          "title-service-link": {},
          singleLink: true,
          nodeTypes: ["titleService"]
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethod",
        properties: {
          EventType: "onClick",
          text: "onClick"
        },
        links: [function (graph) {
          return [{
            target: context.node4,
            linkProperties: {
              properties: {
                type: "EventMethod",
                EventMethod: {}
              }
            }
          }];
        }],
        callback: function (node) {
          context.node14 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node4,
        value: false
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node4,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethodInstance",
        parent: context.node14,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventMethodInstance",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: "onClick Instance",
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },
        callback: function (node) {
          context.node15 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node16,
        source: context.node15,
        properties: {
          type: "MethodCall",
          MethodCall: {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethod",
        properties: {
          EventType: "onClick",
          text: "onClick"
        },
        links: [function (graph) {
          return [{
            target: context.node5,
            linkProperties: {
              properties: {
                type: "EventMethod",
                EventMethod: {}
              }
            }
          }];
        }],
        callback: function (node) {
          context.node17 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethodInstance",
        parent: context.node17,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventMethodInstance",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: "onClick Instance",
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },
        callback: function (node) {
          context.node18 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node19,
        source: context.node18,
        properties: {
          type: "MethodCall",
          MethodCall: {}
        }
      }
    }];
  }, ...[].interpolate(0, 20, x => {
    if (x !== 2) {
      return {
        operation: "CHANGE_NODE_PROPERTY",
        options: function () {
          return {
            prop: "Pinned",
            id: context["node" + x],
            value: false
          };
        }
      };
    }

    return null;
  }).filter(x => x)];
});
// CONCATENATED MODULE: ./app/nodepacks/AddNavigateBackHandler.js
/* harmony default export */ var AddNavigateBackHandler = (function (args = {}) {
  // node0
  let context = {
    node0: args.button,
    evt: args.evt || "onClick",
    ...args
  };
  return [function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethod",
        properties: {
          EventType: context.evt,
          text: context.evt
        },
        links: [function (graph) {
          return [{
            target: context.node0,
            linkProperties: {
              properties: {
                type: "EventMethod",
                EventMethod: {}
              }
            }
          }];
        }],
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethodInstance",
        parent: context.node1,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventMethodInstance",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: `${context.evt} Instance`,
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },
        callback: function (node) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "NavigationAction",
        linkProperties: {
          properties: {
            type: "NavigationMethod",
            NavigationMethod: {}
          }
        },
        parent: context.node2,
        properties: {
          text: "GoBack",
          NavigationAction: "GoBack"
        },
        callback: function (node) {
          context.node3 = node.id;
        }
      }
    }];
  }, ...[].interpolate(0, 4, x => {
    return {
      operation: "CHANGE_NODE_PROPERTY",
      options: function () {
        return {
          prop: "Pinned",
          id: context["node" + x],
          value: false
        };
      }
    };
  }).filter(x => x)];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateSelectorToDataChainSelectorDC.js

/* harmony default export */ var CreateSelectorToDataChainSelectorDC = (function (args = {}) {
  // node2,node4,node5
  let context = { ...args,
    node2: uuidv4(),
    node4: args.model,
    node5: args.property
  };
  return [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: `Get Selector DataChain Value ${args.viewName} ${args.viewType} ${args.propertyName} ${args.external_api} ${args.screen} ${args.uiType}`
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "NavigationAction"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "UIType",
        id: context.node0,
        value: args.uiType
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, groupId) {
          context.node1 = node.id;
          context.node2 = groupId || context.node2;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => x ? x.object : null"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.node2
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node3,
        value: "Model - Property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node3,
        value: context.node4
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node4,
        source: context.node3,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Property",
        id: context.node3,
        value: context.node5
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node5,
        source: context.node3,
        properties: {
          type: "property-link",
          "property-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node3,
        value: "Get model property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "data-chain",
        groupProperties: {
          id: context.node2
        },
        properties: {
          ChainParent: context.node3
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node) {
          context.node6 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node6,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node6,
        value: "complete"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node6,
        value: true
      }
    }];
  }, ...[].interpolate(0, 7, x => {
    if (x !== 4 && x !== 5 && x !== 2) {
      return {
        operation: "CHANGE_NODE_PROPERTY",
        options: function () {
          return {
            prop: "Pinned",
            id: context["node" + x],
            value: false
          };
        }
      };
    }

    return null;
  }).filter(x => x), function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/ConnectListViewModelToExternalViewModel.js
/* harmony default export */ var ConnectListViewModelToExternalViewModel = (function (args = {}) {
  // node0,node1
  //
  let context = { ...args,
    node0: args.target,
    node1: args.source
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node0,
        source: context.node1,
        properties: {
          type: "component-external-connection",
          "component-external-connection": {},
          nodeTypes: ["ComponentApi"]
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/LoadModel.js
/* eslint-disable func-names */


/* harmony default export */ var LoadModel = (function (args = {}) {
  //
  if (!args.model_view_name) {
    throw "missing model_view_name argument";
  }

  if (!args.model_item) {
    throw "missing model_item argument";
  } // model_view_name, model_item


  let context = { ...args
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (_graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Load " + args.model_view_name + ""
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: UPDATE_NODE_PROPERTY,
      options: {
        id: context.node0,
        properties: { ...viewPackages
        }
      }
    }];
  }, function (_graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ...viewPackages,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],

        callback(node, _graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }

      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => useParameters()"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "read parameters"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, _graph, _group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: false
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Lambda"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node2,
        value: "params => {\n   let { value, viewModel } = params;\n   let dispatch = GetDispatch();\n   let getState = GetState();\n   let currentItem = GetK(getState(), UI_MODELS, " + args.model_item + ", value);\n   if(currentItem) {\n\tdispatch(clearScreenInstance(viewModel, currentItem?currentItem.id:null, currentItem)); \n\tdispatch(updateScreenInstanceObject(viewModel,currentItem?currentItem.id:null, { ...currentItem }));\n   }\n\n   return params;\n}"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "update local"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/ConnectLifecycleMethodToDataChain.js


/* harmony default export */ var ConnectLifecycleMethodToDataChain = (function (args = {}) {
  // node0,node2
  if (!args.lifeCycleMethod) {
    throw "missing life cylcle method";
  }

  if (!args.dataChain) {
    throw "missing data chain";
  }

  let context = { ...args,
    node0: args.lifeCycleMethod,
    node2: args.dataChain
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    if (typeof args.lifeCycleMethod === "function") {
      context.node0 = args.lifeCycleMethod(graph);
    }

    if (typeof args.dataChain === "function") {
      context.node2 = args.dataChain(graph);
    }

    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "LifeCylceMethodInstance",
        parent: context.node0,
        groupProperties: {},
        linkProperties: {
          properties: { ...uiactions_LinkProperties.LifeCylceMethodInstance
          }
        },
        properties: { ...viewPackages,
          text: "componentDidMount Instance",
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node2,
        source: context.node1,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/SetLinkInstanceUpdateTrue.js

/* harmony default export */ var SetLinkInstanceUpdateTrue = (function (args = {}) {
  // node0
  //
  if (!args.link) {
    throw "requires a link to update the instance update";
  }

  let context = { ...args,
    node0: args.link
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "UPDATE_LINK_PROPERTY",
      options: {
        id: context.node0,
        prop: "InstanceUpdate",
        value: true
      }
    }];
  }];
  let clearPinned = [];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/SetModelsApiLinkForInstanceUpdate.js





/* harmony default export */ var SetModelsApiLinkForInstanceUpdate = (function (args = {}) {
  let {
    graph,
    viewPackage
  } = args;
  graph = graph || GetCurrentGraph();

  if (!viewPackage) {
    throw "no view package";
  }

  let components = GetNodesByProperties({
    [nodetypes_NodeProperties.ViewPackage]: viewPackage,
    [nodetypes_NodeProperties.NODEType]: NodeTypes.ComponentNode
  }, graph);
  let result = [];
  components.map(component => {
    let externalNodes = GetNodesLinkedTo(graph, {
      id: component.id,
      link: nodetypes_LinkType.ComponentExternalApi
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentExternalApi);
    externalNodes.map(externalNode => {
      let externalConnections = GetNodesLinkedTo(graph, {
        id: externalNode.id,
        link: nodetypes_LinkType.ComponentExternalConnection
      });
      externalConnections.map(externalConnection => {
        let link = GetLinkBetween(externalNode.id, externalConnection.id, graph);
        if (link) result.push(...SetLinkInstanceUpdateTrue({
          link: link.id
        }));
      });
    });
    let eventMethods = GetNodesLinkedTo(graph, {
      id: component.id,
      link: nodetypes_LinkType.EventMethod
    });
    eventMethods.map(eventMethod => {
      let eventMethodInstances = GetNodesLinkedTo(graph, {
        id: eventMethod.id,
        link: nodetypes_LinkType.EventMethodInstance
      });
      eventMethodInstances.map(eventMethodInstance => {
        let link = GetLinkBetween(eventMethod.id, eventMethodInstance.id, graph);
        if (link) result.push(...SetLinkInstanceUpdateTrue({
          link: link.id
        }));
      });
    });
  });
  return result;
});
// CONCATENATED MODULE: ./app/nodepacks/GetModelViewModelForList.js

/* harmony default export */ var GetModelViewModelForList = (function (args = {}) {
  // node2,node3
  //
  let context = { ...args,
    node2: args.model,
    node3: args.viewModel
  };
  let {
    modelViewName
  } = context;
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: `Get ${modelViewName} Model VM key`
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: null,
        properties: {
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: false
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: false
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "ModelKey"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "ModelKey",
        id: context.node1,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node1,
        properties: {
          type: "ModelKey",
          ModelKey: {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get item view model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node0,
        source: context.node3,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/SetupViewModelOnScreen.js




/* harmony default export */ var SetupViewModelOnScreen = (function (args = {}) {
  let {
    screen,
    graph
  } = args;
  graph = graph || GetCurrentGraph();
  let externalNode = GetNodesLinkedTo(graph, {
    id: screen,
    link: nodetypes_LinkType.ComponentExternalApi
  }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentExternalApi && GetNodeTitle(x) === ApiNodeKeys.ViewModel);

  if (externalNode && args.model) {
    return GetModelViewModelForList({
      viewModel: externalNode.id,
      modelViewName: GetNodeTitle(args.model),
      ...args
    });
  }
});
// CONCATENATED MODULE: ./app/nodepacks/AppendGetIdsToDataChain.js


/* harmony default export */ var AppendGetIdsToDataChain = (function (args = {}) {
  // node0,node1
  //
  if (!args.dataChain) {
    throw "missing data chain to append getIds data chain node";
  }

  if (!args.dataChainGroup) {
    throw "missing data chain group to append getIds data chain node";
  }

  let context = { ...args,
    node0: args.dataChain,
    node1: args.dataChainGroup
  };
  let {
    viewPackages = {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4()
    }
  } = args;
  let result = [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node0,
        value: false
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          id: context.node1
        },
        properties: {
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Get Model Ids"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "get ids"
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/GetModelViewModelForUpdate.js



/* harmony default export */ var GetModelViewModelForUpdate = (function (args = {}) {
  // node2
  // screen
  if (!args.screen) {
    throw "missing screen argument";
  }

  let context = { ...args,
    node2: args.viewModel
  };
  let {
    viewPackages = {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4()
    }
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get " + args.screen + " view model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "ViewModelKey"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "ViewModelKey",
        id: context.node1,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node1,
        properties: {
          type: "ViewModelKey",
          ViewModelKey: {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get form view model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "ViewModelKey",
        id: context.node1,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node1,
        properties: {
          type: "ViewModelKey",
          ViewModelKey: {}
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: UPDATE_NODE_PROPERTY,
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }, {
    operation: UPDATE_NODE_PROPERTY,
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }, {
    operation: UPDATE_NODE_PROPERTY,
    options: function () {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/constants/nodepackages.js


/* eslint-disable compat/compat */

/* eslint-disable no-new */

/* eslint-disable no-constant-condition */

/* eslint-disable camelcase */

/* eslint-disable func-names */























const GetSpecificModels = {
  type: "get-specific-models",
  method: args => {
    const {
      model,
      dispatch,
      getState
    } = args; // Check for existing method of this type
    // if no methods exist, then create a new method.
    // graph = GraphMethods.addNewNodeOfType(graph, options, NodeTypes.Model);

    const agents = GetAgentNodes();
    agents.map(agent => {
      let methodProps;

      if (ModelNotConnectedToFunction(agent.id, model.id, GetSpecificModels.type)) {
        const context = {};
        const outer_commands = [{
          operation: ADD_NEW_NODE,
          options: {
            nodeType: NodeTypes.Method,
            parent: model.id,
            groupProperties: {},
            properties: {
              [nodetypes_NodeProperties.NodePackage]: model.id,
              [nodetypes_NodeProperties.NodePackageType]: GetSpecificModels.type,
              [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
              [nodetypes_NodeProperties.FunctionType]: functiontypes_FunctionTypes.Get_Object_Agent_Value__IListObject_By_Specific,
              [nodetypes_NodeProperties.MethodType]: nodetypes_Methods.GetAll,
              [nodetypes_NodeProperties.HttpMethod]: HTTP_METHODS.POST,
              [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(model)} Get Specific Objects`
            },
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.FunctionOperator
              }
            },
            callback: methodNode => {
              context.methodNode = methodNode;
            }
          }
        }, function () {
          const {
            methodNode
          } = context;
          const {
            constraints
          } = MethodFunctions[functiontypes_FunctionTypes.Get_Object_Agent_Value__IListObject_By_Specific];
          let perOrModelNode = null;
          let commands = [];
          Object.values(constraints).forEach(constraint => {
            switch (constraint.key) {
              case FunctionTemplateKeys.Model:
              case FunctionTemplateKeys.Agent:
              case FunctionTemplateKeys.User:
              case FunctionTemplateKeys.ModelOutput:
                methodProps = { ...methodProps,
                  ...(uiactions_GetNodeProp(GetNodeById(methodNode.id), nodetypes_NodeProperties.MethodProps) || {})
                };

                if (constraint[nodetypes_NodeProperties.IsAgent]) {
                  methodProps[constraint.key] = agent.id;
                } else if (constraint.key === FunctionTemplateKeys.User) {
                  methodProps[constraint.key] = uiactions_GetNodeProp(GetNodeById(agent.id), nodetypes_NodeProperties.UIUser) || GetUsers()[0].id;
                } else {
                  methodProps[constraint.key] = model.id;
                }

                break;

              case FunctionTemplateKeys.Permission:
              case FunctionTemplateKeys.ModelFilter:
                PerformGraphOperation([{
                  operation: ADD_NEW_NODE,
                  options: {
                    parent: methodNode.id,
                    nodeType: constraint.key === FunctionTemplateKeys.Permission ? NodeTypes.Permission : NodeTypes.ModelFilter,
                    groupProperties: {},
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.NodePackageType]: GetSpecificModels.type,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(methodNode)} ${constraint.key === FunctionTemplateKeys.Permission ? NodeTypes.Permission : NodeTypes.ModelFilter}`
                    },
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.FunctionOperator
                      }
                    },
                    callback: newNode => {
                      methodProps = { ...methodProps,
                        ...(uiactions_GetNodeProp(GetNodeById(methodNode.id), nodetypes_NodeProperties.MethodProps) || {})
                      };
                      methodProps[constraint.key] = newNode.id;
                      perOrModelNode = newNode;
                    }
                  }
                }])(dispatch, getState);

                if (constraint.key === FunctionTemplateKeys.ModelFilter) {
                  commands = [...commands, {
                    operation: CHANGE_NODE_PROPERTY,
                    options: {
                      prop: nodetypes_NodeProperties.FilterAgent,
                      id: perOrModelNode.id,
                      value: agent.id
                    }
                  }, {
                    operation: CHANGE_NODE_PROPERTY,
                    options: {
                      prop: nodetypes_NodeProperties.FilterModel,
                      id: perOrModelNode.id,
                      value: model.id
                    }
                  }, {
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,
                    options: {
                      target: model.id,
                      source: perOrModelNode.id,
                      properties: { ...nodetypes_LinkProperties.ModelTypeLink
                      }
                    }
                  }, {
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,
                    options: {
                      target: agent.id,
                      source: perOrModelNode.id,
                      properties: { ...nodetypes_LinkProperties.AgentTypeLink
                      }
                    }
                  }];
                }

                break;

              default:
                break;
            }

            commands = [...commands, ...[{
              operation: CHANGE_NODE_PROPERTY,
              options: {
                prop: nodetypes_NodeProperties.MethodProps,
                id: methodNode.id,
                value: methodProps
              }
            }, {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,
              options: {
                target: methodProps[constraint.key],
                source: methodNode.id,
                properties: { ...nodetypes_LinkProperties.FunctionOperator
                }
              }
            }]];
          });

          if (ModelNotConnectedToFunction(agent.id, model.id, GetSpecificModels.type, NodeTypes.Controller)) {
            const subcontext = {};
            commands.push({
              operation: ADD_NEW_NODE,
              options: {
                nodeType: NodeTypes.Controller,
                properties: {
                  [nodetypes_NodeProperties.NodePackage]: model.id,
                  [nodetypes_NodeProperties.NodePackageType]: GetSpecificModels.type,
                  [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
                  [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(model)} ${GetNodeTitle(agent)} Controller`
                },
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.FunctionOperator
                  }
                },
                callback: controllerNode => {
                  subcontext.controllerNode = controllerNode;
                }
              }
            }, () => {
              const {
                controllerNode
              } = context;

              if (ModelNotConnectedToFunction(agent.id, model.id, GetSpecificModels.type, NodeTypes.Maestro)) {
                return PerformGraphOperation([{
                  operation: ADD_NEW_NODE,
                  options: {
                    nodeType: NodeTypes.Maestro,
                    parent: controllerNode.id,
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.NodePackageType]: GetSpecificModels.type,
                      [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(model)} ${GetNodeTitle(agent)} Maestro`
                    },
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.MaestroLink
                      }
                    },
                    callback: maestroNode => {
                      subcontext.maestroNode = maestroNode;
                    }
                  }
                }]);
              }
            }, () => {
              const {
                maestroNode
              } = subcontext;
              return [{
                operation: uiactions_ADD_LINK_BETWEEN_NODES,
                options: {
                  target: methodNode.id,
                  source: maestroNode.id,
                  properties: { ...nodetypes_LinkProperties.FunctionLink
                  }
                }
              }];
            });
          }

          PerformGraphOperation(commands)(dispatch, getState);
        }];
        PerformGraphOperation(outer_commands)(dispatch, getState);
      }
    });
  },
  methodType: functiontypes_FunctionTypes.Get_Object_Agent_Value__IListObject_By_Specific
};
const GetAllModels = {
  type: "get-all-models",
  method: CreateFunction({
    nodePackageType: "get-all-models",
    methodType: nodetypes_Methods.GetAll,
    httpMethod: HTTP_METHODS.GET,
    functionType: functiontypes_FunctionTypes.Get_Agent_Value__IListObject,
    functionName: `Get All`
  }),
  methodType: functiontypes_FunctionTypes.Get_Agent_Value__IListObject
};
const CreateLoginModels = {
  type: "Build Login",
  methodType: "Login Models",
  method: (args = {}) => {
    // let currentGraph = GetCurrentGraph(GetStateFunc()());
    // currentGraph = newNode(currentGraph);
    const nodePackageType = "login-models";
    const nodePackage = "login-models";
    const viewPackage = {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
      [nodetypes_NodeProperties.NodePackage]: nodePackage,
      [nodetypes_NodeProperties.NodePackageType]: nodePackageType
    };
    const newStuff = {};
    setViewPackageStamp(viewPackage, "create-login-models");
    PerformGraphOperation([{
      operation: ADD_NEW_NODE,
      options: {
        nodeType: NodeTypes.Model,
        // groupProperties: {},
        properties: { ...viewPackage,
          [nodetypes_NodeProperties.ExcludeFromController]: true,
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UIText]: `Red Login Model`
        },
        callback: newNode => {
          newStuff.loginModel = newNode.id;
        }
      }
    }, function () {
      return [{
        propName: "User Name"
      }, {
        propName: "Password"
      }, {
        propName: "Remember Me"
      }].map(v => {
        const {
          propName
        } = v;
        return {
          operation: ADD_NEW_NODE,
          options: {
            nodeType: NodeTypes.Property,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.PropertyLink
              }
            },
            groupProperties: {},
            parent: newStuff.loginModel,
            properties: { ...viewPackage,
              [nodetypes_NodeProperties.Pinned]: false,
              [nodetypes_NodeProperties.UIAttributeType]: uiactions_NodePropertyTypes.STRING,
              [nodetypes_NodeProperties.UIText]: propName
            }
          }
        };
      });
    }, {
      operation: ADD_NEW_NODE,
      options: {
        nodeType: NodeTypes.Model,
        // groupProperties: {},
        properties: { ...viewPackage,
          [nodetypes_NodeProperties.ExcludeFromController]: true,
          [nodetypes_NodeProperties.UIText]: `Red Register View Model`,
          [nodetypes_NodeProperties.Pinned]: false
        },
        callback: newNode => {
          // methodProps = { ...methodProps, ...(GetNodeProp(GetNodeById(methodNode.id), NodeProperties.MethodProps) || {}) };
          // methodProps[constraint.key] = newNode.id;
          // perOrModelNode = newNode;
          newStuff.registerModel = newNode.id;
        }
      }
    }, function () {
      return [{
        propName: "User Name"
      }, {
        propName: "Email",
        propType: uiactions_NodePropertyTypes.EMAIL
      }, {
        propName: "Password"
      }, {
        propName: "Confirm Password"
      }].map(v => {
        const {
          propName,
          propType
        } = v;
        return {
          operation: ADD_NEW_NODE,
          options: {
            nodeType: NodeTypes.Property,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.PropertyLink
              }
            },
            groupProperties: {},
            parent: newStuff.registerModel,
            properties: {
              [nodetypes_NodeProperties.NodePackage]: nodePackage,
              [nodetypes_NodeProperties.UIAttributeType]: propType || uiactions_NodePropertyTypes.STRING,
              [nodetypes_NodeProperties.Pinned]: false,
              [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
              [nodetypes_NodeProperties.UIText]: propName
            }
          }
        };
      });
    }, {
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.Controller,
          properties: { ...viewPackage,
            [nodetypes_NodeProperties.ExcludeFromGeneration]: true,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.UIText]: "Authorization"
          },
          callback: node => {
            newStuff.controller = node.id;
          }
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.Maestro,
          parent: newStuff.controller,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.MaestroLink
            }
          },
          properties: { ...viewPackage,
            [nodetypes_NodeProperties.ExcludeFromGeneration]: true,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.UIText]: "Authorization Maestro"
          },
          callback: node => {
            newStuff.maestro = node.id;
          }
        };
      }

    }, function (graph) {
      newStuff.graph = graph;
      return [];
    }])(GetDispatchFunc(), GetStateFunc());
    const regsterResult = CreateAgentFunction({
      viewPackage,
      model: GetNodeById(newStuff.registerModel, newStuff.graph),
      agent: {},
      maestro: newStuff.maestro,
      nodePackageType: "register-user",
      methodType: nodetypes_Methods.Create,
      user: uiactions_NodesByType(GetState(), NodeTypes.Model).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsUser)),
      httpMethod: HTTP_METHODS.POST,
      functionType: functiontypes_FunctionTypes.Register,
      functionName: `Register`
    })({
      dispatch: GetDispatchFunc(),
      getState: GetStateFunc()
    });
    const loginResult = CreateAgentFunction({
      viewPackage,
      model: GetNodeById(newStuff.loginModel, newStuff.graph),
      agent: {},
      maestro: newStuff.maestro,
      nodePackageType: "login-user",
      methodType: nodetypes_Methods.Create,
      user: uiactions_NodesByType(GetState(), NodeTypes.Model).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsUser)),
      httpMethod: HTTP_METHODS.POST,
      functionType: functiontypes_FunctionTypes.Login,
      functionName: `Authenticate`
    })({
      dispatch: GetDispatchFunc(),
      getState: GetStateFunc()
    });
    let viewName = "Authenticate";
    args = args || {};
    let chosenChildren = GetModelPropertyChildren(newStuff.loginModel).map(x => x.id);
    let method_results = CreateDefaultView.method({
      viewName,
      dispatch: GetDispatchFunc(),
      getState: GetStateFunc(),
      model: GetNodeById(newStuff.loginModel, newStuff.graph),
      isSharedComponent: false,
      isDefaultComponent: false,
      isPluralComponent: false,
      uiTypes: {
        [UITypes.ReactNative]: args[UITypes.ReactNative] || false,
        [UITypes.ElectronIO]: args[UITypes.ElectronIO] || false,
        [UITypes.VR]: args[UITypes.VR] || false,
        [UITypes.Web]: args[UITypes.Web] || false
      },
      chosenChildren,
      viewName: `${viewName}`,
      viewType: viewtypes_ViewTypes.Create
    });
    const authenticateScreen = method_results.screenNodeId;
    addInstanceEventsToForms({
      method_results,
      targetMethod: loginResult.methodNode.id
    });

    if (method_results.instanceFunc) {
      PerformGraphOperation([...PostAuthenticate({
        screen: null,
        functionName: "Post Authenticate ReactNative",
        pressInstance: method_results.instanceFunc.onPress
      }), ...PostAuthenticate({
        screen: null,
        functionName: "Post Authenticate ElectronIo",
        clickInstance: method_results.instanceFunc.onClick
      })])(GetDispatchFunc(), GetStateFunc());
    }

    viewName = "Register";
    chosenChildren = GetModelPropertyChildren(newStuff.registerModel).map(x => x.id);
    method_results = CreateDefaultView.method({
      viewName,
      dispatch: GetDispatchFunc(),
      getState: GetStateFunc(),
      model: GetNodeById(newStuff.registerModel, newStuff.graph),
      isSharedComponent: false,
      isDefaultComponent: false,
      isPluralComponent: false,
      uiTypes: {
        [UITypes.ReactNative]: args[UITypes.ReactNative] || false,
        [UITypes.ElectronIO]: args[UITypes.ElectronIO] || false,
        [UITypes.VR]: args[UITypes.VR] || false,
        [UITypes.Web]: args[UITypes.Web] || false
      },
      chosenChildren,
      viewName: `${viewName}`,
      viewType: viewtypes_ViewTypes.Create
    });
    addInstanceEventsToForms({
      method_results,
      targetMethod: regsterResult.methodNode.id
    });
    const registerScreen = method_results.screenNodeId;

    if (method_results.instanceFunc) {
      PerformGraphOperation([...PostRegister({
        screen: authenticateScreen,
        name: "Post Register ReactNative",
        pressInstance: method_results.instanceFunc.onPress
      }), ...PostRegister({
        screen: authenticateScreen,
        name: "Post Register ElectronIO",
        clickInstance: method_results.instanceFunc.onClick
      })])(GetDispatchFunc(), GetStateFunc());
    }

    const titleService = GetNodeByProperties({
      [nodetypes_NodeProperties.NODEType]: NodeTypes.TitleService
    });
    PerformGraphOperation(HomeView({
      titleService: titleService.id,
      registerForm: registerScreen,
      authenticateForm: authenticateScreen
    }))(GetDispatchFunc(), GetStateFunc());
    setViewPackageStamp(null, "create-login-models");
  }
};

function addTitleService(args) {
  const {
    newItems
  } = args;
  return {
    operation: ADD_NEW_NODE,

    options(graph) {
      const $node = GetNodeByProperties({
        [nodetypes_NodeProperties.UIText]: `Title Service`,
        [nodetypes_NodeProperties.NODEType]: NodeTypes.TitleService
      }, graph);

      if ($node) {
        newItems.titleService = $node.id;
        return false;
      }

      return {
        nodeType: NodeTypes.TitleService,
        properties: {
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UIText]: `Title Service`
        },
        callback: res => {
          newItems.titleService = res.id;
        }
      };
    }

  };
}

function addInstanceEventsToForms(args) {
  const {
    method_results,
    targetMethod
  } = args;

  if (method_results && method_results.formButton) {
    PerformGraphOperation([{
      operation: CHANGE_NODE_PROPERTY,

      options() {
        return {
          prop: nodetypes_NodeProperties.Pinned,
          value: false,
          id: method_results.formButton
        };
      }

    }])(GetDispatchFunc(), GetStateFunc());

    if (method_results.formButtonApi) {
      const context = {
        evts: {}
      };
      PerformGraphOperation([...Object.keys(method_results.formButtonApi).map(evt => {
        return {
          operation: ADD_NEW_NODE,

          options(graph) {
            const currentNode = GetNodeById(method_results.formButtonApi[evt], graph);
            return addInstanceFunc(currentNode, instanceFuncNode => {
              context.evts[evt] = {};
              context.evts[evt].instanceFuncNode = instanceFuncNode;
            })();
          }

        };
      }), function (graph) {
        return Object.keys(context.evts).map(evt => {
          const {
            instanceFuncNode
          } = context.evts[evt];
          method_results.instanceFunc = method_results.instanceFunc || {};
          method_results.instanceFunc[evt] = instanceFuncNode.id;
          const source = instanceFuncNode.id;
          const target = targetMethod;
          return ConnectLifecycleMethod({
            target,
            source,
            graph
          });
        });
      }])(GetDispatchFunc(), GetStateFunc());
    }
  }
}

const AddAgentUser = {
  type: "add-agent-user",
  methodType: "Add User Agent",
  method: () => {
    let userId = null;
    PerformGraphOperation([{
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.Model,
          callback: node => {
            userId = node.id;
          },
          properties: {
            [nodetypes_NodeProperties.UIText]: `User`,
            [nodetypes_NodeProperties.IsUser]: true,
            [nodetypes_NodeProperties.IsAgent]: true
          }
        };
      }

    }, {
      operation: CHANGE_NODE_PROPERTY,

      options() {
        return {
          id: userId,
          prop: nodetypes_NodeProperties.UIUser,
          value: userId
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.Model,
          properties: {
            [nodetypes_NodeProperties.UIText]: `Agent`,
            [nodetypes_NodeProperties.IsAgent]: true,
            [nodetypes_NodeProperties.UIUser]: userId
          },
          links: [{
            target: userId,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.UserLink
              }
            }
          }]
        };
      }

    }])(GetDispatchFunc(), GetStateFunc());
  }
};
function CreatePagingSkipDataChains() {
  const result = {};
  let skipResult = false;
  let arrayLengthNode = null;
  let defaultPagingValue = null;
  PerformGraphOperation([{
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.IsDataChainPagingSkip]: true,
        [nodetypes_NodeProperties.EntryPoint]: true
      }, graph);

      if (model) {
        result.pagingSkip = model.id;
        skipResult = true;
        return false;
      }

      return {
        nodeType: NodeTypes.DataChain,
        callback: node => {
          result.pagingSkip = node.id;
        },
        properties: {
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
          [nodetypes_NodeProperties.UIText]: "Paging Skip",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.IsDataChainPagingSkip]: true,
          [nodetypes_NodeProperties.EntryPoint]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(graph) {
      if (skipResult) {
        return false;
      }

      const temp = SplitDataCommand(GetNodeById(result.pagingSkip, graph), split => {
        result.pagingSkipOuput = split.id;
      }, {
        [nodetypes_NodeProperties.Pinned]: false,
        [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
        [nodetypes_NodeProperties.UIText]: "Paging Skip Ouput",
        [nodetypes_NodeProperties.AsOutput]: true
      });
      return temp.options;
    }

  }, function (graph) {
    if (skipResult) {
      return false;
    }

    return InsertNodeInbetween(GetNodeById(result.pagingSkip, graph), result.pagingSkipOuput, graph, insertedNode => {
      arrayLengthNode = insertedNode.id;
    }, {
      [nodetypes_NodeProperties.Pinned]: false
    });
  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipResult) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.DataChainFunctionType,
        value: DataChainFunctionKeys.ArrayLength,
        id: arrayLengthNode
      };
    }

  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipResult) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.UIText,
        value: `Paging ${DataChainFunctionKeys.ArrayLength}`,
        id: arrayLengthNode
      };
    }

  }, function (graph) {
    if (skipResult) {
      return false;
    }

    return InsertNodeInbetween(GetNodeById(arrayLengthNode, graph), result.pagingSkipOuput, graph, insertedNode => {
      defaultPagingValue = insertedNode.id;
    }, {
      [nodetypes_NodeProperties.Pinned]: false
    });
  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipResult) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.DataChainFunctionType,
        value: DataChainFunctionKeys.NumericalDefault,
        id: defaultPagingValue
      };
    }

  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipResult) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.UIText,
        value: `Paging ${DataChainFunctionKeys.NumericalDefault}`,
        id: defaultPagingValue
      };
    }

  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipResult) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.NumberParameter,
        value: "0",
        id: defaultPagingValue
      };
    }

  }])(GetDispatchFunc(), GetStateFunc());
  return result;
}
function CreatePagingTakeDataChains() {
  const result = {};
  let skipTake = false;
  let defaultPagingValue = null;
  PerformGraphOperation([{
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.IsDataChainPagingTake]: true,
        [nodetypes_NodeProperties.EntryPoint]: true
      }, graph);

      if (model) {
        result.pagingTake = model.id;
        skipTake = true;
        return false;
      }

      return {
        nodeType: NodeTypes.DataChain,
        callback: node => {
          result.pagingTake = node.id;
        },
        properties: {
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
          [nodetypes_NodeProperties.UIText]: "Paging Take",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.IsDataChainPagingTake]: true,
          [nodetypes_NodeProperties.EntryPoint]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(graph) {
      if (skipTake) {
        return false;
      }

      const temp = SplitDataCommand(GetNodeById(result.pagingTake, graph), split => {
        result.pagingTakeOuput = split.id;
      }, {
        [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
        [nodetypes_NodeProperties.Pinned]: false,
        [nodetypes_NodeProperties.UIText]: "Paging Take Ouput",
        [nodetypes_NodeProperties.AsOutput]: true
      });
      return temp.options;
    }

  }, function (graph) {
    if (skipTake) {
      return false;
    }

    return InsertNodeInbetween(GetNodeById(result.pagingTake, graph), result.pagingTakeOuput, graph, insertedNode => {
      defaultPagingValue = insertedNode.id;
    });
  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipTake) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.DataChainFunctionType,
        value: DataChainFunctionKeys.NumericalDefault,
        id: defaultPagingValue
      };
    }

  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipTake) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.UIText,
        value: `Paging ${DataChainFunctionKeys.NumericalDefault}`,
        id: defaultPagingValue
      };
    }

  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipTake) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.NumberParameter,
        value: "50",
        id: defaultPagingValue
      };
    }

  }, {
    operation: CHANGE_NODE_PROPERTY,

    options() {
      if (skipTake) {
        return false;
      }

      return {
        prop: nodetypes_NodeProperties.Pinned,
        value: false,
        id: defaultPagingValue
      };
    }

  }])(GetDispatchFunc(), GetStateFunc());
  return result;
}
function CreateScreenModel(viewModel, options = {
  isList: true
}) {
  const result = {};
  let pageModelId = null;
  let skip = false;
  PerformGraphOperation([{
    operation: ADD_NEW_NODE,

    options(graph) {
      const $node = GetNodeByProperties({
        [nodetypes_NodeProperties.ExcludeFromController]: true,
        [nodetypes_NodeProperties.UIText]: viewModel + " Model",
        [nodetypes_NodeProperties.IsViewModel]: true
      }, graph);

      if ($node) {
        pageModelId = $node.id;
        result.model = pageModelId;
        skip = true;
        return false;
      }

      return {
        nodeType: NodeTypes.Model,
        callback: pageModel => {
          pageModelId = pageModel.id;
          result.model = pageModelId;
        },
        properties: {
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.ExcludeFromController]: true,
          [nodetypes_NodeProperties.UIText]: viewModel + " Model",
          [nodetypes_NodeProperties.IsViewModel]: true
        }
      };
    }

  }, options && options.isList ? {
    operation: ADD_NEW_NODE,

    options() {
      if (skip) {
        return false;
      }

      return {
        nodeType: NodeTypes.Property,
        callback: skipModel => {
          result.list = skipModel.id;
        },
        parent: pageModelId,
        groupProperties: {},
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.PropertyLink
          }
        },
        properties: {
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UIText]: List
        }
      };
    }

  } : false])(GetDispatchFunc(), GetStateFunc());
  return result;
}
function createViewPagingDataChain(newItems, viewName, viewPackage, skipChain = true) {
  let skip = false;
  const skipOrTake = skipChain ? "Skip" : "Take";
  return function () {
    return [{
      // The data chain for a list screen
      operation: ADD_NEW_NODE,

      options(graph) {
        const $node = GetNodeByProperties({
          [nodetypes_NodeProperties.UIText]: skipChain ? `Get ${viewName} Skip` : `Get ${viewName} Take`,
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
          [nodetypes_NodeProperties.QueryParameterType]: skipChain ? QUERY_PARAMETER_KEYS.Skip : QUERY_PARAMETER_KEYS.Take,
          [nodetypes_NodeProperties.Model]: newItems.currentNode,
          [nodetypes_NodeProperties.PagingSkip]: skipChain,
          [nodetypes_NodeProperties.IsPaging]: true,
          [nodetypes_NodeProperties.PagingTake]: !skipChain,
          [nodetypes_NodeProperties.EntryPoint]: true
        }, graph);

        if ($node) {
          newItems.pagingEntry = $node.id;
          skip = true;
          return false;
        }

        return {
          nodeType: NodeTypes.DataChain,
          properties: {
            [nodetypes_NodeProperties.UIText]: skipChain ? `Get ${viewName} Skip` : `Get ${viewName} Take`,
            [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
            [nodetypes_NodeProperties.QueryParameterType]: skipChain ? QUERY_PARAMETER_KEYS.Skip : QUERY_PARAMETER_KEYS.Take,
            [nodetypes_NodeProperties.Model]: newItems.currentNode,
            [nodetypes_NodeProperties.PagingSkip]: skipChain,
            [nodetypes_NodeProperties.IsPaging]: true,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.PagingTake]: !skipChain,
            [nodetypes_NodeProperties.EntryPoint]: true,
            ...viewPackage
          },
          callback: res => {
            newItems.pagingEntry = res.id;
          }
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options(graph) {
        if (skip) {
          return false;
        }

        const $node = GetNodeByProperties({
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.ReferenceDataChain,
          [nodetypes_NodeProperties.UIText]: `${viewName} ${skipOrTake} VM Ref`,
          [nodetypes_NodeProperties.DataChainReference]: newItems.screenListDataChain
        }, graph);

        if ($node) {
          newItems.viewModelListRefNode = $node.id;
          return false;
        }

        const temp = SplitDataCommand(GetNodeById(newItems.pagingEntry, graph), split => {
          newItems.viewModelListRefNode = split.id;
        }, {
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.ReferenceDataChain,
          [nodetypes_NodeProperties.UIText]: `${viewName} ${skipOrTake} VM Ref`,
          [nodetypes_NodeProperties.DataChainReference]: newItems.screenListDataChain,
          [nodetypes_NodeProperties.Pinned]: true,
          ...viewPackage
        }, graph);
        return temp.options;
      }

    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        if (skip) {
          return false;
        }

        if (newItems.screenListDataChainAlreadyMade) {
          return false;
        }

        return {
          target: newItems.viewModelListRefNode,
          source: newItems.screenListDataChain,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options(graph) {
        if (skip) {
          return false;
        }

        const groupProperties = uiactions_GetNodeProp(newItems.viewModelListRefNode, nodetypes_NodeProperties.GroupParent, graph) ? {
          id: uiactions_getGroup(uiactions_GetNodeProp(newItems.viewModelListRefNode, nodetypes_NodeProperties.GroupParent, graph), graph).id
        } : null;
        const model = GetNodeByProperties({
          [skipChain ? nodetypes_NodeProperties.IsDataChainPagingSkip : nodetypes_NodeProperties.IsDataChainPagingTake]: true,
          [nodetypes_NodeProperties.EntryPoint]: true
        }, graph);
        const $node = GetNodeByProperties({
          [nodetypes_NodeProperties.UIText]: `${viewName} ${skipOrTake} Paging Ref`,
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.ReferenceDataChain,
          [nodetypes_NodeProperties.DataChainReference]: model ? model.id : null,
          [nodetypes_NodeProperties.ChainParent]: newItems.viewModelListRefNode
        }, graph);

        if ($node) {
          newItems.pagingRefNode = $node.id;
          return false;
        }

        return {
          parent: newItems.viewModelListRefNode,
          nodeType: NodeTypes.DataChain,
          groupProperties,
          properties: {
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.UIText]: `${viewName} ${skipOrTake} Paging Ref`,
            [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.ReferenceDataChain,
            [nodetypes_NodeProperties.DataChainReference]: model ? model.id : null,
            [nodetypes_NodeProperties.ChainParent]: newItems.viewModelListRefNode
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          },
          callback: v => {
            newItems.pagingRefNode = v.id;
          }
        };
      }

    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options(graph) {
        if (skip) {
          return false;
        }

        const model = GetNodeByProperties({
          [skipChain ? nodetypes_NodeProperties.IsDataChainPagingSkip : nodetypes_NodeProperties.IsDataChainPagingTake]: true,
          [nodetypes_NodeProperties.EntryPoint]: true
        }, graph);
        return {
          target: newItems.pagingRefNode,
          source: model ? model.id : null,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options(graph) {
        if (skip) {
          return false;
        }

        const groupProperties = uiactions_GetNodeProp(newItems.pagingRefNode, nodetypes_NodeProperties.GroupParent, graph) ? {
          id: uiactions_getGroup(uiactions_GetNodeProp(newItems.pagingRefNode, nodetypes_NodeProperties.GroupParent, graph), graph).id
        } : null;
        return {
          parent: newItems.pagingRefNode,
          nodeType: NodeTypes.DataChain,
          groupProperties,
          properties: {
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.ChainParent]: newItems.pagingRefNode,
            [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
            [nodetypes_NodeProperties.UIText]: `${viewName} ${skipOrTake} Output`,
            [nodetypes_NodeProperties.AsOutput]: true
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          }
        };
      }

    }];
  };
}
function CreatePagingModel() {
  let result = null;
  let pageModelId = null;
  let skipModelId = null;
  let takeModelId = null;
  let filterModelId = null;
  let sortModelId = null;
  PerformGraphOperation([{
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.IsPagingModel]: true,
        [nodetypes_NodeProperties.NODEType]: NodeTypes.Model
      }, graph);

      if (model) {
        pageModelId = model.id;
        return false;
      }

      return {
        nodeType: NodeTypes.Model,
        callback: pageModel => {
          pageModelId = pageModel.id;
        },
        properties: {
          [nodetypes_NodeProperties.ExcludeFromController]: true,
          [nodetypes_NodeProperties.UIText]: "Paging Model",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.IsPagingModel]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.PagingSkip]: true,
        [nodetypes_NodeProperties.NODEType]: NodeTypes.Property
      }, graph);

      if (model) {
        skipModelId = model.id;
        return false;
      }

      return {
        nodeType: NodeTypes.Property,
        callback: skipModel => {
          skipModelId = skipModel.id;
        },
        parent: pageModelId,
        groupProperties: {},
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.PropertyLink
          }
        },
        properties: {
          [nodetypes_NodeProperties.UIText]: "Skip",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.PagingSkip]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.PagingTake]: true,
        [nodetypes_NodeProperties.NODEType]: NodeTypes.Property
      }, graph);

      if (model) {
        takeModelId = model.id;
        return false;
      }

      return {
        nodeType: NodeTypes.Property,
        callback: takeModel => {
          takeModelId = takeModel.id;
        },
        parent: pageModelId,
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: "Take",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.PagingTake]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.PagingFilter]: true,
        [nodetypes_NodeProperties.NODEType]: NodeTypes.Property
      }, graph);

      if (model) {
        filterModelId = model.id;
        return false;
      }

      return {
        nodeType: NodeTypes.Property,
        callback: filterModel => {
          filterModelId = filterModel.id;
        },
        parent: pageModelId,
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: "Filter",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.PagingFilter]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options(graph) {
      const model = GetNodeByProperties({
        [nodetypes_NodeProperties.PagingSort]: true,
        [nodetypes_NodeProperties.NODEType]: NodeTypes.Property
      }, graph);

      if (model) {
        sortModelId = model.id;
        return false;
      }

      return {
        nodeType: NodeTypes.Property,
        callback: sortModel => {
          sortModelId = sortModel.id;
        },
        parent: pageModelId,
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.ExcludeFromController]: true,
          [nodetypes_NodeProperties.UIText]: "Sort",
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.PagingSort]: true
        }
      };
    }

  }])(GetDispatchFunc(), GetStateFunc());
  result = {
    pageModelId,
    skipModelId,
    takeModelId,
    filterModelId,
    sortModelId
  };
  return result;
}
const CreateDefaultView = {
  type: "Create View - Form",
  methodType: "React Native Views",

  method(_args) {
    const method_result = {};

    const default_View_method = (args = {}) => {
      let {
        viewName,
        isList
      } = args;
      let {
        model
      } = args;
      let {
        isPluralComponent = false
      } = args;
      const {
        viewType,
        isDefaultComponent,
        uiType = UITypes.ReactNative,
        isSharedComponent,
        connectedModel,
        chosenChildren = []
      } = args;
      const state = GetState();

      if (typeof model === 'string') {
        model = GetNodeById(model);
      }

      if (connectedModel) {
        if (uiactions_GetNodeProp(connectedModel, nodetypes_NodeProperties.NODEType) === NodeTypes.Model) {
          isPluralComponent = true;
        }
      }

      const currentNode = model || Node(state, Visual(state, SELECTED_NODE));
      let screenNodeId = null;
      let screenComponentId = null;
      let listComponentId = null;
      let screenNodeOptionId = null;
      let childComponents = [];
      const modelComponentSelectors = [];
      let layout = null;
      let listLayout = null;
      const viewModelNodeFocusId = null;
      const viewModelNodeBlurId = null;
      const createConnections = [];
      const createListConnections = [];
      viewName = viewName || GetNodeTitle(currentNode);
      const useModelInstance = [viewtypes_ViewTypes.Get, viewtypes_ViewTypes.GetAll, viewtypes_ViewTypes.Delete].some(v => viewType === v);
      const viewPackage = {
        [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
        [nodetypes_NodeProperties.ViewPackageTitle]: viewName
      };
      setViewPackageStamp(viewPackage, "CreateDefaultView");
      const newItems = {};
      let viewComponentType = null;
      let viewComponent = null;
      let multi_item_component = ComponentTypes[uiType].List.key;
      let needsLoadToScreenState = false;

      switch (viewType) {
        case viewtypes_ViewTypes.Update:
          needsLoadToScreenState = true;
          break;

        default:
          break;
      }

      switch (viewType) {
        case viewtypes_ViewTypes.Get:
        case viewtypes_ViewTypes.GetAll:
        case viewtypes_ViewTypes.Delete:
          viewComponentType = ComponentTypes[uiType].Text.key;
          viewComponent = ComponentTypes[uiType].Text;

          if (isPluralComponent && isSharedComponent) {
            isList = true;
            multi_item_component = ComponentTypes[uiType].MultiViewList.key;
          } else if (isSharedComponent) {
            isList = false;
          }

          break;

        default:
          viewComponentType = ComponentTypes[uiType].Input.key;
          viewComponent = ComponentTypes[uiType].Input;

          if (isPluralComponent && isSharedComponent) {
            isList = true;
            viewComponentType = ComponentTypes[uiType].Text.key;
            multi_item_component = ComponentTypes[uiType].MultiSelectList.key;
            viewComponent = ComponentTypes[uiType].Text;
          } else if (isSharedComponent) {
            isList = true;
            viewComponentType = ComponentTypes[uiType].Text.key;
            multi_item_component = ComponentTypes[uiType].SingleSelect.key;
            viewComponent = ComponentTypes[uiType].Text;
          }

          break;
      }

      let dataSourceId;
      const modelType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType);
      const isModel = modelType === NodeTypes.Model;

      if (isModel) {
        let modelChildren = GetModelPropertyChildren(currentNode.id);
        newItems.currentNode = currentNode.id;

        if (chosenChildren && chosenChildren.length) {
          modelChildren = modelChildren.filter(x => chosenChildren.some(v => v === x.id));
        }

        const modelProperties = modelChildren.filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsDefaultProperty));
        childComponents = modelProperties.map(() => null);
        const screenComponentEvents = [];

        if (isList) {
          CreatePagingModel();
          CreatePagingSkipDataChains();
          CreatePagingTakeDataChains();
        } // let pageViewModel = null;
        // if (!isSharedComponent) {
        //   pageViewModel = CreateScreenModel(viewName);
        // }


        PerformGraphOperation([!isSharedComponent ? {
          operation: ADD_NEW_NODE,

          options(graph) {
            const res = GetNodesByProperties({
              [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
              [nodetypes_NodeProperties.UIText]: `${viewName} Form`,
              [nodetypes_NodeProperties.ViewType]: viewType,
              [nodetypes_NodeProperties.Model]: currentNode.id
            }, graph).find(x => x);

            if (res) {
              screenNodeId = res.id;
              newItems.screenNodeId = res.id;
              method_result.screenNodeId = screenNodeId;
              return false;
            }

            return {
              nodeType: NodeTypes.Screen,
              callback: screenNode => {
                screenNodeId = screenNode.id;
                newItems.screenNodeId = screenNode.id;
              },
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                [nodetypes_NodeProperties.ViewType]: viewType,
                [nodetypes_NodeProperties.UIText]: `${viewName} Form`,
                [nodetypes_NodeProperties.Model]: currentNode.id
              }
            };
          }

        } : false, !isSharedComponent ? function (graph) {
          return addComponentApiToForm({
            newItems,
            text: "value",
            parent: newItems.screenNodeId,
            graph,
            isSingular: true
          });
        } : null, !isSharedComponent ? function (graph) {
          return addComponentApiToForm({
            newItems,
            text: ApiNodeKeys.ViewModel,
            parent: newItems.screenNodeId,
            graph,
            isSingular: true,
            internalProperties: {
              [nodetypes_NodeProperties.DefaultComponentApiValue]: useModelInstance ? false : GetCodeName(newItems.screenNodeId)
            }
          });
        } : null, //Adding load data chain
        ...(needsLoadToScreenState && false ? LoadModel({
          model_view_name: `${viewName} Load ${GetNodeTitle(currentNode)}`,
          model_item: `Models.${GetCodeName(currentNode)}`,
          callback: context => {
            newItems.dataChainForLoading = context.entry;
          }
        }) : []), {
          operation: ADD_NEW_NODE,

          options(graph) {
            const $node = GetNodeByProperties({
              [nodetypes_NodeProperties.UIText]: `Title Service`,
              [nodetypes_NodeProperties.NODEType]: NodeTypes.TitleService
            }, graph);

            if ($node) {
              newItems.titleService = $node.id;
              return false;
            }

            return {
              nodeType: NodeTypes.TitleService,
              properties: {
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UIText]: `Title Service`
              },
              callback: res => {
                newItems.titleService = res.id;
              }
            };
          }

        }, !isSharedComponent && isList ? {
          // The data chain for a list screen
          operation: ADD_NEW_NODE,

          options(graph) {
            const $node = GetNodeByProperties({
              [nodetypes_NodeProperties.UIText]: `${viewName} Screen DC`,
              [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Selector,
              [nodetypes_NodeProperties.Selector]: newItems.screenSelector,
              [nodetypes_NodeProperties.EntryPoint]: true,
              [nodetypes_NodeProperties.SelectorProperty]: SelectorPropertyKeys.Object
            }, graph);

            if ($node) {
              newItems.screenListDataChain = $node.id;
              newItems.screenListDataChainAlreadyMade = true;
              return false;
            }

            return {
              nodeType: NodeTypes.DataChain,
              properties: {
                [nodetypes_NodeProperties.UIText]: `${viewName} Screen DC`,
                [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Selector,
                [nodetypes_NodeProperties.Selector]: newItems.screenSelector,
                [nodetypes_NodeProperties.EntryPoint]: true,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.AsOutput]: true,
                [nodetypes_NodeProperties.SelectorProperty]: SelectorPropertyKeys.Object
              },
              links: [{
                target: newItems.screenSelector,
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.DataChainLink
                  }
                }
              }],
              callback: res => {
                newItems.screenListDataChain = res.id;
              }
            };
          }

        } : false, !isSharedComponent ? {
          operation: NEW_SCREEN_OPTIONS,

          options() {
            let formLayout = CreateLayout();
            formLayout = SetCellsLayout(formLayout, 1);
            const rootCellId = GetFirstCell(formLayout);
            const cellProperties = GetCellProperties(formLayout, rootCellId);
            cellProperties.style = { ...cellProperties.style,
              flexDirection: "column"
            };
            let componentProps = null;

            if (useModelInstance) {
              componentProps = createComponentApi();
              GENERAL_COMPONENT_API.map(x => {
                componentProps = addComponentApi(componentProps, {
                  modelProp: x.property
                });
              });
              GENERAL_COMPONENT_API.map(t => {
                const apiProperty = t.property;

                (function () {
                  const rootCellId = GetFirstCell(formLayout);
                  const cellProperties = GetCellProperties(formLayout, rootCellId);
                  cellProperties.componentApi = cellProperties.componentApi || {};
                  cellProperties.componentApi[apiProperty] = {
                    instanceType: InstanceTypes.ApiProperty,
                    apiProperty
                  };
                })();
              });
            }

            return {
              callback: screenOptionNode => {
                screenNodeOptionId = screenOptionNode.id;
                newItems.screenNodeOptionId = screenNodeOptionId;
              },
              parent: screenNodeId,
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `${viewName} ${uiType} Form`,
                [nodetypes_NodeProperties.UIType]: uiType,
                [nodetypes_NodeProperties.ComponentType]: ComponentTypes[uiType].Generic.key,
                [nodetypes_NodeProperties.ComponentApi]: componentProps,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.Layout]: formLayout,
                [nodetypes_NodeProperties.Model]: currentNode.id,
                [nodetypes_NodeProperties.ViewType]: viewType,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance
              },
              groupProperties: {},
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ScreenOptionsLink
                }
              }
            };
          }

        } : false, !isSharedComponent ? function () {
          return addComponentApiToForm({
            newItems,
            text: "value",
            parent: newItems.screenNodeOptionId
          });
        } : null, !isSharedComponent ? function () {
          return addComponentApiToForm({
            newItems,
            text: ApiNodeKeys.ViewModel,
            parent: newItems.screenNodeOptionId
          });
        } : null, !isSharedComponent ? function () {
          return connectComponentToExternalApi({
            newItems,
            parent: newItems.screenNodeId,
            key: "value",
            properties: nodetypes_LinkProperties.ComponentExternalConnection,
            child: newItems.screenNodeOptionId
          });
        } : null, !isSharedComponent ? function () {
          return connectComponentToExternalApi({
            newItems,
            parent: newItems.screenNodeId,
            properties: nodetypes_LinkProperties.ComponentExternalConnection,
            key: ApiNodeKeys.ViewModel,
            child: newItems.screenNodeOptionId
          });
        } : null, ...(!isSharedComponent ? SCREEN_COMPONENT_EVENTS.map(t => {
          return {
            operation: ADD_NEW_NODE,

            options() {
              return {
                nodeType: NodeTypes.LifeCylceMethod,
                properties: { ...viewPackage,
                  [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                  [nodetypes_NodeProperties.EventType]: t,
                  [nodetypes_NodeProperties.Pinned]: false,
                  [nodetypes_NodeProperties.UIText]: `${t}`
                },
                links: [{
                  target: newItems.screenNodeOptionId,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.LifeCylceMethod
                    }
                  }
                }],
                callback: screenNode => {
                  screenComponentEvents.push(screenNode.id);
                }
              };
            }

          };
        }) : []), ...(needsLoadToScreenState && false ? ConnectLifecycleMethodToDataChain({
          lifeCycleMethod: graph => {
            const sce = screenComponentEvents.find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType, graph) === ComponentLifeCycleEvents.ComponentDidMount);
            return sce;
          },
          dataChain: () => newItems.dataChainForLoading
        }) : []), !isSharedComponent && isList ? createViewPagingDataChain(newItems, viewName, viewPackage, true) : false, !isSharedComponent && isList ? createViewPagingDataChain(newItems, viewName, viewPackage, false) : false, isList ? {
          operation: NEW_COMPONENT_NODE,

          options(currentGraph) {
            listLayout = CreateLayout();
            listLayout = SetCellsLayout(listLayout, 1);
            const rootCellId = GetFirstCell(listLayout);
            const cellProperties = GetCellProperties(listLayout, rootCellId);
            cellProperties.style = { ...cellProperties.style,
              flexDirection: "column"
            };
            const componentProps = null;
            let connectto = [];

            if (isDefaultComponent) {
              connectto = getViewTypeEndpointsForDefaults(viewType, currentGraph, currentNode.id);
            }

            return {
              callback: listComponent => {
                listComponentId = listComponent.id;
                newItems.listComponentId = listComponentId;
                connectto.map(ct => {
                  createListConnections.push(() => {
                    return setSharedComponent({
                      properties: { ...nodetypes_LinkProperties.DefaultViewType,
                        viewType,
                        uiType,
                        isPluralComponent
                      },
                      viewType,
                      uiType,
                      isPluralComponent,
                      source: ct.id,
                      target: listComponentId
                    })(GetDispatchFunc(), GetStateFunc());
                  }, () => {
                    PerformGraphOperation([...["value", ApiNodeKeys.ViewModel, "label", "placeholder", "error", "success"].map(v => function () {
                      const graph = GetCurrentGraph(GetStateFunc()());
                      return addComponentApiToForm({
                        newItems,
                        text: v,
                        parent: ct.id,
                        isSingular: true,
                        graph
                      });
                    })])(GetDispatchFunc(), GetStateFunc());
                  });
                });
              },
              parent: screenNodeOptionId,
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `${viewName} ${multi_item_component}`,
                [nodetypes_NodeProperties.UIType]: uiType,
                [nodetypes_NodeProperties.ViewType]: viewType,
                [nodetypes_NodeProperties.IsPluralComponent]: isPluralComponent,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.SharedComponent]: isSharedComponent,
                [nodetypes_NodeProperties.ComponentType]: multi_item_component,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                [nodetypes_NodeProperties.Layout]: listLayout,
                [nodetypes_NodeProperties.ComponentApi]: componentProps
              },
              groupProperties: {},
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentLink
                }
              }
            };
          }

        } : false, isList ? function () {
          return addListItemComponentApi(newItems, ApiNodeKeys.ViewModel, false, (v, _i) => {
            newItems.componentItemListViewModel = _i;
          }, newItems.listComponentId, {
            useAsValue: false
          });
        } : null, ...["index", "separators", "value"].map(text => {
          return function () {
            if (!isList) {
              return [];
            }

            return addListItemComponentApi(newItems, text, true, (v, _i) => {
              newItems["list" + v] = _i;
            }, newItems.listComponentId, {
              useAsValue: false
            });
          };
        }), isList ? {
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentApi,
              callback: nn => {
                newItems.listComponentInternalApi = nn.id;
              },
              parent: newItems.listComponentId,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.UIText]: `item`,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UseAsValue]: true
              }
            };
          }

        } : null, isList ? {
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentExternalApi,
              callback: nn => {
                newItems.listComponentExternalApi = nn.id;
              },
              parent: newItems.listComponentId,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentExternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UIText]: `value`
              }
            };
          }

        } : null, isList ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              source: newItems.listComponentInternalApi,
              target: newItems.listComponentExternalApi,
              properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
              }
            };
          }

        } : null, isList && !isSharedComponent ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              source: newItems.listComponentExternalApi,
              target: getApiConnectors(newItems, newItems.screenNodeOptionId, "value").internalId,
              properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
              }
            };
          }

        } : null, isList ? {
          operation: NEW_DATA_SOURCE,

          options(currentGraph) {
            return {
              parent: listComponentId,
              callback: dataSource => {
                dataSourceId = dataSource.id;
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                [nodetypes_NodeProperties.UIType]: uiactions_GetNodeProp(listComponentId, nodetypes_NodeProperties.UIType, currentGraph),
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(currentNode)} Data Source ${uiactions_GetNodeProp(listComponentId, nodetypes_NodeProperties.UIType, currentGraph)}`
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.DataSourceLink
                }
              }
            };
          }

        } : false, {
          operation: NEW_COMPONENT_NODE,

          options(currentGraph) {
            layout = CreateLayout();
            layout = SetCellsLayout(layout, 1);
            const rootCellId = GetFirstCell(layout);
            const cellProperties = GetCellProperties(layout, rootCellId);
            cellProperties.style = { ...cellProperties.style,
              flexDirection: "column"
            };
            const propertyCount = modelProperties.length + 2;
            const componentProps = null;
            layout = SetCellsLayout(layout, propertyCount, rootCellId);
            let connectto = [];

            if (isDefaultComponent && !isList) {
              connectto = getViewTypeEndpointsForDefaults(viewType, currentGraph, currentNode.id);
            }

            return {
              callback: screenComponent => {
                screenComponentId = screenComponent.id;
                newItems.screenComponentId = screenComponentId;
                connectto.map(ct => {
                  createConnections.push(function () {
                    return setSharedComponent({
                      properties: { ...nodetypes_LinkProperties.DefaultViewType,
                        viewType,
                        uiType,
                        isPluralComponent
                      },
                      source: ct.id,
                      isPluralComponent,
                      target: screenComponentId,
                      viewType,
                      uiType
                    })(GetDispatchFunc(), GetStateFunc());
                  });
                });
              },
              parent: isList ? listComponentId : screenNodeOptionId,
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `${viewName}`,
                [nodetypes_NodeProperties.UIType]: uiType,
                [nodetypes_NodeProperties.ViewType]: viewType,
                [nodetypes_NodeProperties.SharedComponent]: isSharedComponent,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.ComponentType]: isList ? ComponentTypes[uiType].ListItem.key : ComponentTypes[uiType].Form.key,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                [nodetypes_NodeProperties.Layout]: layout,
                [nodetypes_NodeProperties.ComponentApi]: componentProps
              },
              groupProperties: {},
              linkProperties: {
                properties: isList ? { ...nodetypes_LinkProperties.ListItem
                } : { ...nodetypes_LinkProperties.ComponentLink
                }
              }
            };
          }

        }, function () {
          return addListItemComponentApi(newItems, ApiNodeKeys.ViewModel, false, (v, _i) => {
            newItems.componentViewModelApiIds = _i;
          }, newItems.screenComponentId, {
            useAsValue: false
          });
        }, isList ? function () {
          if (!isList) {
            return [];
          }

          return {
            operation: uiactions_ADD_LINK_BETWEEN_NODES,

            options() {
              return {
                target: newItems.componentItemListViewModel.internalId,
                source: newItems.componentViewModelApiIds.externalId,
                properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
                }
              };
            }

          };
        } : null, ...["index", "separators"].map(text => {
          return function () {
            if (!isList) {
              return [];
            }

            return [...addListItemComponentApi(newItems, text, false, (v, _i) => {
              newItems["listItem" + v] = _i;
            }, newItems.screenComponentId)];
          };
        }), ...["index", "separators"].map(text => {
          return function () {
            if (!isList) {
              return [];
            }

            return {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                return {
                  target: newItems["list" + text].internalId,
                  source: newItems["listItem" + text].externalId,
                  properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
                  }
                };
              }

            };
          };
        }), {
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentApi,
              callback: nn => {
                newItems.screenComponentIdInternalApi = nn.id;
              },
              parent: newItems.screenComponentId,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.UIText]: `value`,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UseAsValue]: true
              }
            };
          }

        }, {
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentExternalApi,
              callback: nn => {
                newItems.screenComponentIdExternalApi = nn.id;
                setApiConnectors(newItems, newItems.screenComponentId, {
                  externalId: nn.id,
                  internalId: newItems.screenComponentIdInternalApi
                }, "value");
              },
              parent: newItems.screenComponentId,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentExternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UIText]: `value`
              }
            };
          }

        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              source: getApiConnectors(newItems, newItems.screenComponentId, "value").internalId,
              target: getApiConnectors(newItems, newItems.screenComponentId, "value").externalId,
              properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
              }
            };
          }

        }, !isSharedComponent ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            if (screenNodeOptionId || listComponentId) {
              return {
                source: getApiConnectors(newItems, newItems.screenComponentId, "value").externalId,
                target: getApiConnectors(newItems, isList ? listComponentId : screenNodeOptionId, "value").internalId,
                properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
                }
              };
            }
          }

        } : false, !isSharedComponent ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            if (screenNodeOptionId || listComponentId) {
              return {
                source: getApiConnectors(newItems, newItems.screenComponentId, ApiNodeKeys.ViewModel).externalId,
                target: getApiConnectors(newItems, isList ? listComponentId : screenNodeOptionId, ApiNodeKeys.ViewModel).internalId,
                properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
                }
              };
            }
          }

        } : null, !isSharedComponent ? {
          operation: CHANGE_NODE_PROPERTY,

          options(currentGraph) {
            const formLayout = uiactions_GetNodeProp(screenNodeOptionId, nodetypes_NodeProperties.Layout, currentGraph);
            const rootCellId = GetFirstCell(formLayout);
            const cellProperties = GetCellProperties(formLayout, rootCellId);
            cellProperties.children[rootCellId] = isList ? listComponentId : screenComponentId;
            return {
              prop: nodetypes_NodeProperties.Layout,
              value: formLayout,
              id: screenNodeOptionId
            };
          }

        } : false, isList ? {
          operation: CHANGE_NODE_PROPERTY,

          options(currentGraph) {
            const formLayout = uiactions_GetNodeProp(listComponentId, nodetypes_NodeProperties.Layout, currentGraph);
            const rootCellId = GetFirstCell(formLayout);
            const cellProperties = GetCellProperties(formLayout, rootCellId);
            cellProperties.children[rootCellId] = screenComponentId;
            return {
              prop: nodetypes_NodeProperties.Layout,
              value: formLayout,
              id: listComponentId
            };
          }

        } : false, ...modelProperties.map((modelProperty, modelIndex) => {
          const sharedComponent = GetSharedComponentFor(viewType, modelProperty, currentNode.id, isSharedComponent);

          if (!sharedComponent) {
            switch (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.NODEType)) {
              case NodeTypes.Model:
                return {};

              case NodeTypes.Property:
                if (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UseModelAsType)) {
                  // if the property is a model reference, it should be a shared component or something.
                  return {};
                }

                break;

              default:
                break;
            }
          } else {
            childComponents[modelIndex] = sharedComponent;
            return [...["value", ApiNodeKeys.ViewModel, "label", "placeholder", "error", "success"].map(v => function () {
              const graph = GetCurrentGraph(GetStateFunc()());
              return addComponentApiToForm({
                newItems,
                text: v,
                parent: sharedComponent,
                isSingular: true,
                graph
              });
            })];
            return {};
          }

          return [{
            operation: NEW_COMPONENT_NODE,

            options() {
              const componentTypeToUse = viewComponentType; // Check if the property has a default view to use for different types of situations

              return {
                parent: screenComponentId,
                groupProperties: {},
                properties: { ...viewPackage,
                  [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(modelProperty)}`,
                  [nodetypes_NodeProperties.UIType]: uiType,
                  [nodetypes_NodeProperties.Label]: GetNodeTitle(modelProperty),
                  [nodetypes_NodeProperties.ComponentType]: sharedComponent || componentTypeToUse,
                  [nodetypes_NodeProperties.UsingSharedComponent]: !!sharedComponent,
                  [nodetypes_NodeProperties.Pinned]: false,
                  [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance
                },
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.ComponentLink
                  }
                },
                links: [{
                  target: modelProperty.id,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.PropertyLink,
                      [LinkPropertyKeys.ComponentProperty]: true
                    }
                  }
                }],
                callback: component => {
                  childComponents[modelIndex] = component.id;
                }
              };
            }

          }, function () {
            return nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex);
          }, function () {
            return nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex, "label");
          }, function () {
            return nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex, "placeholder");
          }, function () {
            return nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex, "error");
          }, function () {
            return nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex, "success");
          }, function () {
            return nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex, ApiNodeKeys.ViewModel, newItems.componentViewModelApiIds.internalId);
          }, function () {
            return addComponentEventApiNodes({
              newItems,
              childComponents,
              modelIndex,
              viewComponent,
              viewPackage,
              modelProperty,
              currentNode,
              useModelInstance
            });
          }, ...["value", ApiNodeKeys.ViewModel, "label", "placeholder", "error", "success"].map(v => {
            return function (graph) {
              let connectto = [];

              if (isDefaultComponent) {
                connectto = getViewTypeEndpointsForDefaults(viewType, graph, currentNode.id);
              }

              const shared_to_component_commands = [];
              connectto.map(ct => {
                shared_to_component_commands.push(...addComponentApiToForm({
                  newItems,
                  text: v,
                  parent: ct.id,
                  isSingular: true,
                  graph
                }));
              });
              return shared_to_component_commands.flatten();
            };
          }).filter(x => x && isSharedComponent && isDefaultComponent), isSharedComponent && isDefaultComponent ? function (graph) {
            let connectto = [];

            if (isDefaultComponent) {
              connectto = getViewTypeEndpointsForDefaults(viewType, graph, currentNode.id);
            }

            const shared_to_component_commands = [];
            connectto.map(ct => {
              const temp = GetNodesLinkedTo(graph, {
                id: ct.id,
                link: nodetypes_LinkType.ComponentInternalApi
              }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentApi); // && GetNodeProp(x, NodeProperties.UIText) === text

              temp.map(t => {
                shared_to_component_commands.push(...connectComponentToExternalApi({
                  newItems,
                  parent: ct.id,
                  key: uiactions_GetNodeProp(t, nodetypes_NodeProperties.UIText),
                  properties: { ...nodetypes_LinkProperties.ComponentExternalConnection,
                    ...(needsLoadToScreenState ? {
                      [LinkPropertyKeys.InstanceUpdate]: false
                    } : {})
                  },
                  child: childComponents[modelIndex]
                }));
              });
            });
            return shared_to_component_commands;
          } : null].filter(x => x);
        }).flatten(), ...modelProperties.map(modelProperty => {
          return {
            operation: uiactions_ADD_LINK_BETWEEN_NODES,

            options() {
              const sharedComponent = GetSharedComponentFor(viewType, modelProperty, currentNode.id, isSharedComponent);

              if (screenComponentId && sharedComponent && !existsLinkBetween(GetCurrentGraph(GetState()), {
                source: screenComponentId,
                target: sharedComponent,
                type: nodetypes_LinkType.SharedComponentInstance
              })) {
                return {
                  source: screenComponentId,
                  target: sharedComponent,
                  properties: { ...nodetypes_LinkProperties.SharedComponentInstance
                  }
                };
              }
            }

          };
        }), {
          operation: NEW_COMPONENT_NODE,

          options() {
            return {
              parent: screenComponentId,
              groupProperties: {},
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `${Execute} Button ${viewName} Component`,
                [nodetypes_NodeProperties.UIType]: uiType,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.Label]: `${viewName} ${Execute}`,
                [nodetypes_NodeProperties.ExecuteButton]: true,
                [nodetypes_NodeProperties.ComponentType]: ComponentTypes[uiType].Button.key,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentLink
                }
              },
              callback: component => {
                childComponents.push(component.id);
                newItems.button = component.id;
                method_result.formButton = component.id;
              }
            };
          }

        }, {
          operation: NEW_COMPONENT_NODE,

          options() {
            return {
              parent: screenComponentId,
              groupProperties: {},
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `${Cancel} Button ${viewName} Component`,
                [nodetypes_NodeProperties.UIType]: uiType,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.Label]: `${viewName} ${Cancel}`,
                [nodetypes_NodeProperties.ComponentType]: ComponentTypes[uiType].Button.key,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentLink
                }
              },
              callback: component => {
                childComponents.push(component.id);
                newItems.cancelbutton = component.id;
                method_result.cancelButton = component.id;
              }
            };
          }

        }, addTitleService({
          newItems
        }), ...addButtonApiNodes(newItems), ...addButtonApiNodes(newItems, () => {
          return newItems.cancelbutton;
        }), {
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentApi,
              callback: nn => {
                newItems.buttonInternalApi = nn.id;
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                }
              },
              parent: newItems.button,
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.UIText]: `value`,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UseAsValue]: true
              }
            };
          }

        }, {
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentExternalApi,
              callback: nn => {
                newItems.buttonExternalApi = nn.id;
              },
              parent: newItems.button,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentExternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.UIText]: `value`
              }
            };
          }

        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              source: newItems.buttonInternalApi,
              target: newItems.buttonExternalApi,
              properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
              }
            };
          }

        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              target: newItems.screenComponentIdInternalApi,
              source: newItems.buttonExternalApi,
              properties: { ...nodetypes_LinkProperties.ComponentExternalConnection,
                ...(needsLoadToScreenState ? {
                  [LinkPropertyKeys.InstanceUpdate]: true
                } : {})
              }
            };
          }

        }, function () {
          return addComponentApiToForm({
            newItems,
            text: ApiNodeKeys.ViewModel,
            parent: newItems.button
          });
        }, function () {
          return connectComponentToExternalApi({
            newItems,
            parent: newItems.screenComponentId,
            key: ApiNodeKeys.ViewModel,
            properties: { ...nodetypes_LinkProperties.ComponentExternalConnection,
              ...(needsLoadToScreenState ? {
                [LinkPropertyKeys.InstanceUpdate]: true
              } : {})
            },
            child: newItems.button
          });
        }, ...ComponentTypes[uiType].Button.eventApi.map(t => {
          return {
            operation: ADD_NEW_NODE,

            options() {
              return {
                nodeType: NodeTypes.EventMethod,
                properties: { ...viewPackage,
                  [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                  [nodetypes_NodeProperties.EventType]: t,
                  [nodetypes_NodeProperties.UIText]: `${t}`,
                  [nodetypes_NodeProperties.Pinned]: false
                },

                callback(component) {
                  method_result.formButtonApi = method_result.formButtonApi || {};
                  method_result.formButtonApi[t] = component.id;
                },

                links: [{
                  target: currentNode.id,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.ModelTypeLink
                    }
                  }
                }, {
                  target: newItems.button,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.EventMethod
                    }
                  }
                }]
              };
            }

          };
        }), {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            const executeButtonComponent = childComponents.length - 2;
            const rootCellId = GetFirstCell(layout);
            const children = GetChildren(layout, rootCellId);
            const childId = children[executeButtonComponent];
            const cellProperties = GetCellProperties(layout, childId);
            cellProperties.children[childId] = childComponents[executeButtonComponent];
            cellProperties.style.flex = null;
            cellProperties.style.height = null;
            return {
              prop: nodetypes_NodeProperties.Layout,
              id: screenComponentId,
              value: layout
            };
          }

        }, {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            const executeButtonComponent = childComponents.length - 1;
            const rootCellId = GetFirstCell(layout);
            const children = GetChildren(layout, rootCellId);
            const childId = children[executeButtonComponent];
            const cellProperties = GetCellProperties(layout, childId);
            cellProperties.children[childId] = childComponents[executeButtonComponent];
            cellProperties.style.flex = null;
            cellProperties.style.height = null;
            return {
              prop: nodetypes_NodeProperties.Layout,
              id: screenComponentId,
              value: layout
            };
          }

        }, ...modelProperties.map((modelProperty, modelIndex) => {
          return {
            operation: CHANGE_NODE_PROPERTY,

            options() {
              let sharedComponent = GetSharedComponentFor(viewType, modelProperty, currentNode.id, isSharedComponent);

              if (!sharedComponent) {
                switch (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.NODEType)) {
                  case NodeTypes.Model:
                    return {};

                  case NodeTypes.Property:
                    if (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UseModelAsType)) {
                      const _ui_model_type = uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UIModelType);

                      if (_ui_model_type) {
                        sharedComponent = GetSharedComponentFor(viewType, modelProperty, _ui_model_type, isSharedComponent);
                      }

                      if (!sharedComponent) {
                        // if the property is a model reference, it should be a shared component or something.
                        return {};
                      }
                    }

                    break;
                }
              }

              const rootCellId = GetFirstCell(layout);
              const children = GetChildren(layout, rootCellId);
              const childId = children[modelIndex];
              const cellProperties = GetCellProperties(layout, childId);
              cellProperties.children[childId] = sharedComponent || childComponents[modelIndex];
              cellProperties.style.flex = null;
              cellProperties.style.height = null;
              return {
                prop: nodetypes_NodeProperties.Layout,
                id: screenComponentId,
                value: layout
              };
            }

          };
        }), ...modelProperties.map((modelProperty, modelIndex) => {
          const sharedComponent = GetSharedComponentFor(viewType, modelProperty, currentNode.id, isSharedComponent);

          if (!sharedComponent) {
            switch (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.NODEType)) {
              case NodeTypes.Model:
                return {};

              case NodeTypes.Property:
                if (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UseModelAsType)) {
                  // if the property is a model reference, it should be a shared component or something.
                  return {};
                }

                break;
            }
          }

          return {
            operation: CHANGE_NODE_PROPERTY,

            options(graph) {
              let componentProps = createComponentApi();
              const componentTypes = ComponentTypes[uiType];
              const compNodeId = childComponents[modelIndex];
              const compNode = GetNodeById(compNodeId, graph);
              const componentType = uiactions_GetNodeProp(compNode, nodetypes_NodeProperties.ComponentType);

              if (!sharedComponent && componentTypes[componentType]) {
                componentTypes[componentType].defaultApi.map(x => {
                  componentProps = addComponentApi(componentProps, {
                    modelProp: x.property
                  });
                });
              } else if (sharedComponent) {
                componentProps = {}; //     let { instanceType, model, selector, modelProperty, apiProperty, handlerType, isHandler, dataChain } = apiConfig[i];

                SHARED_COMPONENT_API.map(x => {
                  componentProps[x.property] = {
                    instanceType: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                    model: currentNode.id,
                    modelProperty: modelProperty.id,
                    handlerType: HandlerTypes.Property
                  };
                });
              } else {
                throw "sharedComponent should be set";
              }

              return {
                prop: nodetypes_NodeProperties.ComponentApi,
                id: compNodeId,
                value: componentProps
              };
            }

          };
        }), {
          operation: CHANGE_NODE_PROPERTY,

          options(graph) {
            let componentProps = createComponentApi();
            const componentTypes = ComponentTypes[uiType];
            const compNodeId = childComponents[childComponents.length - 1];
            const compNode = GetNodeById(compNodeId, graph);
            const componentType = uiactions_GetNodeProp(compNode, nodetypes_NodeProperties.ComponentType);
            componentTypes[componentType].defaultApi.map(x => {
              componentProps = addComponentApi(componentProps, {
                modelProp: x.property
              });
            });
            return {
              prop: nodetypes_NodeProperties.ComponentApi,
              id: compNodeId,
              value: componentProps
            };
          }

        }, {
          operation: CHANGE_NODE_PROPERTY,

          options(graph) {
            let componentProps = createComponentApi();
            const componentTypes = ComponentTypes[uiType];
            const compNodeId = childComponents[childComponents.length - 2];
            const compNode = GetNodeById(compNodeId, graph);
            const componentType = uiactions_GetNodeProp(compNode, nodetypes_NodeProperties.ComponentType);
            componentTypes[componentType].defaultApi.map(x => {
              componentProps = addComponentApi(componentProps, {
                modelProp: x.property
              });
            });
            return {
              prop: nodetypes_NodeProperties.ComponentApi,
              id: compNodeId,
              value: componentProps
            };
          }

        }].filter(x => x))(GetDispatchFunc(), GetStateFunc());
        PerformGraphOperation(AddNavigateBackHandler({
          button: newItems.cancelbutton,
          evt: uiType === UITypes.ReactNative ? "onPress" : "onClick"
        }))(GetDispatchFunc(), GetStateFunc());
        const selectorNode = GetNodesByProperties({
          [nodetypes_NodeProperties.Model]: currentNode.id,
          [nodetypes_NodeProperties.NODEType]: NodeTypes.Selector //  [NodeProperties.IsShared]: isSharedComponent,
          // [NodeProperties.InstanceType]: useModelInstance

        }).find(x => x);
        PerformGraphOperation([{
          operation: selectorNode ? ADD_LINKS_BETWEEN_NODES : ADD_NEW_NODE,

          options() {
            if (selectorNode) {
              modelComponentSelectors.push(selectorNode.id);
              return {
                links: [{
                  source: selectorNode.id,
                  target: currentNode.id,
                  properties: { ...nodetypes_LinkProperties.ModelTypeLink
                  }
                }]
              };
            }

            return {
              nodeType: NodeTypes.Selector,
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(currentNode)}${useModelInstance ? " Instance" : ""}`,
                [nodetypes_NodeProperties.Model]: currentNode.id,
                [nodetypes_NodeProperties.Pinned]: false // [NodeProperties.IsShared]: isSharedComponent,
                // [NodeProperties.InstanceType]: useModelInstance

              },
              links: [{
                target: currentNode.id,
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.ModelTypeLink
                  }
                }
              }],
              callback: selector => {
                modelComponentSelectors.push(selector.id);
              }
            };
          }

        }])(GetDispatchFunc(), GetStateFunc());
        const propertyDataChainAccesors = [];
        const datachainLink = [];
        let skipModelDataChainListParts = false;
        let listDataChainId = null;
        let listDataChainExitId = null;
        PerformGraphOperation([isList ? {
          operation: ADD_NEW_NODE,

          options() {
            const node = GetNodesByProperties({
              [nodetypes_NodeProperties.EntryPoint]: true,
              [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Models,
              [nodetypes_NodeProperties.UIModelType]: currentNode.id
            }).find(x => x);

            if (node) {
              listDataChainId = node.id;
              skipModelDataChainListParts = true;
              return null;
            }

            return {
              callback: dataChain => {
                listDataChainId = dataChain.id;
              },
              nodeType: NodeTypes.DataChain,
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `Get ${viewName} Objects`,
                [nodetypes_NodeProperties.EntryPoint]: true,
                [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Models,
                [nodetypes_NodeProperties.UIModelType]: currentNode.id,
                [nodetypes_NodeProperties.Pinned]: false,
                [nodetypes_NodeProperties.InstanceType]: useModelInstance
              },
              links: [{
                target: currentNode.id,
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.ModelTypeLink
                  }
                }
              }]
            };
          }

        } : false, isList ? {
          operation: ADD_NEW_NODE,

          options(graph) {
            if (skipModelDataChainListParts) {
              return null;
            }

            const temp = SplitDataCommand(GetNodeById(listDataChainId, graph), (split, graph, groupId) => {
              listDataChainExitId = split.id;
              newItems.listDataChainExitId = listDataChainExitId;
              newItems.listDataChainExitGroupId = groupId;
            }, viewPackage);
            return temp.options;
          }

        } : false, isList ? {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            if (skipModelDataChainListParts) {
              return null;
            }

            return {
              prop: nodetypes_NodeProperties.DataChainFunctionType,
              id: listDataChainExitId,
              value: DataChainFunctionKeys.Pass
            };
          }

        } : false, isList ? {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            if (skipModelDataChainListParts) {
              return null;
            }

            return {
              prop: nodetypes_NodeProperties.UIText,
              id: listDataChainExitId,
              value: `${GetNodeTitle(currentNode)}s DC Complete`
            };
          }

        } : false, isList ? {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            if (skipModelDataChainListParts) {
              return null;
            }

            return {
              prop: nodetypes_NodeProperties.AsOutput,
              id: listDataChainExitId,
              value: true
            };
          }

        } : false, isList ? {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            return {
              prop: nodetypes_NodeProperties.DataChain,
              id: dataSourceId,
              value: listDataChainId
            };
          }

        } : false, isList ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              target: listDataChainId,
              source: dataSourceId,
              properties: { ...nodetypes_LinkProperties.DataChainLink
              }
            };
          }

        } : false, isList ? {
          operation: CHANGE_NODE_PROPERTY,

          options() {
            return {
              prop: nodetypes_NodeProperties.UIModelType,
              id: dataSourceId,
              value: currentNode.id
            };
          }

        } : false, isList ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              target: currentNode.id,
              source: dataSourceId,
              properties: { ...nodetypes_LinkProperties.ModelTypeLink
              }
            };
          }

        } : false].filter(x => x))(GetDispatchFunc(), GetStateFunc());
        let skipAddingComplete = false;
        PerformGraphOperation([{
          operation: ADD_NEW_NODE,

          options(graph) {
            const node = GetNodesByProperties({
              [nodetypes_NodeProperties.UIText]: `Get ${viewName}`,
              [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Selector,
              [nodetypes_NodeProperties.EntryPoint]: true,
              [nodetypes_NodeProperties.Model]: currentNode.id,
              [nodetypes_NodeProperties.Selector]: modelComponentSelectors[0],
              [nodetypes_NodeProperties.SelectorProperty]: SelectorPropertyKeys.Object
            }, graph).find(x => x);

            if (node) {
              skipAddingComplete = true;
              newItems.getObjectDataChain = node.id;
              return null;
            }

            return {
              nodeType: NodeTypes.DataChain,
              callback: n => {
                newItems.getObjectDataChain = n.id;
              },
              properties: { ...viewPackage,
                [nodetypes_NodeProperties.UIText]: `Get ${viewName}`,
                [nodetypes_NodeProperties.EntryPoint]: true,
                [nodetypes_NodeProperties.Model]: currentNode.id,
                [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Selector,
                [nodetypes_NodeProperties.Selector]: modelComponentSelectors[0],
                [nodetypes_NodeProperties.SelectorProperty]: SelectorPropertyKeys.Object,
                [nodetypes_NodeProperties.Pinned]: true
              },
              links: [{
                target: modelComponentSelectors[0],
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.DataChainLink
                  }
                }
              }, {
                target: currentNode.id,
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.ModelTypeLink
                  }
                }
              }]
            };
          }

        }, {
          operation: ADD_NEW_NODE,

          options(graph) {
            if (skipAddingComplete) {
              return false;
            }

            const temp = AddChainCommand(GetNodeById(newItems.getObjectDataChain, graph), () => {}, graph, { ...viewPackage,
              [nodetypes_NodeProperties.AsOutput]: true,
              [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
              [nodetypes_NodeProperties.UIText]: `Get ${viewName} Complete`
            });
            return temp.options;
          }

        }])(GetDispatchFunc(), GetStateFunc());
        modelProperties.forEach((modelProperty, propertyIndex) => {
          let propDataChainNodeId = null;
          let skip = false;
          let _ui_model_type = false;
          let referenceproperty = false; // Needs an accessor even if it is a shared or reference property

          switch (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.NODEType)) {
            case NodeTypes.Model:
              return {};

            case NodeTypes.Property:
              if (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UseModelAsType)) {
                // if the property is a model reference, it should be a shared component or something.
                // The ViewType will be need the data chain accessor to get the property value
                // on the object.

                /*
                                    current.[property]
                                    we need to get the property to pass to the shared component.
                                */
                // If the thing being referenced is a n => many that means it will need,
                // the 'current' id to be able to query for the children objects.
                if (uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UseModelAsType)) {
                  _ui_model_type = uiactions_GetNodeProp(modelProperty, nodetypes_NodeProperties.UIModelType);

                  if (_ui_model_type) {
                    referenceproperty = GetSharedComponentFor(viewType, modelProperty, _ui_model_type, isSharedComponent);
                  }
                }
              }

              break;

            default:
              break;
          }

          const buildPropertyResult = BuildPropertyDataChainAccessor({
            viewName,
            modelProperty,
            currentNode,
            modelComponentSelectors,
            skip,
            isSharedComponent,
            viewPackage,
            propertyDataChainAccesors,
            uiType,
            viewType,
            newItems,
            childComponents,
            propertyIndex
          });

          if (referenceproperty) {
            // add data-chain accessor to view-type external connections
            AttachDataChainAccessorTo(referenceproperty, buildPropertyResult.propDataChainNodeId);
            AttachSelectorAccessorTo(referenceproperty, modelComponentSelectors[0]);
            return {};
          }

          skip = buildPropertyResult.skip;
          propDataChainNodeId = buildPropertyResult.propDataChainNodeId;

          if (_ui_model_type) {
            return {};
          }

          ConnectExternalApisToSelectors({
            modelComponentSelectors,
            newItems,
            viewType,
            childComponents,
            propertyIndex
          });
          const compNodeId = childComponents[propertyIndex];
          const rootCellId = GetFirstCell(layout);
          const children = GetChildren(layout, rootCellId);
          const childId = children[propertyIndex];
          const apiList = PropertyApiList; // getComponentApiList(componentApi);

          const apiDataChainLists = {};
          newItems.apiDataChain = newItems.apiDataChain || {};
          newItems.apiDataChain[childId] = apiDataChainLists;
          setupPropertyApi({
            viewName,
            modelProperty,
            currentNode,
            modelComponentSelectors,
            useModelInstance,
            isSharedComponent,
            viewPackage,
            propertyDataChainAccesors,
            apiList,
            uiType,
            apiDataChainLists,
            propDataChainNodeId,
            uiType,
            viewType,
            newItems,
            childComponents,
            propertyIndex
          });
          PerformGraphOperation([...apiList.map(api => {
            return {
              operation: CHANGE_NODE_PROPERTY,

              options() {
                const apiProperty = api.value;
                const cellProperties = GetCellProperties(layout, childId);
                cellProperties.componentApi = cellProperties.componentApi || {}; // let { instanceType, model, selector, handlerType, dataChain, modelProperty } = cellProperties.componentApi[apiProperty] || {};

                if (ARE_BOOLEANS.some(v => v === apiProperty)) {
                  cellProperties.componentApi[apiProperty] = {
                    instanceType: InstanceTypes.Boolean,
                    handlerType: HandlerTypes.Property
                  };
                } else if (ARE_HANDLERS.some(v => v === apiProperty)) {
                  if ([ARE_TEXT_CHANGE].some(v => v === apiProperty)) {
                    cellProperties.componentApi[apiProperty] = {
                      instanceType: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                      handlerType: HandlerTypes.ChangeText
                    };
                  } else {
                    cellProperties.componentApi[apiProperty] = {
                      instanceType: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
                      handlerType: HandlerTypes.Change
                    };
                  }
                } else {
                  cellProperties.componentApi[apiProperty] = {
                    instanceType: useModelInstance ? InstanceTypes.SelectorInstance : InstanceTypes.Selector,
                    selector: modelComponentSelectors[0],
                    handlerType: HandlerTypes.Property,
                    dataChain: apiDataChainLists[apiProperty] // propertyDataChainAccesors[propertyIndex]

                  };

                  if (apiDataChainLists[apiProperty]) {
                    datachainLink.push({
                      operation: uiactions_ADD_LINK_BETWEEN_NODES,

                      options() {
                        return {
                          target: modelComponentSelectors[0],
                          source: compNodeId,
                          linkProperties: { ...nodetypes_LinkProperties.SelectorLink
                          }
                        };
                      }

                    });
                  }
                }

                switch (apiProperty) {
                  case ON_BLUR:
                    cellProperties.componentApi[apiProperty].model = viewModelNodeBlurId;
                    cellProperties.componentApi[apiProperty].modelProperty = modelProperties[propertyIndex].id;
                    cellProperties.componentApi[apiProperty].handlerType = HandlerTypes.Blur;
                    break;

                  case ON_CHANGE_TEXT:
                  case ON_CHANGE:
                    cellProperties.componentApi[apiProperty].modelProperty = modelProperties[propertyIndex].id;
                    break;

                  case ON_FOCUS:
                    cellProperties.componentApi[apiProperty].model = viewModelNodeFocusId;
                    cellProperties.componentApi[apiProperty].modelProperty = modelProperties[propertyIndex].id;
                    cellProperties.componentApi[apiProperty].handlerType = HandlerTypes.Focus;
                    break;

                  default:
                    break;
                }

                if (cellProperties.componentApi[apiProperty].modelProperty) {
                  datachainLink.push({
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,

                    options() {
                      return {
                        target: cellProperties.componentApi[apiProperty].modelProperty,
                        source: compNodeId,
                        linkProperties: { ...nodetypes_LinkProperties.ComponentApi,
                          modelProperty: true
                        }
                      };
                    }

                  });
                }

                if (cellProperties.componentApi[apiProperty].model) {
                  datachainLink.push({
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,

                    options() {
                      return {
                        target: cellProperties.componentApi[apiProperty].model,
                        source: compNodeId,
                        linkProperties: { ...nodetypes_LinkProperties.ComponentApi,
                          model: true
                        }
                      };
                    }

                  });
                }

                return {
                  prop: nodetypes_NodeProperties.Layout,
                  id: screenComponentId,
                  value: layout
                };
              }

            };
          })])(GetDispatchFunc(), GetStateFunc());
        });
        PerformGraphOperation(datachainLink)(GetDispatchFunc(), GetStateFunc());
        PerformGraphOperation([...[].interpolate(0, modelProperties.length + 1, modelIndex => {
          return applyDefaultComponentProperties(GetNodeById(childComponents[modelIndex]), uiType);
        }).flatten(), applyDefaultComponentProperties(GetNodeById(screenComponentId), uiType), applyDefaultComponentProperties(GetNodeById(screenNodeOptionId), uiType)])(GetDispatchFunc(), GetStateFunc());
        createConnections.map(t => t());
        createListConnections.map(t => t());

        if (isList) {
          if (newItems.listComponentId) {
            const listViewModel = GetComponentExternalApiNode(ComponentApiTypes.ViewModel, newItems.listComponentId);
            const screenViewModelInternal = GetComponentInternalApiNode(ComponentApiTypes.ViewModel, newItems.screenNodeOptionId);

            if (listViewModel && screenViewModelInternal) {
              PerformGraphOperation(ConnectListViewModelToExternalViewModel({
                target: screenViewModelInternal.id,
                source: listViewModel.id
              }))(GetDispatchFunc(), GetStateFunc());
            }
          } //ConnectListViewModelToExternalViewModel

        }
      }

      if (isList) {
        if (newItems.listDataChainExitId && newItems.listDataChainExitGroupId) {
          PerformGraphOperation(AppendGetIdsToDataChain({
            dataChain: newItems.listDataChainExitId,
            dataChainGroup: newItems.listDataChainExitGroupId
          }))(GetDispatchFunc(), GetStateFunc());
        }
      }

      if (needsLoadToScreenState) {
        PerformGraphOperation(SetModelsApiLinkForInstanceUpdate({
          viewPackage: viewPackage[nodetypes_NodeProperties.ViewPackage]
        }))(GetDispatchFunc(), GetStateFunc());

        if (!isSharedComponent) {
          if (isList) {
            PerformGraphOperation(SetupViewModelOnScreen({
              model: currentNode.id,
              screen: screenNodeId
            }))(GetDispatchFunc(), GetStateFunc());
          } else {
            let modelView_DataChain;
            PerformGraphOperation([...GetModelViewModelForUpdate({
              screen: GetNodeTitle(screenNodeId),
              viewModel: screenNodeId,
              callback: ctx => {
                const {
                  entry
                } = ctx;
                modelView_DataChain = entry;
              }
            }), function (graph) {
              const externalNode = GetNodesLinkedTo(graph, {
                id: screenNodeId,
                link: nodetypes_LinkType.ComponentExternalApi
              }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentExternalApi && GetNodeTitle(x) === ApiNodeKeys.ViewModel);
              return [{
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: modelView_DataChain,
                    source: externalNode.id,
                    properties: { ...nodetypes_LinkProperties.DataChainLink
                    }
                  };
                }

              }];
            }])(GetDispatchFunc(), GetStateFunc());
          }
        }
      }

      SelectedNode(currentNode.id)(GetDispatchFunc(), GetStateFunc());
    };

    const {
      uiTypes
    } = _args;

    if (uiTypes) {
      for (const i in uiTypes) {
        if (uiTypes[i]) {
          default_View_method({ ..._args,
            uiType: i
          });
          setViewPackageStamp(null, "CreateDefaultView");
        }
      }
    } else {
      default_View_method({ ..._args
      });
      setViewPackageStamp(null, "CreateDefaultView");
    }

    return method_result;
  }

};
function applyDefaultComponentProperties(currentNode, _ui_type) {
  // var { state } = this.props;
  // var currentNode = Node(state, Visual(state, SELECTED_NODE));
  // let screenOption = currentNode ? GetConnectedNodeByType(state, currentNode.id, NodeTypes.ScreenOption) || GetConnectedNodeByType(state, currentNode.id, NodeTypes.ComponentNode, TARGET) : null;
  // let _ui_type = GetNodeProp(screenOption, NodeProperties.UIType);
  const result = [];

  if (currentNode) {
    const componentTypes = ComponentTypes[_ui_type] || {};
    const componentType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ComponentType);
    Object.keys(componentTypes[componentType] ? componentTypes[componentType].properties : {}).map(key => {
      const prop_obj = componentTypes[componentType].properties[key];

      if (prop_obj.parameterConfig) {
        const selectedComponentApiProperty = key;
        let componentProperties = uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty);
        componentProperties = componentProperties || {};
        componentProperties[selectedComponentApiProperty] = componentProperties[selectedComponentApiProperty] || {};
        componentProperties[selectedComponentApiProperty] = {
          instanceType: InstanceTypes.ApiProperty,
          isHandler: prop_obj.isHandler,
          apiProperty: prop_obj.nodeProperty
        };
        result.push({
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: prop_obj.nodeProperty,
            id: currentNode.id,
            value: componentProperties
          }
        });
      }
    });
  }

  return result;
}

function CreateFunction(option) {
  const {
    nodePackageType,
    methodType,
    httpMethod,
    functionType,
    functionName
  } = option;

  if (!nodePackageType) {
    throw "missing node package type";
  }

  if (!methodType) {
    throw "missing method type";
  }

  if (!httpMethod) {
    throw "missing http method";
  }

  if (!functionType) {
    throw "function type missing";
  }

  if (!functionName) {
    throw "function name is missing";
  }

  return args => {
    const {
      model,
      dispatch,
      getState
    } = args; // Check for existing method of this type
    // if no methods exist, then create a new method.
    // graph = GraphMethods.addNewNodeOfType(graph, options, NodeTypes.Model);

    const agents = GetAgentNodes();
    agents.filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExcludeFromController)).forEach(agent => {
      let methodProps;

      if (ModelNotConnectedToFunction(agent.id, model.id, nodePackageType)) {
        const context = {};
        const outer_commands = [{
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.Method,
              parent: model.id,
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.NodePackage]: model.id,
                [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
                [nodetypes_NodeProperties.FunctionType]: functionType,
                [nodetypes_NodeProperties.MethodType]: methodType,
                [nodetypes_NodeProperties.HttpMethod]: httpMethod,
                [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(model)} ${functionName}`
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.FunctionOperator
                }
              },
              callback: methodNode => {
                context.methodNode = methodNode;
              }
            };
          }

        }, function () {
          const {
            methodNode
          } = context;
          const {
            constraints
          } = MethodFunctions[functionType];
          let commands = [];
          Object.values(constraints).forEach(constraint => {
            let perOrModelNode = null;

            switch (constraint.key) {
              case FunctionTemplateKeys.Model:
              case FunctionTemplateKeys.Agent:
              case FunctionTemplateKeys.User:
              case FunctionTemplateKeys.ModelOutput:
                methodProps = { ...methodProps,
                  ...(uiactions_GetNodeProp(GetNodeById(methodNode.id), nodetypes_NodeProperties.MethodProps) || {})
                };

                if (constraint[nodetypes_NodeProperties.IsAgent]) {
                  methodProps[constraint.key] = agent.id;
                } else if (constraint.key === FunctionTemplateKeys.User) {
                  methodProps[constraint.key] = uiactions_GetNodeProp(GetNodeById(agent.id), nodetypes_NodeProperties.UIUser) || GetUsers()[0].id;
                } else {
                  methodProps[constraint.key] = model.id;
                }

                break;

              case FunctionTemplateKeys.Permission:
              case FunctionTemplateKeys.ModelFilter:
                PerformGraphOperation([{
                  operation: ADD_NEW_NODE,
                  options: {
                    parent: methodNode.id,
                    nodeType: constraint.key === FunctionTemplateKeys.Permission ? NodeTypes.Permission : NodeTypes.ModelFilter,
                    groupProperties: {},
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(methodNode)} ${constraint.key === FunctionTemplateKeys.Permission ? NodeTypes.Permission : NodeTypes.ModelFilter}`
                    },
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.FunctionOperator
                      }
                    },
                    callback: newNode => {
                      methodProps = { ...methodProps,
                        ...(uiactions_GetNodeProp(GetNodeById(methodNode.id), nodetypes_NodeProperties.MethodProps) || {})
                      };
                      methodProps[constraint.key] = newNode.id;
                      perOrModelNode = newNode;
                    }
                  }
                }])(dispatch, getState);

                if (constraint.key === FunctionTemplateKeys.ModelFilter) {
                  commands = [...commands, {
                    operation: CHANGE_NODE_PROPERTY,
                    options: {
                      prop: nodetypes_NodeProperties.FilterAgent,
                      id: perOrModelNode.id,
                      value: agent.id
                    }
                  }, {
                    operation: CHANGE_NODE_PROPERTY,
                    options: {
                      prop: nodetypes_NodeProperties.FilterModel,
                      id: perOrModelNode.id,
                      value: model.id
                    }
                  }, {
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,
                    options: {
                      target: model.id,
                      source: perOrModelNode.id,
                      properties: { ...nodetypes_LinkProperties.ModelTypeLink
                      }
                    }
                  }, {
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,
                    options: {
                      target: agent.id,
                      source: perOrModelNode.id,
                      properties: { ...nodetypes_LinkProperties.AgentTypeLink
                      }
                    }
                  }];
                }

                break;

              default:
                break;
            }

            commands = [...commands, ...[{
              operation: CHANGE_NODE_PROPERTY,
              options: {
                prop: nodetypes_NodeProperties.MethodProps,
                id: methodNode.id,
                value: methodProps
              }
            }, {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,
              options: {
                target: methodProps[constraint.key],
                source: methodNode.id,
                properties: { ...nodetypes_LinkProperties.FunctionOperator
                }
              }
            }]];
          });

          if (ModelNotConnectedToFunction(agent.id, model.id, nodePackageType, NodeTypes.Controller)) {
            commands.push({
              operation: ADD_NEW_NODE,
              options: {
                nodeType: NodeTypes.Controller,
                properties: {
                  [nodetypes_NodeProperties.NodePackage]: model.id,
                  [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                  [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
                  [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(model)} ${GetNodeTitle(agent)} Controller`
                },
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.FunctionOperator
                  }
                },
                callback: controllerNode => {
                  context.controllerNode = controllerNode;
                }
              }
            }, () => {
              const {
                controllerNode
              } = context;

              if (ModelNotConnectedToFunction(agent.id, model.id, nodePackageType, NodeTypes.Maestro)) {
                return [{
                  operation: ADD_NEW_NODE,
                  options: {
                    nodeType: NodeTypes.Maestro,
                    parent: controllerNode.id,
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                      [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(model)} ${GetNodeTitle(agent)} Maestro`
                    },
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.MaestroLink
                      }
                    },
                    callback: maestroNode => {
                      context.maestroNode = maestroNode;
                    }
                  }
                }];
              }

              return [];
            }, () => [{
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                const {
                  maestroNode
                } = context;
                return {
                  target: methodNode.id,
                  source: maestroNode.id,
                  properties: { ...nodetypes_LinkProperties.FunctionLink
                  }
                };
              }

            }]);
          }

          return commands;
        }];
        PerformGraphOperation(outer_commands)(dispatch, getState);
      }
    });
  };
}

function CreateAgentFunction(option) {
  const {
    nodePackageType,
    methodType,
    parentId: parent,
    httpMethod,
    functionType,
    functionName,
    viewPackage,
    model,
    agent
  } = option;

  if (!nodePackageType) {
    throw "missing node package type";
  }

  if (!methodType) {
    throw "missing method type";
  }

  if (!httpMethod) {
    throw "missing http method";
  }

  if (!functionType) {
    throw "function type missing";
  }

  if (!functionName) {
    throw "function name is missing";
  }

  return args => {
    const {
      dispatch,
      getState
    } = args; // Check for existing method of this type
    // if no methods exist, then create a new method.
    // graph = GraphMethods.addNewNodeOfType(graph, options, NodeTypes.Model);

    let methodProps;
    const new_nodes = {};
    let _viewPackage = null;
    _viewPackage = viewPackage || {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4()
    };
    setViewPackageStamp(_viewPackage, "CreateAgentFunction");

    if (ModelNotConnectedToFunction(agent.id, model.id, nodePackageType)) {
      const outer_commands = [{
        operation: ADD_NEW_NODE,

        options() {
          return {
            nodeType: NodeTypes.Method,
            groupProperties: {},
            properties: {
              [nodetypes_NodeProperties.NodePackage]: model.id,
              [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
              [nodetypes_NodeProperties.NodePackageAgent]: agent.id,
              [nodetypes_NodeProperties.FunctionType]: functionType,
              [nodetypes_NodeProperties.MethodType]: methodType,
              [nodetypes_NodeProperties.HttpMethod]: httpMethod,
              [nodetypes_NodeProperties.UIText]: `${functionName}`
            },
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.FunctionOperator
              }
            },
            callback: methodNode => {
              new_nodes.methodNode = methodNode;
            }
          };
        }

      }, function () {
        const {
          methodNode
        } = new_nodes;
        const {
          constraints
        } = MethodFunctions[functionType];
        let commands = [{
          operation: ADD_DEFAULT_PROPERTIES,
          options: {
            parent: model.id,
            groupProperties: {},
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.PropertyLink
              }
            }
          }
        }];
        Object.values(constraints).map(constraint => {
          let validator = null;
          let perOrModelNode = null;
          let executor = null;

          switch (constraint.key) {
            case FunctionTemplateKeys.Model:
            case FunctionTemplateKeys.Agent:
            case FunctionTemplateKeys.Parent:
            case FunctionTemplateKeys.User:
            case FunctionTemplateKeys.ModelOutput:
              methodProps = { ...methodProps,
                ...(uiactions_GetNodeProp(GetNodeById(methodNode.id), nodetypes_NodeProperties.MethodProps) || {})
              };

              if (constraint[nodetypes_NodeProperties.IsAgent]) {
                methodProps[constraint.key] = agent.id;
              } else if (constraint.key === FunctionTemplateKeys.User) {
                methodProps[constraint.key] = option.user ? option.user.id : uiactions_GetNodeProp(GetNodeById(agent.id), nodetypes_NodeProperties.UIUser) || GetUsers()[0].id;
                commands.push({
                  operation: uiactions_ADD_LINK_BETWEEN_NODES,

                  options() {
                    return {
                      source: methodNode.id,
                      target: methodProps[constraint.key],
                      properties: { ...nodetypes_LinkProperties.FunctionOperator
                      }
                    };
                  }

                });
              } else if (constraint.key === FunctionTemplateKeys.Parent) {
                methodProps[constraint.key] = parent.id;
              } else {
                methodProps[constraint.key] = model.id;
              }

              break;

            case FunctionTemplateKeys.Validator:
              commands.push(...[{
                operation: ADD_NEW_NODE,

                options() {
                  return {
                    parent: methodNode.id,
                    nodeType: NodeTypes.Validator,
                    groupProperties: {},
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.Collapsed]: true,
                      [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(methodNode)} Validator`,
                      [nodetypes_NodeProperties.ValidatorModel]: model.id,
                      [nodetypes_NodeProperties.ValidatorAgent]: agent.id,
                      [nodetypes_NodeProperties.ValidatorFunction]: methodNode.id
                    },
                    callback: _node => {
                      methodProps[constraint.key] = _node.id;
                      validator = _node;
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: model.id,
                    source: validator.id,
                    properties: { ...nodetypes_LinkProperties.ValidatorModelLink
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: agent.id,
                    source: validator.id,
                    properties: { ...nodetypes_LinkProperties.ValidatorAgentLink
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: methodNode.id,
                    source: validator.id,
                    properties: { ...nodetypes_LinkProperties.ValidatorFunctionLink
                    }
                  };
                }

              }]);
              break;

            case FunctionTemplateKeys.Executor:
              commands.push(...[{
                operation: ADD_NEW_NODE,

                options() {
                  return {
                    parent: methodNode.id,
                    nodeType: NodeTypes.Executor,
                    groupProperties: {},
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                      [nodetypes_NodeProperties.ExecutorFunctionType]: methodType,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(methodNode)} Executor`,
                      [nodetypes_NodeProperties.ExecutorModel]: model.id,
                      [nodetypes_NodeProperties.ExecutorModelOutput]: model.id,
                      [nodetypes_NodeProperties.ExecutorFunction]: methodNode.id,
                      [nodetypes_NodeProperties.ExecutorAgent]: agent.id
                    },
                    callback: _node => {
                      methodProps[constraint.key] = _node.id;
                      executor = _node;
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: model.id,
                    source: executor.id,
                    properties: { ...nodetypes_LinkProperties.ExecutorModelLink
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: agent.id,
                    source: executor.id,
                    properties: { ...nodetypes_LinkProperties.ExecutorAgentLink
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: methodNode.id,
                    source: executor.id,
                    properties: { ...nodetypes_LinkProperties.ExecutorFunctionLink
                    }
                  };
                }

              }]);
              break;

            case FunctionTemplateKeys.Permission:
            case FunctionTemplateKeys.ModelFilter:
              commands.push(...[{
                operation: ADD_NEW_NODE,

                options() {
                  return {
                    parent: methodNode.id,
                    nodeType: constraint.key === FunctionTemplateKeys.Permission ? NodeTypes.Permission : NodeTypes.ModelFilter,
                    groupProperties: {},
                    properties: {
                      [nodetypes_NodeProperties.NodePackage]: model.id,
                      [nodetypes_NodeProperties.NodePackageType]: nodePackageType,
                      [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(methodNode)} ${constraint.key === FunctionTemplateKeys.Permission ? NodeTypes.Permission : NodeTypes.ModelFilter}`
                    },
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.FunctionOperator
                      }
                    },
                    callback: newNode => {
                      methodProps = { ...methodProps,
                        ...(uiactions_GetNodeProp(GetNodeById(methodNode.id), nodetypes_NodeProperties.MethodProps) || {})
                      };
                      methodProps[constraint.key] = newNode.id;
                      perOrModelNode = newNode;
                    }
                  };
                }

              }]);

              if (constraint.key === FunctionTemplateKeys.ModelFilter) {
                commands = [...commands, {
                  operation: CHANGE_NODE_PROPERTY,

                  options() {
                    return {
                      prop: nodetypes_NodeProperties.FilterAgent,
                      id: perOrModelNode.id,
                      value: agent.id
                    };
                  }

                }, {
                  operation: CHANGE_NODE_PROPERTY,

                  options() {
                    return {
                      prop: nodetypes_NodeProperties.FilterModel,
                      id: perOrModelNode.id,
                      value: model.id
                    };
                  }

                }, {
                  operation: uiactions_ADD_LINK_BETWEEN_NODES,

                  options() {
                    return {
                      target: model.id,
                      source: perOrModelNode.id,
                      properties: { ...nodetypes_LinkProperties.ModelTypeLink
                      }
                    };
                  }

                }, {
                  operation: uiactions_ADD_LINK_BETWEEN_NODES,

                  options() {
                    return {
                      target: agent.id,
                      source: perOrModelNode.id,
                      properties: { ...nodetypes_LinkProperties.AgentTypeLink
                      }
                    };
                  }

                }];
              }

              break;

            default:
              break;
          }

          commands = [...commands, ...[{
            operation: CHANGE_NODE_PROPERTY,

            options() {
              return {
                prop: nodetypes_NodeProperties.MethodProps,
                id: methodNode.id,
                value: methodProps
              };
            }

          }, {
            operation: uiactions_ADD_LINK_BETWEEN_NODES,

            options() {
              return {
                target: methodProps[constraint.key],
                source: methodNode.id,
                properties: { ...nodetypes_LinkProperties.FunctionOperator
                }
              };
            }

          }]];
        });
        return commands;
      }];
      PerformGraphOperation(outer_commands)(dispatch, getState);
      updateMethodParameters(new_nodes.methodNode.id, functionType, viewPackage)(dispatch, getState);
      attachMethodToMaestro(new_nodes.methodNode.id, model.id, option)(dispatch, getState, null, viewPackage);
      PerformGraphOperation([{
        operation: NO_OP,

        options() {}

      }]);
    }

    setViewPackageStamp(null, "CreateAgentFunction");
    return new_nodes;
  };
}

function addListItemComponentApi(newItems, text, noExternal, keyfunc, parent, options = {
  useAsValue: true
}) {
  let internalId;
  let externalId;
  return [{
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.ComponentApi,
        callback: nn => {
          internalId = nn.id;

          if (keyfunc && noExternal) {
            keyfunc(text, {
              internalId,
              externalId
            });
            setApiConnectors(newItems, parent, {
              internalId,
              externalId
            }, text);
          }
        },
        parent,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentInternalApi
          }
        },
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: text,
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UseAsValue]: options.useAsValue
        }
      };
    }

  }, noExternal ? null : {
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.ComponentExternalApi,
        callback: nn => {
          externalId = nn.id;
        },
        parent,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentExternalApi
          }
        },
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UIText]: text
        }
      };
    }

  }, noExternal ? null : {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      if (keyfunc) {
        keyfunc(text, {
          internalId,
          externalId
        });
      }

      setApiConnectors(newItems, parent, {
        internalId,
        externalId
      }, text);
      return {
        source: internalId,
        target: externalId,
        properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
        }
      };
    }

  }].filter(x => x);
}

function addComponentEventApiNodes(args) {
  const {
    newItems,
    childComponents,
    modelIndex,
    modelProperty,
    currentNode,
    viewComponent,
    viewPackage,
    useModelInstance
  } = args;
  const parent = childComponents[modelIndex];
  newItems.eventApis = newItems.eventApis || {};
  return (viewComponent.eventApi || []).map(apiName => {
    const apiNameInstance = `${apiName} Instance`;
    const apiNameEventHandler = `${apiName} Event Handler`;
    return [{
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.EventMethod,
          callback: nn => {
            newItems.eventApis[childComponents[modelIndex]] = { ...(newItems.eventApis[childComponents[modelIndex]] || {}),
              [apiName]: nn.id
            };
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.EventMethod
            }
          },
          parent,
          groupProperties: {},
          properties: { ...viewPackage,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
            [nodetypes_NodeProperties.EventType]: apiName,
            [nodetypes_NodeProperties.UIText]: `${apiName}`
          },
          links: [{
            target: currentNode.id,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.ModelTypeLink
              }
            }
          }]
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.EventMethodInstance,
          callback: nn => {
            newItems.eventApis[childComponents[modelIndex]] = { ...(newItems.eventApis[childComponents[modelIndex]] || {}),
              [apiNameInstance]: nn.id
            };
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.EventMethodInstance
            }
          },
          parent: newItems.eventApis[childComponents[modelIndex]][apiName],
          groupProperties: {},
          properties: {
            [nodetypes_NodeProperties.UIText]: `${apiName} Instance`,
            [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance,
            [nodetypes_NodeProperties.EventType]: apiName,
            [nodetypes_NodeProperties.Model]: currentNode.id,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.Property]: modelProperty.id,
            [nodetypes_NodeProperties.AutoDelete]: {
              properties: {
                [nodetypes_NodeProperties.NODEType]: NodeTypes.ComponentApiConnector
              }
            }
          }
        };
      }

    }, {
      operation: ADD_NEW_NODE,

      options() {
        return {
          nodeType: NodeTypes.EventHandler,
          callback: nn => {
            newItems.eventApis[childComponents[modelIndex]] = { ...(newItems.eventApis[childComponents[modelIndex]] || {}),
              [apiNameEventHandler]: nn.id
            };
          },
          parent: newItems.eventApis[childComponents[modelIndex]][apiNameInstance],
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.EventHandler
            }
          },
          groupProperties: {},
          properties: {
            [nodetypes_NodeProperties.EventType]: apiName,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.UIText]: `${apiName} EventHandler`
          }
        };
      }

    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          source: newItems.eventApis[childComponents[modelIndex]][apiNameEventHandler],
          target: modelProperty.id,
          properties: { ...nodetypes_LinkProperties.PropertyLink
          }
        };
      }

    }];
  }).flatten();
}

function nodepackages_addComponentApiNodes(newItems, childComponents, modelIndex, apiName = "value", externalApiId) {
  const parent = childComponents[modelIndex];
  let componentInternalValue = null;
  let componentExternalValue = null;
  return [{
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.ComponentApi,
        callback: nn => {
          componentInternalValue = nn.id;
          newItems[childComponents[modelIndex]] = { ...(newItems[childComponents[modelIndex]] || {}),
            [apiName]: {
              componentInternalValue: nn.id
            }
          };
        },
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentInternalApi
          }
        },
        parent,
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: apiName,
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UseAsValue]: true // [NodeProperties.ComponentApiKey]: viewComponentType.internalApiNode || null

        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.ComponentExternalApi,
        callback: nn => {
          componentExternalValue = nn.id;
          newItems[childComponents[modelIndex]] = { ...newItems[childComponents[modelIndex]],
            [apiName]: { ...newItems[childComponents[modelIndex]][apiName],
              componentExternalValue: nn.id
            }
          };
        },
        parent,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentExternalApi
          }
        },
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: apiName,
          [nodetypes_NodeProperties.Pinned]: false // [NodeProperties.ComponentApiKey]:  viewComponentType.externalApiNode || null

        }
      };
    }

  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      if (parent) {
        setApiConnectors(newItems, parent, {
          internalId: componentInternalValue,
          externalId: componentExternalValue
        }, apiName);
      }

      return {
        source: componentInternalValue,
        target: componentExternalValue,
        properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
        }
      };
    }

  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        target: externalApiId || newItems.screenComponentIdInternalApi,
        source: componentExternalValue,
        properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
        }
      };
    }

  }].filter(x => x);
}

function addButtonApiNodes(newItems, btn) {
  let buttonInternalApi = null;
  let buttonExternalApi = null;

  btn = btn || (() => null);

  return [{
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.ComponentApi,
        callback: nn => {
          buttonInternalApi = nn.id;
        },
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentInternalApi
          }
        },
        parent: btn() || newItems.button,
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: `label`,
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UseAsValue]: true
        }
      };
    }

  }, {
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.ComponentExternalApi,
        callback: nn => {
          buttonExternalApi = nn.id;
        },
        parent: btn() || newItems.button,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentExternalApi
          }
        },
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UIText]: `label`
        }
      };
    }

  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        source: buttonInternalApi,
        target: buttonExternalApi,
        properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
        }
      };
    }

  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        target: newItems.titleService,
        source: buttonExternalApi,
        properties: { ...nodetypes_LinkProperties.TitleServiceLink
        }
      };
    }

  }];
}

function ConnectExternalApisToSelectors(args) {
  const {
    modelComponentSelectors,
    newItems,
    viewType,
    childComponents,
    propertyIndex
  } = args;
  const steps = [];

  switch (viewType) {
    case viewtypes_ViewTypes.Update:
    case viewtypes_ViewTypes.Create:
      steps.push({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,

        options() {
          return {
            target: modelComponentSelectors[0],
            source: newItems[childComponents[propertyIndex]].value.componentExternalValue,
            properties: { ...nodetypes_LinkProperties.SelectorLink
            }
          };
        }

      });
      break;

    default:
      break;
  }

  PerformGraphOperation([...steps, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        target: newItems.titleService,
        source: newItems[childComponents[propertyIndex]].label.componentExternalValue,
        properties: { ...nodetypes_LinkProperties.TitleServiceLink
        }
      };
    }

  }])(GetDispatchFunc(), GetStateFunc());

  if (newItems[childComponents[propertyIndex]].placeholder) {
    PerformGraphOperation([...steps, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          target: newItems.titleService,
          source: newItems[childComponents[propertyIndex]].placeholder.componentExternalValue,
          properties: { ...nodetypes_LinkProperties.TitleServiceLink
          }
        };
      }

    }])(GetDispatchFunc(), GetStateFunc());
  }
}

function BuildPropertyDataChainAccessor(args) {
  const {
    viewName,
    modelProperty,
    viewPackage,
    currentNode,
    modelComponentSelectors,
    propertyDataChainAccesors,
    newItems,
    viewType
  } = args;
  let skip = false;
  let propDataChainNodeId = null;
  let entryNodeProperties = null;
  let links = null;
  let skipDataChainStep = false;
  let addcomplete = false;

  switch (viewType) {
    case viewtypes_ViewTypes.Update:
    case viewtypes_ViewTypes.Create:
      entryNodeProperties = {
        [nodetypes_NodeProperties.UIText]: `Get ${viewName} ${viewType} Object => ${GetNodeTitle(modelProperty)}`,
        [nodetypes_NodeProperties.EntryPoint]: true,
        [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Selector,
        [nodetypes_NodeProperties.Selector]: modelComponentSelectors[0],
        [nodetypes_NodeProperties.SelectorProperty]: SelectorPropertyKeys.Object,
        [nodetypes_NodeProperties.Pinned]: false,
        [nodetypes_NodeProperties.Property]: modelProperty.id
      };
      links = [{
        target: modelComponentSelectors[0],
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        }
      }];
      break;

    default:
      skipDataChainStep = true;
      addcomplete = true;
      entryNodeProperties = {
        [nodetypes_NodeProperties.UIText]: `Get ${viewName} ${viewType} Object => ${GetNodeTitle(modelProperty)}`,
        [nodetypes_NodeProperties.EntryPoint]: true,
        [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.ModelProperty,
        [nodetypes_NodeProperties.UIModelType]: currentNode.id,
        [nodetypes_NodeProperties.Pinned]: false,
        [nodetypes_NodeProperties.Property]: modelProperty.id
      };
      links = [{
        target: modelProperty.id,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.PropertyLink
          }
        }
      }, {
        target: currentNode.id,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ModelTypeLink
          }
        }
      }];
      break;
  }

  PerformGraphOperation([{
    operation: ADD_NEW_NODE,

    options() {
      const node = GetNodesByProperties({ ...entryNodeProperties
      }).find(x => x);

      if (node) {
        propDataChainNodeId = node.id;
        skip = true;
        propertyDataChainAccesors.push(propDataChainNodeId);
        setModelPropertyViewTypePropNode(newItems, modelProperty, viewType, node);
        return null;
      }

      return {
        nodeType: NodeTypes.DataChain,
        properties: { ...viewPackage,
          ...entryNodeProperties
        },
        links,
        callback: propNode => {
          propDataChainNodeId = propNode.id;
          propertyDataChainAccesors.push(propDataChainNodeId);
          setModelPropertyViewTypePropNode(newItems, modelProperty, viewType, propNode);
        }
      };
    }

  }, skipDataChainStep ? false : {
    operation: ADD_NEW_NODE,

    options() {
      if (skip) {
        return {};
      }

      return {
        parent: propDataChainNodeId,
        nodeType: NodeTypes.DataChain,
        groupProperties: {
          [GroupProperties.ExternalEntryNode]: uiactions_GetNodeProp(GetNodeById(propDataChainNodeId), nodetypes_NodeProperties.ChainParent),
          [GroupProperties.GroupEntryNode]: propDataChainNodeId,
          [GroupProperties.GroupExitNode]: propDataChainNodeId,
          [GroupProperties.ExternalExitNode]: GetDataChainNextId(propDataChainNodeId)
        },
        properties: { ...viewPackage,
          [nodetypes_NodeProperties.UIText]: `Get ${GetNodeTitle(modelProperty)}`,
          [nodetypes_NodeProperties.ChainParent]: propDataChainNodeId,
          [nodetypes_NodeProperties.AsOutput]: true,
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Property,
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.UIModelType]: currentNode.id,
          [nodetypes_NodeProperties.Property]: modelProperty.id
        },
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        },
        links: [{
          target: currentNode.id,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ModelTypeLink
            }
          }
        }, {
          target: modelProperty.id,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.PropertyLink
            }
          }
        }],
        callback: () => {}
      };
    }

  }, addcomplete ? {
    operation: ADD_NEW_NODE,

    options(graph) {
      if (skip) {
        return false;
      }

      const groupProperties = uiactions_GetNodeProp(propDataChainNodeId, nodetypes_NodeProperties.GroupParent, graph) ? {
        id: uiactions_getGroup(uiactions_GetNodeProp(propDataChainNodeId, nodetypes_NodeProperties.GroupParent, graph), graph).id
      } : null;
      return {
        parent: propDataChainNodeId,
        nodeType: NodeTypes.DataChain,
        groupProperties,
        properties: {
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.ChainParent]: propDataChainNodeId,
          [nodetypes_NodeProperties.DataChainFunctionType]: DataChainFunctionKeys.Pass,
          [nodetypes_NodeProperties.UIText]: `Get ${viewName} ${viewType} Object => ${GetNodeTitle(modelProperty)} Output`,
          [nodetypes_NodeProperties.AsOutput]: true
        },
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        }
      };
    }

  } : false].filter(x => x))(GetDispatchFunc(), GetStateFunc());
  return {
    skip,
    propDataChainNodeId
  };
}

function setModelPropertyViewTypePropNode(newItems, modelProperty, viewType, propNode) {
  if (!newItems.PropertyDataChainGetter) {
    newItems.PropertyDataChainGetter = {};
  }

  if (!newItems.PropertyDataChainGetter[modelProperty.id]) {
    newItems.PropertyDataChainGetter[modelProperty.id] = {};
  }

  newItems.PropertyDataChainGetter[modelProperty.id][viewType] = propNode.id;
}

function setupPropertyApi(args) {
  const {
    childId,
    apiList,
    childComponents,
    propertyIndex,
    viewName,
    apiDataChainLists,
    modelProperty,
    currentNode,
    modelComponentSelectors,
    viewType,
    uiType,
    newItems
  } = args;
  newItems.apiDataChain = newItems.apiDataChain || {};
  newItems.apiDataChain[childId] = apiDataChainLists;
  PerformGraphOperation([...apiList.map(api => {
    const apiProperty = api.value;

    if (ARE_BOOLEANS.some(v => v === apiProperty) || ARE_HANDLERS.some(v => v === apiProperty)) {
      return false;
    }

    let _context = null;

    switch (apiProperty) {
      case ApiProperty.Success:
        return [];
      // return [
      //   ...AttributeSuccess({
      //     model: currentNode.id,
      //     property: modelProperty.id,
      //     propertyName: GetNodeTitle(modelProperty),
      //     viewName,
      //     uiType,
      //     callback: context => {
      //       _context = context;
      //       apiDataChainLists[apiProperty] = _context.entry;
      //     }
      //   })
      // ];

      case ApiProperty.Error:
        return [];
      // return [
      //   ...AttributeError({
      //     model: currentNode.id,
      //     property: modelProperty.id,
      //     propertyName: `${viewName} ${GetNodeTitle(
      //       modelProperty
      //     )} ${uiType}`,
      //     viewName,
      //     callback: context => {
      //       _context = context;
      //       apiDataChainLists[apiProperty] = _context.entry;
      //     }
      //   })
      // ];

      default:
        break;
    }

    return [...CreateSelectorToDataChainSelectorDC({
      model: currentNode.id,
      property: modelProperty.id,
      viewName,
      viewType,
      uiType,
      propertyName: GetNodeTitle(modelProperty),
      screen: GetNodeTitle(newItems.screenNodeId),
      external_api: apiProperty,
      callback: context => {
        _context = context;
        apiDataChainLists[apiProperty] = _context.entry;
      }
    })];
  }).flatten().filter(x => x), ...apiList.map(v => v.value).map(api_key => {
    return {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        if (newItems[childComponents[propertyIndex]][api_key]) {
          return {
            target: apiDataChainLists[api_key],
            source: newItems[childComponents[propertyIndex]][api_key].componentExternalValue,
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          };
        }
      }

    };
  }), ...apiList.map(v => v.value).map(api_key => {
    return {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        if (modelComponentSelectors[0]) {
          return {
            target: modelComponentSelectors[0],
            source: newItems[childComponents[propertyIndex]][api_key].componentExternalValue,
            properties: { ...nodetypes_LinkProperties.SelectorLink
            }
          };
        }
      }

    };
  })])(GetDispatchFunc(), GetStateFunc());
}

function connectComponentToExternalApi(args) {
  const {
    newItems,
    child,
    key,
    parent,
    properties
  } = args;
  const {
    externalId
  } = getApiConnectors(newItems, child, key);
  const {
    internalId
  } = getApiConnectors(newItems, parent, key);
  return [{
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        source: externalId,
        target: internalId,
        properties: { ...properties
        }
      };
    }

  }];
}

function addComponentApiToForm(args) {
  const {
    newItems,
    text,
    parent,
    isSingular,
    graph,
    internalProperties = {},
    externalProperties = {}
  } = args;
  let externalId;
  let internalId;
  let skip = false;
  return [{
    operation: ADD_NEW_NODE,

    options() {
      if (parent) {
        if (isSingular && graph) {
          const temp = GetNodesLinkedTo(graph, {
            id: parent,
            link: nodetypes_LinkType.ComponentInternalApi
          }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentApi && uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIText) === text);

          if (temp) {
            internalId = temp.id;
            skip = true;
            return false;
          }
        }

        return {
          nodeType: NodeTypes.ComponentApi,
          callback: nn => {
            internalId = nn.id;
          },
          parent,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ComponentInternalApi
            }
          },
          groupProperties: {},
          properties: { ...internalProperties,
            [nodetypes_NodeProperties.UIText]: text,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.UseAsValue]: true
          }
        };
      }
    }

  }, {
    operation: ADD_NEW_NODE,

    options() {
      if (isSingular && graph) {
        const temp = GetNodesLinkedTo(graph, {
          id: parent,
          link: nodetypes_LinkType.ComponentExternalApi
        }).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentApi && uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIText) === text);

        if (temp) {
          externalId = temp.id;
          skip = true;
          return false;
        }
      }

      if (parent && !skip) {
        return {
          nodeType: NodeTypes.ComponentExternalApi,
          callback: nn => {
            externalId = nn.id;
          },
          parent,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ComponentExternalApi
            }
          },
          groupProperties: {},
          properties: { ...externalProperties,
            [nodetypes_NodeProperties.Pinned]: false,
            [nodetypes_NodeProperties.UIText]: text
          }
        };
      }
    }

  }, {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      if (parent) {
        setApiConnectors(newItems, parent, {
          internalId,
          externalId
        }, text);
      }

      if (parent && !skip) {
        return {
          source: internalId,
          target: externalId,
          properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
          }
        };
      }
    }

  }];
}

function setApiConnectors(newItems, parent, api, key) {
  newItems.apiConnectors = newItems.apiConnectors || {};
  newItems.apiConnectors[parent] = newItems.apiConnectors[parent] || {};
  newItems.apiConnectors[parent][key] = api;
}

function getApiConnectors(newItems, parent, key) {
  newItems.apiConnectors = newItems.apiConnectors || {};
  newItems.apiConnectors[parent] = newItems.apiConnectors[parent] || {};
  return newItems.apiConnectors[parent][key];
}

function AttachDataChainAccessorTo(nodeId, accessorId) {
  const externalApis = GetNodesLinkedTo(GetCurrentGraph(GetState()), {
    id: nodeId,
    link: nodetypes_LinkType.ComponentExternalApi
  });
  PerformGraphOperation([...externalApis.map(externalApi => {
    return {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          target: accessorId,
          source: externalApi.id,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }

    };
  })])(GetDispatchFunc(), GetStateFunc());
}

function AttachSelectorAccessorTo(nodeId, accessorId) {
  const externalApis = GetNodesLinkedTo(GetCurrentGraph(GetState()), {
    id: nodeId,
    link: nodetypes_LinkType.ComponentExternalApi
  });
  PerformGraphOperation([...externalApis.map(externalApi => {
    return {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          target: accessorId,
          source: externalApi.id,
          properties: { ...nodetypes_LinkProperties.SelectorLink
          }
        };
      }

    };
  })])(GetDispatchFunc(), GetStateFunc());
}
// CONCATENATED MODULE: ./app/components/treeviewmenu.js
var treeviewmenu_REACT_ELEMENT_TYPE;

function treeviewmenu_jsx(type, props, key, children) { if (!treeviewmenu_REACT_ELEMENT_TYPE) { treeviewmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: treeviewmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



var treeviewmenu_ref =
/*#__PURE__*/
treeviewmenu_jsx("i", {
  className: "fa fa-angle-left pull-right"
});

class treeviewmenu_TreeViewMenu extends external_react_["Component"] {
  active() {
    return this.props.active ? "active" : "";
  }

  open() {
    return this.props.open ? "menu-open" : "";
  }

  display() {
    return this.props.open ? "block" : "block";
  }

  icon() {
    return this.props.icon || (this.props.children ? "fa fa-folder" : null) || "fa fa-wrench";
  }

  render() {
    return treeviewmenu_jsx("li", {
      title: this.props.description,
      className: `treeview ${this.active()} ${this.open()}`
    }, void 0, treeviewmenu_jsx("a", {
      onClick: () => {
        if (this.props.toggle) this.props.toggle();

        if (this.props.onClick) {
          this.props.onClick();
        }
      }
    }, void 0, this.props.hideIcon ? null : treeviewmenu_jsx("i", {
      className: `${this.icon()}`
    }), treeviewmenu_jsx("span", {
      title: this.props.description || this.props.title
    }, void 0, this.props.title), this.props.hideArrow || !this.props.children ? null : treeviewmenu_jsx("span", {
      className: "pull-right-container"
    }, void 0, treeviewmenu_ref, this.props.right ? this.props.right : null), !this.props.hideArrow && this.props.right ? null : treeviewmenu_jsx("span", {
      className: "pull-right-container"
    }, void 0, this.props.right ? this.props.right : null)), treeviewmenu_jsx("ul", {
      className: "treeview-menu",
      style: {
        display: this.display(),
        ...(this.props.innerStyle || {})
      }
    }, void 0, this.props.children));
  }

}
// CONCATENATED MODULE: ./app/components/sidebar.js
var sidebar_REACT_ELEMENT_TYPE;

function sidebar_jsx(type, props, key, children) { if (!sidebar_REACT_ELEMENT_TYPE) { sidebar_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebar_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



class sidebar_SideBar extends external_react_["Component"] {
  open() {
    return this.props.open ? "control-sidebar-open" : "";
  }

  extraWidth() {
    return this.props.extraWide ? "extra-wide" : "";
  }

  relative() {
    return this.props.relative ? RelativeMenuCss : {};
  }

  render() {
    return sidebar_jsx("aside", {
      style: { ...this.relative(),
        minHeight: "auto",
        ...(this.props.style || {})
      },
      className: `control-sidebar control-sidebar-dark ${this.open()} ${this.extraWidth()}`
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/sidebarmenu.js
var sidebarmenu_REACT_ELEMENT_TYPE;

function sidebarmenu_jsx(type, props, key, children) { if (!sidebarmenu_REACT_ELEMENT_TYPE) { sidebarmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebarmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class sidebarmenu_SideBarMenu extends external_react_["Component"] {
  render() {
    return sidebarmenu_jsx("ul", {
      className: "sidebar-menu tree"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/agentbasedmethods.js

var agentbasedmethods_REACT_ELEMENT_TYPE;

function agentbasedmethods_jsx(type, props, key, children) { if (!agentbasedmethods_REACT_ELEMENT_TYPE) { agentbasedmethods_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: agentbasedmethods_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















var agentbasedmethods_ref =
/*#__PURE__*/
agentbasedmethods_jsx("div", {});

class agentbasedmethods_AgentBasedMethods extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;

    if (!state || !HasCurrentGraph()) {
      return agentbasedmethods_ref;
    }

    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    return agentbasedmethods_jsx(tabpane_TabPane, {
      active: true
    }, void 0, agentbasedmethods_jsx(formcontrol_FormControl, {}, void 0, agentbasedmethods_jsx("h3", {}, void 0, titles_QuickMethods), agentbasedmethods_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).filter(t => uiactions_GetNodeProp(t, nodetypes_NodeProperties.IsAgent)).toNodeSelect(),
      label: Agents,
      onChange: value => {
        this.props.setVisual(BATCH_AGENT, value);
      },
      value: Visual(state, BATCH_AGENT)
    }), agentbasedmethods_jsx("div", {
      style: {
        paddingBottom: 10
      }
    }, void 0, agentbasedmethods_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: Clear,
      icon: 'fa fa-times',
      toggle: () => {
        this.props.graphOperation(uiactions_NodesByType(state, NodeTypes.Model).map(model => {
          return {
            operation: CHANGE_NODE_PROPERTY,
            options: {
              prop: uiactions_NodeProperties.AgentBasedMethod,
              id: model.id,
              value: false
            }
          };
        }));
      }
    }), agentbasedmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: Models,
      icon: 'fa fa-object-group',
      open: Visual(state, 'agent-base-methods'),
      innerStyle: {
        maxHeight: 400,
        overflowY: 'auto'
      },
      right: null,
      hideArrow: true,
      active: true,
      toggle: () => {
        this.props.toggleVisual('agent-base-methods');
      }
    }, void 0, uiactions_NodesByType(state, NodeTypes.Model).map(model => {
      return agentbasedmethods_jsx(treeviewmenu_TreeViewMenu, {
        hideArrow: true,
        title: uiactions_GetNodeProp(model, nodetypes_NodeProperties.UIText),
        icon: !uiactions_GetNodeProp(model, nodetypes_NodeProperties.AgentBasedMethod) ? "fa fa-circle-o" : 'fa fa-check-circle-o',
        toggle: () => {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.AgentBasedMethod,
            id: model.id,
            value: !uiactions_GetNodeProp(model, nodetypes_NodeProperties.AgentBasedMethod)
          });
        }
      }, `node--${model.id}`);
    }))), agentbasedmethods_jsx(selectinput_SelectInput, {
      options: Object.keys(MethodFunctions).map(t => {
        return {
          title: MethodFunctions[t] && MethodFunctions[t].title ? MethodFunctions[t].title : t,
          value: t
        };
      }),
      label: FunctionTypes,
      onChange: value => {
        this.props.setVisual(BATCH_FUNCTION_TYPE, value);
      },
      value: Visual(state, BATCH_FUNCTION_TYPE)
    }), agentbasedmethods_jsx(textinput_TextInput, {
      label: MethodName,
      value: Visual(state, BATCH_FUNCTION_NAME),
      onChange: value => {
        this.props.setVisual(BATCH_FUNCTION_NAME, value);
      }
    }), agentbasedmethods_jsx("button", {
      type: "button",
      className: "btn btn-block btn-info btn-sm",
      onClick: () => {
        this.props.executeGraphOperations(uiactions_NodesByType(state, NodeTypes.Model).filter(x => {
          return uiactions_GetNodeProp(x, nodetypes_NodeProperties.AgentBasedMethod);
        }).map(model => {
          let functionName = MethodFunctions[Visual(state, BATCH_FUNCTION_TYPE)].titleTemplate(GetNodeTitle(model), GetNodeTitle(GetNodeById(Visual(state, BATCH_AGENT))));
          return {
            node: currentNode,
            type: Visual(state, BATCH_FUNCTION_NAME),
            method: {
              method: CreateAgentFunction({
                nodePackageType: functionName,
                methodType: MethodFunctions[Visual(state, BATCH_FUNCTION_TYPE)].method,
                model: model,
                parentId: GetNodeById(Visual(state, BATCH_PARENT)),
                agent: GetNodeById(Visual(state, BATCH_AGENT)),
                httpMethod: HTTP_METHODS.POST,
                functionType: Visual(state, BATCH_FUNCTION_TYPE),
                functionName
              })
            },
            methodType: Visual(state, BATCH_FUNCTION_TYPE)
          };
        }));
      }
    }, void 0, "Build")));
  }

}

/* harmony default export */ var agentbasedmethods = (UIConnect(agentbasedmethods_AgentBasedMethods));
// CONCATENATED MODULE: ./app/nodepacks/GetProjectUrlsDataChain.js
/* harmony default export */ var GetProjectUrlsDataChain = (function (args = {}) {
  // node2
  let context = { ...args
  };
  return [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get Project Urls"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: false
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "New Red Graph"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "New Menu"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.node2
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node3,
        value: "Add Urls to Graph"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node3,
        value: "Add Urls To Graph"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node3,
        value: true
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/temppack.js
/* harmony default export */ var temppack = (function (args = {}) {
  // node4,node5
  // propertyName
  let context = { ...args
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get Success For " + args.propertyName + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => x ? x.object : null"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Get object from selector result"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node2,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node2,
        value: "x => x ? x.sucess: null"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "Get success from "
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node2,
        value: "x => x ? x.dirty: null"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "Get dirty from selector result"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node2,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node2
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node3,
        value: "Model - Property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node3,
        value: context.node4
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node4,
        source: context.node3,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Property",
        id: context.node3,
        value: context.node5
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node5,
        source: context.node3,
        properties: {
          type: "property-link",
          "property-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node3,
        value: "Get Property from dirty"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node6 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node6,
        value: "Model - Property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node6
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node6,
        value: context.node4
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node4,
        source: context.node6,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node6
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Property",
        id: context.node6,
        value: context.node5
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node5,
        source: context.node6,
        properties: {
          type: "property-link",
          "property-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node6,
        value: "Get Property from object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node3
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node7 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node7,
        value: "IfThanElse"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node7,
        value: "if dirty then check validity"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node6,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node6
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node8 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node8,
        value: "Validation"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node8,
        value: "validate property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node7
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "ChainNodeInput1",
        id: context.node7,
        value: context.node8
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node8,
        target: context.node7,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "data-chain",
        properties: {
          MergeChain: true
        },
        groupProperties: {
          id: context.group0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node9 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node9,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node9,
        value: "x => false"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node9,
        value: "return false"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node7
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "ChainNodeInput2",
        id: context.node7,
        value: context.node9
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node9,
        target: context.node7,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node7,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node7
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node10 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node10,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node10,
        value: "complete"
      }
    }];
  }];
  return [...result, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateDashboard_1.js



/* harmony default export */ var CreateDashboard_1 = (function (args = {}) {
  // node3,node4,node5,node6,node7,node8,node9,node10,node11,node12
  //
  let context = { ...args,
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4(),
    node6: uuidv4(),
    node7: uuidv4(),
    node8: uuidv4(),
    node9: uuidv4(),
    node10: uuidv4(),
    node11: uuidv4(),
    node12: uuidv4(),
    name: args.name || "Dashboard"
  };
  let {
    viewPackages = {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4()
    }
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "" + context.name + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "screen"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_SCREEN_OPTIONS",
      options: {
        parent: context.node0,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "screen-options",
            "screen-options": {}
          }
        },
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "UIType",
        id: context.node1,
        value: "ElectronIO"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "" + context.name + " IO"
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node1,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO"
        },
        linkProperties: {
          properties: {
            type: "component",
            stroke: "#B7245C",
            component: {}
          }
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
          context.group1 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node3]: {
              [context.node4]: {},
              [context.node5]: {}
            }
          },
          properties: {
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {},
                [context.node12]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SecondaryMain"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node12]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "RightContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {},
                [context.node12]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SecondaryMain"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node12]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "RightContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {},
                [context.node12]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SecondaryMain"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node12]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "RightContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {},
                [context.node12]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SecondaryMain"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node12]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "RightContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {},
                [context.node12]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {
                [context.node7]: context.node2
              },
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SecondaryMain"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node12]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "RightContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "" + context.name + " IO Title"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node2,
        value: "H3"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node1,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {},
                [context.node12]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {
                [context.node7]: context.node2
              },
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SecondaryMain"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node12]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "25%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "RightContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node6,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node7,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node8,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node9,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node10,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node11,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node12,
        value: false
      };
    }
  }];
  let applyViewPackages = [...["node0", "node1", "node2"].map(v => {
    return {
      operation: UPDATE_NODE_PROPERTY,
      options: function () {
        return {
          id: context[v],
          properties: viewPackages
        };
      }
    };
  })];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateConfiguration.js

/* harmony default export */ var CreateConfiguration = (function (args = {}) {
  //
  //
  let context = { ...args
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Configuration"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "configuration"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Domain",
        id: context.node0,
        value: "localhost:44338"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "UseHttps",
        id: context.node0,
        value: true
      }
    }];
  }];
  let clearPinned = [];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateFetchParameters.js


/* harmony default export */ var CreateFetchParameters = (function (args = {}) {
  //
  //
  let context = { ...args
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Fetch Parameters"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "IsFetchParameter",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_PROPERTY_NODE",
      options: {
        parent: context.node0,
        properties: {
          uiAttributeType: "STRING"
        },
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "property-link",
            "property-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiAttributeType",
        id: context.node1,
        value: "LISTOFSTRINGS"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Ids"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "UseInView",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "ExcludeFromController",
        id: context.node0,
        value: true
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateFetchService.js


/* harmony default export */ var CreateFetchService = (function (args = {}) {
  //
  //
  let context = { ...args
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": "Fetch Service"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "screen"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "selector"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "service-interface"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "FetchService"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node0,
        "value": true
      }
    }];
  }];
  let clearPinned = [];
  let applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, graphh => {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context, graphh);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateFetchOutput.js


/* harmony default export */ var CreateFetchOutput = (function (args = {}) {
  //
  //
  let context = { ...args
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Fetch Output"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "FetchService"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "maestro"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "IsFetchOutput",
        id: context.node0,
        value: true
      }
    }];
  }];
  let clearPinned = [];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, grapph => {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context, grapph);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreatePropertiesForFetch.js




/* harmony default export */ var CreatePropertiesForFetch = (function (args = {}) {
  let {
    id
  } = args;
  let fetchServices = GetNodesLinkedTo(GetCurrentGraph(), {
    id,
    link: nodetypes_LinkType.FetchServiceOuput
  });
  let result = [];

  if (fetchServices && fetchServices.length) {
    let fetchService = fetchServices[0];
    GetNodesLinkedTo(GetCurrentGraph(), {
      id,
      link: nodetypes_LinkType.PropertyLink
    }).map(v => {
      result.push({
        operation: REMOVE_NODE,
        options: {
          id: v.id
        }
      });
    });
    let models = GetNodesLinkedTo(GetCurrentGraph(), {
      id: fetchService.id,
      link: nodetypes_LinkType.FetchService
    }).map(model => {
      let methodprops = uiactions_GetNodeProp(model.id, nodetypes_NodeProperties.MethodProps) || {};
      return methodprops[FunctionTemplateKeys.ModelOutput] || methodprops[FunctionTemplateKeys.Model];
    }).filter(x => x).unique().map(v => GetNodeById(v));
    models.map(model => {
      result.push({
        operation: ADD_NEW_NODE,
        options: function () {
          return {
            nodeType: NodeTypes.Property,
            parent: id,
            properties: {
              [nodetypes_NodeProperties.UseModelAsType]: true,
              [nodetypes_NodeProperties.UIModelType]: model.id,
              [nodetypes_NodeProperties.UIText]: GetNodeTitle(model),
              [nodetypes_NodeProperties.IsTypeList]: true
            },
            groupProperties: {},
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.PropertyLink
              }
            },
            links: [{
              target: model.id,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ModelTypeLink
                }
              }
            }]
          };
        }
      });
    });
  }

  return result;
});
// CONCATENATED MODULE: ./app/nodepacks/CreateFetchServiceIdempotently.js








/* harmony default export */ var CreateFetchServiceIdempotently = (function (args = {}) {
  //
  let result = [];
  let context = { ...args
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let graph = GetCurrentGraph();
  let fetchParameter = GetNodeByProperties({
    [nodetypes_NodeProperties.IsFetchParameter]: true
  }, graph);
  let fetchOutput = GetNodeByProperties({
    [nodetypes_NodeProperties.IsFetchOutput]: true
  }, graph);
  let fetchService = GetNodeByProperties({
    [nodetypes_NodeProperties.NODEType]: NodeTypes.FetchService
  });

  if (!fetchParameter) {
    result.push(...CreateFetchParameters({
      callback: (context, g) => {
        fetchParameter = GetNodeById(context.entry, g);
      }
    }));
  }

  if (!fetchOutput) {
    result.push(...CreateFetchOutput({
      callback: (context, g) => {
        fetchOutput = GetNodeById(context.entry, g);
      }
    }));
  }

  if (!fetchService) {
    result.push(...CreateFetchService({
      callback: (context, g) => {
        fetchService = GetNodeById(context.entry, g);
      }
    }));
  }

  result.push(function () {
    let fetchCompatibleMethods = uiactions_NodesByType(null, NodeTypes.Method).filter(method => {
      let funcType = uiactions_GetNodeProp(method, nodetypes_NodeProperties.FunctionType);
      let {
        isFetchCompatible
      } = funcType && MethodFunctions[funcType] ? MethodFunctions[funcType] : {};
      return isFetchCompatible;
    });
    let tempresult = [];
    fetchCompatibleMethods.map(fetchMethod => {
      tempresult.push({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: function () {
          return {
            target: fetchMethod.id,
            source: fetchService.id,
            properties: { ...uiactions_LinkProperties.FetchService
            }
          };
        }
      });
      let param = GetMethodNodeProp(fetchMethod, FunctionTemplateKeys.FetchParameter);

      if (fetchParameter && param !== fetchParameter.id) {
        let methodProps = { ...(uiactions_GetNodeProp(fetchMethod, nodetypes_NodeProperties.MethodProps) || {})
        };
        methodProps[FunctionTemplateKeys.FetchParameter] = fetchParameter.id;
        tempresult.push({
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            source: fetchMethod.id,
            target: param
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            source: fetchMethod.id,
            target: fetchParameter.id,
            properties: { ...uiactions_LinkProperties.FunctionOperator
            }
          }
        }, {
          operation: UPDATE_NODE_PROPERTY,
          options: function () {
            return {
              id: fetchMethod.id,
              properties: {
                [nodetypes_NodeProperties.MethodProps]: methodProps
              }
            };
          }
        }, {
          operation: UPDATE_NODE_PROPERTY,
          options: function () {
            return {
              id: fetchParameter.id,
              properties: {
                [nodetypes_NodeProperties.ExcludeFromController]: true
              }
            };
          }
        });
      }
    });
    return tempresult;
  });
  result.push({
    operation: uiactions_ADD_LINK_BETWEEN_NODES,
    options: function () {
      return {
        target: fetchOutput.id,
        source: fetchService.id,
        properties: { ...uiactions_LinkProperties.FetchServiceOuput
        }
      };
    }
  });
  result.push(function () {
    return CreatePropertiesForFetch({
      id: fetchOutput.id
    });
  });
  return result;
});
// CONCATENATED MODULE: ./app/nodepacks/batch/CreateViewTypes.js






function CreateViewTypes() {
  const models = uiactions_NodesByType(null, NodeTypes.Model);
  const result = [];
  models.forEach(model => {
    const modelChildren = GetLogicalChildren(model.id);
    const modelProperties = GetNodesLinkedTo(null, {
      id: model.id,
      componentType: NodeTypes.Property,
      link: nodetypes_LinkType.ModelTypeLink
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UseModelAsType));
    const modelLinkedNodes = GetNodesLinkedTo(null, {
      id: model.id,
      link: nodetypes_LinkType.DefaultViewType,
      componentType: NodeTypes.ViewType
    });
    [...modelProperties, ...modelChildren].forEach(child => {
      const childModelLinkedNodes = GetNodesLinkedTo(null, {
        id: child.id,
        link: nodetypes_LinkType.DefaultViewType,
        componentType: NodeTypes.ViewType
      });
      const commonViewTypes = childModelLinkedNodes.intersection(modelLinkedNodes, (x, y) => y.id === x.id);
      const isProperty = uiactions_GetNodeProp(child, nodetypes_NodeProperties.UseModelAsType);
      Object.keys(viewtypes_ViewTypes).filter(x => !commonViewTypes.some(cvt => uiactions_GetNodeProp(cvt, nodetypes_NodeProperties.ViewType) === x)).forEach(viewType => {
        result.push(...CreateViewTypes_setupDefaultViewType({
          properties: { ...nodetypes_LinkProperties.DefaultViewType,
            viewType
          },
          target: isProperty ? model.id : child.id,
          isPluralComponent: uiactions_GetNodeProp(child, nodetypes_NodeProperties.NODEType) === NodeTypes.Model,
          source: isProperty ? child.id : model.id,
          viewCurrentType: viewType
        }));
      });
    });
  });
  return result;
}
CreateViewTypes.title = 'Create View Type Connections'; // export function ConnectViewType() {
//   let connectto = [];
//   Object.values(ViewTypes).map(viewType => {
//     connectto = getViewTypeEndpointsForDefaults(viewType, null, nodeId);
//     connectto.map(ct => {
//       this.props.setSharedComponent({
//         properties: {
//           ...LinkProperties.DefaultViewType,
//           viewType
//         },
//         source: ct.id,
//         target: properties.autoConnectViewType
//       })
//     });
//   });
// }

function CreateViewTypes_setupDefaultViewType(args) {
  const {
    properties,
    target,
    source,
    viewCurrentType,
    isPluralComponent
  } = args;
  const result = [];
  const graph = GetCurrentGraph();
  let isPropertyLink = false;

  if (existsLinkBetween(graph, {
    target,
    source,
    type: nodetypes_LinkType.ModelTypeLink
  })) {
    const isUsedAsModelType = uiactions_GetNodeProp(source, nodetypes_NodeProperties.UseModelAsType);

    if (isUsedAsModelType) {
      const targetedTypeNode = uiactions_GetNodeProp(source, nodetypes_NodeProperties.UIModelType);

      if (targetedTypeNode === target) {
        isPropertyLink = true;
      }
    }
  }

  const rightLink = isPropertyLink || existsLinkBetween(graph, {
    target,
    source,
    type: nodetypes_LinkType.LogicalChildren
  });

  if (rightLink) {
    const useModelAsType = uiactions_GetNodeProp(target, nodetypes_NodeProperties.UseModelAsType);
    result.push(...[viewCurrentType].map(viewType => {
      const sibling = uuidv4();
      return {
        operation: ADD_NEW_NODE,

        options() {
          return {
            nodeType: NodeTypes.ViewType,
            properties: {
              [nodetypes_NodeProperties.IsPluralComponent]: isPluralComponent,
              [nodetypes_NodeProperties.ViewType]: viewType,
              [nodetypes_NodeProperties.UIText]: `[${viewType}] ${GetNodeTitle(target)} => ${GetNodeTitle(source)} ${isPluralComponent ? 'Plural' : ''}`
            },
            ...(useModelAsType ? {
              parent: target,
              groupProperties: {}
            } : {}),
            links: [{
              target,
              linkProperties: {
                properties: { ...properties,
                  viewType,
                  sibling,
                  target
                }
              }
            }, {
              target: source,
              linkProperties: {
                properties: { ...properties,
                  viewType,
                  sibling,
                  source
                }
              }
            }]
          };
        }

      };
    }));
  }

  return result;
}
// CONCATENATED MODULE: ./app/templates/electronio/v1/app/actions/uiActions.js

const BATCH = "BATCH";
const uiActions_UI_UPDATE = "UI_UPDATE";
const UISI_UPDATE = "UISI_UPDATE";
const UISMI_UPDATE = "UISMI_UPDATE";
const UISMI_UPDATE_OBJECT = "UISMI_UPDATE_OBJECT";
const UISP_UPDATE = "UISP_UPDATE";
const UIMI_UPDATE = "UIMI_UPDATE";
const UI_MODELS = "UI_MODELS";
const RESET_ALL = "RESET_ALL";
const SCREEN_PROPERTIES = "SCREEN_PROPERTIES";
const MODEL_INSTANCE = "MODEL_INSTANCE";
const MODEL_INSTANCE_DIRTY = "MODEL_INSTANCE_DIRTY";
const MODEL_INSTANCE_ON_BLUR = "MODEL_INSTANCE_ON_BLUR";
const MODEL_INSTANCE_FOCUSED = "MODEL_INSTANCE_FOCUSED";
const MODEL_INSTANCE_ON_FOCUS = "MODEL_INSTANCE_ON_FOCUS";
const APP_STATE = "APP_STATE";
const SCREEN_INSTANCE = "SCREEN_INSTANCE";
const SCREEN_MODEL_INSTANCE = "SCREEN_MODEL_INSTANCE";
const SCREEN_MODEL_INSTANCE_OBJECT = "SCREEN_MODEL_INSTANCE_OBJECT";
const SCREEN_INSTANCE_DIRTY = "SCREEN_INSTANCE_DIRTY";
const SCREEN_INSTANCE_ON_BLUR = "SCREEN_INSTANCE_ON_BLUR";
const SCREEN_INSTANCE_FOCUSED = "SCREEN_INSTANCE_FOCUSED";
const SCREEN_INSTANCE_ON_FOCUS = "SCREEN_INSTANCE_ON_FOCUS";
const uiActions_VISUAL = "VISUAL";

let uiActions_getState;

let uiActions_dispatch;

function GetItems(modelType) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelDic = uiActions_GetC(state, UI_MODELS, modelType);

    if (modelDic) {
      return Object.values(modelDic);
    }
  }

  return [];
}
function GetScreenProperties(screen) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelDic = uiActions_GetC(state, SCREEN_PROPERTIES, screen);

    if (modelDic) {
      return modelDic;
    }
  }

  return null;
}
function UISP(screen, property, value) {
  return {
    type: UISP_UPDATE,
    key: SCREEN_PROPERTIES,
    screen,
    property,
    value
  };
}
function GetItem(modelType, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelDic = uiActions_GetC(state, UI_MODELS, modelType);

    if (modelDic) {
      return modelDic[id];
    }
  }

  return null;
}
function setGetState() {
  return (dispatch, getState) => {
    uiActions_getState = getState;
    uiActions_dispatch = dispatch;
  };
}
function GetDispatch() {
  if (uiActions_dispatch) {
    return uiActions_dispatch;
  }
}
function uiActions_GetState() {
  if (uiActions_getState) {
    return uiActions_getState;
  }
}
function uiActions_setTestGetState(func) {
  uiActions_getState = func;
}
function setDispatch(func) {
  uiActions_dispatch = func;
}
function UIV(item, value) {
  return uiActions_UIC(uiActions_VISUAL, item, value);
}
function uiActions_UIC(section, item, value) {
  return {
    type: uiActions_UI_UPDATE,
    item,
    value,
    section
  };
}
function UIModels(model, value) {
  return {
    type: UI_MODELS,
    model,
    value
  };
}
function Chain(id, funcs) {
  let res = id;
  funcs.map(func => {
    res = func(res);
  });
  return res;
}
function UISI(form, model, item, value) {
  return {
    type: UISI_UPDATE,
    key: SCREEN_INSTANCE,
    form,
    model,
    item,
    value
  };
}
function UISMI(form, model, instance, item, value) {
  return {
    type: UISMI_UPDATE,
    key: SCREEN_MODEL_INSTANCE,
    form,
    model,
    instance,
    item,
    value
  };
}
function UISMIO(form, model, instance, value) {
  return {
    type: UISMI_UPDATE_OBJECT,
    key: SCREEN_MODEL_INSTANCE,
    form,
    model,
    instance,
    value
  };
}
function UIMI(form, model, instance, item, value) {
  return {
    type: UIMI_UPDATE,
    key: MODEL_INSTANCE,
    form,
    model,
    instance,
    item,
    value
  };
}
function Batch(a, b, c, d, e, f, g, h, i) {
  return {
    type: BATCH,
    batch: [a, b, c, d, e, f, g, h, i].filter(x => x)
  };
}
function uiActions_Visual(state, key) {
  let _state = uiActions_Get(state, uiActions_VISUAL);

  if (_state) {
    return _state[key];
  }

  return null;
}
function uiActions_GetC(state, key, id) {
  if (state) {
    if (state.uiReducer && state.uiReducer[key]) return state.uiReducer[key][id];
  }

  return null;
}
function GetK(state, key, id, instance) {
  if (state) {
    if (state.uiReducer && state.uiReducer[key]) {
      if (state.uiReducer[key][id]) return state.uiReducer[key][id][instance];
    }
  }

  return null;
}
function uiActions_Get(state, key) {
  if (state) if (state.uiReducer[key]) return state.uiReducer[key];
  return null;
}
let _navigation = null;
function setNavigate(navigation) {
  _navigation = navigation;
}
function uiActions_navigate(a, b, c) {
  if (_navigation) return _navigation.navigate(a, b, c);
}
function GetScreenParam(param) {
  if (_navigation) return _navigation.getParam(param, undefined);
  return undefined;
}
function GetScreenInstance(key, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInst(state);

    if (screenInstance && screenInstance[key]) {
      return screenInstance[key][id] || null;
    }
  }

  return null;
}
function GetModelInstance(key, instance, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInst(state);

    if (modelInstance && modelInstance[key] && modelInstance[key][instance]) {
      return modelInstance[key][instance][id] || null;
    }
  }

  return null;
}
function GetScreenInst(state) {
  return uiActions_GetC(state, SCREEN_INSTANCE, SCREEN_INSTANCE);
}
function GetScreenModelInst(state, instance, id) {
  let item = GetK(state, SCREEN_MODEL_INSTANCE, SCREEN_INSTANCE, instance, id);

  if (item) {
    return item[id] || null;
  }

  return null;
}
function GetScreenModelDirtyInst(state, instance, id) {
  let item = GetK(state, SCREEN_MODEL_INSTANCE, SCREEN_INSTANCE_DIRTY, instance, id);

  if (item) {
    return item[id] || null;
  }

  return null;
}
function GetScreenModelFocusedInst(state, instance, id) {
  let item = GetK(state, SCREEN_MODEL_INSTANCE, SCREEN_INSTANCE_FOCUSED, instance, id);

  if (item) {
    return item[id] || null;
  }

  return null;
}
function GetScreenModelBlurInst(state, instance, id) {
  let item = GetK(state, SCREEN_MODEL_INSTANCE, SCREEN_INSTANCE_ON_BLUR, instance, id);

  if (item) {
    return item[id] || null;
  }

  return null;
}
function GetScreenModelFocusInst(state, instance, id) {
  let item = GetK(state, SCREEN_MODEL_INSTANCE, SCREEN_INSTANCE_ON_FOCUS, instance, id);

  if (item) {
    return item[id] || null;
  }

  return null;
}
function GetAppState(state) {
  return uiActions_GetC(state, APP_STATE, APP_STATE);
}
function GetModelInst(state, instance, id) {
  return GetK(state, UI_MODELS, instance, id);
}
function GetScreenInstanceBlur(key, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstBlur(state);

    if (screenInstance && screenInstance[key]) {
      return screenInstance[key][id] || null;
    }
  }

  return null;
}
function GetModelInstanceBlur(key, instance, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstBlur(state, instance);

    if (modelInstance && modelInstance[key]) {
      return modelInstance[key][id] || null;
    }
  }

  return null;
}
function GetScreenInstanceBlurObject(key) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstBlur(state);

    if (screenInstance) {
      return screenInstance[key] || null;
    }
  }

  return null;
}
function GetModelInstanceBlurObject(key, instance) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstBlur(state, instance);

    if (modelInstance) {
      return modelInstance[key] || null;
    }
  }

  return null;
}
function GetScreenInstBlur(state) {
  return uiActions_GetC(state, SCREEN_INSTANCE, SCREEN_INSTANCE_ON_BLUR);
}
function GetModelInstBlur(state, instance) {
  return uiActions_GetC(state, MODEL_INSTANCE, MODEL_INSTANCE_ON_BLUR, instance);
}
function GetScreenInstanceFocus(key, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstFocus(state);

    if (screenInstance && screenInstance[key]) {
      return screenInstance[key][id] || null;
    }
  }

  return null;
}
function GetModelInstanceFocus(key, instance, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstFocus(state, instance);

    if (modelInstance && modelInstance[key]) {
      return modelInstance[key][id] || null;
    }
  }

  return null;
}
function GetScreenInstanceFocusObject(key) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstFocus(state);

    if (screenInstance) {
      return screenInstance[key] || null;
    }
  }

  return null;
}
function GetModelInstanceFocusObject(key, instance) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstFocus(state, instance);

    if (modelInstance) {
      return modelInstance[key] || null;
    }
  }

  return null;
}
function GetScreenInstFocus(state) {
  return uiActions_GetC(state, SCREEN_INSTANCE, SCREEN_INSTANCE_ON_FOCUS);
}
function GetModelInstFocus(state, instance) {
  return GetK(state, MODEL_INSTANCE, MODEL_INSTANCE_ON_FOCUS, instance);
}
function GetScreenInstanceDirty(key, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstDirty(state);

    if (screenInstance && screenInstance[key]) {
      return screenInstance[key][id] || null;
    }
  }

  return null;
}
function GetModelInstanceDirty(key, instance, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstDirty(state, instance);

    if (modelInstance && modelInstance[key]) {
      return modelInstance[key][id] || null;
    }
  }

  return null;
}
function GetScreenInstanceDirtyObject(key) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstDirty(state);

    if (screenInstance) {
      return screenInstance[key] || null;
    }
  }

  return null;
}
function GetModelInstanceDirtyObject(key, instance) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstDirty(state, instance);

    if (modelInstance) {
      return modelInstance[key] || null;
    }
  }

  return null;
}
function GetScreenInstDirty(state) {
  return uiActions_GetC(state, SCREEN_INSTANCE, SCREEN_INSTANCE_DIRTY);
}
function GetModelInstDirty(state, instance) {
  return GetK(state, MODEL_INSTANCE, MODEL_INSTANCE_DIRTY, instance);
}
function GetScreenInstanceFocused(key, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstFocused(state);

    if (screenInstance && screenInstance[key]) {
      return screenInstance[key][id] || null;
    }
  }

  return null;
}
function GetModelInstanceFocused(key, instance, id) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstFocused(state, instance);

    if (modelInstance && modelInstance[key]) {
      return modelInstance[key][id] || null;
    }
  }

  return null;
}
function GetScreenInstanceFocusedObject(key) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInstFocused(state);

    if (screenInstance) {
      return screenInstance[key] || null;
    }
  }

  return null;
}
function GetModelInstanceFocusedObject(key, instance) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInstFocused(state, instance);

    if (modelInstance) {
      return modelInstance[key] || null;
    }
  }

  return null;
}
function GetScreenInstFocused(state) {
  return uiActions_GetC(state, SCREEN_INSTANCE, SCREEN_INSTANCE_FOCUSED);
}
function GetModelInstFocused(state, instance) {
  return GetK(state, MODEL_INSTANCE, MODEL_INSTANCE_FOCUSED, instance);
}
function GetScreenInstanceObject(key) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenInst(state);

    if (screenInstance) {
      return screenInstance[key];
    }
  }

  return null;
}
function GetScreenModelInstance(key, viewModel) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenModelInst(state, viewModel, key);

    if (screenInstance) {
      return screenInstance;
    }
  }

  return null;
}
function GetScreenModelBlurInstance(key, viewModel) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenModelBlurInst(state, viewModel, key);

    if (screenInstance) {
      return screenInstance;
    }
  }

  return null;
}
function GetScreenModelDirtyInstance(key, viewModel) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenModelDirtyInst(state, viewModel, key);

    if (screenInstance) {
      return screenInstance;
    }
  }

  return null;
}
function GetScreenModelFocusInstance(key, viewModel) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenModelFocusInst(state, viewModel, key);

    if (screenInstance) {
      return screenInstance;
    }
  }

  return null;
}
function GetScreenModelFocusedInstance(key, viewModel) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let screenInstance = GetScreenModelFocusedInst(state, viewModel, key);

    if (screenInstance) {
      return screenInstance;
    }
  }

  return null;
}
function GetAppStateObject(key) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let appState = GetAppState(state);

    if (appState) {
      return appState[key];
    }
  }
}
function GetModelInstanceObject(key, instance) {
  if (uiActions_getState) {
    let state = uiActions_getState();

    let modelInstance = GetModelInst(state, instance, key);

    if (modelInstance) {
      return modelInstance;
    }
  }

  return null;
}
function updateScreenInstance(model, id, value, options = {}) {
  return (dispatch, getState) => {
    if (options && options.update) {
      dispatch(Batch(UISMI(SCREEN_INSTANCE, model, options.value, id, value), UISMI(SCREEN_INSTANCE_DIRTY, model, options.value, id, true)));
    } else {
      dispatch(Batch(UISI(SCREEN_INSTANCE, model, id, value), UISI(SCREEN_INSTANCE_DIRTY, model, id, true)));
    }
  };
}
function updateScreenInstanceObject(model, instance, value) {
  return (dispatch, getState) => {
    dispatch(Batch(UISMIO(SCREEN_INSTANCE, model, instance, value)));
  };
}
function clearScreenInstance(model, id, options = {}) {
  return (dispatch, getState) => {
    if (options && options.update) {
      dispatch(Batch(UISMI(SCREEN_INSTANCE, model, options.value, id, null), UISMI(SCREEN_INSTANCE_ON_BLUR, model, options.value, id, false), UISMI(SCREEN_INSTANCE_ON_FOCUS, model, options.value, id, false), UISMI(SCREEN_INSTANCE_DIRTY, model, options.value, id, false), UISMI(SCREEN_INSTANCE_FOCUSED, model, options.value, id, false), UISMI(SCREEN_INSTANCE_FOCUSED, model, options.value, id, false)));
    } else {
      dispatch(Batch(UISI(SCREEN_INSTANCE, model, id, null), UISI(SCREEN_INSTANCE_ON_BLUR, model, id, false), UISI(SCREEN_INSTANCE_ON_FOCUS, model, id, false), UISI(SCREEN_INSTANCE_DIRTY, model, id, false), UISI(SCREEN_INSTANCE_FOCUSED, model, id, false), UISI(SCREEN_INSTANCE_FOCUSED, model, id, false)));
    }
  };
}
function updateScreenInstanceBlur(model, id, options = {}) {
  return (dispatch, getState) => {
    if (options && options.update) {
      dispatch(Batch(UISMI(SCREEN_INSTANCE_ON_BLUR, model, options.value, id, true), UISMI(SCREEN_INSTANCE_FOCUSED, model, options.value, id, false)));
    } else {
      dispatch(Batch(UISI(SCREEN_INSTANCE_ON_BLUR, model, id, true), UISI(SCREEN_INSTANCE_FOCUSED, model, id, false)));
    }
  };
}
function updateScreenInstanceFocus(model, id, options = {}) {
  return (dispatch, getState) => {
    if (options && options.update) {
      dispatch(Batch(UISMI(SCREEN_INSTANCE_ON_FOCUS, model, options.value, id, true), UISMI(SCREEN_INSTANCE_FOCUSED, model, options.value, id, true)));
    } else {
      dispatch(Batch(UISI(SCREEN_INSTANCE_ON_FOCUS, model, id, true), UISI(SCREEN_INSTANCE_FOCUSED, model, id, true)));
    }
  };
}
function updateModelInstance(model, instance, id, value) {
  return (dispatch, getState) => {
    dispatch(Batch(UISI(MODEL_INSTANCE, model, instance, id, value), UISI(MODEL_INSTANCE_DIRTY, model, instance, id, true)));
  };
}
function clearModelInstance(model, instance, id) {
  return (dispatch, getState) => {
    dispatch(Batch(UISI(MODEL_INSTANCE_ON_BLUR, model, instance, id, false), UISI(MODEL_INSTANCE_ON_FOCUS, model, instance, id, false), UISI(MODEL_INSTANCE_DIRTY, model, instance, id, false), UISI(MODEL_INSTANCE_FOCUSED, model, instance, id, false), UISI(MODEL_INSTANCE_FOCUSED, model, instance, id, false)));
  };
}
function updateModelInstanceBlur(model, instance, id) {
  return (dispatch, getState) => {
    dispatch(Batch(UISI(MODEL_INSTANCE_ON_BLUR, model, instance, id, true), UISI(MODEL_INSTANCE_FOCUSED, model, instance, id, false)));
  };
}
function updateModelInstanceFocus(model, instance, id) {
  return (dispatch, getState) => {
    dispatch(Batch(UISI(MODEL_INSTANCE_ON_FOCUS, model, instance, id, true), UISI(MODEL_INSTANCE_FOCUSED, model, instance, id, true)));
  };
}
// CONCATENATED MODULE: ./app/nodepacks/batch/AddAgentMethods.js






function AddAgentMethods() {
  const result = [];
  const agents = uiactions_NodesByType(null, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent)).filter(x => GetNodeTitle(x) !== 'User');
  const models = uiactions_NodesByType(null, NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent));
  const functionTypes = [functiontypes_FunctionTypes.Create_Object__Object, functiontypes_FunctionTypes.Get_Objects_From_List_Of_Ids, functiontypes_FunctionTypes.Update_Object_Agent_Value__Object, functiontypes_FunctionTypes.Get_Agent_Value__IListObject, functiontypes_FunctionTypes.Get_Object_Agent_Value__Object];
  agents.forEach(agent => {
    models.forEach(model => {
      functionTypes.forEach(functionType => {
        const functionName = MethodFunctions[functionType].titleTemplate(GetNodeTitle(model), GetNodeTitle(agent));
        result.push({
          method: {
            method: CreateAgentFunction({
              nodePackageType: functionName,
              methodType: MethodFunctions[functionType].method,
              model,
              agent,
              httpMethod: HTTP_METHODS.POST,
              //might not be used
              functionType,
              functionName
            })
          },
          methodType: functionType
        });
      });
    });
  });
  executeGraphOperations(result)(GetDispatchFunc(), GetStateFunc());
  return [];
}
// CONCATENATED MODULE: ./app/nodepacks/batch/CreateComponentAll.js






function CreateComponentAll() {
  const result = [];
  const models = uiactions_NodesByType(null, NodeTypes.Model).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent)).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsViewModel));
  const properties = uiactions_NodesByType(null, NodeTypes.Property);
  models.forEach(v => {
    const defaultViewTypes = GetNodesLinkedTo(null, {
      id: v.id,
      componentType: NodeTypes.ViewType,
      link: nodetypes_LinkType.DefaultViewType
    });
    [...properties, ...models].filter(x => x.id !== v.id).forEach(w => {
      const defaultViewTypesOther = GetNodesLinkedTo(null, {
        id: w.id,
        componentType: NodeTypes.ViewType,
        link: nodetypes_LinkType.DefaultViewType
      });
      const intersections = defaultViewTypes.intersection(defaultViewTypesOther, (x, y) => y.id === x.id);
      if (intersections && intersections.length) result.push(...CreateComponentModel({
        model: v.id,
        connectedModel: w.id,
        isSharedComponent: true,
        isDefaultComponent: true
      }));
    });
  });
  models.forEach(v => {
    result.push(...CreateComponentModel({
      model: v.id
    }));
  });
  return result;
}
function CreateComponentModel(args = {}) {
  const {
    model,
    connectedModel,
    viewTypes = [viewtypes_ViewTypes.Create, viewtypes_ViewTypes.Update, viewtypes_ViewTypes.Get, viewtypes_ViewTypes.GetAll],
    defaultArgs = {}
  } = args;
  const operations = [];
  const result = [];
  viewTypes.forEach(viewType => {
    const viewName = `${args.isSharedComponent ? 'Shared' : ''} ${GetNodeTitle(model)} ${viewType}`;
    const properties = GetModelPropertyChildren(model).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsDefaultProperty));
    operations.push({
      node: GetNodeById(model),
      method: CreateDefaultView,
      options: { ...CreateComponentAll_defaultParameters({
          isDefaultComponent: args.isDefaultComponent,
          isPluralComponent: args.isPluralComponent,
          isSharedComponent: args.isSharedComponent,
          connectedModel,
          ...defaultArgs,
          viewName
        }),
        viewType,
        isList: viewType === viewtypes_ViewTypes.GetAll,
        chosenChildren: properties.map(v => v.id)
      }
    });
  });

  if (operations.length) {
    executeGraphOperations(operations)(GetDispatchFunc, GetStateFunc);
  }

  return result;
}

function CreateComponentAll_defaultParameters(args = {}) {
  const {
    viewName = null,
    uiTypes = {
      [UITypes.ReactNative]: true,
      [UITypes.ElectronIO]: true,
      [UITypes.VR]: false,
      [UITypes.Web]: false
    },
    chosenChildren = []
  } = args;
  return { ...args,
    viewName,
    uiTypes,
    chosenChildren
  };
}

;
// CONCATENATED MODULE: ./app/nodepacks/batch/SelectAllOnModelFilters.js



function SelectAllOnModelFilters() {
  const filters = uiactions_NodesByType(null, NodeTypes.ModelFilter);
  return filters.map(filter => {
    const model = uiactions_GetNodeProp(filter, NodeProperties.FilterModel);
    const propnodes = GetModelPropertyChildren(model);
    const fprops = uiactions_GetNodeProp(filter, NodeProperties.FilterPropreties) || {};
    propnodes.map(node => {
      fprops[node.id] = true;
    });
    return {
      operation: CHANGE_NODE_PROPERTY,
      options: {
        prop: NodeProperties.FilterPropreties,
        id: filter.id,
        value: fprops
      }
    };
  });
}
// CONCATENATED MODULE: ./app/nodepacks/method/AddFiltersToGetAll.js




function AddFiltersToGetAll() {
  let methods = uiactions_NodesByType(null, NodeTypes.Method);
  let result = [];
  methods.filter(x => (MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {}).method === nodetypes_Methods.GetAll).filter(x => {
    return !GetNodeLinkedTo(null, {
      id: x.id,
      link: nodetypes_LinkType.ModelItemFilter
    });
  }).map(method => {
    let _node = null;
    let methodProps = GetMethodNodeProp(method, FunctionTemplateKeys.Agent) || GetMethodNodeProp(method, FunctionTemplateKeys.User) || "";
    result.push({
      operation: NEW_MODEL_ITEM_FILTER,
      options: {
        parent: method.id,
        groupProperties: {},
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ModelItemFilter
          }
        },
        callback: node => {
          _node = node;
        }
      }
    }, function () {
      return {
        operation: UPDATE_NODE_PROPERTY,
        options: {
          id: _node.id,
          properties: {
            [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(method)} Filter`
          }
        }
      };
    });
  });
  return result;
}
AddFiltersToGetAll.title = "Add Filters to GetALL methods";
AddFiltersToGetAll.description = "Adds default filters to all the get all methods";
// CONCATENATED MODULE: ./app/nodepacks/AddAllPropertiesToExecutor.js



function AddAllPropertiesToExecutor(args = {
  currentNode
}) {
  let {
    currentNode
  } = args;
  var propertyNodes = GetModelPropertyChildren(uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExecutorModel), {
    skipLogicalChildren: true
  }).toNodeSelect();
  return AddAllPropertiesToExecutor_addProperty(propertyNodes.filter(x => !uiactions_GetNodeProp(x.value, nodetypes_NodeProperties.IsDefaultProperty)).map(t => {
    return t.value;
  }), currentNode);
}
AddAllPropertiesToExecutor.description = "Add all properties to executor (execpt default properties)";

let AddAllPropertiesToExecutor_addProperty = (values, currentNode) => {
  let executor = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createExecutor();
  var operation = values.map(value => {
    var id = currentNode.id;
    executor = addValidatator(executor, {
      id: value
    });
    return [{
      operation: CHANGE_NODE_PROPERTY,
      options: function () {
        return {
          id: currentNode.id,
          prop: nodetypes_NodeProperties.Executor,
          value: executor,
          callback: _updatedExecutor => {
            executor = _updatedExecutor;
          }
        };
      }
    }, {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,
      options: function () {
        return {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExecutorModelLink,
            ...createEventProp(LinkEvents.Remove, {
              function: "OnRemoveExecutorPropConnection"
            })
          }
        };
      }
    }];
  }).flatten();
  return operation;
};
// CONCATENATED MODULE: ./app/nodepacks/batch/HaveAllPropertiesOnExecutors.js




function HaveAllPropertiesOnExecutors() {
  const executors = uiactions_NodesByType(null, NodeTypes.Executor);
  const result = [];
  executors.forEach(executor => {
    const steps = AddAllPropertiesToExecutor({
      currentNode: executor
    });
    result.push(...steps);
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/AddCopyPropertiesToExecutor.js






function AddCopyPropertiesToExecutor(args = {
  executor,
  currentNode
}) {
  let {
    executor,
    currentNode
  } = args;

  if (executor && executor.properties) {
    Object.keys(executor.properties).forEach(key => {
      if (!hasValidator(executor, {
        id: key,
        validator: uuidv4(),
        validatorArgs: {
          type: ExecutorRules.Copy,
          ...ExecutorUI[ExecutorRules.Copy]
        }
      })) {
        executor = addValidatator(executor, {
          id: key,
          validator: uuidv4(),
          validatorArgs: {
            type: ExecutorRules.Copy,
            ...ExecutorUI[ExecutorRules.Copy]
          }
        });
      }
    });
    return [{
      operations: CHANGE_NODE_PROPERTY,
      options: {
        id: currentNode.id,
        prop: nodetypes_NodeProperties.Executor,
        value: executor
      }
    }];
  }

  return [];
}

AddCopyPropertiesToExecutor.title = 'Add Copy Command';
AddCopyPropertiesToExecutor.description = 'Adds a copy command to each property in the executor';
/* harmony default export */ var nodepacks_AddCopyPropertiesToExecutor = (AddCopyPropertiesToExecutor);
// CONCATENATED MODULE: ./app/nodepacks/batch/AddCopyCommandToExecutors.js




function AddCopyCommandToExecutors() {
  const executors = uiactions_NodesByType(null, NodeTypes.Executor);
  const result = [];
  executors.forEach(executor => {
    const steps = nodepacks_AddCopyPropertiesToExecutor({
      currentNode: executor,
      executor: uiactions_GetNodeProp(executor, nodetypes_NodeProperties.Executor)
    });
    result.push(...steps);
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/batch/AddChainToNavigateNextScreen.js


/* harmony default export */ var AddChainToNavigateNextScreen = (function (args = {}) {
  // node0,node1
  if (!args.dataChain) {
    throw new Error('No data chain ');
  }

  if (!args.screen) {
    throw new Error('No screen ');
  } //


  let context = { ...args,
    node0: args.dataChain,
    node1: args.screen
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node0,
        "target": ""
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Screen",
        "id": context.node0,
        "value": context.node1
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node0,
        "target": context.node1,
        "properties": {
          "type": "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }
  }];
  let applyViewPackages = [];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/batch/AddChainToNavigateNextScreens.js





function AddChainToNavigateNextScreens() {
  let screen = GetNodeByProperties({
    [nodetypes_NodeProperties.UIText]: AuthorizedDashboard,
    [nodetypes_NodeProperties.NODEType]: NodeTypes.Screen
  });
  let dataChains = GetNodesByProperties({
    [nodetypes_NodeProperties.UIText]: SelectTargetScreen,
    [nodetypes_NodeProperties.NODEType]: NodeTypes.DataChain
  });

  if (!screen) {
    throw new Error('no screen found');
  }

  if (!dataChains || !dataChains.length) {
    throw new Error('No Target Screen Data chains found');
  }

  const result = [];
  dataChains.forEach(dataChain => {
    result.push(...AddChainToNavigateNextScreen({
      dataChain: dataChain.id,
      screen: screen.id
    }));
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/AddLifeCylcleMethodInstance.js


/* harmony default export */ var AddLifeCylcleMethodInstance = (function (args = {
  node,
  viewPackages
}) {
  let {
    node,
    viewPackages
  } = args;
  return [{
    operation: ADD_NEW_NODE,

    options() {
      return {
        nodeType: NodeTypes.LifeCylceMethodInstance,
        parent: node,
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.LifeCylceMethodInstance
          }
        },
        groupProperties: {},
        properties: {
          [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(node)} Instance`,
          [nodetypes_NodeProperties.AutoDelete]: {
            properties: {
              [nodetypes_NodeProperties.NODEType]: NodeTypes.ComponentApiConnector
            }
          },
          ...viewPackages
        },
        callback: contextNode => {
          if (args.callback) {
            args.callback(contextNode);
          }
        }
      };
    }

  }];
});
// CONCATENATED MODULE: ./app/nodepacks/ClearPreviousViewPackage.js


function ClearPreviosuViewPackage(args = {}) {
  let {
    graph,
    node
  } = args;
  let result = [];
  let vp = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ViewPackage);

  if (vp) {
    let inPackageNodes = GetNodesByProperties({
      [nodetypes_NodeProperties.ViewPackage]: vp
    });
    inPackageNodes.map(inPackageNode => {
      result.push({
        operation: REMOVE_NODE,
        options: function (graph) {
          return {
            id: inPackageNode.id
          };
        }
      });
    });
  }

  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/CreateNavigateToScreenDC.js





/* harmony default export */ var CreateNavigateToScreenDC = (function (args = {}) {
  // node3
  // screen
  if (!args.screen) {
    throw "missing screen argument";
  }

  if (!args.node) {
    throw "missing node argument";
  }

  let context = { ...args,
    node: args.node,
    node3: args.screen
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    let temp = typeof args.node === "function" ? args.node() : args.node;
    let tempnodes = GetNodesLinkedTo(graph, {
      id: temp,
      link: nodetypes_LinkType.DataChainLink
    });
    return [...tempnodes.map(node => ClearPreviosuViewPackage({
      node: node.id,
      graph
    }))].flatten();
  }, function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Navigate to Screen " + GetNodeTitle(args.screen) + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: context.lambda || "x => ({ value: x})"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get param"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Navigate To"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Navigate"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "UseNavigationParams",
        id: context.node2,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Screen",
        id: context.node2,
        value: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node2,
        target: context.node3,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "NavigationAction",
        id: context.node2,
        value: "Go"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "go to place"
      }
    }];
  }, function (graph) {
    return [{
      operation: uiactions_ADD_LINK_BETWEEN_NODES,
      options: function () {
        return {
          source: typeof context.node === "function" ? context.node() : context.node,
          target: context.node0,
          properties: { ...uiactions_LinkProperties.DataChainLink
          }
        };
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateValidatorForProperty.js
/* eslint-disable func-names */


/* harmony default export */ var CreateValidatorForProperty = (function (args = {}) {
  // node2,node3,node5
  //
  if (!args.model) {
    throw "missing model";
  }

  if (!args.modelText) {
    throw new Error("missing modelText");
  }

  let model = args.modelText;

  if (!args.property) {
    throw "missing property";
  }

  if (!args.propertyText) {
    throw "missing propertyText";
  }

  if (!args.methodType) {
    args.methodType = 'Method Type';
  }

  let methodType = args.methodType;
  let property = args.propertyText;

  if (!args.method) {
    throw "missing method  for create validator for property";
  }

  let context = { ...args,
    node2: args.model,
    node3: args.property,
    node5: args.method
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function () {
    return [{
      operation: "NEW_NODE",
      options: {
        callback(node) {
          context.node0 = node.id;
        }

      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: `Validate ${methodType} ${model} ${property}`
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function () {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],

        callback(node, group) {
          context.node1 = node.id;
          context.group0 = group;
        }

      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "check for dirty"
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => {\n let { object, dirty, focus, blur, focused } = x;\n  let result = {};\n  if(dirty && blur) {\n      //#{model}\n      // #{model~property}\n           if( dirty.#{model~property} && blur.#{model~property} ) \n {//updated \n        return { ...x, property: '#{model~property}', validated: true };\n      }\n  }\n    // only dirty fields, will be validatated.\n return { valid: false, validated: false };\n}"
      }
    }];
  }, function () {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node1
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "LambdaInsertArguments",
        id: context.node1,
        value: {
          model: context.node2,
          property: context.node3
        }
      }
    }];
  }, function () {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node1,
        properties: {
          type: "LambdaInsertArguments",
          LambdaInsertArguments: {}
        }
      }
    }];
  }, function () {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: {
          model: context.node2,
          property: context.node3
        },
        source: context.node1
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "LambdaInsertArguments",
        id: context.node1,
        value: {
          model: context.node2,
          property: context.node3
        }
      }
    }];
  }, function () {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node1,
        properties: {
          type: "LambdaInsertArguments",
          LambdaInsertArguments: {}
        }
      }
    }];
  }, function () {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },

        callback(node) {
          context.node4 = node.id;
        }

      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node4,
        value: context.node2
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Property",
        id: context.node4,
        value: context.node3
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node4,
        value: `validate ${model}`
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node4,
        value: "MethodBaseValidation"
      }
    }];
  }, function () {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node4
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Method",
        id: context.node4,
        value: context.node5
      }
    }];
  }, function () {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node4,
        target: context.node5,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function () {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node4,
        value: true
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }

  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }

  }, {
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }

  }, {
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node4,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateValidatorForObject.js
/* eslint-disable no-unused-vars */


/* harmony default export */ var CreateValidatorForObject = (function (args = {}) {
  // node2,node4
  // model, model, model
  if (!args.model) {
    throw new Error('missing model argument');
  }

  if (!args.method) {
    throw new Error('missing method argument');
  }

  if (!args.modelId) {
    throw new Error('missing model argument');
  }

  if (!args.methodType) {
    args.methodType = 'Method Type';
  }

  let methodType = args.methodType;
  const context = { ...args,
    node2: args.modelId,
    node4: args.method
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function (graph) {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": `Validate ${methodType} ${args.model}`
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": `Validate ${args.model} Object`
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "EntryPoint",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node0,
        "value": "Pass"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "parent": context.node0,
        "nodeType": "data-chain",
        "groupProperties": {
          "GroupEntryNode": context.node0,
          "GroupExitNode": context.node0
        },
        "properties": {
          "Pinned": false,
          "ChainParent": context.node0
        },
        "linkProperties": {
          "properties": {
            "type": "data-chain-link",
            "data-chain-link": {}
          }
        },
        "links": [],
        "callback": function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node1,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node1,
        "value": false
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node1,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node1,
        "value": "check for dirty object"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node1,
        "value": "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node1,
        "value": "x => {\n let { object, dirty, focus, blur, focused } = x;\n  let result = {}\n  if(dirty) {\n      //#{model}\n      if(Object.keys(dirty).some(key => dirty[key]))\n {//updated \n        return { ...x, validated: true  };\n      }\n  }\n    // only dirty fields, will be validatated.\n return { valid: false, validated:false };\n}"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node1
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "LambdaInsertArguments",
        "id": context.node1,
        "value": {
          "model": context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node2,
        "source": context.node1,
        "properties": {
          "type": "LambdaInsertArguments",
          "LambdaInsertArguments": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "parent": context.node1,
        "nodeType": "data-chain",
        "groupProperties": {
          "id": context.group0
        },
        "properties": {
          "ChainParent": context.node1
        },
        "linkProperties": {
          "properties": {
            "type": "data-chain-link",
            "data-chain-link": {}
          }
        },
        "callback": function (node, graph, group) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node3,
        "value": "MethodBaseValidation"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node3
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "uiModelType",
        "id": context.node3,
        "value": context.node2
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node2,
        "source": context.node3,
        "properties": {
          "type": "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node3
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Method",
        "id": context.node3,
        "value": context.node4
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node3,
        "target": context.node4,
        "properties": {
          "type": "data-chain-link",
          "data-chain-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node3,
        "value": `validation ${args.model}`
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "AsOutput",
        "id": context.node3,
        "value": true
      }
    }];
  }];
  const clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node2,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node3,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node4,
        value: false
      };
    }

  }];
  const applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node3,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/screens/AppendValidations.js







function AppendValidations({
  subcomponents,
  component,
  screen_option,
  methodType = '',
  InstanceUpdate = true,
  viewPackages,
  method
}) {
  if (!subcomponents) {
    throw new Error("no subcomponents");
  }

  const nonExecuteSubComponents = subcomponents.filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExecuteButton));
  const executeButtons = subcomponents.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExecuteButton));
  const componentInternalValueApi = GetNodesLinkedTo(null, {
    id: component.id,
    link: nodetypes_LinkType.ComponentInternalApi,
    componentType: NodeTypes.ComponentApi
  }).find(componentApi => GetNodeTitle(componentApi) === ComponentApiKeys.Value);
  const result = [];
  const modelType = uiactions_GetNodeProp(screen_option, nodetypes_NodeProperties.Model);
  const selector = modelType ? GetNodeByProperties({
    [nodetypes_NodeProperties.NODEType]: NodeTypes.Selector,
    [nodetypes_NodeProperties.Model]: modelType
  }) : null;

  if (nonExecuteSubComponents.length) {
    nonExecuteSubComponents.forEach(subcomponent => {
      const componentType = uiactions_GetNodeProp(subcomponent, nodetypes_NodeProperties.ComponentType);
      let externalValidationApi;

      switch (componentType) {
        case ComponentTypeKeys.Button:
          break;

        default:
          externalValidationApi = GetNodesLinkedTo(null, {
            id: subcomponent.id,
            link: nodetypes_LinkType.ComponentExternalApi
          }).find(v => GetNodeTitle(v) === ComponentApiKeys.Error);

          if (externalValidationApi) {
            const modelId = uiactions_GetNodeProp(screen_option, nodetypes_NodeProperties.Model);
            let propertyId = uiactions_GetNodeProp(subcomponent, nodetypes_NodeProperties.Property);
            propertyId = propertyId || GetNodeLinkedTo(null, {
              id: subcomponent.id,
              link: nodetypes_LinkType.PropertyLink,
              properties: {
                [LinkPropertyKeys.ComponentProperty]: true
              }
            });

            if (!propertyId) {
              propertyId = GetModelPropertyChildren(modelId).find(v => GetNodeTitle(v) === GetNodeTitle(subcomponent));
            }

            if (propertyId && propertyId.id) {
              propertyId = propertyId.id;
            }

            if (!GetNodeById(propertyId)) {
              return;
            }

            let validatorNode = null;
            const methodType = uiactions_GetNodeProp(method, nodetypes_NodeProperties.MethodType);
            result.push(...CreateValidatorForProperty({
              modelText: GetNodeTitle(modelId),
              propertyText: GetNodeTitle(propertyId),
              model: modelId,
              property: propertyId,
              method,
              methodType,
              viewPackages,
              callback: context => {
                validatorNode = context.entry;
              }
            }), {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                return {
                  target: validatorNode,
                  source: externalValidationApi.id,
                  properties: { ...nodetypes_LinkProperties.DataChainLink
                  }
                };
              }

            });
          }

          break;
      }
    });
  }

  if (executeButtons.length) {
    executeButtons.forEach(button => {
      const componentType = uiactions_GetNodeProp(button, nodetypes_NodeProperties.ComponentType);
      let externalValidationApi;

      switch (componentType) {
        default:
          result.push(ggraph => {
            const res = [];
            externalValidationApi = GetNodesLinkedTo(ggraph, {
              id: button.id,
              link: nodetypes_LinkType.ComponentExternalApi
            }).find(v => GetNodeTitle(v) === ComponentApiKeys.Error);

            if (!externalValidationApi) {
              res.push(...$addComponentApiNodes(button.id, ComponentApiKeys.Error, null, viewPackages));
            }

            return res;
          });
          result.push(ggraph => {
            externalValidationApi = GetNodesLinkedTo(ggraph, {
              id: button.id,
              link: nodetypes_LinkType.ComponentExternalApi
            }).find(v => GetNodeTitle(v) === ComponentApiKeys.Error);

            if (externalValidationApi) {
              const modelId = uiactions_GetNodeProp(screen_option, nodetypes_NodeProperties.Model);
              let validatorNode = null;
              const methodType = uiactions_GetNodeProp(method, nodetypes_NodeProperties.MethodType);
              return [...CreateValidatorForObject({
                model: GetNodeTitle(modelId),
                modelId,
                method,
                methodType,
                viewPackages,
                callback: context => {
                  validatorNode = context.entry;
                }
              }), {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: validatorNode,
                    source: externalValidationApi.id,
                    properties: { ...nodetypes_LinkProperties.DataChainLink
                    }
                  };
                }

              }, {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    target: componentInternalValueApi.id,
                    source: externalValidationApi.id,
                    properties: { ...nodetypes_LinkProperties.ComponentExternalConnection,
                      [LinkPropertyKeys.InstanceUpdate]: InstanceUpdate
                    }
                  };
                }

              }, selector ? {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,

                options() {
                  return {
                    source: externalValidationApi.id,
                    target: selector.id,
                    properties: { ...nodetypes_LinkProperties.SelectorLink
                    }
                  };
                }

              } : null];
            }

            return [];
          });
          break;
      }
    });
  }

  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/screens/ScreenConnectGet.js


/* eslint-disable camelcase */

/* eslint-disable no-underscore-dangle */

/* eslint-disable func-names */










function ScreenConnectGet(args = {
  method,
  node
}) {
  let {
    node,
    method,
    navigateTo
  } = args;

  if (!node) {
    throw "no node";
  }

  if (!method) {
    throw "no method";
  }

  const graph = GetCurrentGraph();
  const screen_options = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.ScreenOptions
  });
  const result = [];
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  screen_options.map(screen_option => {
    const components = GetNodesLinkedTo(graph, {
      id: screen_option.id,
      link: nodetypes_LinkType.Component
    });
    const internalComponentApis = GetNodesLinkedTo(graph, {
      id: screen_option.id,
      link: nodetypes_LinkType.ComponentInternalApi
    });
    components.map(component => {
      const subcomponents = GetNodesLinkedTo(graph, {
        id: component.id,
        link: nodetypes_LinkType.Component
      });
      const buttonComponents = subcomponents.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExecuteButton));

      if (buttonComponents && buttonComponents.length === 1) {
        const subcomponent = buttonComponents[0];
        const events = GetNodesLinkedTo(graph, {
          id: subcomponent.id,
          link: nodetypes_LinkType.EventMethod
        }).filter(x => [ComponentEvents.onClick, ComponentEvents.onPress].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType)));

        const _valueNavigateTargetApi = GetNodesLinkedTo(graph, {
          id: navigateTo,
          link: nodetypes_LinkType.ComponentExternalApi
        }).find(x => GetNodeTitle(x) === ComponentApiKeys.Value);

        const valueGetApi = GetNodesLinkedTo(graph, {
          id: node,
          link: nodetypes_LinkType.ComponentExternalApi
        }).find(x => GetNodeTitle(x) === ComponentApiKeys.Value);
        result.push(_valueNavigateTargetApi ? {
          operation: UPDATE_NODE_PROPERTY,

          options() {
            return {
              id: _valueNavigateTargetApi.id,
              properties: {
                [nodetypes_NodeProperties.IsUrlParameter]: true
              }
            };
          }

        } : null);
        result.push(_valueNavigateTargetApi ? {
          operation: UPDATE_NODE_PROPERTY,

          options() {
            return {
              id: navigateTo,
              properties: {
                [nodetypes_NodeProperties.UIText]: uiactions_GetNodeProp(navigateTo, nodetypes_NodeProperties.UIText)
              }
            };
          }

        } : null);
        result.push(valueGetApi ? {
          operation: UPDATE_NODE_PROPERTY,

          options() {
            return {
              id: valueGetApi.id,
              properties: {
                [nodetypes_NodeProperties.IsUrlParameter]: true
              }
            };
          }

        } : null);
        result.push(valueGetApi ? {
          operation: UPDATE_NODE_PROPERTY,

          options() {
            return {
              id: node,
              properties: {
                [nodetypes_NodeProperties.UIText]: uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIText)
              }
            };
          }

        } : null);
        events.forEach(evnt => {
          const eventMethodInstances = GetNodesLinkedTo(graph, {
            id: evnt.id,
            link: nodetypes_LinkType.EventMethodInstance
          });
          eventMethodInstances.forEach(eventMethodInstance => {
            const vp = uiactions_GetNodeProp(eventMethodInstance, nodetypes_NodeProperties.ViewPackage);

            if (vp) {
              const inPackageNodes = GetNodesByProperties({
                [nodetypes_NodeProperties.ViewPackage]: vp
              });
              inPackageNodes.map(inPackageNode => {
                result.push({
                  operation: REMOVE_NODE,
                  options: function () {
                    return {
                      id: inPackageNode.id
                    };
                  }
                });
              });
            }
          });
          let _instanceNode = null;
          let _navigateContext = null;
          result.push(...[{
            operation: ADD_NEW_NODE,
            options: addInstanceFunc(evnt, instanceNode => {
              _instanceNode = instanceNode;
            }, viewPackages)
          }], ...CreateNavigateToScreenDC({
            screen: navigateTo,
            node: () => _instanceNode.id,
            viewPackages,
            callback: navigateContext => {
              _navigateContext = navigateContext;
            }
          }), currentGraph => {
            const valueComponentApiNode = GetComponentApiNode(ComponentApiKeys.Value, subcomponent.id, currentGraph);
            return {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,
              options: Connect(_instanceNode.id, valueComponentApiNode.id, nodetypes_LinkProperties.ComponentApi)
            };
          });
        });
      }

      result.push(...AppendValidations({
        subcomponents,
        component,
        methodType: nodetypes_Methods.Get,
        screen_option,
        method,
        viewPackages
      }));
    });
    const lifeCylcleMethods = GetNodesLinkedTo(graph, {
      id: screen_option.id,
      link: nodetypes_LinkType.LifeCylceMethod
    });
    lifeCylcleMethods.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIText) === ComponentLifeCycleEvents.ComponentDidMount).map(lifeCylcleMethod => {
      const lifeCylcleMethodInstances = GetNodesLinkedTo(graph, {
        id: lifeCylcleMethod.id,
        link: nodetypes_LinkType.LifeCylceMethodInstance
      });
      lifeCylcleMethodInstances.map(lifeCylcleMethodInstance => {
        const vp = uiactions_GetNodeProp(lifeCylcleMethodInstance, nodetypes_NodeProperties.ViewPackage);

        if (vp) {
          const inPackageNodes = GetNodesByProperties({
            [nodetypes_NodeProperties.ViewPackage]: vp
          });
          inPackageNodes.map(inPackageNode => {
            result.push({
              operation: REMOVE_NODE,
              options: function () {
                return {
                  id: inPackageNode.id
                };
              }
            });
          });
        }
      });
      const apiEndpoints = {};
      let cycleInstance = null;
      result.push(...AddLifeCylcleMethodInstance({
        node: lifeCylcleMethod.id,
        viewPackages,
        callback: _cycleInstance => {
          cycleInstance = _cycleInstance;
        }
      }), graph => {
        if (cycleInstance) {
          return ConnectLifecycleMethod({
            target: method,
            source: cycleInstance.id,
            graph,
            viewPackages,
            callback: (context, graph) => {
              if (context.apiEndPoints) {
                context.apiEndPoints.filter(d => {
                  const temp = GetNodesLinkedTo(graph, {
                    id: d.id,
                    link: nodetypes_LinkType.ComponentApiConnection
                  }).find(v => TEMPLATE_PARAMETERS[GetCodeName(v)]);

                  if (temp) {
                    apiEndpoints[GetCodeName(temp)] = d;
                  }

                  return temp;
                });
              }
            }
          });
        }

        return [];
      }, () => {
        if (apiEndpoints) {
          return Object.keys(apiEndpoints).map(key => {
            const apiEndpoint = apiEndpoints[key];
            let internalComponentApi = internalComponentApis.find(v => GetCodeName(v) === key);

            if (!internalComponentApi) {
              internalComponentApi = internalComponentApis.find(v => GetCodeName(v) === "value");
            }

            if (apiEndpoint && internalComponentApi) {
              return {
                operation: uiactions_ADD_LINK_BETWEEN_NODES,
                options: {
                  source: apiEndpoint.id,
                  target: internalComponentApi.id,
                  properties: { ...nodetypes_LinkProperties.ComponentApi
                  }
                }
              };
            }

            return false;
          });
        }
      });
    });
  });
  return result.filter(x => x);
}
// CONCATENATED MODULE: ./app/nodepacks/StoreModelArrayStandard.js
/* eslint-disable func-names */



/* harmony default export */ var StoreModelArrayStandard = (function (args = {
  state_key: "StateKeyReplace"
}) {
  // node2
  //
  const context = { ...args,
    node2: args.model
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback(node) {
          context.node0 = node.id;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: `Store Model Array Standard ${args.modelText || ""}`
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: UPDATE_NODE_PROPERTY,
      options: {
        id: context.node0,
        properties: { ...viewPackages
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ...viewPackages,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],

        callback(node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Save Model Array To State"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node1,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node1,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Store Model To State"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: { ...viewPackages,
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },

        callback(node, graph, group) {
          context.node3 = node.id;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node3,
        value: "Save Model Array Ids to State Under Key"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node3,
        value: "Map"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node3,
        value: "x => x ? x.id : null"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node3,
        value: "Extract ids"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: { ...viewPackages,
          ChainParent: context.node3
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },

        callback(node, graph, group) {
          context.node4 = node.id;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node4,
        value: "Save Model Array Ids to State Under Key"
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback(node) {
          context.node5 = node.id;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_NODE",
      options: {
        id: context.node5,

        callback(node) {
          context.node4 = node.id;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback(node) {
          context.node6 = node.id;
        }

      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node6,
        value: "State Key"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node6,
        value: "StateKey"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node6,
        value: `${args.state_key}`
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node4
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "StateKey",
        id: context.node4,
        value: context.node6
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node6,
        source: context.node4,
        properties: {
          type: "StateKey",
          StateKey: {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node4,
        value: "Save model to state key"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node4,
        value: true
      }
    }];
  }];
  const clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node6,
        value: false
      };
    }

  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/screens/ScreenConnectGetAll.js











function ScreenConnectGetAll(args = {
  method,
  node
}) {
  let {
    node,
    method,
    navigateTo
  } = args;

  if (!node) {
    throw "no node";
  }

  if (!method) {
    throw "no method";
  }

  const graph = GetCurrentGraph();
  const screenOptions = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.ScreenOptions
  });
  const result = [];
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  screenOptions.forEach(screenOption => {
    const components = GetNodesLinkedTo(graph, {
      id: screenOption.id,
      link: nodetypes_LinkType.Component
    });
    components.forEach(component => {
      const internalComponentApi = GetNodesLinkedTo(graph, {
        id: component.id,
        link: nodetypes_LinkType.ComponentInternalApi
      });
      internalComponentApi.filter(x => uiactions_GetNodeProp(component, nodetypes_NodeProperties.ComponentType) === ComponentTypeKeys.List).filter(x => [ComponentApiKeys.Value, ComponentApiKeys.Index, ComponentApiKeys.Item, ComponentApiKeys.Separators].some(v => v === GetNodeTitle(x))).forEach(internal => {
        result.push(() => {
          return [{
            operation: UPDATE_NODE_PROPERTY,
            options: {
              id: internal.id,
              properties: {
                [nodetypes_NodeProperties.AsLocalContext]: true
              }
            }
          }];
        });
      });
      const listItems = GetNodesLinkedTo(graph, {
        id: component.id,
        link: nodetypes_LinkType.ListItem
      });
      listItems.map(listItem => {
        const subcomponents = GetNodesLinkedTo(graph, {
          id: listItem.id,
          link: nodetypes_LinkType.Component
        });
        const executeButtons = subcomponents.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExecuteButton));

        if (executeButtons && executeButtons.length === 1) {
          const subcomponent = executeButtons[0];
          const valueComponentApiNodeItems = GetNodesLinkedTo(graph, {
            id: subcomponent.id,
            link: nodetypes_LinkType.ComponentInternalApi
          }).find(x => GetNodeTitle(x) === ComponentApiKeys.Value);
          const valueNavigateTargetApiItems = GetNodesLinkedTo(graph, {
            id: navigateTo,
            link: nodetypes_LinkType.ComponentExternalApi
          }).find(x => GetNodeTitle(x) === ComponentApiKeys.Value);
          const events = GetNodesLinkedTo(graph, {
            id: subcomponent.id,
            link: nodetypes_LinkType.EventMethod
          }).filter(x => [ComponentEvents.onClick, ComponentEvents.onPress].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType)));
          events.map(evnt => {
            const eventMethodInstances = GetNodesLinkedTo(graph, {
              id: evnt.id,
              link: nodetypes_LinkType.EventMethodInstance
            });
            eventMethodInstances.map(eventMethodInstance => {
              const vp = uiactions_GetNodeProp(eventMethodInstance, nodetypes_NodeProperties.ViewPackage);

              if (vp) {
                const inPackageNodes = GetNodesByProperties({
                  [nodetypes_NodeProperties.ViewPackage]: vp
                });
                inPackageNodes.forEach(inPackageNode => {
                  result.push({
                    operation: REMOVE_NODE,

                    options(graph) {
                      return {
                        id: inPackageNode.id
                      };
                    }

                  });
                });
              }
            });
            let _instanceNode = null;
            let _navigateContext = null;
            const lambdaFunc = "v => ({ value: v })";
            result.push(...[{
              operation: ADD_NEW_NODE,
              options: addInstanceFunc(evnt, instanceNode => {
                _instanceNode = instanceNode;
              }, viewPackages)
            }], ...CreateNavigateToScreenDC({
              screen: navigateTo,
              node: () => _instanceNode.id,
              lambda: lambdaFunc,
              viewPackages,
              callback: navigateContext => {
                _navigateContext = navigateContext;
              }
            }), {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                return {
                  source: _instanceNode.id,
                  target: valueComponentApiNodeItems.id,
                  properties: { ...nodetypes_LinkProperties.ComponentApi
                  }
                };
              }

            }, valueNavigateTargetApiItems ? {
              operation: UPDATE_NODE_PROPERTY,

              options() {
                return {
                  id: valueNavigateTargetApiItems.id,
                  properties: {
                    [nodetypes_NodeProperties.IsUrlParameter]: true
                  }
                };
              }

            } : null);
          });
        }

        result.push(...AppendValidations({
          subcomponents,
          component,
          methodType: nodetypes_Methods.Update,
          screen_option: screenOption,
          method,
          viewPackages
        }));
      });
    });
    const lifeCylcleMethods = GetNodesLinkedTo(graph, {
      id: screenOption.id,
      link: nodetypes_LinkType.LifeCylceMethod
    });
    lifeCylcleMethods.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIText) === ComponentLifeCycleEvents.ComponentDidMount).map(lifeCylcleMethod => {
      const lifeCylcleMethodInstances = GetNodesLinkedTo(graph, {
        id: lifeCylcleMethod.id,
        link: nodetypes_LinkType.LifeCylceMethodInstance
      });
      lifeCylcleMethodInstances.map(lifeCylcleMethodInstance => {
        const vp = uiactions_GetNodeProp(lifeCylcleMethodInstance, nodetypes_NodeProperties.ViewPackage);

        if (vp) {
          const inPackageNodes = GetNodesByProperties({
            [nodetypes_NodeProperties.ViewPackage]: vp
          });
          inPackageNodes.forEach(inPackageNode => {
            result.push({
              operation: REMOVE_NODE,

              options() {
                return {
                  id: inPackageNode.id
                };
              }

            });
          });
        }
      });
      let cycleInstance = null;
      let storeModelDataChain = null;
      result.push(...AddLifeCylcleMethodInstance({
        node: lifeCylcleMethod.id,
        viewPackages,
        callback: _cycleInstance => {
          cycleInstance = _cycleInstance;
        }
      }), currentGraph => {
        if (cycleInstance) {
          return ConnectLifecycleMethod({
            target: method,
            source: cycleInstance.id,
            graph: currentGraph,
            viewPackages
          });
        }

        return [];
      }, ...StoreModelArrayStandard({
        viewPackages,
        model: uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model),
        modelText: GetNodeTitle(node),
        state_key: `${GetNodeTitle(uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model))} State`,
        callback: context => {
          storeModelDataChain = context.entry;
        }
      }), graph => {
        return [{
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              target: storeModelDataChain,
              source: cycleInstance.id,
              properties: { ...nodetypes_LinkProperties.DataChainLink,
                singleLink: true,
                nodeTypes: [NodeTypes.DataChain]
              }
            };
          }

        }];
      });
    });
  });
  return result.filter(x => x);
}
// CONCATENATED MODULE: ./app/nodepacks/UpdateModelAndGoBack.js
/* eslint-disable func-names */

/* eslint-disable no-unused-vars */



/* harmony default export */ var UpdateModelAndGoBack = (function (args = {}) {
  // node3
  if (!args.model) {
    throw "missing a model";
  } //


  const modelName = GetNodeTitle(args.model);
  const context = { ...args,
    node3: args.model
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function (_graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback(node) {
          context.node0 = node.id;
        }

      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: `${modelName ? `${modelName} ` : ''}Store Result In Reducer`
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],

        callback(node, _graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }

      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "turn into an array"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => x  !== undefined || x!== null  ? [x] : []"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },

        callback(node, _graph, _group) {
          context.node2 = node.id;
        }

      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "save models"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Save Model Array To State"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node2
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node2,
        value: context.node3
      }
    }];
  }, function (_graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node2,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (_graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node2,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node2
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },

        callback(node, _graph, _group) {
          context.node4 = node.id;
        }

      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node4,
        value: "Navigate To"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "NavigationAction",
        id: context.node4,
        value: "Back"
      }
    }];
  }, function (_graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node4,
        value: "go back"
      }
    }];
  }];
  const clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "AsOutput",
        id: context.node4,
        value: true
      };
    }

  }];
  const applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }

  }, {
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }

  }, {
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }

  }, {
    operation: "UPDATE_NODE_PROPERTY",

    options() {
      return {
        id: context.node4,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/screens/AppendPostMethod.js




function AppendPostMethod(args = {
  method,
  handler,
  viewPackages
}) {
  if (!args.method) {
    throw "missing method for appending a post method";
  }

  if (!args.handler) {
    throw "missing handler";
  }

  let {
    viewPackages
  } = args;
  let model = GetMethodNodeProp(GetNodeById(args.method), FunctionTemplateKeys.Model) || GetMethodNodeProp(GetNodeById(args.method), FunctionTemplateKeys.ModelOutput);
  let dataChain = null;
  return [...UpdateModelAndGoBack({
    viewPackages,
    model: model,
    callback: updateContext => {
      dataChain = updateContext.entry;
    }
  }), function (graph) {
    return {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,
      options: function () {
        return {
          source: args.handler(),
          target: dataChain,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }
    };
  }];
}
// CONCATENATED MODULE: ./app/nodepacks/GetModelObjectFromSelector.js
/* eslint-disable no-unused-vars */

/* eslint-disable func-names */


/* harmony default export */ var GetModelObjectFromSelector = (function (args = {}) {
  //
  // model
  if (!args.model) {
    throw 'missing model argument';
  }

  const context = { ...args
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function () {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": "Get " + args.model + " Object"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "EntryPoint",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "AsOutput",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node0,
        "value": "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node0,
        "value": "x => x ? x.object : null"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node0,
        "value": true
      }
    }];
  }];
  const clearPinned = [];
  const applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function (graph) {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context, graph);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/partial/ClearScreenInstanceLocalStateProperty.js
/* eslint-disable func-names */



/* harmony default export */ var ClearScreenInstanceLocalStateProperty = (function (args = {}) {
  // node1,node2
  args.propertyName = args.propertyName || GetNodeTitle(args.property); // propertyName

  if (!args.propertyName) {
    throw new Error('missing propertyName argument');
  }

  const context = { ...args,
    node1: args.model,
    node2: args.property
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function (graph) {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": `clear local ${args.propertyName}`
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node0,
        "value": "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node0,
        "value": "params => {\n   let { value, viewModel } = (params || {});\n   let dispatch = GetDispatch();\n   let getState = GetState(); \n// #{model}\n  \n dispatch(clearScreenInstance(viewModel, '#{model~prop}')); \n\t\n\n   return params;\n}"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node0
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "LambdaInsertArguments",
        "id": context.node0,
        "value": {
          "model": context.node1,
          "prop": context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node1,
        "source": context.node0,
        "properties": {
          "type": "LambdaInsertArguments",
          "LambdaInsertArguments": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "target": {
          "model": context.node1,
          "prop": context.node2
        },
        "source": context.node0
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "LambdaInsertArguments",
        "id": context.node0,
        "value": {
          "model": context.node1,
          "prop": context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node2,
        "source": context.node0,
        "properties": {
          "type": "LambdaInsertArguments",
          "LambdaInsertArguments": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node0,
        "value": true
      }
    }];
  }];
  const clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node2,
        value: false
      };
    }

  }];
  const applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/partial/ClearScreenInstanceUpdateLocalStateProperty.js
/* eslint-disable func-names */



/* harmony default export */ var ClearScreenInstanceUpdateLocalStateProperty = (function (args = {}) {
  // node1,node2
  args.propertyName = args.propertyName || GetNodeTitle(args.property); // propertyName

  if (!args.propertyName) {
    throw new Error('missing propertyName argument');
  }

  const context = { ...args,
    node1: args.model,
    node2: args.property
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function (graph) {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": `clear local ${args.propertyName}`
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node0,
        "value": "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node0,
        "value": "params => {\n   let { value, viewModel } = (params || {});\n   let dispatch = GetDispatch();\n   let getState = GetState(); \n// #{model}\n  \n dispatch(clearScreenInstance(viewModel, '#{model~prop}', { update: true, value})); \n\t\n\n   return params;\n}"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node0
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "LambdaInsertArguments",
        "id": context.node0,
        "value": {
          "model": context.node1,
          "prop": context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node1,
        "source": context.node0,
        "properties": {
          "type": "LambdaInsertArguments",
          "LambdaInsertArguments": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "target": {
          "model": context.node1,
          "prop": context.node2
        },
        "source": context.node0
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "LambdaInsertArguments",
        "id": context.node0,
        "value": {
          "model": context.node1,
          "prop": context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node2,
        "source": context.node0,
        "properties": {
          "type": "LambdaInsertArguments",
          "LambdaInsertArguments": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node0,
        "value": true
      }
    }];
  }];
  const clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node2,
        value: false
      };
    }

  }];
  const applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/datachain/ClearScreenInstance.js


/* eslint-disable no-undef */

/* eslint-disable prefer-destructuring */




function ClearScreenInstance(args) {
  const {
    viewPackages,
    model,
    update,
    title
  } = args;
  const func = update ? ClearScreenInstanceUpdateLocalStateProperty : ClearScreenInstanceLocalStateProperty;
  const modelProperties = GetModelPropertyChildren(model, {
    skipLogicalChildren: true
  }).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsDefaultProperty));
  const result = [];
  let lastChain = null;
  let entry = null;
  let groupId = null;
  modelProperties.forEach((modelProperty, index) => {
    let modelPropertyContext = null;
    result.push(...func({
      viewPackages,
      model,
      property: modelProperty.id,
      callback: temp => {
        modelPropertyContext = temp;
      }
    }), gg => {
      const res = [];

      if (index === modelProperties.length - 1) {
        res.push({
          operation: UPDATE_NODE_PROPERTY,
          options: {
            id: modelPropertyContext.entry,
            properties: {
              [nodetypes_NodeProperties.AsOutput]: true
            }
          }
        });
      }

      if (groupId) {
        res.push({
          operation: ADD_TO_GROUP,
          options: {
            id: modelPropertyContext.entry,
            groupProperties: {
              id: groupId
            }
          }
        });
      }

      if (lastChain && lastChain === entry) {
        res.push({
          operation: ADD_TO_GROUP,
          options: {
            parent: lastChain,
            id: modelPropertyContext.entry,
            groupCallback: temp => {
              groupId = temp;
            }
          }
        });
      }

      if (lastChain) {
        const temp = lastChain;
        lastChain = modelPropertyContext.entry;
        res.push({
          operation: UPDATE_NODE_PROPERTY,
          options: {
            id: modelPropertyContext.entry,
            properties: {
              [nodetypes_NodeProperties.ChainParent]: temp
            }
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            source: temp,
            target: modelPropertyContext.entry,
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          }
        });
        return res;
      }

      lastChain = modelPropertyContext.entry;
      entry = modelPropertyContext.entry;
      return [{
        operation: UPDATE_NODE_PROPERTY,
        options: {
          id: modelPropertyContext.entry,
          properties: {
            [nodetypes_NodeProperties.EntryPoint]: true,
            [nodetypes_NodeProperties.UIText]: title || GetNodeTitle(modelPropertyContext.entry, gg)
          }
        }
      }];
    });
  });
  result.push({
    operation: NO_OP,

    options() {
      if (args.callback) {
        args.callback({
          entry
        });
      }
    }

  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/screens/ScreenConnectCreate.js











function ScreenConnectCreate(args = {
  method,
  node
}) {
  let {
    node,
    method
  } = args;

  if (!node) {
    throw new Error("no node");
  }

  if (!method) {
    throw new Error("no method");
  }

  const graph = GetCurrentGraph();
  const screen_options = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.ScreenOptions
  });
  const result = [];
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  screen_options.map(screenOption => {
    const components = GetNodesLinkedTo(graph, {
      id: screenOption.id,
      link: nodetypes_LinkType.Component
    });
    components.map(component => {
      const subcomponents = GetNodesLinkedTo(graph, {
        id: component.id,
        link: nodetypes_LinkType.Component
      });
      const executeButtons = subcomponents.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExecuteButton));

      if (executeButtons.length === 1) {
        // There should be only 1 execute button
        const executeButton = executeButtons[0];
        const onEvents = GetNodesLinkedTo(graph, {
          id: executeButton.id,
          link: nodetypes_LinkType.EventMethod
        }).filter(x => [ComponentEvents.onClick, ComponentEvents.onPress].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType)));
        onEvents.forEach(x => {
          const t = GetNodesLinkedTo(graph, {
            id: x.id,
            link: nodetypes_LinkType.EventMethodInstance
          });

          if (t && t.length) {
            t.map(instance => {
              const vp = uiactions_GetNodeProp(instance, nodetypes_NodeProperties.ViewPackage);

              if (vp) {
                const inPackageNodes = GetNodesByProperties({
                  [nodetypes_NodeProperties.ViewPackage]: vp
                });
                inPackageNodes.map(inPackageNode => {
                  result.push({
                    operation: REMOVE_NODE,
                    options: function options() {
                      return {
                        id: inPackageNode.id
                      };
                    }
                  });
                });
              }

              return null;
            });
          }

          let instanceTempNode = null;
          let modelDataChain = null;
          result.push(...[{
            operation: ADD_NEW_NODE,
            options: addInstanceFunc(x, instanceNode => {
              instanceTempNode = instanceNode;
            }, viewPackages)
          }], ...GetModelObjectFromSelector({
            model: GetNodeTitle(node),
            viewPackages,
            callback: (newContext, tempGraph) => {
              modelDataChain = GetNodeById(newContext.entry, tempGraph);
            }
          }), currentGraph => {
            if (instanceTempNode) {
              return ConnectLifecycleMethod({
                target: method,
                dataChain: () => modelDataChain.id,
                source: instanceTempNode.id,
                graph: currentGraph,
                viewPackages
              });
            }

            return [];
          }, ...AppendPostMethod({
            method,
            viewPackages,
            handler: () => instanceTempNode.id
          }));
        });
      }

      result.push(...AppendValidations({
        subcomponents,
        component,
        methodType: nodetypes_Methods.Create,
        screen_option: screenOption,
        InstanceUpdate: false,
        method,
        viewPackages
      }));
    });
    let clearScreenContext = null;
    let componentDidMountInstance = null;
    let componentDidMount = null;
    result.push(...ClearScreenInstance({
      viewPackages,
      title: `Clear ${GetNodeTitle(node)} State`,
      model: uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model),
      callback: temp => {
        clearScreenContext = temp;
      }
    }), gg => {
      componentDidMount = GetNodesLinkedTo(gg, {
        id: screenOption.id,
        link: nodetypes_LinkType.LifeCylceMethod,
        componentType: NodeTypes.LifeCylceMethod
      }).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.EventType) === ComponentLifeCycleEvents.ComponentDidMount);

      if (componentDidMount) {
        componentDidMountInstance = GetNodeLinkedTo(gg, {
          id: componentDidMount.id,
          link: nodetypes_LinkType.LifeCylceMethodInstance,
          componentType: NodeTypes.LifeCylceMethodInstance
        });

        if (!componentDidMountInstance) {
          return {
            operation: ADD_NEW_NODE,
            options: addInstanceFunc(componentDidMount, instanceNode => {
              componentDidMountInstance = instanceNode;
            }, viewPackages, {
              lifecycle: true
            })
          };
        }
      }
    }, () => ({
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          target: clearScreenContext.entry,
          source: componentDidMountInstance.id,
          properties: { ...nodetypes_LinkProperties.CallDataChainLink
          }
        };
      }

    }), () => ({
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options(gg) {
        const viewModelExternalApiNode = GetComponentExternalApiNode(ComponentApiKeys.ViewModel, screenOption.id, gg);
        return {
          source: clearScreenContext.entry,
          target: viewModelExternalApiNode.id,
          properties: { ...nodetypes_LinkProperties.DataChainInputLink
          }
        };
      }

    }), () => ({
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options(gg) {
        const valueExternalApiNode = GetComponentExternalApiNode(ComponentApiKeys.Value, screenOption.id, gg);
        return {
          source: clearScreenContext.entry,
          target: valueExternalApiNode.id,
          properties: { ...nodetypes_LinkProperties.DataChainInputLink
          }
        };
      }

    }));
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/ModifyUpdateLinks.js






/* harmony default export */ var ModifyUpdateLinks = (function (args = {
  name: "Replace Name"
}) {
  // node2
  // name
  const result = [];
  const graph = GetCurrentGraph();
  const eventMethods = uiactions_NodesByType(null, NodeTypes.EventMethod);
  uiactions_NodesByType(null, NodeTypes.ViewType).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewType) === viewtypes_ViewTypes.Update).forEach(node => {
    getNodeLinks(graph, node.id).filter(x => GetLinkProperty(x, LinkPropertyKeys.TYPE) === nodetypes_LinkType.ComponentExternalApi).forEach(link => {
      result.push(() => {
        return [{
          operation: UPDATE_LINK_PROPERTY,
          options: {
            prop: LinkPropertyKeys.InstanceUpdate,
            value: true,
            id: link.id
          }
        }];
      });
    });
  });
  eventMethods.map(eventMethod => {
    const components = GetNodesLinkedTo(graph, {
      id: eventMethod.id,
      link: nodetypes_LinkType.EventMethod,
      componentType: NodeTypes.ComponentNode
    }).filter(x => ComponentIsViewType(x, viewtypes_ViewTypes.Update, graph));

    if (components.length) {
      const eventMethodInstances = GetNodesLinkedTo(graph, {
        id: eventMethod.id,
        link: nodetypes_LinkType.EventMethodInstance
      });
      eventMethodInstances.forEach(eventMethodInstance => {
        const link = GetLinkBetween(eventMethod.id, eventMethodInstance.id, graph); // modify link

        if (link) {
          result.push(() => {
            return [{
              operation: UPDATE_LINK_PROPERTY,
              options: {
                prop: LinkPropertyKeys.InstanceUpdate,
                value: true,
                id: link.id
              }
            }];
          });
        }
      });
    }
  });
  return result;
});
// CONCATENATED MODULE: ./app/nodepacks/screens/ScreenConnectUpdate.js














function ScreenConnectUpdate(args = {
  method,
  node
}) {
  let {
    node,
    method
  } = args;
  const {
    componentDidMountMethods
  } = args;

  if (!node) {
    throw new Error("no node");
  }

  if (!method) {
    throw new Error("no method");
  }

  if (!componentDidMountMethods) {
    throw new Error("no componentDidMountMethods");
  }

  if (!Array.isArray(componentDidMountMethods)) {
    componentDidMountMethods = [componentDidMountMethods];
  }

  const graph = GetCurrentGraph();
  const screenOptions = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.ScreenOptions
  });
  let result = [];
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const valueNavigateTargetApi = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.ComponentExternalApi
  }).find(x => GetNodeTitle(x) === ComponentApiKeys.Value);
  result.push(valueNavigateTargetApi ? {
    operation: UPDATE_NODE_PROPERTY,

    options() {
      return {
        id: valueNavigateTargetApi.id,
        properties: {
          [nodetypes_NodeProperties.IsUrlParameter]: true
        }
      };
    }

  } : null);
  screenOptions.forEach(screenOptionInstance => {
    const lifeCylcleMethods = GetNodesLinkedTo(graph, {
      id: screenOptionInstance.id,
      link: nodetypes_LinkType.LifeCylceMethod
    });
    const valueScreenOptionNavigateTargetApi = GetNodesLinkedTo(graph, {
      id: screenOptionInstance.id,
      link: nodetypes_LinkType.ComponentInternalApi
    }).find(x => GetNodeTitle(x) === ComponentApiKeys.Value);
    lifeCylcleMethods.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIText) === ComponentLifeCycleEvents.ComponentDidMount).forEach(lifeCylcleMethod => {
      const lifeCylcleMethodInstances = GetNodesLinkedTo(graph, {
        id: lifeCylcleMethod.id,
        link: nodetypes_LinkType.LifeCylceMethodInstance
      });
      lifeCylcleMethodInstances.forEach(lifeCylcleMethodInstance => {
        const vp = uiactions_GetNodeProp(lifeCylcleMethodInstance, nodetypes_NodeProperties.ViewPackage);

        if (vp) {
          const inPackageNodes = GetNodesByProperties({
            [nodetypes_NodeProperties.ViewPackage]: vp
          });
          inPackageNodes.forEach(inPackageNode => {
            result.push({
              operation: REMOVE_NODE,

              options() {
                return {
                  id: inPackageNode.id
                };
              }

            });
          });
        }
      });
      componentDidMountMethods.forEach(componentDidMountMethod => {
        let dataChainForLoading = null;
        let cycleInstance = null;
        result.push(...AddLifeCylcleMethodInstance({
          node: lifeCylcleMethod.id,
          viewPackages,
          callback: _cycleInstance => {
            cycleInstance = _cycleInstance;
          }
        }), currentGraph => {
          if (cycleInstance) {
            return ConnectLifecycleMethod({
              connectToParameter: !valueScreenOptionNavigateTargetApi ? null : ae => {
                switch (uiactions_GetNodeProp(ae, nodetypes_NodeProperties.UIText)) {
                  case 'modelId':
                    return {
                      target: valueScreenOptionNavigateTargetApi.id,
                      linkProperties: {
                        properties: { ...nodetypes_LinkProperties.ComponentApi
                        }
                      }
                    };

                  default:
                    return false;
                }
              },
              target: componentDidMountMethod,
              source: cycleInstance.id,
              graph: currentGraph,
              viewPackages
            });
          }

          return [];
        }, ...LoadModel({
          viewPackages,
          model_view_name: `Load ${GetCodeName(uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model))} into state`,
          model_item: `Models.${GetCodeName(uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model))}`,
          callback: context => {
            dataChainForLoading = context.entry;
          }
        }), {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              target: dataChainForLoading,
              source: cycleInstance.id,
              properties: { ...nodetypes_LinkProperties.DataChainLink
              }
            };
          }

        });
      });
    });
    const components = GetNodesLinkedTo(graph, {
      id: screenOptionInstance.id,
      link: nodetypes_LinkType.Component
    });
    components.forEach(component => {
      const subcomponents = GetNodesLinkedTo(graph, {
        id: component.id,
        link: nodetypes_LinkType.Component
      });
      const executiveButtons = subcomponents.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ExecuteButton));

      if (executiveButtons.length === 1) {
        // There should be only 1 execute button
        const executeButton = executiveButtons[0];
        const onEvents = GetNodesLinkedTo(graph, {
          id: executeButton.id,
          link: nodetypes_LinkType.EventMethod
        }).filter(x => [ComponentEvents.onClick, ComponentEvents.onPress].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.EventType)));
        const uiType = uiactions_GetNodeProp(screenOptionInstance, nodetypes_NodeProperties.UIType);
        let eventType = null;

        switch (uiType) {
          case UITypes.ReactNative:
            eventType = 'onPress';
            break;

          default:
            eventType = 'onClick';
            break;
        }

        let newEventNode = null;

        if (onEvents.length === 0) {
          result.push(() => ComponentEventTo(executeButton.id, eventType, eventNode => {
            newEventNode = eventNode;
          }));
          onEvents.push({
            newEventNode: () => newEventNode
          });
        }

        onEvents.forEach(onEventHandler => {
          if (!onEventHandler.newEventNode) {
            const t = GetNodesLinkedTo(graph, {
              id: onEventHandler.id,
              link: nodetypes_LinkType.EventMethodInstance
            });

            if (t && t.length) {
              t.forEach(instance => {
                const vp = uiactions_GetNodeProp(instance, nodetypes_NodeProperties.ViewPackage);
                const parentViewPackage = uiactions_GetNodeProp(onEventHandler, nodetypes_NodeProperties.ViewPackage);

                if (vp && vp !== parentViewPackage) {
                  const inPackageNodes = GetNodesByProperties({
                    [nodetypes_NodeProperties.ViewPackage]: uiactions_GetNodeProp(instance, nodetypes_NodeProperties.ViewPackage)
                  });
                  inPackageNodes.forEach(inPackageNode => {
                    result.push({
                      operation: REMOVE_NODE,

                      options() {
                        return {
                          id: inPackageNode.id
                        };
                      }

                    });
                  });
                } else {
                  result.push({
                    operation: REMOVE_NODE,

                    options() {
                      return {
                        id: instance.id
                      };
                    }

                  });
                }
              });
            }
          }

          let instanceNodeItem = null;
          let modelDataChain = null;
          const modelSelectorNode = GetNodeByProperties({
            [nodetypes_NodeProperties.NODEType]: NodeTypes.Selector,
            [nodetypes_NodeProperties.Model]: uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model)
          });
          result.push(...[{
            operation: ADD_NEW_NODE,
            options: addInstanceFunc(onEventHandler.newEventNode ? onEventHandler.newEventNode : onEventHandler, instanceNode => {
              instanceNodeItem = instanceNode;
            }, viewPackages)
          }], ...GetModelObjectFromSelector({
            model: GetNodeTitle(node),
            viewPackages,
            callback: (newContext, tempGraph) => {
              modelDataChain = GetNodeById(newContext.entry, tempGraph);
            }
          }), currentGraph => {
            if (instanceNodeItem) {
              return ConnectLifecycleMethod({
                target: method,
                selectorNode: () => modelSelectorNode.id,
                dataChain: () => modelDataChain.id,
                source: instanceNodeItem.id,
                graph: currentGraph,
                viewPackages
              });
            }

            return [];
          });
          result.push({
            operation: UPDATE_LINK_PROPERTY,

            options(currentGraph) {
              const link = getLinkInstance(currentGraph, {
                target: instanceNodeItem.id,
                source: onEventHandler.id
              });
              if (link) return {
                id: link.id,
                prop: LinkPropertyKeys.InstanceUpdate,
                value: true
              };
            }

          }, ...AppendPostMethod({
            method,
            viewPackages,
            handler: () => instanceNodeItem.id
          }));
        });
      }

      result.push(...AppendValidations({
        subcomponents,
        component,
        InstanceUpdate: true,
        methodType: nodetypes_Methods.Update,
        screen_option: screenOptionInstance,
        method,
        viewPackages
      }));
      const screenOption = screenOptionInstance;
      let clearScreenContext = null;
      let componentDidMountInstance = null;
      let componentDidMount = null;
      result.push(...ClearScreenInstance({
        viewPackages,
        title: `Clear ${GetNodeTitle(node)} State`,
        model: uiactions_GetNodeProp(node, nodetypes_NodeProperties.Model),
        callback: temp => {
          clearScreenContext = temp;
        }
      }), gg => {
        componentDidMount = GetNodesLinkedTo(gg, {
          id: screenOption.id,
          link: nodetypes_LinkType.LifeCylceMethod,
          componentType: NodeTypes.LifeCylceMethod
        }).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.EventType) === ComponentLifeCycleEvents.ComponentDidMount);

        if (componentDidMount) {
          componentDidMountInstance = GetNodeLinkedTo(gg, {
            id: componentDidMount.id,
            link: nodetypes_LinkType.LifeCylceMethodInstance,
            componentType: NodeTypes.LifeCylceMethodInstance
          });

          if (!componentDidMountInstance) {
            return addInstanceFunc(componentDidMount, instanceNode => {
              componentDidMountInstance = instanceNode;
            }, viewPackages, {
              lifecycle: true
            })();
          }
        }
      }, () => ({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,

        options() {
          return {
            target: clearScreenContext.entry,
            source: componentDidMountInstance.id,
            properties: { ...nodetypes_LinkProperties.CallDataChainLink
            }
          };
        }

      }), () => ({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,

        options(gg) {
          const viewModelExternalApiNode = GetComponentExternalApiNode(ComponentApiKeys.ViewModel, screenOption.id, gg);
          return {
            source: clearScreenContext.entry,
            target: viewModelExternalApiNode.id,
            properties: { ...nodetypes_LinkProperties.CallDataChainLink
            }
          };
        }

      }), () => ({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,

        options(gg) {
          const valueExternalApiNode = GetComponentExternalApiNode(ComponentApiKeys.Value, screenOption.id, gg);
          return {
            source: clearScreenContext.entry,
            target: valueExternalApiNode.id,
            properties: { ...nodetypes_LinkProperties.CallDataChainLink
            }
          };
        }

      }));
    });
  });
  result = [...result, ...ModifyUpdateLinks()].filter(x => x);
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/CollectionDataChainsIntoCollections.js






/* harmony default export */ var CollectionDataChainsIntoCollections = (function (args = {}) {
  const result = [];
  const graph = GetCurrentGraph();
  const screens = uiactions_NodesByType(null, NodeTypes.Screen);
  const screenWithoutDataChainCollection = screens; // .filter(screen => {
  //   return !GetNodesLinkedTo(graph, {
  //     id: screen.id,
  //     link: LinkType.DataChainCollectionReference
  //   }).length;
  // });

  screenWithoutDataChainCollection.map(screen => {
    const temp = {};
    const screenoptions = GetNodesLinkedTo(graph, {
      id: screen.id,
      link: nodetypes_LinkType.ScreenOptions
    });

    if (!GetNodesLinkedTo(graph, {
      id: screen.id,
      link: nodetypes_LinkType.DataChainCollectionReference
    }).length) {
      result.push({
        operation: ADD_NEW_NODE,

        options() {
          return {
            nodeType: NodeTypes.DataChainCollection,
            linkProperties: {
              properties: { ...nodetypes_LinkProperties.DataChainCollectionReference
              }
            },
            parent: screen.id,
            properties: {
              [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(screen)}`,
              [nodetypes_NodeProperties.Pinned]: false
            },
            callback: node => {
              temp.screen = node;
            }
          };
        }

      });
    }

    screenoptions.map(screenoption => {
      result.push(graph => {
        const add_screenoption_reference = !GetNodesLinkedTo(graph, {
          id: screenoption.id,
          link: nodetypes_LinkType.DataChainCollectionReference
        }).length;
        const screen = GetNodeLinkedTo(graph, {
          id: screenoption.id,
          link: nodetypes_LinkType.ScreenOptions
        });
        let collectionReference;

        if (screen) {
          collectionReference = GetNodeLinkedTo(graph, {
            id: screen.id,
            link: nodetypes_LinkType.DataChainCollectionReference
          });
        }

        let temp;
        return [add_screenoption_reference ? {
          operation: ADD_NEW_NODE,

          options(graph) {
            return {
              nodeType: NodeTypes.DataChainCollection,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.DataChainCollectionReference
                }
              },
              parent: screenoption.id,
              properties: {
                [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(screenoption)}`,
                [nodetypes_NodeProperties.Pinned]: false
              },
              callback: node => {
                temp = node;
              }
            };
          }

        } : false, collectionReference && add_screenoption_reference ? {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options() {
            return {
              source: temp.id,
              target: collectionReference.id,
              properties: { ...nodetypes_LinkProperties.DataChainCollection
              }
            };
          }

        } : null];
      });
      const components = GetNodesLinkedTo(graph, {
        id: screenoption.id,
        link: nodetypes_LinkType.Component
      });
      components.map(component => {
        const nodes_linked = GetNodesLinkedTo(graph, {
          id: component.id,
          link: nodetypes_LinkType.DataChainCollectionReference
        });

        if (nodes_linked.length) {
          return null;
        }

        result.push(graph => {
          const screenoption = GetNodesLinkedTo(graph, {
            id: component.id,
            link: nodetypes_LinkType.Component
          }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ScreenOption)[0];
          let collectionReference;

          if (screenoption) {
            collectionReference = GetNodeLinkedTo(graph, {
              id: screenoption.id,
              link: nodetypes_LinkType.DataChainCollectionReference
            });
          }

          let subtemp;
          return [{
            operation: ADD_NEW_NODE,

            options() {
              return {
                nodeType: NodeTypes.DataChainCollection,
                linkProperties: {
                  properties: { ...nodetypes_LinkProperties.DataChainCollectionReference
                  }
                },
                parent: component.id,
                properties: {
                  [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(component)}`,
                  [nodetypes_NodeProperties.Pinned]: false
                },
                callback: node => {
                  subtemp = node;
                }
              };
            }

          }, collectionReference ? {
            operation: uiactions_ADD_LINK_BETWEEN_NODES,

            options() {
              return {
                source: subtemp.id,
                target: collectionReference.id,
                properties: { ...nodetypes_LinkProperties.DataChainCollection
                }
              };
            }

          } : null];
        });
      });
      GetNodesLinkedTo(graph, {
        id: screenoption.id,
        link: nodetypes_LinkType.LifeCylceMethod
      }).map(lifeCycleMethod => {
        const res = GetNodesLinkedTo(graph, {
          id: lifeCycleMethod.id,
          link: nodetypes_LinkType.LifeCylceMethodInstance
        }).map(lifecylceInstanceMethod => {
          const chains = [...GetNodesLinkedTo(graph, {
            id: lifecylceInstanceMethod.id,
            link: nodetypes_LinkType.DataChainLink
          }).filter(chain => {
            return GetNodesLinkedTo(graph, {
              id: chain.id
            }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) !== NodeTypes.DataChain).length;
          }), ...GetNodesLinkedTo(graph, {
            id: lifecylceInstanceMethod.id,
            link: nodetypes_LinkType.PreDataChainLink
          }).filter(chain => {
            return GetNodesLinkedTo(graph, {
              id: chain.id
            }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) !== NodeTypes.DataChain).length;
          }), ...GetNodesLinkedTo(graph, {
            id: lifecylceInstanceMethod.id,
            link: nodetypes_LinkType.CallDataChainLink
          }).filter(chain => {
            return GetNodesLinkedTo(graph, {
              id: chain.id
            }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) !== NodeTypes.DataChain).length;
          })];
          return chains;
        });
        return res;
      }).flatten().forEach(chain => {
        result.push({
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options(ggraph) {
            let screenOptionCollectionReference;

            if (screenoption) {
              screenOptionCollectionReference = GetNodeLinkedTo(ggraph, {
                id: screenoption.id,
                link: nodetypes_LinkType.DataChainCollectionReference
              });
            }

            return {
              target: screenOptionCollectionReference.id,
              source: chain.id,
              properties: { ...nodetypes_LinkProperties.DataChainCollection
              }
            };
          }

        });
      });
    });
  });
  [UITypes.ElectronIO, UITypes.ReactNative].forEach(uiType => {
    let sharedReferenceCollection = GetNodeByProperties({
      [nodetypes_NodeProperties.SharedReferenceCollection]: true,
      [nodetypes_NodeProperties.UIType]: uiType
    }, graph);

    if (!sharedReferenceCollection) {
      result.push({
        operation: ADD_NEW_NODE,

        options() {
          return {
            nodeType: NodeTypes.DataChainCollection,
            properties: {
              [nodetypes_NodeProperties.UIText]: `Shared Components ${uiType}`,
              [nodetypes_NodeProperties.Pinned]: false,
              [nodetypes_NodeProperties.UIType]: uiType,
              [nodetypes_NodeProperties.SharedReferenceCollection]: true
            },
            callback: node => {
              sharedReferenceCollection = node;
            }
          };
        }

      });
    }

    const componentNodes = uiactions_NodesByType(null, NodeTypes.ComponentNode).filter(x => {
      return uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === uiType;
    });
    componentNodes.map(d => CollectionDataChainsIntoCollections_getTopComponent(graph, d)).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.SharedComponent)).unique();
    componentNodes.sort((a, b) => {
      const a_lineage = getComponentLineage(graph, a);
      const b_lineage = getComponentLineage(graph, b);
      const intersects = a_lineage.intersection(b_lineage);

      if (intersects.length === 0) {
        return a_lineage.length - b_lineage.length;
      }

      if (a_lineage.length !== b_lineage.length) {
        return a_lineage.length - b_lineage.length;
      }

      return 0;
    }).forEach(component => {
      result.push(function (graph) {
        const externalApiDataChains = getComponentExternalApiDataChains(graph, component);
        const internalApiDataChains = getComponentInternalApiDataChains(graph, component);
        const eventApiDataChains = getComponentEventDataChains(graph, component);
        let reference = null;
        const steps = [];
        reference = getCollectionReference(graph, component);

        if (!reference) {
          steps.push({
            operation: ADD_NEW_NODE,

            options(graph) {
              const parentReference = getParentCollectionReference(graph, component);

              if (true) {
                return {
                  nodeType: NodeTypes.DataChainCollection,
                  properties: {
                    [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(component)}`,
                    [nodetypes_NodeProperties.Pinned]: false
                  },
                  links: [{
                    target: (parentReference || sharedReferenceCollection).id,
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.DataChainCollection
                      }
                    }
                  }, {
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.DataChainCollectionReference
                      }
                    },
                    target: component.id
                  }].filter(x => x),
                  callback: node => {
                    reference = node;
                  }
                };
              } else {}
            }

          });
        }

        return [...steps, ...[...externalApiDataChains, ...internalApiDataChains, ...eventApiDataChains].map(dc => {
          return {
            operation: uiactions_ADD_LINK_BETWEEN_NODES,

            options(graph) {
              reference = reference || getCollectionReference(graph, component);
              return {
                target: reference.id,
                source: dc.id,
                properties: { ...nodetypes_LinkProperties.DataChainCollection
                }
              };
            }

          };
        })];
      });
    });
    screens.forEach(screen => {
      const screen_data_chains = [];
      const externalApiDataChains = getComponentExternalApiDataChains(graph, screen);
      const internalApiDataChains = getComponentInternalApiDataChains(graph, screen);
      const eventApiDataChains = getComponentEventDataChains(graph, screen);
      screen_data_chains.push(...externalApiDataChains, ...internalApiDataChains, ...eventApiDataChains);
      let reference = null;
      result.push(...[...screen_data_chains].map(dc => {
        return {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,

          options(graph) {
            reference = reference || getCollectionReference(graph, screen);
            return {
              target: reference.id,
              source: dc.id,
              properties: { ...nodetypes_LinkProperties.DataChainCollection
              }
            };
          }

        };
      }));
    });
  });
  return result.filter(x => x);
});

function getComponentLineage(graph, node) {
  let parent = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.Component,
    direction: graph_methods_TARGET
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentNode)[0];

  if (!parent) {
    parent = GetNodesLinkedTo(graph, {
      id: node.id,
      link: nodetypes_LinkType.Component,
      direction: graph_methods_TARGET
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ScreenOption)[0];
  }

  if (!parent) {
    parent = GetNodesLinkedTo(graph, {
      id: node.id,
      link: nodetypes_LinkType.ListItem,
      direction: graph_methods_TARGET
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentNode)[0];
  }

  if (!parent) {
    parent = GetNodesLinkedTo(graph, {
      id: node.id,
      link: nodetypes_LinkType.ScreenOptions,
      direction: graph_methods_TARGET
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Screen)[0];
  }

  if (parent) {
    return [...getComponentLineage(graph, parent), node.id];
  }

  return [node.id];
}

function getParentCollectionReference(graph, node) {
  node = getParentComponent(graph, node);
  if (node) return GetNodeLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.DataChainCollectionReference
  });
  return null;
}

function getCollectionReference(graph, node) {
  return GetNodeLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.DataChainCollectionReference
  });
}

function getParentComponent(graph, node) {
  let parent = GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.Component,
    direction: graph_methods_TARGET
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentNode)[0];

  if (!parent) {
    parent = GetNodesLinkedTo(graph, {
      id: node.id,
      link: nodetypes_LinkType.ListItem,
      direction: graph_methods_TARGET
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ComponentNode)[0];

    if (parent) {}
  }

  return parent;
}

function CollectionDataChainsIntoCollections_getTopComponent(graph, node) {
  const parent = getParentComponent(graph, node);

  if (parent) {
    return CollectionDataChainsIntoCollections_getTopComponent(graph, parent);
  }

  return node;
}

function getComponentExternalApiDataChains(graph, node) {
  const result = [];
  GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.ComponentExternalApi,
    direction: SOURCE
  }).map(res => {
    result.push(...GetNodesLinkedTo(graph, {
      id: res.id,
      link: nodetypes_LinkType.DataChainLink,
      direction: SOURCE
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.EntryPoint)));
  });
  return result;
}

function getComponentInternalApiDataChains(graph, node) {
  const result = [];
  GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.ComponentInternalApi,
    direction: SOURCE
  }).map(res => {
    result.push(...GetNodesLinkedTo(graph, {
      id: res.id,
      link: nodetypes_LinkType.DataChainLink,
      direction: SOURCE
    }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.EntryPoint)));
  });
  return result;
}

function getComponentEventDataChains(graph, node) {
  const result = [];
  GetNodesLinkedTo(graph, {
    id: node.id,
    link: nodetypes_LinkType.EventMethod,
    componentType: NodeTypes.EventMethod
  }).map(res => {
    const instances = GetNodesLinkedTo(graph, {
      id: res.id,
      link: nodetypes_LinkType.EventMethodInstance,
      componentType: NodeTypes.EventMethodInstance
    });
    instances.map(res => {
      result.push(...GetNodesLinkedTo(graph, {
        id: res.id,
        link: nodetypes_LinkType.DataChainLink,
        componentType: NodeTypes.DataChain
      }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.EntryPoint)));
    });
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/batch/ConnectScreens.js










function ConnectScreens() {
  const screens = uiactions_NodesByType(null, NodeTypes.Screen).filter(x => !["login-models", "Authenticate", "Register"].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.NodePackage) || v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewPackageTitle)));
  screens.forEach(screen => {
    const viewType = uiactions_GetNodeProp(screen, nodetypes_NodeProperties.ViewType);
    const methods = GetPossibleMethods(screen);
    const navigateToScreens = GetPossibleNavigateScreens(screen);
    const componentsDidMounts = GetPossibleComponentDidMount(screen);

    if (methods.length) {
      let commands = [];

      switch (viewType) {
        case viewtypes_ViewTypes.Get:
          commands = ScreenConnectGet({
            method: methods[0].id,
            node: screen.id,
            navigateTo: navigateToScreens[0].id
          });
          break;

        case viewtypes_ViewTypes.GetAll:
          commands = ScreenConnectGetAll({
            method: methods[0].id,
            node: screen.id,
            navigateTo: navigateToScreens[0].id
          });
          break;

        case viewtypes_ViewTypes.Create:
          commands = ScreenConnectCreate({
            method: methods[0].id,
            node: screen.id
          });
          break;

        case viewtypes_ViewTypes.Update:
          commands = ScreenConnectUpdate({
            method: methods[0].id,
            componentDidMountMethods: componentsDidMounts.map(x => x.id),
            node: screen.id
          });
          break;

        default:
          break;
      }

      commands.push(() => CollectionDataChainsIntoCollections());
      graphOperation([...commands])(GetDispatchFunc(), GetStateFunc());
      ;
    }
  });
}
function GetPossibleNavigateScreens(screen) {
  const screens = uiactions_NodesByType(null, NodeTypes.Screen);
  const viewType = uiactions_GetNodeProp(screen, nodetypes_NodeProperties.ViewType);
  const screenModel = uiactions_GetNodeProp(screen, nodetypes_NodeProperties.Model);
  return screens.filter(x => {
    if (viewType === viewtypes_ViewTypes.Get) {
      return uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewType) === viewtypes_ViewTypes.Update;
    }

    return uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewType) === viewtypes_ViewTypes.Get;
  }).filter(x => {
    if (screenModel) {
      const modelOutput = uiactions_GetNodeProp(x, nodetypes_NodeProperties.Model);
      return modelOutput === screenModel;
    }

    return true;
  });
}
function GetPossibleComponentDidMount(screen) {
  const screenModel = uiactions_GetNodeProp(screen, nodetypes_NodeProperties.Model);
  return uiactions_NodesByType(null, NodeTypes.Method).filter(x => (MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {}).method === viewtypes_ViewTypes.Get).filter(x => {
    if (screenModel) {
      const modelOutput = GetMethodNodeProp(x, FunctionTemplateKeys.ModelOutput) || GetMethodNodeProp(x, FunctionTemplateKeys.Model);
      return modelOutput === screenModel;
    }

    return true;
  });
}
function GetPossibleMethods(screen) {
  const viewType = uiactions_GetNodeProp(screen, nodetypes_NodeProperties.ViewType);
  const screenModel = uiactions_GetNodeProp(screen, nodetypes_NodeProperties.Model);
  return uiactions_NodesByType(null, NodeTypes.Method).filter(x => {
    const functionType = MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {};
    return functionType.method === viewType && !functionType.isFetchCompatible;
  }).filter(x => {
    if (screenModel) {
      const modelOutput = GetMethodNodeProp(x, FunctionTemplateKeys.ModelOutput) || GetMethodNodeProp(x, FunctionTemplateKeys.Model);
      return modelOutput === screenModel;
    }

    return true;
  });
}
// CONCATENATED MODULE: ./app/nodepacks/CreateStandardClaimService.js

/* harmony default export */ var CreateStandardClaimService = (function (args = {}) {
  // node1,node2
  //
  if (!args.model) {
    throw "no model was passed";
  }

  if (!args.user) {
    throw "no user was passed";
  }

  let context = { ...args,
    modelName: args.modelName || "Unknown",
    node1: args.model,
    node2: args.user
  };
  let {
    modelName
  } = context;
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Claim Service"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "ClaimService"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "method",
        groupProperties: {},
        properties: {
          NodePackage: context.node1,
          NodePackageType: "Create " + modelName + " For User",
          NodePackageAgent: context.node2,
          functionType: "Create/Object=>Object(with users)",
          MethodType: "Create",
          HttpMethod: "HttpPost",
          text: "Create " + modelName + " For User"
        },
        linkProperties: {
          properties: {
            type: "function-operator",
            "function-operator": {}
          }
        },
        callback: function (node, graph, group) {
          context.node3 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_DEFAULT_PROPERTIES",
      options: {
        parent: context.node1,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "property-link",
            "property-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node4 = node.id;
          context.group1 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node3,
        target: context.node2,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node1,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "permission",
        groupProperties: {},
        properties: {
          NodePackage: context.node1,
          NodePackageType: "Create " + modelName + " For User",
          text: "Create " + modelName + " For User permission"
        },
        linkProperties: {
          properties: {
            type: "function-operator",
            "function-operator": {}
          }
        },
        callback: function (node, graph, group) {
          context.node5 = node.id;
          context.group2 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2,
          permission: context.node5
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node5,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "model-filter",
        groupProperties: {},
        properties: {
          NodePackage: context.node1,
          NodePackageType: "Create " + modelName + " For User",
          text: "Create " + modelName + " For User model-filter"
        },
        linkProperties: {
          properties: {
            type: "function-operator",
            "function-operator": {}
          }
        },
        callback: function (node, graph, group) {
          context.node6 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "filteragent",
        id: context.node6,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "filtermodel",
        id: context.node6,
        value: context.node1
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node1,
        source: context.node6,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node6,
        properties: {
          type: "agent-type-link",
          "agent-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2,
          permission: context.node5,
          model_filter: context.node6,
          Validator: context.node7,
          executor: context.node8
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node6,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "validator",
        groupProperties: {},
        properties: {
          NodePackage: context.node1,
          collapsed: true,
          NodePackageType: "Create " + modelName + " For User",
          text: "Create " + modelName + " For User Validator",
          ValidatorModel: context.node1,
          ValidatorAgent: context.node2,
          ValidatorFunction: context.node3
        },
        callback: function (node, graph, group) {
          context.node7 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node1,
        source: context.node7,
        properties: {
          type: "validator-model",
          "validator-model": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node7,
        properties: {
          type: "validator-agent",
          "validator-agent": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node7,
        properties: {
          type: "validator-function",
          "validator-function": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2,
          permission: context.node5,
          model_filter: context.node6,
          Validator: context.node7,
          executor: context.node8
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node7,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node3,
        nodeType: "executor",
        groupProperties: {},
        properties: {
          NodePackage: context.node1,
          NodePackageType: "Create " + modelName + " For User",
          ExecutorFunctionType: "Create",
          text: "Create " + modelName + " For User Executor",
          ExecutorModel: context.node1,
          ExecutorModelOutput: context.node1,
          ExecutorFunction: context.node3,
          ExecutorAgent: context.node2
        },
        callback: function (node, graph, group) {
          context.node8 = node.id;
          context.executor = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node1,
        source: context.node8,
        properties: {
          type: "executor-model",
          "executor-model": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node8,
        properties: {
          type: "validator-agent",
          "validator-agent": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node8,
        properties: {
          type: "executor-function",
          "executor-function": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node3,
        value: {
          user: context.node2,
          model: context.node1,
          agent: context.node2,
          permission: context.node5,
          model_filter: context.node6,
          Validator: context.node7,
          executor: context.node8
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node8,
        source: context.node3,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "method-api-parameters",
        properties: {
          text: "Body",
          UriBody: true
        },
        links: [function (graph) {
          return [{
            target: context.node3,
            linkProperties: {
              properties: {
                type: "MethodApiParameters",
                MethodApiParameters: {},
                body: true
              }
            }
          }];
        }],
        callback: function (node) {
          context.node9 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "controller",
        properties: {
          text: "" + modelName + " Controller"
        },
        links: [function (graph) {
          return [{
            target: context.node1,
            properties: {
              type: "model-type-link",
              "model-type-link": {}
            }
          }];
        }],
        callback: function (node) {
          context.node10 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node10,
        value: "systemUser",
        prop: "codeUser"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "maestro",
        properties: {
          text: "" + modelName + " Maestro"
        },
        links: [function (graph) {
          return [{
            target: context.node1,
            properties: {
              type: "model-type-link",
              "model-type-link": {}
            }
          }];
        }],
        callback: function (node) {
          context.node11 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node10,
        target: context.node11,
        properties: {
          type: "maestro-link",
          "maestro-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node11,
        target: context.node3,
        properties: {
          type: "function-link",
          "function-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node3,
        source: context.node0,
        properties: {
          type: "ClaimServiceAuthorizationMethod",
          ClaimServiceAuthorizationMethod: {},
          nodeTypes: ["method"]
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "method",
        groupProperties: {},
        properties: {
          NodePackage: context.node2,
          NodePackageType: "Update User",
          NodePackageAgent: context.node2,
          functionType: "Update/Object=>Object(with users)",
          MethodType: "Update",
          HttpMethod: "HttpPost",
          text: "Update User"
        },
        linkProperties: {
          properties: {
            type: "function-operator",
            "function-operator": {}
          }
        },
        callback: function (node, graph, group) {
          context.node12 = node.id;
          context.group3 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_DEFAULT_PROPERTIES",
      options: {
        parent: context.node2,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "property-link",
            "property-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node13 = node.id;
          context.group4 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node12,
        target: context.node2,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node12,
        nodeType: "permission",
        groupProperties: {},
        properties: {
          NodePackage: context.node2,
          NodePackageType: "Update User",
          text: "Update User permission"
        },
        linkProperties: {
          properties: {
            type: "function-operator",
            "function-operator": {}
          }
        },
        callback: function (node, graph, group) {
          context.node14 = node.id;
          context.group5 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2,
          permission: context.node14
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node14,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node12,
        nodeType: "model-filter",
        groupProperties: {},
        properties: {
          NodePackage: context.node2,
          NodePackageType: "Update User",
          text: "Update User model-filter"
        },
        linkProperties: {
          properties: {
            type: "function-operator",
            "function-operator": {}
          }
        },
        callback: function (node, graph, group) {
          context.node15 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "filteragent",
        id: context.node15,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "filtermodel",
        id: context.node15,
        value: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node15,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node15,
        properties: {
          type: "agent-type-link",
          "agent-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2,
          permission: context.node14,
          model_filter: context.node15,
          Validator: context.node16,
          executor: context.node17
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node15,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node12,
        nodeType: "validator",
        groupProperties: {},
        properties: {
          NodePackage: context.node2,
          collapsed: true,
          NodePackageType: "Update User",
          text: "Update User Validator",
          ValidatorModel: context.node2,
          ValidatorAgent: context.node2,
          ValidatorFunction: context.node12
        },
        callback: function (node, graph, group) {
          context.node16 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node16,
        properties: {
          type: "validator-model",
          "validator-model": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node16,
        properties: {
          type: "validator-agent",
          "validator-agent": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node12,
        source: context.node16,
        properties: {
          type: "validator-function",
          "validator-function": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2,
          permission: context.node14,
          model_filter: context.node15,
          Validator: context.node16,
          executor: context.node17
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node16,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node12,
        nodeType: "executor",
        groupProperties: {},
        properties: {
          NodePackage: context.node2,
          NodePackageType: "Update User",
          ExecutorFunctionType: "Update",
          text: "Update User Executor",
          ExecutorModel: context.node2,
          ExecutorModelOutput: context.node2,
          ExecutorFunction: context.node12,
          ExecutorAgent: context.node2
        },
        callback: function (node, graph, group) {
          context.node17 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node17,
        properties: {
          type: "executor-model",
          "executor-model": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node2,
        source: context.node17,
        properties: {
          type: "validator-agent",
          "validator-agent": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node12,
        source: context.node17,
        properties: {
          type: "executor-function",
          "executor-function": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "methodProperties",
        id: context.node12,
        value: {
          user: context.node2,
          model: context.node2,
          agent: context.node2,
          permission: context.node14,
          model_filter: context.node15,
          Validator: context.node16,
          executor: context.node17
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node17,
        source: context.node12,
        properties: {
          type: "function-operator",
          "function-operator": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "method-api-parameters",
        properties: {
          text: "Body",
          UriBody: true
        },
        links: [function (graph) {
          return [{
            target: context.node12,
            linkProperties: {
              properties: {
                type: "MethodApiParameters",
                MethodApiParameters: {},
                body: true
              }
            }
          }];
        }],
        callback: function (node) {
          context.node18 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "controller",
        properties: {
          text: "User Controller"
        },
        links: [function (graph) {
          return [{
            target: context.node2,
            properties: {
              type: "model-type-link",
              "model-type-link": {}
            }
          }];
        }],
        callback: function (node) {
          context.node19 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node19,
        value: "systemUser",
        prop: "codeUser"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "maestro",
        properties: {
          text: "User Maestro"
        },
        links: [function (graph) {
          return [{
            target: context.node2,
            properties: {
              type: "model-type-link",
              "model-type-link": {}
            }
          }];
        }],
        callback: function (node) {
          context.node20 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node19,
        target: context.node20,
        properties: {
          type: "maestro-link",
          "maestro-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node20,
        target: context.node12,
        properties: {
          type: "function-link",
          "function-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node12,
        source: context.node0,
        properties: {
          type: "ClaimServiceUpdateUserMethod",
          ClaimServiceUpdateUserMethod: {},
          nodeTypes: ["method"]
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node6,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node7,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node8,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node9,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node10,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node11,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node12,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node13,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node14,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node15,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node16,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node17,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node18,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node19,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node20,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/batch/CreateClaimService.js




function CreateClaimService() {
  const claimService = GetNodeByProperties({
    [nodetypes_NodeProperties.NODEType]: NodeTypes.ClaimService
  });

  if (!claimService) {
    let claimServiceExecutor = null;
    const agent = uiactions_NodesByType(null, NodeTypes.Model).find(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent) && !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsUser));
    graphOperation([...CreateStandardClaimService({
      modelName: GetNodeTitle(agent),
      model: agent.id,
      user: uiactions_GetNodeProp(agent, nodetypes_NodeProperties.UIUser),
      callback: claimServiceContext => {
        claimServiceExecutor = claimServiceContext.executor;
      }
    }), currentGraph => {
      const steps = nodepacks_AddCopyPropertiesToExecutor({
        currentNode: claimServiceExecutor,
        executor: uiactions_GetNodeProp(claimServiceExecutor, nodetypes_NodeProperties.Executor, currentGraph)
      });
      return steps;
    }], null, 'standard-claim-service')(GetDispatchFunc(), GetStateFunc());
    ;
  }
}
// CONCATENATED MODULE: ./app/nodepacks/AddEvent.js
/* eslint-disable func-names */


/* harmony default export */ var nodepacks_AddEvent = (function (args = {}) {
  // node0
  //
  if (!args.component) {
    throw "missing component";
  }

  if (!args.eventType) {
    throw "missing eventType";
  }

  if (args.eventTypeHandler && !args.property) {
    throw "missing property";
  }

  const context = { ...args,
    node0: args.component
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function () {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethod",
        parent: context.node0,
        properties: { ...viewPackages,
          EventType: context.eventType,
          text: context.eventType
        },
        linkProperties: {
          properties: {
            type: "EventMethod",
            EventMethod: {}
          }
        },

        callback(node) {
          context.node4 = node.id;
          context.eventTypeNode = node.id;
        }

      }
    }];
  }, function () {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethodInstance",
        parent: context.node4,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventMethodInstance",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: `${context.eventType} Instance`,
          EventType: context.eventType,
          Pinned: false,
          ...viewPackages,
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },

        callback(node, graph, group) {
          context.node5 = node.id;
          context.group1 = group;
          context.eventTypeInstanceNode = node.id;
        }

      }
    }];
  }, context.eventTypeHandler ? function () {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventHandler",
        parent: context.node5,
        ...viewPackages,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventHandler",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: `${context.eventType} Handler`,
          Pinned: false,
          EventType: context.eventType,
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },

        callback(node, graph, group) {
          context.node5 = node.id;
          context.group1 = group;
        }

      }
    }];
  } : null, context.eventTypeHandler && context.property ? function () {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node5,
        target: context.property,
        properties: { ...nodetypes_LinkProperties.PropertyLink
        }
      }
    }];
  } : null].filter(x => x);
  const clearPinned = !args.clearPinned ? [] : [{
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }

  }, {
    operation: "CHANGE_NODE_PROPERTY",

    options() {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }

  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/viewtype/CreateModelKeyDC.js


/* harmony default export */ var CreateModelKeyDC = (function (args = {}) {
  // node1
  if (!args.modelId) {
    throw new Error('missing model id');
  } // model


  if (!args.model) {
    throw 'missing model argument';
  }

  let context = { ...args,
    node1: args.modelId
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node0,
        "value": "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "EntryPoint",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "AsOutput",
        "id": context.node0,
        "value": true
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node0,
        "value": "ModelKey"
      }
    }];
  }, function (graph) {
    return [{
      "operation": "REMOVE_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node0
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "ModelKey",
        "id": context.node0,
        "value": context.node1
      }
    }];
  }, function (graph) {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "target": context.node1,
        "source": context.node0,
        "properties": {
          "type": "ModelKey",
          "ModelKey": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node0,
        "value": "Get " + args.model + " Model Key"
      }
    }];
  }];
  let clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateModelPropertyGetterDC.js



/* harmony default export */ var CreateModelPropertyGetterDC = (function (args = {}) {
  // node3,node4,node5
  // modelName, propertyName
  if (!args.modelName) {
    throw "missing modelName argument";
  }

  if (!args.propertyName) {
    throw "missing propertyName argument";
  }

  if (!args.model) {
    throw "missing model argument";
  }

  if (!args.property) {
    throw "missing propertyName argument";
  }

  let context = { ...args,
    node3: args.model,
    node4: args.model,
    node5: args.property
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get " + args.modelName + " " + args.propertyName + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: nodetypes_NodeProperties.DataChainFunctionType,
        id: context.node0,
        value: DataChainFunctionKeys.Pass
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          DataChainFunctionType: "Pass",
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => x.object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "get object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Model - Property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node2,
        value: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node2,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node2,
        value: context.node4
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node4,
        source: context.node2,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Property",
        id: context.node2,
        value: context.node5
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node5,
        source: context.node2,
        properties: {
          type: "property-link",
          "property-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "get object property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/viewtype/SetupViewTypeForCreate.js








function SetupViewTypeForCreate(args = {}) {
  const {
    node,
    eventType,
    eventTypeHandler,
    callback,
    uiType = UITypes.ElectronIO
  } = args;
  const graph = GetCurrentGraph();
  const result = [];

  if (!node) {
    throw new Error('missing node');
  }

  if (!eventType) {
    throw new Error('missing eventType');
  }

  if (!eventTypeHandler) {
    throw new Error('missing eventTypeHandler');
  }

  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const {
    model,
    property,
    modelType
  } = GetViewTypeModelType(node);
  const properties = [property];
  const component = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.DefaultViewType
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === uiType).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.SharedComponent));

  if (component) {
    GetNodesLinkedTo(null, {
      id: component.id,
      link: nodetypes_LinkType.ListItem,
      componentType: NodeTypes.ComponentNode
    }).forEach(listItem => {
      GetNodesLinkedTo(null, {
        id: listItem.id,
        link: nodetypes_LinkType.Component,
        componentType: NodeTypes.ComponentNode
      }).forEach(subcomponent => {
        GetNodesLinkedTo(null, {
          id: subcomponent.id,
          link: nodetypes_LinkType.ComponentExternalApi,
          componentType: NodeTypes.ComponentExternalApi
        }).forEach(externalApi => {
          GetNodesLinkedTo(null, {
            id: externalApi.id,
            link: nodetypes_LinkType.ComponentExternalConnection,
            componentType: NodeTypes.ComponentApi
          }).forEach(externalConnection => {
            const link = GetLinkBetween(externalApi.id, externalConnection.id, graph);

            if (link) {
              result.push({
                operation: UPDATE_LINK_PROPERTY,
                options: {
                  prop: LinkPropertyKeys.InstanceUpdate,
                  value: false,
                  id: link.id
                }
              });
            }
          });
        });
      });
    });
  }

  const propertyModel = modelType;
  /* GetNodeLinkedTo(null, {
  id: property.id,
  link: LinkType.PropertyLink
  }); */

  const valueExternalNode = GetNodesLinkedTo(null, {
    id: node,
    link: nodetypes_LinkType.ComponentExternalApi,
    componentType: NodeTypes.ComponentExternalApi
  }).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.ValueName) === ComponentApiKeys.Value);
  let modelKeyDC = null;
  const externalNodes = GetNodesLinkedTo(null, {
    id: node,
    link: nodetypes_LinkType.ComponentExternalApi,
    componentType: NodeTypes.ComponentExternalApi
  });
  const viewModelExternalNode = externalNodes.find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.ValueName) === ComponentApiKeys.ViewModel);
  result.push(...externalNodes.map(externalNode => {
    const link = GetLinkBetween(node, externalNode.id, graph);

    if (link) {
      return {
        operation: UPDATE_LINK_PROPERTY,
        options: {
          prop: LinkPropertyKeys.InstanceUpdate,
          value: false,
          id: link.id
        }
      };
    }

    return null;
  }));
  result.push(...CreateModelKeyDC({
    model: `${GetNodeTitle(node)} ${GetNodeTitle(property)}`,
    modelId: model.id,
    viewPackages,
    callback: modelKeyContext => {
      modelKeyDC = modelKeyContext.entry;
    }
  }), {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      if (viewModelExternalNode) {
        return {
          target: modelKeyDC,
          source: viewModelExternalNode.id,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }

      return false;
    }

  });
  let temp;
  result.push(...CreateModelPropertyGetterDC({
    model: propertyModel.id,
    property: property.id,
    viewPackages,
    propertyName: `${GetNodeTitle(node)}${GetNodeTitle(property.id)}`,
    modelName: GetNodeTitle(propertyModel),
    callback: context => {
      temp = context.entry;
    }
  }), {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        source: valueExternalNode.id,
        target: temp,
        properties: { ...nodetypes_LinkProperties.DataChainLink
        }
      };
    }

  });
  const selector = GetNodeByProperties({
    [nodetypes_NodeProperties.NODEType]: NodeTypes.Selector,
    [nodetypes_NodeProperties.Model]: modelType.id
  });

  if (selector) {
    result.push({
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          source: valueExternalNode.id,
          target: selector.id,
          properties: { ...nodetypes_LinkProperties.SelectorLink
          }
        };
      }

    });
  }

  result.push(...nodepacks_AddEvent({
    component: node,
    viewPackages,
    eventType,
    eventTypeHandler: properties.length ? eventTypeHandler : false,
    property: properties.length ? properties[0].id : null,
    callback
  }));
  return result;
}
SetupViewTypeForCreate.title = 'Setup View Type For Create';
SetupViewTypeForCreate.description = `Setup view-type nodes for create. Adds an onChange event, and sets the dataChain for viewmodel.`;
function GetViewTypeModelType(node) {
  const graph = GetCurrentGraph();
  const properties = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.DefaultViewType,
    componentType: NodeTypes.Property
  });
  const models = GetNodesLinkedTo(graph, {
    id: node,
    link: nodetypes_LinkType.DefaultViewType
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Model);
  let model = models[0];
  let property = properties[0];
  let modelType = null;

  if (!property) {
    console.warn('no property');
    const modelOptions = GetNodesLinkedTo(graph, {
      id: node,
      link: nodetypes_LinkType.DefaultViewType,
      componentType: NodeTypes.Model
    });

    if (modelOptions.length === 2) {
      if (existsLinkBetween(graph, {
        id: node,
        link: nodetypes_LinkType.LogicalChildren,
        source: modelOptions[0].id,
        target: modelOptions[1].id
      })) {
        [property, model] = modelOptions;
      } else if (existsLinkBetween(graph, {
        id: node,
        link: nodetypes_LinkType.LogicalChildren,
        source: modelOptions[1].id,
        target: modelOptions[0].id
      })) {
        [model, property] = modelOptions;
        modelType = property;
      } else {
        throw new Error('unhandled: the defaultviewtype should have two models that are connected to each other in a child/parent relationship');
      }
    } else {
      throw new Error(`an incorrect number of models is connected to the viewtype ${modelOptions.length}`);
    }
  } else {
    modelType = GetNodeLinkedTo(graph, {
      id: property.id,
      link: nodetypes_LinkType.PropertyLink,
      componentType: NodeTypes.Model
    });
  }

  return {
    model,
    property,
    modelType
  };
}
// CONCATENATED MODULE: ./app/nodepacks/viewtype/SetupViewTypeForGetAll.js







function SetupViewTypeForGetAll(args = {}) {
  const {
    node
  } = args;
  const graph = GetCurrentGraph();
  const result = [];

  if (!node) {
    throw new Error('missing node');
  }

  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const {
    model,
    property,
    modelType
  } = GetViewTypeModelType(node);
  const propertyModel = GetNodeLinkedTo(null, {
    id: property.id,
    link: nodetypes_LinkType.PropertyLink
  });
  const externalNodes = GetNodesLinkedTo(null, {
    id: node,
    link: nodetypes_LinkType.ComponentExternalApi,
    componentType: NodeTypes.ComponentExternalApi
  });
  const valueExternalNode = externalNodes.find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.ValueName) === ComponentApiKeys.Value);
  let modelKeyDC = null;
  const viewModelExternalNode = GetNodesLinkedTo(null, {
    id: node,
    link: nodetypes_LinkType.ComponentExternalApi,
    componentType: NodeTypes.ComponentExternalApi
  }).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.ValueName) === ComponentApiKeys.ViewModel);
  result.push(...externalNodes.map(externalNode => {
    const link = GetLinkBetween(node, externalNode.id, graph);

    if (link) {
      return {
        operation: UPDATE_LINK_PROPERTY,
        options: {
          prop: LinkPropertyKeys.InstanceUpdate,
          value: false,
          id: link.id
        }
      };
    }

    return null;
  }));
  result.push(...GetNodesLinkedTo(null, {
    id: viewModelExternalNode.id,
    link: nodetypes_LinkType.DataChainLink,
    componentType: NodeTypes.DataChain
  }).map(dc => ({
    operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
    options: {
      target: dc.id,
      source: viewModelExternalNode.id
    }
  })));
  result.push(...CreateModelKeyDC({
    model: `${GetNodeTitle(node)} ${GetNodeTitle(property)}`,
    modelId: model.id,
    viewPackages,
    callback: modelKeyContext => {
      modelKeyDC = modelKeyContext.entry;
    }
  }), {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      if (viewModelExternalNode) {
        return {
          target: modelKeyDC,
          source: viewModelExternalNode.id,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }

      return false;
    }

  });
  result.push(...GetNodesLinkedTo(null, {
    id: valueExternalNode.id,
    link: nodetypes_LinkType.DataChainLink,
    componentType: NodeTypes.DataChain
  }).map(dc => ({
    operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
    options: {
      target: dc.id,
      source: valueExternalNode.id
    }
  })));
  let temp;
  result.push(...CreateModelPropertyGetterDC({
    model: propertyModel.id,
    viewPackages,
    property: property.id,
    propertyName: `${GetNodeTitle(node)}${GetNodeTitle(property.id)}`,
    modelName: GetNodeTitle(propertyModel),
    callback: context => {
      temp = context.entry;
    }
  }), {
    operation: uiactions_ADD_LINK_BETWEEN_NODES,

    options() {
      return {
        source: valueExternalNode.id,
        target: temp,
        properties: { ...nodetypes_LinkProperties.DataChainLink
        }
      };
    }

  });
  const selector = GetNodeByProperties({
    [nodetypes_NodeProperties.NODEType]: NodeTypes.Selector,
    [nodetypes_NodeProperties.Model]: modelType.id
  });

  if (selector) {
    result.push({
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          source: valueExternalNode.id,
          target: selector.id,
          properties: { ...nodetypes_LinkProperties.SelectorLink
          }
        };
      }

    });
  }

  return result.filter(x => x);
}
SetupViewTypeForGetAll.title = 'Setup View Type For GetAll';
SetupViewTypeForGetAll.description = `Setup view-type nodes for create. Sets the dataChain for viewmodel.`;
// CONCATENATED MODULE: ./app/nodepacks/viewtype/AddComponentDidMountToViewTypeComponent.js




function AddComponentDidMountToViewTypeComponent(args = {}) {
  const result = [];
  const currentGraph = GetCurrentGraph();
  const {
    node,
    viewPackages
  } = args;
  let lifeCycleMethod = null;
  let lifeCycleInstance = null;
  const component = GetNodesLinkedTo(currentGraph, {
    id: node,
    link: nodetypes_LinkType.DefaultViewType
  }).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.SharedComponent));

  if (component) {
    result.push(() => {
      return SCREEN_COMPONENT_EVENTS.map(t => ({
        operation: ADD_NEW_NODE,

        options() {
          return {
            nodeType: NodeTypes.LifeCylceMethod,
            properties: {
              [nodetypes_NodeProperties.EventType]: t,
              ...viewPackages,
              [nodetypes_NodeProperties.Pinned]: false,
              [nodetypes_NodeProperties.UIText]: `${t}`
            },
            callback: lifeCycle => {
              if (t === ComponentLifeCycleEvents.ComponentDidMount) {
                lifeCycleMethod = lifeCycle;
              }
            },
            links: [{
              target: component.id,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.LifeCylceMethod
                }
              }
            }]
          };
        }

      }));
    }, () => {
      if (lifeCycleMethod) {
        const temp = addInstanceFunc(lifeCycleMethod, lci => {
          lifeCycleInstance = lci;
        }, viewPackages, {
          lifeCycle: true
        });
        return {
          operation: ADD_NEW_NODE,
          options: temp
        };
      }

      return [];
    }, () => {
      if (args.callback) {
        args.callback({
          lifeCycleMethod,
          component,
          lifeCycleInstance
        });
      }

      return [];
    });
  }

  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/viewtype/AttachGetAllOnComponentDidMount.js





function AttachGetAllOnComponentDidMount(args = {}) {
  const result = [];
  const {
    node,
    functionToLoadModels,
    viewPackages
  } = args;
  const model = GetViewTypeModel(node);
  let storeModelArrayDC = null;
  let didMountContext = null;
  result.push(...StoreModelArrayStandard({
    model,
    viewPackages,
    modelText: `${GetNodeTitle(model)} State`,
    state_key: `${GetNodeTitle(model)} State`,
    callback: storeModelArrayContext => {
      storeModelArrayDC = storeModelArrayContext.entry;
    }
  }), ...AddComponentDidMountToViewTypeComponent({ ...args,
    callback: didMountContextArgs => {
      didMountContext = didMountContextArgs;
    }
  }), graph => {
    if (!didMountContext.skip) {
      return ConnectLifecycleMethod({
        target: functionToLoadModels,
        source: didMountContext.lifeCycleInstance.id,
        graph
      });
    }

    return [];
  }, () => {
    const newLocal = {
      operation: uiactions_ADD_LINK_BETWEEN_NODES,

      options() {
        return {
          target: storeModelArrayDC,
          source: didMountContext.lifeCycleInstance.id,
          properties: { ...nodetypes_LinkProperties.DataChainLink
          }
        };
      }

    };
    return [newLocal];
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/RemoveAllViewPackage.js



function RemoveAllViewPackage(args = {
  view
}) {
  const result = [];
  const {
    view
  } = args;

  if (view) {
    const inPackageNodes = GetNodesByProperties({
      [nodetypes_NodeProperties.ViewPackage]: view
    });
    inPackageNodes.forEach(inPackageNode => {
      result.push({
        operation: REMOVE_NODE,

        options() {
          return {
            id: inPackageNode.id
          };
        }

      });
    });
  }

  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/viewtype/GetModelPropertyForViewType.js

function GetModelPropertyForViewType(args = {}) {
  const {
    node
  } = args;
  return GetViewTypeModelType(node);
}
GetModelPropertyForViewType.title = 'Gets the model and property that the shared component will stand in for.';
// CONCATENATED MODULE: ./app/nodepacks/viewtype/AppendViewTypeValidation.js






function AppendViewTypeValidation(args) {
  const {
    node,
    viewPackages,
    method,
    uiType = UITypes.ElectronIO
  } = args;
  const startGraph = GetCurrentGraph();
  const result = [];
  const component = GetNodesLinkedTo(startGraph, {
    id: node,
    link: nodetypes_LinkType.DefaultViewType,
    componentType: NodeTypes.ComponentNode
  }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.UIType) === uiType);
  const {
    model,
    property,
    modelType
  } = GetModelPropertyForViewType({
    node
  });

  if (!component) {
    console.warn('no component');
  }

  const selector = GetNodeByProperties({
    [nodetypes_NodeProperties.NODEType]: NodeTypes.Selector,
    [nodetypes_NodeProperties.Model]: modelType.id
  });

  if (component) {
    const componentType = uiactions_GetNodeProp(component, nodetypes_NodeProperties.ComponentType);
    let externalValidationApi;

    switch (componentType) {
      case ComponentTypeKeys.Button:
        break;

      default:
        result.push(graph => {
          externalValidationApi = GetNodesLinkedTo(graph, {
            id: node.id,
            link: nodetypes_LinkType.ComponentExternalApi
          }).find(v => GetNodeTitle(v) === ComponentApiKeys.Error);

          if (!externalValidationApi) {
            return $addComponentApiNodes(node, ComponentApiKeys.Error, null, viewPackages);
          }

          return [];
        });
        result.push(graph => {
          externalValidationApi = GetNodesLinkedTo(graph, {
            id: node,
            link: nodetypes_LinkType.ComponentExternalApi
          }).find(v => GetNodeTitle(v) === ComponentApiKeys.Error);

          if (externalValidationApi) {
            const modelId = model.id;
            let propertyId = property.id;
            propertyId = propertyId || GetNodeLinkedTo(null, {
              id: node,
              link: nodetypes_LinkType.PropertyLink,
              properties: {
                [LinkPropertyKeys.ComponentProperty]: true
              }
            });

            if (!propertyId) {
              propertyId = GetModelPropertyChildren(modelId).find(v => GetNodeTitle(v) === GetNodeTitle(node));
            }

            if (propertyId && propertyId.id) {
              propertyId = propertyId.id;
            }

            if (!GetNodeById(propertyId)) {
              return;
            }

            let validatorNode = null;
            const methodType = uiactions_GetNodeProp(method, nodetypes_NodeProperties.MethodType);
            return [...CreateValidatorForProperty({
              modelText: GetNodeTitle(modelId),
              propertyText: GetNodeTitle(propertyId),
              model: modelId,
              property: propertyId,
              methodType,
              method,
              viewPackages,
              callback: context => {
                validatorNode = context.entry;
              }
            }), {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                return {
                  target: validatorNode,
                  source: externalValidationApi.id,
                  properties: { ...nodetypes_LinkProperties.DataChainLink
                  }
                };
              }

            }, selector ? {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                return {
                  source: externalValidationApi.id,
                  target: selector.id,
                  properties: { ...nodetypes_LinkProperties.SelectorLink
                  }
                };
              }

            } : null];
          }
        });
        break;
    }
  }

  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/viewtype/SetupViewTypeFor.js










function SetupViewTypeFor(args = {}) {
  const {
    skipClear = false,
    node,
    uiType = UITypes.ElectronIO
  } = args;
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const component = GetNodesLinkedTo(null, {
    id: node,
    componentType: NodeTypes.ComponentNode
  }).find(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.UIType) === uiType);

  if (!component) {
    console.warn('no component found for ' + uiType);
    return [];
  }

  const context = {
    uiType,
    viewPackages,
    ...args
  };
  const result = [];
  const lastViewPackage = uiactions_GetNodeProp(node, nodetypes_NodeProperties.LastViewPackage);

  if (lastViewPackage && !skipClear) {
    result.push(...RemoveAllViewPackage({
      view: lastViewPackage
    }));
  }

  setViewPackageStamp(viewPackages, 'setup-view-type-for');
  const viewType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ViewType);
  let createUpdateContext = null;

  switch (viewType) {
    case nodetypes_Methods.Update:
    case nodetypes_Methods.Create:
      result.push(...SetupViewTypeForCreate({ ...context,
        callback: setviewContext => {
          createUpdateContext = setviewContext;
        }
      }));

      if (viewType === nodetypes_Methods.Update) {
        result.push(ggraph => {
          const {
            eventTypeInstanceNode,
            eventTypeNode
          } = createUpdateContext;
          const link = GetLinkBetween(eventTypeNode, eventTypeInstanceNode, ggraph);

          if (link) {
            return {
              operation: UPDATE_LINK_PROPERTY,
              options: {
                prop: LinkPropertyKeys.InstanceUpdate,
                value: true,
                id: link.id
              }
            };
          }
        });
      }

      break;

    case nodetypes_Methods.Get:
    case nodetypes_Methods.GetAll:
      result.push(...SetupViewTypeForGetAll(context));
      break;

    default:
      break;
  }

  result.push(...AttachGetAllOnComponentDidMount(context));
  result.push({
    operation: UPDATE_NODE_PROPERTY,
    options: {
      id: node,
      properties: {
        [nodetypes_NodeProperties.LastViewPackage]: viewPackages[nodetypes_NodeProperties.ViewPackage]
      }
    }
  });
  const {
    model,
    property
  } = GetViewTypeModelType(node);
  result.push(...AppendViewTypeValidation({
    model,
    property,
    method: args.validationMethod,
    ...args
  }));
  result.push(() => {
    setViewPackageStamp(null, 'setup-view-type-for');
    return [];
  });
  result.push(() => {
    return CollectionDataChainsIntoCollections();
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/batch/SetupViewTypes.js





function SetupViewTypes() {
  const viewTypes = uiactions_NodesByType(null, NodeTypes.ViewType);
  const result = [];
  viewTypes.filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewType) !== nodetypes_Methods.Delete).forEach(node => {
    const validationMethod = GetValidationMethodForViewType(node);
    const functionToLoadModels = GetFunctionToLoadModel(node);
    [UITypes.ElectronIO, UITypes.ReactNative].forEach(uiType => {
      result.push(...SetupViewTypeFor({
        validationMethod: validationMethod ? validationMethod.id : null,
        functionToLoadModels: functionToLoadModels ? functionToLoadModels.id : null,
        node: node.id,
        uiType,
        eventTypeHandler: true,
        eventType: 'onChange',
        skipClear: true
      }));
      result.push(...SetupViewTypeFor({
        node: node.id,
        validationMethod: validationMethod ? validationMethod.id : null,
        functionToLoadModels: functionToLoadModels ? functionToLoadModels.id : null,
        uiType,
        eventTypeHandler: true,
        eventType: 'onChange',
        skipClear: true
      }));
    });
  });
  graphOperation([...result])(GetDispatchFunc(), GetStateFunc());
}
function GetValidationMethodForViewTypes(node) {
  const viewTypeModel = node ? GetViewTypeModel(node.id) : null;
  const methodType = uiactions_GetNodeProp(node, nodetypes_NodeProperties.ViewType);
  return uiactions_NodesByType(null, NodeTypes.Method).filter(x => [methodType].some(meth => meth === (MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {}).method)).filter(x => {
    if (viewTypeModel) {
      const modelOutput = GetMethodNodeProp(x, FunctionTemplateKeys.ModelOutput) || GetMethodNodeProp(x, FunctionTemplateKeys.Model);
      return viewTypeModel && modelOutput === viewTypeModel.id;
    }

    return false;
  });
}
function GetValidationMethodForViewType(node) {
  return GetValidationMethodForViewTypes(node).find(x => x);
}
function GetFunctionToLoadModels(node) {
  const viewTypeModel = node ? GetViewTypeModel(node.id) : null;
  return uiactions_NodesByType(null, NodeTypes.Method).filter(x => {
    const functionType = MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {};
    return functionType.method === nodetypes_Methods.GetAll;
  }).filter(x => {
    const functionType = MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {};
    return !functionType.isFetchCompatible;
  }).filter(x => {
    if (viewTypeModel) {
      const modelOutput = GetMethodNodeProp(x, FunctionTemplateKeys.ModelOutput) || GetMethodNodeProp(x, FunctionTemplateKeys.Model);
      return viewTypeModel && modelOutput === viewTypeModel.id;
    }

    return false;
  });
}
function GetFunctionToLoadModel(node) {
  return GetFunctionToLoadModels(node).find(x => x);
}
// CONCATENATED MODULE: ./app/nodepacks/batch/buildAll.js



















function BuildAll() {
  const result = [];
  setFlag(true, 'hide_new_nodes', Flags.HIDE_NEW_NODES);

  try {
    result.push(...CreateViewTypes());
    graphOperation(result)(GetDispatchFunc(), GetStateFunc());
    AddAgentMethods();
    CreateComponentAll();
    graphOperation(SelectAllOnModelFilters())(GetDispatchFunc(), GetStateFunc());
    graphOperation(AddFiltersToGetAll())(GetDispatchFunc(), GetStateFunc());
    graphOperation(HaveAllPropertiesOnExecutors())(GetDispatchFunc(), GetStateFunc());
    graphOperation(AddCopyCommandToExecutors())(GetDispatchFunc(), GetStateFunc());
    graphOperation(CreateDashboard_1({
      name: AuthorizedDashboard
    }))(GetDispatchFunc(), GetStateFunc());
    executeGraphOperation(null, CreateLoginModels, {
      [UITypes.ElectronIO]: true,
      [UITypes.ReactNative]: true
    })(GetDispatchFunc(), GetStateFunc());
    graphOperation(AddChainToNavigateNextScreens())(GetDispatchFunc(), GetStateFunc());
    graphOperation(CreateConfiguration())(GetDispatchFunc(), GetStateFunc());
    graphOperation(CreateFetchServiceIdempotently())(GetDispatchFunc(), GetStateFunc());
    graphOperation(CreateFetchServiceIdempotently())(GetDispatchFunc(), GetStateFunc());
    CreateClaimService();
    ConnectScreens();
    SetupViewTypes();
  } catch (e) {
    console.log(e);
  }

  setFlag(false, 'hide_new_nodes', Flags.HIDE_NEW_NODES);
  return [];
}
BuildAll.title = 'Build All';
// CONCATENATED MODULE: ./app/components/quickmethods.js

var quickmethods_REACT_ELEMENT_TYPE;

function quickmethods_jsx(type, props, key, children) { if (!quickmethods_REACT_ELEMENT_TYPE) { quickmethods_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: quickmethods_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


























var quickmethods_ref =
/*#__PURE__*/
quickmethods_jsx(batchmenu, {});

var quickmethods_ref2 =
/*#__PURE__*/
quickmethods_jsx(agentbasedmethods, {});

var _ref3 =
/*#__PURE__*/
quickmethods_jsx("h4", {}, void 0, "Methods");

var _ref4 =
/*#__PURE__*/
quickmethods_jsx("br", {});

class quickmethods_QuickMethods extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      selectedMethods: {}
    };
  }

  render() {
    const {
      state
    } = this.props;
    const sharedcontrolkey = "View Package Shared Control";
    const use_as_default = "Use As Default Shared Component";
    const use_as_plural = "Create Components for 1 to Many Relationships";
    const currentNode = Node(state, Visual(state, SELECTED_NODE));

    function getChosenChildren() {
      const chosenChildren = GetModelPropertyChildren(currentNode.id).filter(child => Visual(state, ChoseModel(child.id))).map(x => x.id);
      return chosenChildren;
    }

    const defaultParameters = () => ({
      viewName: Visual(state, "View Package Title"),
      isSharedComponent: Visual(state, sharedcontrolkey),
      isDefaultComponent: Visual(state, sharedcontrolkey) && Visual(state, use_as_default),
      isPluralComponent: Visual(state, sharedcontrolkey) && Visual(state, use_as_plural),
      uiTypes: {
        [UITypes.ReactNative]: Visual(state, UITypes.ReactNative),
        [UITypes.ElectronIO]: Visual(state, UITypes.ElectronIO),
        [UITypes.VR]: Visual(state, UITypes.VR),
        [UITypes.Web]: Visual(state, UITypes.Web)
      },
      chosenChildren: getChosenChildren()
    });

    return quickmethods_jsx(mainsidebar_Header, {
      relative: true
    }, void 0, quickmethods_jsx(sidebar_SideBar, {
      relative: true,
      style: {
        paddingTop: 0
      }
    }, void 0, quickmethods_jsx(sidebarmenu_SideBarMenu, {}, void 0, quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: titles_QuickMethods,
      open: Visual(state, titles_QuickMethods),
      active: true,
      toggle: () => {
        this.props.toggleVisual(titles_QuickMethods);
      },
      icon: "fa fa-tag"
    }, void 0, quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: titles_UIParameters,
      open: Visual(state, titles_UIParameters),
      active: true,
      toggle: () => {
        this.props.toggleVisual(titles_UIParameters);
      },
      icon: "fa fa-tag"
    }, void 0, quickmethods_ref, quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "Create Model by Agent",
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, {
          type: Visual(state, BATCH_FUNCTION_NAME),
          method: CreateAgentFunction({
            nodePackageType: Visual(state, BATCH_FUNCTION_NAME),
            methodType: MethodFunctions[Visual(state, BATCH_FUNCTION_TYPE)].method,
            model: GetNodeById(Visual(state, BATCH_MODEL)),
            parentId: GetNodeById(Visual(state, BATCH_PARENT)),
            agent: GetNodeById(Visual(state, BATCH_AGENT)),
            httpMethod: HTTP_METHODS.POST,
            functionType: Visual(state, BATCH_FUNCTION_TYPE),
            functionName: Visual(state, BATCH_FUNCTION_NAME)
          }),
          methodType: Visual(state, BATCH_FUNCTION_TYPE)
        });
      }
    })), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: AgentBaseMethods,
      open: Visual(state, AgentBaseMethods),
      active: true,
      toggle: () => {
        this.props.toggleVisual(AgentBaseMethods);
      },
      icon: "fa fa-tag"
    }, void 0, quickmethods_ref2), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "More Commands",
      open: Visual(state, "More Commands"),
      active: true,
      toggle: () => {
        this.props.toggleVisual("More Commands");
      },
      icon: "fa fa-tag"
    }, void 0, quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: GetSpecificModels.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, GetSpecificModels);
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "Get Project Urls Data Chain",
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(GetProjectUrlsDataChain());
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "Test Command",
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(temppack());
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: GetAllModels.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, GetAllModels);
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "Create Dashboard 1",
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(CreateDashboard_1());
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "Create Fetch Service",
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(CreateFetchServiceIdempotently());
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: "Create Configuration",
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(CreateConfiguration());
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: CreateLoginModels.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, CreateLoginModels, {
          [UITypes.ElectronIO]: true,
          [UITypes.ReactNative]: true
        });
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: AddAgentUser.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, AddAgentUser);
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: CreateViewTypes.title,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(CreateViewTypes());
      }
    }), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: BuildAll.title,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.setState();
        this.props.graphOperation(BuildAll());
      }
    })), quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: CreateDefaultView.type,
      open: Visual(state, CreateDefaultView.type),
      active: true,
      toggle: () => {
        this.props.toggleVisual(CreateDefaultView.type);
      },
      icon: "fa fa-tag"
    }, void 0, quickmethods_jsx(textinput_TextInput, {
      label: ViewPackage,
      value: Visual(state, "View Package Title"),
      onChange: value => {
        this.props.setVisual("View Package Title", value);
      }
    }), quickmethods_jsx(checkbox_CheckBox, {
      label: SharedControl,
      value: Visual(state, sharedcontrolkey),
      onChange: value => {
        this.props.setVisual(sharedcontrolkey, value);
      }
    }), quickmethods_jsx(checkbox_CheckBox, {
      label: UITypes.ElectronIO,
      value: Visual(state, UITypes.ElectronIO),
      onChange: value => {
        this.props.setVisual(UITypes.ElectronIO, value);
      }
    }), quickmethods_jsx(checkbox_CheckBox, {
      label: UITypes.ReactNative,
      value: Visual(state, UITypes.ReactNative),
      onChange: value => {
        this.props.setVisual(UITypes.ReactNative, value);
      }
    }), Visual(state, sharedcontrolkey) ? quickmethods_jsx(checkbox_CheckBox, {
      label: UseAsDefault,
      value: Visual(state, use_as_default),
      onChange: value => {
        this.props.setVisual(use_as_default, value);
      }
    }) : null, Visual(state, sharedcontrolkey) ? quickmethods_jsx(checkbox_CheckBox, {
      label: AsPlural,
      value: Visual(state, use_as_plural),
      onChange: value => {
        this.props.setVisual(use_as_plural, value);
      }
    }) : null, quickmethods_jsx(treeviewmenu_TreeViewMenu, {
      title: NodeProperties,
      open: Visual(state, `${NodeProperties} quick method`),
      active: true,
      toggle: () => {
        this.props.toggleVisual(`${NodeProperties} quick method`);
      },
      icon: "fa fa-tag"
    }, void 0, GetModelPropertyChildren(currentNode ? currentNode.id : null).map(child => // Could use something besides a VISUAL for this.
    quickmethods_jsx(checkbox_CheckBox, {
      label: GetNodeTitle(child),
      value: Visual(state, ChoseModel(child.id)),
      onChange: value => {
        this.props.setVisual(ChoseModel(child.id), value);
      }
    }, child.id))), quickmethods_jsx("div", {
      style: {
        paddingRight: 10
      }
    }, void 0, _ref3, quickmethods_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => this.state.selectedMethods[item.value],
      items: Object.keys(viewtypes_ViewTypes).map(x => ({
        id: x,
        value: x,
        title: x
      })),
      onClick: item => {
        this.setState({
          selectedMethods: { ...(this.state.selectedMethods || {}),
            [item.value]: !this.state.selectedMethods[item.value]
          }
        });
      }
    }), _ref4, quickmethods_jsx("button", {
      type: "button",
      className: "btn btn-block btn-success btn-sm",
      onClick: () => {
        const operations = [];
        const viewName = `${Visual(state, "View Package Title") || ""}` || GetNodeTitle(currentNode);
        [viewtypes_ViewTypes.Create, viewtypes_ViewTypes.Update, viewtypes_ViewTypes.Delete, viewtypes_ViewTypes.Get].filter(x => this.state.selectedMethods[x]).map(t => {
          operations.push({
            node: currentNode,
            method: CreateDefaultView,
            options: { ...defaultParameters(),
              viewName: `${viewName} ${t}`,
              viewType: t
            }
          });
        });

        if (this.state.selectedMethods[viewtypes_ViewTypes.GetAll]) {
          operations.push({
            node: currentNode,
            method: CreateDefaultView,
            options: { ...defaultParameters(),
              viewName: `${viewName} ${viewtypes_ViewTypes.GetAll}`,
              viewType: viewtypes_ViewTypes.GetAll,
              isList: true
            }
          });
        }

        if (operations.length) {
          this.props.executeGraphOperations(operations);
        }
      }
    }, void 0, CreateComponents)))))));
  }

}

/* harmony default export */ var quickmethods = (UIConnect(quickmethods_QuickMethods));
// CONCATENATED MODULE: ./app/components/serviceinterfacemenu.js
var serviceinterfacemenu_REACT_ELEMENT_TYPE;

function serviceinterfacemenu_jsx(type, props, key, children) { if (!serviceinterfacemenu_REACT_ELEMENT_TYPE) { serviceinterfacemenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: serviceinterfacemenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




















var serviceinterfacemenu_ref =
/*#__PURE__*/
serviceinterfacemenu_jsx("div", {});

class serviceinterfacemenu_ServiceInterfaceMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ServiceInterface);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (!active) {
      return serviceinterfacemenu_ref;
    }

    return serviceinterfacemenu_jsx(mainsidebar_Header, {
      active: active,
      relative: true
    }, void 0, serviceinterfacemenu_jsx(sidebar_SideBar, {
      style: {
        paddingTop: 0
      }
    }, void 0, serviceinterfacemenu_jsx(sidebarmenu_SideBarMenu, {}, void 0, currentNode ? serviceinterfacemenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      hideArrow: true,
      title: AddServiceInterfaceMenu,
      icon: 'fa fa-plus',
      onClick: () => {
        let groupProperties = {};
        this.props.graphOperation(ADD_NEW_NODE, {
          parent: currentNode.id,
          nodeType: NodeTypes.ServiceInterfaceMethod,
          groupProperties,
          properties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ServiceInterfaceMethod
            }
          }
        });
      }
    }) : null)));
  }

}

/* harmony default export */ var serviceinterfacemenu = (UIConnect(serviceinterfacemenu_ServiceInterfaceMenu));
// CONCATENATED MODULE: ./app/components/treeviewitem.js
var treeviewitem_REACT_ELEMENT_TYPE;

function treeviewitem_jsx(type, props, key, children) { if (!treeviewitem_REACT_ELEMENT_TYPE) { treeviewitem_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: treeviewitem_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class treeviewitem_TreeViewItem extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-circle-o";
  }

  render() {
    return treeviewitem_jsx("li", {}, void 0, treeviewitem_jsx("a", {
      onClick: () => {
        if (this.props.onClick) this.props.onClick();
      }
    }, void 0, treeviewitem_jsx("i", {
      className: this.icon()
    }), this.props.title, this.props.right ? treeviewitem_jsx("span", {
      class: "pull-right-container"
    }, void 0, this.props.right) : null), this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/sidemenucontainer.js
var sidemenucontainer_REACT_ELEMENT_TYPE;

function sidemenucontainer_jsx(type, props, key, children) { if (!sidemenucontainer_REACT_ELEMENT_TYPE) { sidemenucontainer_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidemenucontainer_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















const NAVIGATION_PARAMETERS = 'NAVIGATION_PARAMETERS';
const sidemenucontainer_SELECTED_TAB = 'SELECTED_TAB';

var sidemenucontainer_ref =
/*#__PURE__*/
sidemenucontainer_jsx("div", {});

var sidemenucontainer_ref2 =
/*#__PURE__*/
sidemenucontainer_jsx("br", {});

class sidemenucontainer_SideMenuContainer extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;

    if (this.props.tab && !VisualEq(state, sidemenucontainer_SELECTED_TAB, this.props.tab)) {
      return sidemenucontainer_ref;
    }

    return sidemenucontainer_jsx("div", {
      style: {
        position: 'relative'
      }
    }, void 0, sidemenucontainer_jsx(mainsidebar_Header, {
      notactive: !this.props.active,
      relative: true
    }, void 0, sidemenucontainer_jsx(sidebar_SideBar, {
      relative: true,
      style: {
        paddingTop: 0
      }
    }, void 0, sidemenucontainer_jsx(sidebarmenu_SideBarMenu, {}, void 0, sidemenucontainer_jsx(treeviewmenu_TreeViewMenu, {
      title: `${this.props.title}`,
      icon: this.props.icon || 'fa fa-object-group',
      open: Visual(state, this.props.visual),
      active: Visual(state, this.props.visual),
      onClick: () => {
        this.props.toggleVisual(this.props.visual);
      }
    }, void 0, sidemenucontainer_ref2, this.props.children)))));
  }

}

/* harmony default export */ var sidemenucontainer = (UIConnect(sidemenucontainer_SideMenuContainer));
// EXTERNAL MODULE: external "electron"
var external_electron_ = __webpack_require__("electron");

// CONCATENATED MODULE: ./app/components/checkboxproperty.js
var checkboxproperty_REACT_ELEMENT_TYPE;

function checkboxproperty_jsx(type, props, key, children) { if (!checkboxproperty_REACT_ELEMENT_TYPE) { checkboxproperty_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: checkboxproperty_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }






class checkboxproperty_CheckBoxProperty extends external_react_["Component"] {
  render() {
    let currentNode = this.props.node;
    return checkboxproperty_jsx(checkbox_CheckBox, {
      label: this.props.title,
      title: this.props.title,
      value: uiactions_GetNodeProp(currentNode, this.props.property),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: this.props.property,
          id: currentNode.id,
          value: value
        });
      }
    });
  }

}

/* harmony default export */ var checkboxproperty = (UIConnect(checkboxproperty_CheckBoxProperty));
// CONCATENATED MODULE: ./app/components/eventhandleractivitymenu.js

var eventhandleractivitymenu_REACT_ELEMENT_TYPE;

function eventhandleractivitymenu_jsx(type, props, key, children) { if (!eventhandleractivitymenu_REACT_ELEMENT_TYPE) { eventhandleractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: eventhandleractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }






















class eventhandleractivitymenu_EventHandlerActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, [uiactions_NodeTypes.EventHandler]);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    return eventhandleractivitymenu_jsx(sidemenucontainer, {
      active: active,
      tab: dashboard_PARAMETER_TAB,
      visual: "event-handler",
      title: titles_EventHandlerActivityMenu
    }, void 0, eventhandleractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? eventhandleractivitymenu_jsx(formcontrol_FormControl, {}, void 0, eventhandleractivitymenu_jsx(selectinput_SelectInput, {
      label: EventType,
      options: Object.keys(ComponentEvents).map(val => {
        return {
          value: ComponentEvents[val],
          title: val
        };
      }),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.EventType,
          id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.EventType)
    }), eventhandleractivitymenu_jsx(checkboxproperty, {
      title: UseValue,
      property: uiactions_NodeProperties.UseValue,
      node: currentNode
    })) : null));
  }

}

/* harmony default export */ var eventhandleractivitymenu = (UIConnect(eventhandleractivitymenu_EventHandlerActivityMenu));
// CONCATENATED MODULE: ./app/components/content.js
var content_REACT_ELEMENT_TYPE;

function content_jsx(type, props, key, children) { if (!content_REACT_ELEMENT_TYPE) { content_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: content_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class content_Content extends external_react_["Component"] {
  render() {
    return content_jsx("div", {
      className: "content-wrapper",
      style: {
        minHeight: '946px'
      }
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/navigationparametermenu.js

var navigationparametermenu_REACT_ELEMENT_TYPE;

function navigationparametermenu_jsx(type, props, key, children) { if (!navigationparametermenu_REACT_ELEMENT_TYPE) { navigationparametermenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: navigationparametermenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















const navigationparametermenu_NAVIGATION_PARAMETERS = 'NAVIGATION_PARAMETERS';

var navigationparametermenu_ref =
/*#__PURE__*/
navigationparametermenu_jsx("br", {});

class navigationparametermenu_NavigationParameterMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentNode;
    let screenOption = currentNode ? GetConnectedNodeByType(state, currentNode.id, NodeTypes.ScreenOption) || GetConnectedNodeByType(state, currentNode.id, NodeTypes.ComponentNode, graph_methods_TARGET) : null;

    let _ui_type = uiactions_GetNodeProp(screenOption, uiactions_NodeProperties.UIType);

    let componentTypes = ComponentTypes[_ui_type] || {};
    let componentType = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType);
    let componentProperties = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentProperties);
    let componentPropertiesList = getComponentPropertyList(componentProperties);
    let components = [];

    if (componentTypes[componentType] && componentTypes[componentType].properties) {
      Object.keys(componentTypes[componentType].properties).map(key => {
        let prop_obj = componentTypes[componentType].properties[key];

        if (prop_obj && prop_obj.ui) {
          if (prop_obj.options) {
            let nodeproperty = uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty);

            if (nodeproperty === NAVIGATION) {
              components.push(navigationparametermenu_jsx(selectinput_SelectInput, {
                label: Navigation,
                options: uiactions_NodesByType(state, NodeTypes.Screen).toNodeSelect(),
                value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Navigation),
                onChange: value => {
                  this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                    prop: nodetypes_NodeProperties.Navigation,
                    id: currentNode.id,
                    value
                  });
                }
              }, `${nodeproperty} - ${_ui_type} - ${componentType} - ${key}`));
              let screenParameters = uiactions_GetNodeProp(GetNodeById(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Navigation)), nodetypes_NodeProperties.ScreenParameters) || [];
              let treeMenu = screenParameters.map(v => {
                let innertree = `${nodeproperty} - ${_ui_type} - ${componentType} - parameter - ${GetParameterName(v)}`;
                let navparameters = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NavigationParameters) || {};
                let parameterProperty = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NavigationParametersProperty) || {};
                return navigationparametermenu_jsx(treeviewmenu_TreeViewMenu, {
                  title: `${GetParameterName(v)}`,
                  icon: 'fa fa-object-group',
                  open: Visual(state, innertree),
                  active: Visual(state, innertree),
                  onClick: () => {
                    this.props.toggleVisual(innertree);
                  }
                }, void 0, navigationparametermenu_jsx(formcontrol_FormControl, {}, void 0, navigationparametermenu_jsx(selectinput_SelectInput, {
                  label: GetParameterName(v),
                  options: componentPropertiesList,
                  value: navparameters[v.id],
                  onChange: value => {
                    let parameters = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NavigationParameters) || {};
                    parameters[v.id] = value;
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: nodetypes_NodeProperties.NavigationParameters,
                      id: currentNode.id,
                      value: parameters
                    });
                  }
                }, `${innertree}`), componentProperties && navparameters && v && v.id && navparameters[v.id] ? navigationparametermenu_jsx(selectinput_SelectInput, {
                  options: GetNodesLinkedTo(GetRootGraph(state), {
                    id: componentProperties.properties[navparameters[v.id]],
                    direction: SOURCE
                  }).toNodeSelect(),
                  onChange: val => {
                    parameterProperty[navparameters[v.id]] = val;
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: uiactions_NodeProperties.NavigationParametersProperty,
                      id: currentNode.id,
                      value: parameterProperty
                    });
                  },
                  label: Property,
                  value: parameterProperty[navparameters[v.id]]
                }) : null));
              });
              components.push(treeMenu);
            }
          }
        }
      });
    }

    return navigationparametermenu_jsx("div", {
      style: {
        position: 'relative'
      }
    }, void 0, navigationparametermenu_jsx(mainsidebar_Header, {
      notactive: !active,
      relative: true
    }, void 0, navigationparametermenu_jsx(sidebar_SideBar, {
      relative: true,
      style: {
        paddingTop: 0
      }
    }, void 0, navigationparametermenu_jsx(sidebarmenu_SideBarMenu, {}, void 0, navigationparametermenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Navigation}`,
      icon: 'fa fa-object-group',
      open: Visual(state, navigationparametermenu_NAVIGATION_PARAMETERS),
      active: Visual(state, navigationparametermenu_NAVIGATION_PARAMETERS),
      onClick: () => {
        this.props.toggleVisual(navigationparametermenu_NAVIGATION_PARAMETERS);
      }
    }, void 0, navigationparametermenu_ref, components)))));
  }

}

/* harmony default export */ var navigationparametermenu = (UIConnect(navigationparametermenu_NavigationParameterMenu));
// CONCATENATED MODULE: ./app/components/screenactivitymenu.js
var screenactivitymenu_REACT_ELEMENT_TYPE;

function screenactivitymenu_jsx(type, props, key, children) { if (!screenactivitymenu_REACT_ELEMENT_TYPE) { screenactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: screenactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















class screenactivitymenu_ScreenActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Screen);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (currentNode) {
      var show_dependent = currentNode && currentNode.properties && currentNode.properties[uiactions_NodeProperties.UseUIDependsOn];
      ;
      var use_model_as_type = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UseModelAsType);
      var many_to_many_enabled = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexus);
      var property_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Property).filter(x => {
        return x.id !== currentNode.id;
      }).map(node => {
        return {
          value: node.id,
          title: GetNodeTitle(node)
        };
      });
    }

    return screenactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, screenactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ScreenOptions
    }), screenactivitymenu_jsx(selectinput_SelectInput, {
      label: Priority,
      options: [].interpolate(0, 10, x => x).map(t => ({
        title: t,
        value: t
      })),
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Priority),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Priority,
          id: currentNode.id,
          value
        });
      }
    }), screenactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, screenactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_SCREEN_OPTIONS, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ScreenOptionsLink
            }
          }
        });
      },
      icon: 'fa fa-puzzle-piece',
      title: AddScreenOptions,
      description: AddScreenOptions
    })));
  }

}

/* harmony default export */ var screenactivitymenu = (UIConnect(screenactivitymenu_ScreenActivityMenu));
// CONCATENATED MODULE: ./app/components/datasourceactivitymenu.js
var datasourceactivitymenu_REACT_ELEMENT_TYPE;

function datasourceactivitymenu_jsx(type, props, key, children) { if (!datasourceactivitymenu_REACT_ELEMENT_TYPE) { datasourceactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: datasourceactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















class datasourceactivitymenu_DataSourceActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.DataSource);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    return datasourceactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, datasourceactivitymenu_jsx(formcontrol_FormControl, {}, void 0, datasourceactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIModelType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIModelType,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ModelTypeLink
          }
        });
      },
      label: Models,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIModelType),
      options: GetModelNodes().toNodeSelect()
    }), datasourceactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.DataChain],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.DataChain,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.DataChainLink
          }
        });
      },
      label: DataChain,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChain),
      options: uiactions_GetDataChainEntryNodes().toNodeSelect()
    })), datasourceactivitymenu_jsx("button", {
      type: "submit",
      className: "btn btn-primary",
      onClick: () => {
        this.props.graphOperation(NEW_CONDITION_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ConditionLink
            }
          }
        });
      }
    }, void 0, AddCondition));
  }

}

/* harmony default export */ var datasourceactivitymenu = (UIConnect(datasourceactivitymenu_DataSourceActivityMenu));
// CONCATENATED MODULE: ./app/components/sidebartabs.js
var sidebartabs_REACT_ELEMENT_TYPE;

function sidebartabs_jsx(type, props, key, children) { if (!sidebartabs_REACT_ELEMENT_TYPE) { sidebartabs_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebartabs_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class sidebartabs_SideBarTabs extends external_react_["Component"] {
  render() {
    return sidebartabs_jsx("ul", {
      className: "nav nav-tabs nav-justified control-sidebar-tabs"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/sidebartab.js
var sidebartab_REACT_ELEMENT_TYPE;

function sidebartab_jsx(type, props, key, children) { if (!sidebartab_REACT_ELEMENT_TYPE) { sidebartab_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebartab_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class sidebartab_SideBarTab extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-wrench";
  }

  active() {
    return this.props.active ? 'active' : "";
  }

  ariaExapanded() {
    return this.props.active ? 'true' : 'false';
  }

  render() {
    return sidebartab_jsx("li", {
      className: this.active()
    }, void 0, sidebartab_jsx("a", {
      "data-toggle": "tab",
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      },
      "aria-expanded": this.ariaExapanded()
    }, void 0, sidebartab_jsx("i", {
      className: this.icon()
    })));
  }

}
// CONCATENATED MODULE: ./app/components/screenoptionsactivitymenu.js

var screenoptionsactivitymenu_REACT_ELEMENT_TYPE;

function screenoptionsactivitymenu_jsx(type, props, key, children) { if (!screenoptionsactivitymenu_REACT_ELEMENT_TYPE) { screenoptionsactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: screenoptionsactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }
















class screenoptionsactivitymenu_ScreenOptionsActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ScreenOption);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (currentNode) {}

    let componentTypes = ComponentTypes[uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType)] || {};
    let componentType = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType);
    return screenoptionsactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, screenoptionsactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ScreenOptions
    }), screenoptionsactivitymenu_jsx(selectinput_SelectInput, {
      label: UIType,
      options: Object.keys(UITypes).map(t => ({
        title: t,
        value: t
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIType,
          id: currentNode.id,
          value: value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType)
    }), screenoptionsactivitymenu_jsx(checkbox_CheckBox, {
      label: EnableMenu,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.EnabledMenu),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.EnabledMenu,
          id: currentNode.id,
          value
        });
      }
    }), screenoptionsactivitymenu_jsx(selectinput_SelectInput, {
      label: AddComponentDidMount,
      options: uiactions_NodesByType(state, uiactions_NodeTypes.Method).toNodeSelect(),
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentDidMountEvent),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIChoiceType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ComponentDidMountEvent,
          id: currentNode.id,
          value: [value, ...(uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentDidMountEvent) || [])].unique()
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: {}
        });
      }
    }), screenoptionsactivitymenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentDidMountEvent) || [];
        return item && types.some(x => x === item.id);
      },
      items: (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentDidMountEvent) || []).map(t => {
        return GetNode(GetCurrentGraph(state), t);
      }).toNodeSelect(),
      onClick: item => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentDidMountEvent) || [];
        var ids = types;

        if (types.some(t => item.id === t)) {
          ids = [...ids.filter(t => t !== item.id)].unique(x => x);
        } else {
          ids = [...ids, item.id].unique(x => x);
        }

        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.ComponentDidMountEvent,
            id: currentNode.id,
            value: ids
          }
        }, {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: item.id,
            source: id
          }
        }]);
      }
    }), screenoptionsactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, screenoptionsactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout()
        });
        this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
      },
      icon: 'fa fa-puzzle-piece',
      title: SetupLayout,
      description: SetupLayout
    }), screenoptionsactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_COMPONENT_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          properties: {
            [uiactions_NodeProperties.UIType]: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType)
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ComponentLink
            }
          }
        });
        this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
      },
      icon: 'fa fa-puzzle-piece',
      title: AddComponentNew,
      description: AddComponentNew
    })));
  }

}

/* harmony default export */ var screenoptionsactivitymenu = (UIConnect(screenoptionsactivitymenu_ScreenOptionsActivityMenu));
// CONCATENATED MODULE: ./app/components/serviceactivitymenu.js

var serviceactivitymenu_REACT_ELEMENT_TYPE;

function serviceactivitymenu_jsx(type, props, key, children) { if (!serviceactivitymenu_REACT_ELEMENT_TYPE) { serviceactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: serviceactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















class serviceactivitymenu_ServiceActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Services);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let serviceType = currentNode ? uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ServiceType) : '';
    let propinputs = [];

    if (serviceType) {
      let serviceTypeSetup = ServiceTypeSetups[serviceType];

      if (serviceTypeSetup && serviceTypeSetup.properties) {
        Object.keys(serviceTypeSetup.properties).map(prop => {
          var prop_setup = serviceTypeSetup.properties[prop];
          var value = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ServiceTypeSettings) || {};

          if (prop_setup && prop_setup.type) {
            switch (prop_setup.type) {
              case 'string':
                propinputs.push(serviceactivitymenu_jsx(textinput_TextInput, {
                  onChange: val => {
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: uiactions_NodeProperties.ServiceTypeSettings,
                      id: currentNode.id,
                      value: { ...value,
                        [prop]: val
                      }
                    });
                  },
                  label: prop.unCamelCase(),
                  value: value[prop] || ''
                }, `service-type${prop}`));
                break;

              case 'boolean':
                propinputs.push(serviceactivitymenu_jsx(checkbox_CheckBox, {
                  onChange: val => {
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: uiactions_NodeProperties.ServiceTypeSettings,
                      id: currentNode.id,
                      value: { ...value,
                        [prop]: val
                      }
                    });
                  },
                  label: prop.unCamelCase(),
                  value: value[prop] || ''
                }, `service-type${prop}`));
                break;
            }
          }
        });
      }
    }

    return serviceactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, serviceactivitymenu_jsx(formcontrol_FormControl, {}, void 0, serviceactivitymenu_jsx(selectinput_SelectInput, {
      label: ServiceActivity,
      options: Object.keys(ServiceTypes).map(t => {
        return {
          title: t,
          value: ServiceTypes[t]
        };
      }),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ServiceType,
          id: currentNode.id,
          value
        });
      },
      value: serviceType
    }), propinputs));
  }

}

/* harmony default export */ var serviceactivitymenu = (UIConnect(serviceactivitymenu_ServiceActivityMenu));
// CONCATENATED MODULE: ./app/components/sidebarcontent.js
var sidebarcontent_REACT_ELEMENT_TYPE;

function sidebarcontent_jsx(type, props, key, children) { if (!sidebarcontent_REACT_ELEMENT_TYPE) { sidebarcontent_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebarcontent_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class sidebarcontent_SideBarContent extends external_react_["Component"] {
  render() {
    return sidebarcontent_jsx("ul", {
      className: "tab-content"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/navbarbutton.js
var navbarbutton_REACT_ELEMENT_TYPE;

function navbarbutton_jsx(type, props, key, children) { if (!navbarbutton_REACT_ELEMENT_TYPE) { navbarbutton_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: navbarbutton_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/prop-types */

class navbarbutton_NavBarButton extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-gears";
  }

  title() {
    return this.props.title || '';
  }

  render() {
    return navbarbutton_jsx("li", {}, void 0, navbarbutton_jsx("a", {
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      },
      title: this.title(),
      style: {
        position: 'relative'
      },
      "data-toggle": "control-sidebar"
    }, void 0, navbarbutton_jsx("i", {
      className: this.icon()
    }), this.props.secondaryicon ? navbarbutton_jsx("i", {
      className: this.props.secondaryicon,
      style: {
        position: 'absolute',
        left: 10,
        top: 10,
        fontSize: '10px',
        zIndex: 10
      }
    }) : null));
  }

}
// CONCATENATED MODULE: ./app/components/box.js
var box_REACT_ELEMENT_TYPE;

function box_jsx(type, props, key, children) { if (!box_REACT_ELEMENT_TYPE) { box_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: box_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



class box_Box extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  label() {
    return this.props.label || "{label}";
  }

  value() {
    return this.props.value || "";
  }

  title() {
    return this.props.title || "{title}";
  }

  primary() {
    return this.props.primary ? "box-primary" : "";
  }

  backgroundColor() {
    return this.props.backgroundColor ? this.props.backgroundColor : "";
  }

  render() {
    const style = {};
    const styleAll = {};
    const maxStyle = {};

    if (this.props.maxheight) {
      style.maxHeight = `${this.props.maxheight}px`;
      style.overflowY = "auto";
    }

    if (this.backgroundColor()) {
      style.background = this.backgroundColor();
      styleAll.background = this.backgroundColor();
    }

    return box_jsx("div", {
      className: `box ${this.primary()}`,
      style: { ...styleAll,
        ...maxStyle
      }
    }, void 0, box_jsx("div", {
      className: "box-header with-border",
      style: { ...styleAll
      },
      onClick: () => {
        this.setState({
          open: !this.state.open
        });
      }
    }, void 0, box_jsx("h3", {
      className: "box-title",
      style: {
        cursor: "pointer",
        ...styleAll
      }
    }, void 0, this.title())), this.props.onSearch && !this.state.open ? box_jsx("div", {
      className: "box-header"
    }, void 0, box_jsx(textinput_TextInput, {
      slim: true,
      placeholder: 'search',
      immediate: true,
      value: this.state.search,
      onChange: val => {
        this.setState({
          search: val
        });
        this.props.onSearch(val);
      }
    })) : null, box_jsx("div", {
      className: "box-body",
      style: { ...styleAll,
        ...style
      }
    }, void 0, this.state.open ? null : this.props.children), box_jsx("div", {
      className: "box-footer",
      style: { ...styleAll
      }
    }, void 0, this.props.footer));
  }

}
// CONCATENATED MODULE: ./app/components/enumerationeditmenu.js
var enumerationeditmenu_REACT_ELEMENT_TYPE;

function enumerationeditmenu_jsx(type, props, key, children) { if (!enumerationeditmenu_REACT_ELEMENT_TYPE) { enumerationeditmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: enumerationeditmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class enumerationeditmenu_EnumerationEditMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      value: ''
    };
  }

  render() {
    var {
      state
    } = this.props;
    return enumerationeditmenu_jsx(formcontrol_FormControl, {
      sidebarform: true
    }, void 0, enumerationeditmenu_jsx(textinput_TextInput, {
      onClick: () => {
        if (this.props.onComplete) {
          this.props.onComplete(this.state.value);
          this.setState({
            value: ''
          });
        }
      },
      value: this.state.value,
      onChange: value => {
        this.setState({
          value
        });
      },
      inputgroup: true,
      placeholder: Enumeration
    }));
  }

}
// CONCATENATED MODULE: ./app/components/executoritem.js

var executoritem_REACT_ELEMENT_TYPE;

function executoritem_jsx(type, props, key, children) { if (!executoritem_REACT_ELEMENT_TYPE) { executoritem_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: executoritem_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















var executoritem_ref =
/*#__PURE__*/
executoritem_jsx("div", {}, void 0, "reference");

var executoritem_ref2 =
/*#__PURE__*/
executoritem_jsx("div", {}, void 0, "item");

var executoritem_ref3 =
/*#__PURE__*/
executoritem_jsx("div", {});

var executoritem_ref4 =
/*#__PURE__*/
executoritem_jsx("div", {});

var _ref5 =
/*#__PURE__*/
executoritem_jsx("div", {}, void 0, "reference");

class executoritem_ExecutorItem extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Executor);
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var validator;
    var validatorItem;
    var function_variables = [];

    if (currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExecutorModel)) {
      validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor);
      validatorItem = validator.properties[this.props.property].validators[this.props.validator];
    } else if (currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ModelItemFilter)) {
      validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel);
      validatorItem = validator.properties[this.props.property].validators[this.props.validator];
      var methods = GetLinkChainFromGraph(graph, {
        id: currentNode.id,
        links: [{
          direction: graph_methods_TARGET,
          type: nodetypes_LinkType.ModelItemFilter
        }]
      }, [NodeTypes.Method]);

      if (methods && methods.length) {
        var props = GetMethodProps(methods[0]);
        let filterParameters = GetMethodFilterParameters(currentNode.id, true);

        if (filterParameters && filterParameters.length) {
          function_variables = filterParameters;
        } else if (props) {
          function_variables = Object.keys(props).map(t => ({
            title: t,
            value: t
          }));
        }
      }
    } else {
      validator = this.props.selectedValidator;

      if (validator) {
        validatorItem = validator.properties[this.props.property].validators[this.props.validator];
      }

      function_variables = this.props.function_variables;
    }

    if (validatorItem) {
      if (validatorItem.arguments && validatorItem.arguments.reference) {
        var {
          types
        } = validatorItem.arguments.reference;

        if (types) {
          let _nodes_types = uiactions_NodesByType(state, types).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ExtensionType ? isUIExtensionEnumerable(x) : true);

          validator = validator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createValidator();
          let item = getValidatorItem(validator, {
            property: this.props.property,
            validator: this.props.validator
          });
          let editlist = [];

          if (item && item.node) {
            let node = GetNode(graph, item.node);

            switch (uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType)) {
              case NodeTypes.Enumeration:
                var enums = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Enumeration) || [];
                editlist = enums.map(_enum => {
                  return executoritem_jsx("div", {
                    className: `external-event ${item.enumeration && item.enumeration[_enum.id || _enum] ? 'bg-red' : 'bg-black'}`,
                    style: {
                      cursor: 'pointer'
                    },
                    onClick: () => {
                      item.enumeration = item.enumeration || {};
                      item.enumeration[_enum.id || _enum] = !item.enumeration[_enum.id || _enum];
                      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                        id: currentNode.id,
                        prop: nodetypes_NodeProperties.Executor,
                        value: validator
                      });
                    }
                  }, void 0, " ", _enum.value);
                });
                break;

              case NodeTypes.ExtensionType:
                var list_enums = GetUIExentionEnumeration(node);
                var list_key_field = GetUIExentionKeyField(node);
                editlist = list_enums.map(_enum => {
                  return executoritem_jsx("div", {
                    className: `external-event ${item.extension && item.extension[_enum[list_key_field]] ? 'bg-red' : 'bg-black'}`,
                    style: {
                      cursor: 'pointer'
                    },
                    onClick: () => {
                      item.extension = item.extension || {};
                      item.extension[_enum[list_key_field]] = !item.extension[_enum[list_key_field]];
                      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                        id: currentNode.id,
                        prop: nodetypes_NodeProperties.Executor,
                        value: validator
                      });
                    }
                  }, void 0, " ", _enum[list_key_field]);
                });
                break;
            }
          }

          let formControll = executoritem_jsx(formcontrol_FormControl, {}, void 0, executoritem_jsx(selectinput_SelectInput, {
            options: _nodes_types.map(t => ({
              title: GetNodeTitle(t),
              value: t.id
            })),
            defaultSelectText: NodeType,
            label: Property,
            onChange: value => {
              var id = currentNode.id;
              validator = validator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createValidator();
              let item = getValidatorItem(validator, {
                property: this.props.property,
                validator: this.props.validator
              });
              let old_one = item.node;
              item.node = value;

              if (this.props.onChange) {
                this.props.onChange();
              } else {
                if (old_one) {
                  this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
                    target: old_one,
                    source: id
                  });
                }

                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  id,
                  prop: nodetypes_NodeProperties.Executor,
                  value: validator
                });
                this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
                  target: value,
                  source: id,
                  properties: { ...uiactions_LinkProperties.ExecutorModelItemLink,
                    ...createEventProp(LinkEvents.Remove, {
                      property: this.props.property,
                      validator: this.props.validator,
                      function: 'OnRemoveExecutorItemPropConnection',
                      node: item.node
                    })
                  }
                });
              }
            },
            value: validatorItem ? validatorItem.node : ''
          }), editlist);

          return formControll;
        }

        return executoritem_ref;
      } else if (validatorItem.arguments && validatorItem.arguments.method_reference) {
        return this.getMethodReferenceItem(validator, validatorItem);
      } else if (validatorItem.arguments && validatorItem.arguments.functionvariables) {
        let functionVariableControl = executoritem_jsx(formcontrol_FormControl, {}, void 0, executoritem_jsx(selectinput_SelectInput, {
          options: function_variables,
          label: FunctionVariables,
          onChange: value => {
            var id = currentNode.id;
            validator = validator || this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
            let item = getValidatorItem(validator, {
              property: this.props.property,
              validator: this.props.validator
            });
            let old_one = item.node;
            item.node = value;

            if (this.props.onChange) {
              this.props.onChange();
            } else {
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.FilterModel,
                value: validator
              });
            }
          },
          value: validatorItem ? validatorItem.node : ''
        }));

        return functionVariableControl;
      } else if (validatorItem.arguments && validatorItem.arguments.modelproperty) {
        let modelParameters = function_variables || GetMethodFilterParameters(currentNode.id, true);
        let node_value = validatorItem ? validatorItem.node : '';
        let nodeProperty = validatorItem ? validatorItem.nodeProperty : '';
        let properties = [];

        if (node_value) {
          let node_ref = GetMethodsProperty(this.props.adjacentNodeId || currentNode.id, node_value);

          if (node_ref) {
            properties = GetModelPropertyChildren(node_ref).toNodeSelect();
          }
        }

        let functionVariableControl = executoritem_jsx(formcontrol_FormControl, {}, void 0, executoritem_jsx(selectinput_SelectInput, {
          options: modelParameters,
          label: FunctionVariables,
          onChange: value => {
            var id = currentNode.id;
            var validator = this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
            let item = getValidatorItem(validator, {
              property: this.props.property,
              validator: this.props.validator
            });
            item.node = value;

            if (this.props.onChange) {
              this.props.onChange();
            } else {
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.FilterModel,
                value: validator
              });
            }
          },
          value: node_value
        }), executoritem_jsx(selectinput_SelectInput, {
          options: properties,
          label: Property,
          onChange: value => {
            var id = currentNode.id;
            var validator = this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
            let item = getValidatorItem(validator, {
              property: this.props.property,
              validator: this.props.validator
            });
            item.nodeProperty = value;

            if (this.props.onChange) {
              this.props.onChange();
            } else {
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.FilterModel,
                value: validator
              });
            }
          },
          value: nodeProperty
        }));

        return functionVariableControl;
      } else if (validatorItem.arguments && validatorItem.arguments.model2modelproperty) {
        let modelParameters = function_variables || GetMethodFilterParameters(currentNode.id, true);
        let node_value = validatorItem ? validatorItem.node : '';
        let many2many = validatorItem ? validatorItem.many2many : '';
        let nodeProperty = validatorItem ? validatorItem.nodeProperty : '';
        let many2manyProperty = validatorItem ? validatorItem.many2manyProperty : '';
        let many2manyMethod = validatorItem ? validatorItem.many2manyMethod : '';
        let properties = [];

        if (node_value) {
          let node_ref = GetMethodsProperty(this.props.adjacentNodeId || currentNode.id, node_value);

          if (node_ref) {
            properties = GetModelPropertyChildren(node_ref).toNodeSelect();
          }
        }

        let manyNodeSelector = null;
        let manyNodePropertySelector = null;
        let manyNodePropertyMethodSelector = null;

        if (modelParameters) {
          let manyNodes = uiactions_GetManyToManyNodes([this.props.property, node_value].filter(x => x)) || [];
          manyNodeSelector = executoritem_jsx(selectinput_SelectInput, {
            options: manyNodes.toNodeSelect(),
            label: ManyToMany,
            onChange: value => {
              var id = currentNode.id;
              validator = validator || this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
              let item = getValidatorItem(validator, {
                property: this.props.property,
                validator: this.props.validator
              });
              item.many2many = value;

              if (this.props.onChange) {
                this.props.onChange();
              } else {
                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  id,
                  prop: nodetypes_NodeProperties.FilterModel,
                  value: validator
                });
              }
            },
            value: many2many
          });

          if (many2many) {
            manyNodePropertySelector = executoritem_jsx(selectinput_SelectInput, {
              options: GetModelPropertyNodes(many2many).toNodeSelect(),
              label: Many2ManyProperties,
              onChange: value => {
                var id = currentNode.id;
                validator = validator || this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
                let item = getValidatorItem(validator, {
                  property: this.props.property,
                  validator: this.props.validator
                });
                item.many2manyProperty = value;

                if (this.props.onChange) {
                  this.props.onChange();
                } else {
                  this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                    id,
                    prop: nodetypes_NodeProperties.FilterModel,
                    value: validator
                  });
                }
              },
              value: many2manyProperty
            });

            if (many2manyProperty) {
              manyNodePropertyMethodSelector = executoritem_jsx(selectinput_SelectInput, {
                options: Object.keys(FilterRules).map(t => {
                  return {
                    title: t,
                    value: FilterRules[t]
                  };
                }),
                label: Many2ManyProperties,
                onChange: value => {
                  var id = currentNode.id;
                  validator = validator || this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
                  let item = getValidatorItem(validator, {
                    property: this.props.property,
                    validator: this.props.validator
                  });
                  item.many2manyMethod = value;

                  if (this.props.onChange) {
                    this.props.onChange();
                  } else {
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      id,
                      prop: nodetypes_NodeProperties.FilterModel,
                      value: validator
                    });
                  }
                },
                value: many2manyMethod
              });
            }
          }
        }

        let functionVariableControl = executoritem_jsx(formcontrol_FormControl, {}, void 0, executoritem_jsx(selectinput_SelectInput, {
          options: modelParameters,
          label: FunctionVariables,
          onChange: value => {
            var id = currentNode.id;
            validator = validator || this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
            let item = getValidatorItem(validator, {
              property: this.props.property,
              validator: this.props.validator
            });
            item.node = value;

            if (this.props.onChange) {
              this.props.onChange();
            } else {
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.FilterModel,
                value: validator
              });
            }
          },
          value: node_value
        }), executoritem_jsx(selectinput_SelectInput, {
          options: properties,
          label: Property,
          onChange: value => {
            var id = currentNode.id;
            validator = validator || this.props.selectedValidator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createValidator();
            let item = getValidatorItem(validator, {
              property: this.props.property,
              validator: this.props.validator
            });
            item.nodeProperty = value;

            if (this.props.onChange) {
              this.props.onChange();
            } else {
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.FilterModel,
                value: validator
              });
            }
          },
          value: nodeProperty
        }), manyNodeSelector, manyNodePropertySelector, manyNodePropertyMethodSelector);

        return functionVariableControl;
      } else if (validatorItem.arguments && validatorItem.arguments.condition) {
        return this.getValidatorArgumentCondition(validator, validatorItem);
      }

      return executoritem_ref2;
    }

    return executoritem_ref3;
  }

  getValidatorArgumentCondition(validator, validatorItem) {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (validatorItem.arguments.condition) {
      let formControll = executoritem_jsx(formcontrol_FormControl, {}, void 0, executoritem_jsx(textinput_TextInput, {
        value: validatorItem && validatorItem.condition ? validatorItem.condition : '',
        label: Condition,
        onChange: value => {
          if (validatorItem.arguments.condition.type === NodePropertyTypes.INT && isNaN(value)) {
            return;
          }

          var id = currentNode.id;
          validator = validator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createValidator();
          let item = getValidatorItem(validator, {
            property: this.props.property,
            validator: this.props.validator
          });
          item.condition = value;

          if (this.props.onChange) {
            this.props.onChange();
          } else {
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              id,
              prop: nodetypes_NodeProperties.Executor,
              value: validator
            });
          }
        }
      }));

      return formControll;
    }

    return executoritem_ref4;
  }

  getMethodReferenceItem(validator, validatorItem) {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let methodNode = GetMethodNode(state, currentNode.id, nodetypes_LinkType.ExecutorFunction);
    let methodNodeProperties = GetMethodProps(methodNode);

    if (validatorItem.arguments && validatorItem.arguments.method_reference) {
      return Object.keys(validatorItem.arguments.method_reference).map(ref => {
        validator = validator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createValidator();
        let editlist = [];
        let options = GetMethodNodeSelectOptions(methodNodeProperties);

        let formControll = executoritem_jsx(formcontrol_FormControl, {}, ref, executoritem_jsx(selectinput_SelectInput, {
          options: options,
          defaultSelectText: NodeType,
          label: Property,
          onChange: value => {
            var id = currentNode.id;
            validator = validator || uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createValidator();
            let item = getValidatorItem(validator, {
              property: this.props.property,
              validator: this.props.validator
            });
            item.references = item.references || {};
            item.references[ref] = value;

            if (this.props.onChange) {
              this.props.onChange();
            } else {
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.Executor,
                value: validator
              });
            }
          },
          value: validatorItem && validatorItem.references ? validatorItem.references[ref] : ''
        }), editlist);

        return formControll;
      });
    }

    return _ref5;
  }

}

/* harmony default export */ var executoritem = (UIConnect(executoritem_ExecutorItem));
// CONCATENATED MODULE: ./app/components/treeviewbuttongroup.js
var treeviewbuttongroup_REACT_ELEMENT_TYPE;

function treeviewbuttongroup_jsx(type, props, key, children) { if (!treeviewbuttongroup_REACT_ELEMENT_TYPE) { treeviewbuttongroup_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: treeviewbuttongroup_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class treeviewbuttongroup_TreeViewButtonGroup extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-circle-o";
  }

  render() {
    return treeviewbuttongroup_jsx("li", {}, void 0, treeviewbuttongroup_jsx("a", {
      onClick: () => {
        if (this.props.onClick) this.props.onClick();
      }
    }, void 0, treeviewbuttongroup_jsx("div", {
      className: "btn-group"
    }, void 0, this.props.children)));
  }

}
// CONCATENATED MODULE: ./app/components/treeviewgroupbutton.js
var treeviewgroupbutton_REACT_ELEMENT_TYPE;

function treeviewgroupbutton_jsx(type, props, key, children) { if (!treeviewgroupbutton_REACT_ELEMENT_TYPE) { treeviewgroupbutton_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: treeviewgroupbutton_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class treeviewgroupbutton_TreeViewGroupButton extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-circle-o";
  }

  render() {
    return treeviewgroupbutton_jsx("button", {
      title: this.props.title,
      type: "button",
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      },
      className: "btn btn-default btn-flat",
      style: {
        backgroundColor: 'transparent',
        borderColor: 'transparent'
      }
    }, void 0, treeviewgroupbutton_jsx("i", {
      className: this.props.icon,
      style: {
        color: '#8aa4af'
      }
    }));
  }

}
// CONCATENATED MODULE: ./app/components/genericpropertymenu.js

var genericpropertymenu_REACT_ELEMENT_TYPE;

function genericpropertymenu_jsx(type, props, key, children) { if (!genericpropertymenu_REACT_ELEMENT_TYPE) { genericpropertymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: genericpropertymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

















var genericpropertymenu_ref =
/*#__PURE__*/
genericpropertymenu_jsx("div", {});

var genericpropertymenu_ref2 =
/*#__PURE__*/
genericpropertymenu_jsx("div", {});

var genericpropertymenu_ref3 =
/*#__PURE__*/
genericpropertymenu_jsx(sidebarheader_SideBarHeader, {
  title: 'Property Setups'
});

class genericpropertymenu_GenericPropertyMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, this.props.nodeType);

    if (!active) {
      return genericpropertymenu_ref;
    }

    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var genericProperty = this.props.executor || this.props.validator || this.props.methodParamSetup;
    let _ui = this.props.ui;
    let propertyExecutors = genericpropertymenu_ref2;

    if (_ui && genericProperty && genericProperty.properties) {
      propertyExecutors = Object.keys(genericProperty.properties).map(key => {
        let _validates = genericProperty.properties[key];
        let visualKey = `GenericPropertyMenu${key}-${currentNode.id}`;
        let temp = Object.keys(_validates && _validates.validators ? _validates.validators : {});
        let selectedValidationsCount = temp.length;
        let selectedValidations = temp.map(v => {
          let selK = `${visualKey}-selected-validation`;
          let selKInner = `${selK}-inne-${v}-r`;
          return genericpropertymenu_jsx(treeviewmenu_TreeViewMenu, {
            title: _validates.validators && _validates.validators[v] && _validates.validators[v].type ? _validates.validators[v].type : v,
            open: Visual(state, selKInner),
            active: Visual(state, selKInner),
            toggle: () => {
              this.props.toggleVisual(selKInner);
            },
            icon: 'fa fa-tag'
          }, `${v}-v-v`, genericpropertymenu_jsx(treeviewbuttongroup_TreeViewButtonGroup, {}, void 0, genericpropertymenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
            title: RemoveExecution,
            onClick: () => {
              let id = currentNode.id;
              let validator = genericProperty;
              let _validates = validator.properties[key];
              delete _validates.validators[v];

              if (this.props.onRemove) {
                this.props.onRemove();
              }
            },
            icon: 'fa fa-minus'
          }), genericpropertymenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
            title: CopyExecution,
            onClick: () => {
              if (this.props.onCopy) {
                this.props.onCopy(key, v);
              }
            },
            icon: 'fa fa-copy'
          }), this.props.pastePart ? genericpropertymenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
            title: Paste,
            icon: 'fa fa-paste',
            onClick: () => {
              if (this.props.onPaste) {
                this.props.onPaste(key, v);
              }
            }
          }) : null), genericpropertymenu_jsx(executoritem, {
            adjacentNodeId: this.props.adjacentNodeId,
            onChange: this.props.onChange,
            function_variables: this.props.function_variables,
            selectedValidator: genericProperty,
            node: currentNode.id,
            property: key,
            validator: v
          }));
        });
        let validationUis = Object.keys(_ui).filter(x => !_validates || !_validates.validators || !_validates.validators[x]).reverse().map(ui => {
          return genericpropertymenu_jsx(treeviewmenu_TreeViewMenu, {
            hideArrow: true,
            title: ui,
            icon: 'fa fa-plus-square-o',
            onClick: () => {
              let id = currentNode.id;
              var executor = genericProperty;
              executor = addValidatator(executor, {
                id: key,
                validator: uuidv4(),
                validatorArgs: {
                  type: ui,
                  ..._ui[ui]
                }
              });

              if (this.props.onAdd) {
                this.props.onAdd();
              }
            }
          }, `${ui}-afjlskf-asfd`);
        });
        return genericpropertymenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, visualKey),
          active: Visual(state, visualKey),
          title: GetNodeTitle(GetNode(graph, key)),
          toggle: () => {
            this.props.toggleVisual(visualKey);
          }
        }, visualKey, genericpropertymenu_jsx(treeviewbuttongroup_TreeViewButtonGroup, {}, void 0, genericpropertymenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
          title: RemoveExecution,
          onClick: () => {
            let id = currentNode.id;

            if (this.props.onRemove) {
              this.props.onRemove(key);
            } else {
              this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
                target: key,
                source: id
              });
            }
          },
          icon: 'fa fa-minus'
        }), genericpropertymenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
          title: CopyExecution,
          onClick: () => {
            if (this.props.onCopy) {
              this.props.onCopy(key);
            }
          },
          icon: 'fa fa-copy'
        }), this.props.pasteAll ? genericpropertymenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
          title: Paste,
          icon: 'fa fa-paste',
          onClick: () => {
            if (this.props.onPaste) {
              this.props.onPaste(key);
            }
          }
        }) : null), genericpropertymenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${SelectedExecutors}(${selectedValidationsCount}) `,
          icon: 'fa  fa-list-ul',
          open: Visual(state, `${visualKey}-selected-executions`),
          active: Visual(state, `${visualKey}-selected-executions`),
          toggle: () => {
            this.props.toggleVisual(`${visualKey}-selected-executions`);
          }
        }, void 0, selectedValidations), genericpropertymenu_jsx(treeviewmenu_TreeViewMenu, {
          title: SelectExecution,
          icon: 'fa fa-plus-circle',
          innerStyle: {
            maxHeight: 200,
            overflowY: 'auto'
          },
          open: Visual(state, `${visualKey}-selectexecution`),
          active: Visual(state, `${visualKey}-selectexecution`),
          toggle: () => {
            this.props.toggleVisual(`${visualKey}-selectexecution`);
          }
        }, void 0, validationUis));
      });
      propertyExecutors = genericpropertymenu_jsx("div", {
        style: {
          position: 'relative'
        }
      }, void 0, genericpropertymenu_jsx(mainsidebar_Header, {
        relative: true
      }, void 0, genericpropertymenu_jsx(sidebar_SideBar, {
        relative: true
      }, void 0, genericpropertymenu_jsx(sidebarmenu_SideBarMenu, {
        relative: true
      }, void 0, genericpropertymenu_ref3, propertyExecutors))));
    }

    return propertyExecutors;
  }

}

/* harmony default export */ var genericpropertymenu = (UIConnect(genericpropertymenu_GenericPropertyMenu));
// CONCATENATED MODULE: ./app/components/genericpropertycontainer.js
var genericpropertycontainer_REACT_ELEMENT_TYPE;

function genericpropertycontainer_jsx(type, props, key, children) { if (!genericpropertycontainer_REACT_ELEMENT_TYPE) { genericpropertycontainer_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: genericpropertycontainer_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }
















var genericpropertycontainer_ref =
/*#__PURE__*/
genericpropertycontainer_jsx("div", {});

class genericpropertycontainer_GenericPropertyContainer extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = this.props.active || IsCurrentNodeA(state, this.props.nodeType);

    if (!active) {
      return genericpropertycontainer_ref;
    }

    return genericpropertycontainer_jsx(mainsidebar_Header, {
      relative: true
    }, void 0, genericpropertycontainer_jsx(sidebar_SideBar, {
      relative: true
    }, void 0, this.props.top ? this.props.top : null, genericpropertycontainer_jsx(sidebarmenu_SideBarMenu, {}, void 0, this.props.children)));
  }

}

/* harmony default export */ var genericpropertycontainer = (UIConnect(genericpropertycontainer_GenericPropertyContainer));
// CONCATENATED MODULE: ./app/constants/condition.js
const PERMISSION = 'permission';
const FILTER = 'filter';
const VALIDATION = 'validation';
// CONCATENATED MODULE: ./app/components/conditionfiltermenu.js

var conditionfiltermenu_REACT_ELEMENT_TYPE;

function conditionfiltermenu_jsx(type, props, key, children) { if (!conditionfiltermenu_REACT_ELEMENT_TYPE) { conditionfiltermenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: conditionfiltermenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

























const CONDITION_FILTER_MENU_PARAMETER = "condition-filter-menu-parameter";
const CONDITION_FILTER_MENU_PARAMETER_PROPERTIES = "condition-filter-menu-parameter-properties";
const DATA_SOURCE = "DATA_SOURCE";

var conditionfiltermenu_ref =
/*#__PURE__*/
conditionfiltermenu_jsx("div", {});

var conditionfiltermenu_ref2 =
/*#__PURE__*/
conditionfiltermenu_jsx("div", {});

var conditionfiltermenu_ref3 =
/*#__PURE__*/
conditionfiltermenu_jsx(sidebarheader_SideBarHeader, {
  title: "Parameters"
});

var conditionfiltermenu_ref4 =
/*#__PURE__*/
conditionfiltermenu_jsx(sidebarheader_SideBarHeader, {
  title: "Parameter Properties"
});

class conditionfiltermenu_ConditionFilterMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let methodProps;
    let methodDefinition;
    let methodDefinitionKey = this.props.methodDefinitionKey;
    let interestingNode;

    if (currentNode) {
      switch (methodDefinitionKey) {
        case PERMISSION:
          interestingNode = uiactions_GetPermissionNode(currentNode.id);
          break;

        case FILTER:
          interestingNode = uiactions_GetModelItemFilter(currentNode.id);
          break;

        case VALIDATION:
          interestingNode = uiactions_GetValidationNode(currentNode.id);
          break;
      }

      if (interestingNode) {
        methodDefinition = interestingNode ? GetMethodDefinition(interestingNode.id) : null;
        methodProps = GetMethodsProperties(interestingNode.id);
      }
    }

    if (methodDefinition && methodDefinition[methodDefinitionKey] && methodDefinition[methodDefinitionKey].params && methodDefinition[methodDefinitionKey].params.length) {} else if (this.props.view && currentNode) {
      interestingNode = uiactions_GetDataSourceNode(currentNode.id);

      if (!interestingNode) {
        return conditionfiltermenu_ref;
      }

      methodProps = {
        [DATA_SOURCE]: uiactions_GetNodeProp(interestingNode, nodetypes_NodeProperties.UIModelType)
      };
    } else {
      return conditionfiltermenu_ref2;
    }

    let filterParameters = GetMethodPermissionParameters(interestingNode.id, true);

    if (currentNode) {
      switch (methodDefinitionKey) {
        case PERMISSION:
          break;

        case FILTER:
          filterParameters = GetMethodFilterParameters(interestingNode.id, true);
          break;

        case VALIDATION:
          filterParameters = GetMethodValidationParameters(interestingNode.id, true);
          break;
      }
    }

    let id = currentNode.id;
    let models = [];

    if (methodDefinition) {
      let mdparams = methodDefinition[methodDefinitionKey].params;
      models = mdparams.map(t => {
        if (typeof t === "object") {
          return t.key;
        }

        return t;
      }).map((t, t_index) => {
        if (mdparams[t_index] && mdparams[t_index].changeparameter) {
          let mdprops = {};
          mdparams.filter(x => typeof x === "string").map(x => {
            mdprops[x] = GetNodeTitle(methodProps[x]);
          });
          return {
            title: bindTemplate(mdparams[t_index].template, mdprops),
            value: t,
            id: t
          };
        }

        return {
          title: `${GetNodeTitle(methodProps[t])} (${t})`,
          value: t,
          id: t
        };
      });
    } else if (this.props.view) {
      models = GetModelNodes().toNodeSelect();
    }

    let methodFunctionType = this.props.view ? DATA_SOURCE : GetMethodFunctionType(interestingNode.id);
    let methodFunctionValidation = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Condition); // UIA.GetMethodFunctionValidation(permissionNode.id);

    let param_list_key = `${currentNode.id} ${methodFunctionType}`;
    let param = Visual(state, param_list_key);
    let param_property_list_key = Visual(state, param_list_key) ? `${param_list_key} ${param}` : null;
    let selectedParameter = Visual(state, param_list_key);
    let model_properties = [];

    if (FunctionTemplateKeys.ChangeParameter === param) {
      let cp_params = methodDefinition[methodDefinitionKey].params;
      let cp = cp_params.find(x => x && x.key === FunctionTemplateKeys.ChangeParameter);

      if (cp) {
        model_properties = GetModelPropertyChildren(this.props.view ? param : methodProps[cp_params[0]]).toNodeSelect();
      }
    } else {
      model_properties = GetModelPropertyChildren(this.props.view ? param : methodProps[param]).toNodeSelect();
    }

    let top = this.getTop({
      model_properties,
      methodProps,
      selectedParameter,
      filterMenuParameter: `${currentNode.id}${CONDITION_FILTER_MENU_PARAMETER}`,
      filterMenuParameterProperties: `${currentNode.id} ${CONDITION_FILTER_MENU_PARAMETER_PROPERTIES}`,
      param_list_key,
      methodFunctionValidation,
      models,
      methodFunctionType,
      param_property_list_key
    });
    let methodParamSetup = getMethodValidationForParameter(methodFunctionValidation, methodFunctionType, Visual(state, param_list_key), Visual(state, param_property_list_key));

    let updateValidation = () => {
      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
        prop: uiactions_NodeProperties.Condition,
        id: currentNode.id,
        value: methodFunctionValidation
      });
    };

    let onCopy = (prop, key) => {
      let copyValue = null;

      if (methodFunctionValidation && methodFunctionValidation.methods && methodFunctionValidation.methods[methodFunctionType] && methodFunctionValidation.methods[methodFunctionType][selectedParameter] && methodFunctionValidation.methods[methodFunctionType][selectedParameter].properties) {
        copyValue = methodFunctionValidation.methods[methodFunctionType][selectedParameter].properties[prop];

        if (copyValue && copyValue.validators && copyValue.validators[key]) {
          copyValue = copyValue.validators[key];
          copyValue = {
            value: JSON.parse(JSON.stringify(copyValue)),
            isAll: false,
            isPart: true
          };
        } else {
          copyValue = {
            value: JSON.parse(JSON.stringify(copyValue)),
            isAll: true,
            isPart: false
          };
        }
      }

      if (copyValue) {
        this.props.setVisual(CopyKey(methodDefinitionKey), copyValue);
      }
    };

    let copyKey = Visual(state, CopyKey(methodDefinitionKey));

    let onPaste = (prop, key) => {
      if (copyKey) {
        if (copyKey.value && copyKey.isAll && prop) {
          if (methodFunctionValidation && methodFunctionValidation.methods && methodFunctionValidation.methods[methodFunctionType] && methodFunctionValidation.methods[methodFunctionType][selectedParameter] && methodFunctionValidation.methods[methodFunctionType][selectedParameter].properties && methodFunctionValidation.methods[methodFunctionType][selectedParameter].properties[prop]) {
            if (copyKey.value && copyKey.value.validators) {
              let updatableObject = methodFunctionValidation.methods[methodFunctionType][selectedParameter].properties[prop].validators;
              Object.values(copyKey.value.validators).map(copyValue => {
                updatableObject[uuidv4()] = copyValue;
              });
            }

            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.Condition,
              id: currentNode.id,
              value: methodFunctionValidation
            });
          }
        } else if (copyKey.isPart && prop && key) {
          debugger;
        }
      }
    };

    let onRemoveValidation = remove => {
      if (remove) {
        methodFunctionValidation = removeMethodValidationParameter(methodFunctionValidation, methodFunctionType, Visual(state, param_list_key), remove);
      }

      updateValidation();
    };

    return conditionfiltermenu_jsx(genericpropertycontainer, {
      title: "asdf",
      subTitle: "afaf",
      nodeType: NodeTypes.Condition,
      top: top
    }, void 0, conditionfiltermenu_jsx(genericpropertymenu, {
      ui: FilterUI,
      function_variables: filterParameters,
      methodParamSetup: methodParamSetup,
      nodeType: NodeTypes.Condition,
      onRemove: onRemoveValidation,
      onCopy: onCopy,
      onPaste: onPaste,
      pasteAll: copyKey && copyKey.isAll,
      pastePart: copyKey && copyKey.isPart,
      adjacentNodeId: interestingNode.id,
      onChange: updateValidation,
      onAdd: updateValidation
    }));
  }

  getTop(args = {}) {
    let {
      methodProps,
      model_properties,
      models,
      selectedParameter,
      filterMenuParameter = CONDITION_FILTER_MENU_PARAMETER,
      filterMenuParameterProperties = CONDITION_FILTER_MENU_PARAMETER_PROPERTIES,
      param_list_key,
      methodFunctionValidation,
      methodFunctionType,
      param_property_list_key
    } = args;
    let {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    return conditionfiltermenu_jsx(sidebarmenu_SideBarMenu, {
      relative: true
    }, void 0, conditionfiltermenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, filterMenuParameter),
      active: Visual(state, filterMenuParameter),
      title: `${GetNodeTitle(methodProps[selectedParameter])} (${selectedParameter})` || "Parameters",
      toggle: () => {
        this.props.toggleVisual(filterMenuParameter);
      }
    }, void 0, conditionfiltermenu_ref3, conditionfiltermenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        return item && selectedParameter === item.id;
      },
      items: models,
      onClick: item => {
        let methodValidationForParameter = addMethodValidationForParamter(methodFunctionValidation, methodFunctionType, item.id);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Condition,
          id: currentNode.id,
          value: methodValidationForParameter
        });
        this.props.setVisual(param_list_key, item.id);
      }
    })), conditionfiltermenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, filterMenuParameterProperties),
      active: Visual(state, filterMenuParameterProperties),
      title: GetNodeTitle(Visual(state, param_property_list_key)) || "Parameter Properties",
      toggle: () => {
        this.props.toggleVisual(filterMenuParameterProperties);
      }
    }, void 0, conditionfiltermenu_ref4, param_property_list_key ? conditionfiltermenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        return item && Visual(state, param_property_list_key) === item.id;
      },
      items: model_properties,
      onClick: item => {
        let methodValidationForParameter = addMethodValidationForParamter(methodFunctionValidation, methodFunctionType, Visual(state, param_list_key), item.id);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Condition,
          id: currentNode.id,
          value: methodValidationForParameter
        });
        this.props.setVisual(param_property_list_key, item.id);
      }
    }) : null));
  }

}

/* harmony default export */ var conditionfiltermenu = (UIConnect(conditionfiltermenu_ConditionFilterMenu));
// CONCATENATED MODULE: ./node_modules/d3-dispatch/src/dispatch.js
var noop = {value: function() {}};

function dispatch_dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch_dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ var src_dispatch = (dispatch_dispatch);

// CONCATENATED MODULE: ./node_modules/d3-dispatch/index.js


// CONCATENATED MODULE: ./node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";

/* harmony default export */ var namespaces = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/namespace.js


/* harmony default export */ var src_namespace = (function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/creator.js



function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ var creator = (function(name) {
  var fullname = src_namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/local.js
var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// CONCATENATED MODULE: ./node_modules/d3-selection/src/matcher.js
var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var matcher_element = document.documentElement;
  if (!matcher_element.matches) {
    var vendorMatches = matcher_element.webkitMatchesSelector
        || matcher_element.msMatchesSelector
        || matcher_element.mozMatchesSelector
        || matcher_element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

/* harmony default export */ var src_matcher = (matcher);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/on.js
var filterEvents = {};

var on_event = null;

if (typeof document !== "undefined") {
  var on_element = document.documentElement;
  if (!("onmouseenter" in on_element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = on_event; // Events can be reentrant (e.g., focus).
    on_event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      on_event = event0;
    }
  };
}

function on_parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

/* harmony default export */ var selection_on = (function(typename, value, capture) {
  var typenames = on_parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
});

function customEvent(event1, listener, that, args) {
  var event0 = on_event;
  event1.sourceEvent = on_event;
  on_event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    on_event = event0;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-selection/src/sourceEvent.js


/* harmony default export */ var sourceEvent = (function() {
  var current = on_event, source;
  while (source = current.sourceEvent) current = source;
  return current;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/point.js
/* harmony default export */ var src_point = (function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/mouse.js



/* harmony default export */ var mouse = (function(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return src_point(node, event);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selector.js
function none() {}

/* harmony default export */ var src_selector = (function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/select.js



/* harmony default export */ var selection_select = (function(select) {
  if (typeof select !== "function") select = src_selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selectorAll.js
function selectorAll_empty() {
  return [];
}

/* harmony default export */ var selectorAll = (function(selector) {
  return selector == null ? selectorAll_empty : function() {
    return this.querySelectorAll(selector);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/selectAll.js



/* harmony default export */ var selectAll = (function(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/filter.js



/* harmony default export */ var selection_filter = (function(match) {
  if (typeof match !== "function") match = src_matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sparse.js
/* harmony default export */ var sparse = (function(update) {
  return new Array(update.length);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/enter.js



/* harmony default export */ var selection_enter = (function() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
});

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

// CONCATENATED MODULE: ./node_modules/d3-selection/src/constant.js
/* harmony default export */ var constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/data.js




var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ var selection_data = (function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/exit.js



/* harmony default export */ var selection_exit = (function() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/merge.js


/* harmony default export */ var selection_merge = (function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/order.js
/* harmony default export */ var order = (function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/sort.js


/* harmony default export */ var sort = (function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/call.js
/* harmony default export */ var call = (function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/nodes.js
/* harmony default export */ var selection_nodes = (function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/node.js
/* harmony default export */ var selection_node = (function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/size.js
/* harmony default export */ var selection_size = (function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/empty.js
/* harmony default export */ var selection_empty = (function() {
  return !this.node();
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/each.js
/* harmony default export */ var each = (function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/attr.js


function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ var selection_attr = (function(name, value) {
  var fullname = src_namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/window.js
/* harmony default export */ var src_window = (function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/style.js


function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ var selection_style = (function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
});

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || src_window(node).getComputedStyle(node, null).getPropertyValue(name);
}

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

/* harmony default export */ var selection_property = (function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ var classed = (function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ var selection_text = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ var html = (function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ var selection_raise = (function() {
  return this.each(raise);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ var selection_lower = (function() {
  return this.each(lower);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/append.js


/* harmony default export */ var append = (function(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/insert.js



function constantNull() {
  return null;
}

/* harmony default export */ var selection_insert = (function(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : src_selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/remove.js
function remove_remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ var selection_remove = (function() {
  return this.each(remove_remove);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/datum.js
/* harmony default export */ var datum = (function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/dispatch.js


function dispatchEvent(node, type, params) {
  var window = src_window(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ var selection_dispatch = (function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selection/index.js






























var selection_root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection_selection() {
  return new Selection([[document.documentElement]], selection_root);
}

Selection.prototype = selection_selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: order,
  sort: sort,
  call: call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: classed,
  text: selection_text,
  html: html,
  raise: selection_raise,
  lower: selection_lower,
  append: append,
  insert: selection_insert,
  remove: selection_remove,
  datum: datum,
  on: selection_on,
  dispatch: selection_dispatch
};

/* harmony default export */ var src_selection = (selection_selection);

// CONCATENATED MODULE: ./node_modules/d3-selection/src/select.js


/* harmony default export */ var src_select = (function(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], selection_root);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/selectAll.js


/* harmony default export */ var src_selectAll = (function(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], selection_root);
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/touch.js



/* harmony default export */ var src_touch = (function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return src_point(node, touch);
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/src/touches.js



/* harmony default export */ var src_touches = (function(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = src_point(node, touches[i]);
  }

  return points;
});

// CONCATENATED MODULE: ./node_modules/d3-selection/index.js


















// CONCATENATED MODULE: ./node_modules/d3-drag/src/noevent.js


function nopropagation() {
  on_event.stopImmediatePropagation();
}

/* harmony default export */ var noevent = (function() {
  on_event.preventDefault();
  on_event.stopImmediatePropagation();
});

// CONCATENATED MODULE: ./node_modules/d3-drag/src/nodrag.js



/* harmony default export */ var nodrag = (function(view) {
  var root = view.document.documentElement,
      selection = src_select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = src_select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-drag/src/constant.js
/* harmony default export */ var src_constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-drag/src/event.js
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// CONCATENATED MODULE: ./node_modules/d3-drag/src/drag.js







// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !on_event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: on_event.x, y: on_event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

/* harmony default export */ var src_drag = (function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = src_dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture) return;
    src_select(on_event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(on_event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = on_event.clientX;
    mousedowny = on_event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = on_event.clientX - mousedownx, dy = on_event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    src_select(on_event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(on_event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = on_event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, src_touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = on_event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = on_event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((on_event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : src_constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : src_constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : src_constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : src_constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
});

// CONCATENATED MODULE: ./node_modules/d3-drag/index.js



// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/zoom.js
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
/* harmony default export */ var src_zoom = (function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    }
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    }
  }

  i.duration = S * 1000;

  return i;
});

// CONCATENATED MODULE: ./node_modules/d3-timer/src/timer.js
var timer_frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++timer_frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --timer_frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  timer_frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    timer_frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (timer_frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    timer_frame = 1, setFrame(wake);
  }
}

// CONCATENATED MODULE: ./node_modules/d3-timer/src/timeout.js


/* harmony default export */ var src_timeout = (function(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});

// CONCATENATED MODULE: ./node_modules/d3-timer/src/interval.js


/* harmony default export */ var src_interval = (function(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});

// CONCATENATED MODULE: ./node_modules/d3-timer/index.js






// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/schedule.js



var emptyOn = src_dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

/* harmony default export */ var transition_schedule = (function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  schedule_create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});

function init(node, id) {
  var schedule = schedule_get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function schedule_set(node, id) {
  var schedule = schedule_get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function schedule_get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function schedule_create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return src_timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    src_timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

// CONCATENATED MODULE: ./node_modules/d3-transition/src/interrupt.js


/* harmony default export */ var interrupt = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/interrupt.js


/* harmony default export */ var selection_interrupt = (function(name) {
  return this.each(function() {
    interrupt(this, name);
  });
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/number.js
/* harmony default export */ var number = (function(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ var decompose = (function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/parse.js


var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/transform/index.js



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/tween.js


function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = schedule_set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = schedule_set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ var transition_tween = (function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = schedule_get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = schedule_set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return schedule_get(node, id).value[name];
  };
}

// CONCATENATED MODULE: ./node_modules/d3-color/src/define.js
/* harmony default export */ var define = (function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// CONCATENATED MODULE: ./node_modules/d3-color/src/color.js


function color_Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(color_Color, color_color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color_color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof color_Color)) o = color_color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function color_rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, color_rgb, extend(color_Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof color_Color)) o = color_color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(color_Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ var src_basis = (function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/basisClosed.js


/* harmony default export */ var basisClosed = (function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/constant.js
/* harmony default export */ var d3_interpolate_src_constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/color.js


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : d3_interpolate_src_constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : d3_interpolate_src_constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : d3_interpolate_src_constant(isNaN(a) ? b : a);
}

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/rgb.js





/* harmony default export */ var src_rgb = ((function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = color_rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);

// CONCATENATED MODULE: ./node_modules/d3-interpolate/src/string.js


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ var string = (function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/interpolate.js



/* harmony default export */ var transition_interpolate = (function(a, b) {
  var c;
  return (typeof b === "number" ? number
      : b instanceof color_color ? src_rgb
      : (c = color_color(b)) ? (b = c, src_rgb)
      : string)(a, b);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attr.js





function attr_attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attr_attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attr_attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attr_attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attr_attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attr_attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

/* harmony default export */ var transition_attr = (function(name, value) {
  var fullname = src_namespace(name), i = fullname === "transform" ? interpolateTransformSvg : transition_interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attr_attrFunctionNS : attr_attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attr_attrRemoveNS : attr_attrRemove)(fullname)
      : (fullname.local ? attr_attrConstantNS : attr_attrConstant)(fullname, i, value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/attrTween.js


function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_attrTween = (function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = src_namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/delay.js


function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

/* harmony default export */ var transition_delay = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : schedule_get(this.node(), id).delay;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/duration.js


function durationFunction(id, value) {
  return function() {
    schedule_set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    schedule_set(this, id).duration = value;
  };
}

/* harmony default export */ var transition_duration = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : schedule_get(this.node(), id).duration;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/ease.js


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    schedule_set(this, id).ease = value;
  };
}

/* harmony default export */ var ease = (function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : schedule_get(this.node(), id).ease;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/filter.js



/* harmony default export */ var transition_filter = (function(match) {
  if (typeof match !== "function") match = src_matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/merge.js


/* harmony default export */ var transition_merge = (function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/on.js


function on_start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = on_start(name) ? init : schedule_set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

/* harmony default export */ var transition_on = (function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? schedule_get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/remove.js
function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ var transition_remove = (function() {
  return this.on("end.remove", removeFunction(this._id));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/select.js




/* harmony default export */ var transition_select = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = src_selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        transition_schedule(subgroup[i], name, id, i, subgroup, schedule_get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selectAll.js




/* harmony default export */ var transition_selectAll = (function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = schedule_get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            transition_schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/selection.js


var selection_Selection = src_selection.prototype.constructor;

/* harmony default export */ var transition_selection = (function() {
  return new selection_Selection(this._groups, this._parents);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/style.js






function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function style_styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function style_styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function style_styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = schedule_set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = style_styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

/* harmony default export */ var transition_style = (function(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : transition_interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, style_styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, style_styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, style_styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_styleTween = (function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/text.js


function text_textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function text_textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ var transition_text = (function(value) {
  return this.tween("text", typeof value === "function"
      ? text_textFunction(tweenValue(this, "text", value))
      : text_textConstant(value == null ? "" : value + ""));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

/* harmony default export */ var transition_textTween = (function(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/transition.js



/* harmony default export */ var transition_transition = (function() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = schedule_get(node, id0);
        transition_schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/end.js


/* harmony default export */ var transition_end = (function() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = schedule_set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/transition/index.js





















var transition_id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function src_transition_transition(name) {
  return src_selection().transition(name);
}

function newId() {
  return ++transition_id;
}

var selection_prototype = src_selection.prototype;

Transition.prototype = src_transition_transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: ease,
  end: transition_end
};

// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/transition.js





var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function transition_inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

/* harmony default export */ var selection_transition = (function(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        transition_schedule(node, name, id, i, group, timing || transition_inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/selection/index.js




src_selection.prototype.interrupt = selection_interrupt;
src_selection.prototype.transition = selection_transition;

// CONCATENATED MODULE: ./node_modules/d3-transition/src/active.js



var active_root = [null];

/* harmony default export */ var src_active = (function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], active_root, name, +i);
      }
    }
  }

  return null;
});

// CONCATENATED MODULE: ./node_modules/d3-transition/src/index.js





// CONCATENATED MODULE: ./node_modules/d3-zoom/src/constant.js
/* harmony default export */ var d3_zoom_src_constant = (function(x) {
  return function() {
    return x;
  };
});

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/event.js
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var transform_identity = new Transform(1, 0, 0);

transform_transform.prototype = Transform.prototype;

function transform_transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return transform_identity;
  return node.__zoom;
}

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/noevent.js


function noevent_nopropagation() {
  on_event.stopImmediatePropagation();
}

/* harmony default export */ var src_noevent = (function() {
  on_event.preventDefault();
  on_event.stopImmediatePropagation();
});

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/zoom.js










// Ignore right-click, since that should open the context menu.
function zoom_defaultFilter() {
  return !on_event.ctrlKey && !on_event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || transform_identity;
}

function defaultWheelDelta() {
  return -on_event.deltaY * (on_event.deltaMode === 1 ? 0.05 : on_event.deltaMode ? 1 : 0.002);
}

function zoom_defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ var d3_zoom_src_zoom = (function() {
  var filter = zoom_defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = zoom_defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = src_zoom,
      listeners = src_dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(transform_identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }

    src_noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = src_select(on_event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = mouse(this),
        x0 = on_event.clientX,
        y0 = on_event.clientY;

    nodrag(on_event.view);
    noevent_nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();

    function mousemoved() {
      src_noevent();
      if (!g.moved) {
        var dx = on_event.clientX - x0, dy = on_event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(on_event.view, g.moved);
      src_noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (on_event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    src_noevent();
    if (duration > 0) src_select(this).transition().duration(duration).call(schedule, t1, p0);
    else src_select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = on_event.touches,
        n = touches.length,
        g = gesture(this, arguments, on_event.changedTouches.length === n),
        started, i, t, p;

    noevent_nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = src_touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = on_event.changedTouches,
        n = touches.length, i, t, p, l;

    src_noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = src_touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = on_event.changedTouches,
        n = touches.length, i, t;

    noevent_nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = src_select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : d3_zoom_src_constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : d3_zoom_src_constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : d3_zoom_src_constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : d3_zoom_src_constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});

// CONCATENATED MODULE: ./node_modules/d3-zoom/src/index.js



// EXTERNAL MODULE: external "d3"
var external_d3_ = __webpack_require__("d3");

// CONCATENATED MODULE: ./app/components/mindmap.js


var mindmap_REACT_ELEMENT_TYPE;

function mindmap_jsx(type, props, key, children) { if (!mindmap_REACT_ELEMENT_TYPE) { mindmap_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: mindmap_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/sort-comp */

/* eslint-disable class-methods-use-this */







const MIN_DIMENSIONAL_SIZE = 20;
let iconSize = 30;
class mindmap_MindMap extends external_react_["Component"] {
  constructor() {
    super();
    this.textSize = {};
    this.mapScale = 1;
    this.mapTranslate = {
      x: 0,
      y: 0
    };
    this.state = {
      id: `id-${Date.now()}`,
      graph: {
        nodes: [].map(t => {
          t.id = t.name;
          return t;
        }),
        links: [],
        groups: [// { "leaves": [0], "groups": [1] },
          // { "leaves": [1, 2] },
          // { "leaves": [3, 4] }
        ]
      }
    };
    this.draw = this.draw.bind(this);
    this.mouseDown = this.mouseDown.bind(this);
    this.mouseUp = this.mouseUp.bind(this);
    this.mouseMove = this.mouseMove.bind(this);
  }

  componentDidMount() {
    // Draw for the first time to initialize.
    this.draw(true); // Redraw based on the new size whenever the browser window is resized.

    window.addEventListener("resize", this.draw);
    window.addEventListener("mousemove", this.mouseMove);
    window.addEventListener("mouseup", this.mouseUp);
    window.addEventListener("mousedown", this.mouseDown);
  }

  mouseDown(evt) {
    this.mouseStartEvent = evt;
  }

  mouseUp(evt) {
    this.mouseStartEvent = null;
    this.mouseMoved = null;
  }

  mouseMove(evt) {
    if (this.mouseStartEvent) {
      this.mouseMoveEvt = evt;
      this.mouseMoved = {
        x: evt.clientX - this.mouseStartEvent.clientX,
        y: evt.clientY - this.mouseStartEvent.clientY
      };
    }
  }

  componentWillUnmount() {
    window.removeEventListener("resize", this.draw);
    window.removeEventListener("mousemove", this.mouseMove);
    window.removeEventListener("mousedown", this.mouseUp);
    window.removeEventListener("mouseup", this.mouseDown);
    var domObj = document.querySelector(`#${this.state.id}`);

    if (domObj) {
      domObj.innerHTML = "";
    }
  }

  calculateNodeTextSize(text, pad) {
    var div = document.querySelector("#secret-div-space");

    if (!div) {
      div = document.createElement("div");
      div.id = "secret-div-space";
      div.setAttribute("id", "secret-div-space");
      div.style.visibility = "hidden";
      div.style.position = "absolute";
      div.classList.add("label");
      div.style.whiteSpace = "normal";
      div.style.maxWidth = (text || "").split(" ").length > 1 ? `200px` : "300px";
      div.style.top = "-10000px";
      div.style.padding = pad * 2 + "px";
      let statenode = document.querySelector(`#${this.state.id}`);

      if (statenode) {
        statenode.appendChild(div);
      }
    }

    div.innerHTML = text;
    return div.getBoundingClientRect();
  }

  draw(options = {
    once: false
  }) {
    var me = this;
    var domObj = document.querySelector(`#${this.state.id}`);
    domObj.innerHTML = "";
    var bb = domObj.getBoundingClientRect();
    var force = external_webcola_["d3adaptor"](external_d3_);
    var width = bb.width - 10; // 960;

    var height = bb.height - 10; // 800;

    var color = external_d3_["scaleOrdinal"](Object.values(uiactions_NodeTypeColors) || external_d3_["schemeCategory10"]);
    me.avoidOverlaps = true;
    var margin = 6,
        pad = 12;
    force.linkDistance(this.props.linkDistance || 280) //.symmetricDiffLinkLengths(this.props.linkDistance || 280)
    .avoidOverlaps(me.avoidOverlaps).convergenceThreshold(0.01).handleDisconnected(false).size([width, height]);
    var svg = makeSVG();

    function makeSVG() {
      let body = external_d3_["select"](`#${me.state.id}`);
      var outer = body.append("svg").attr("width", width).attr("height", height).attr("pointer-events", "all"); // define arrow markers for graph links

      var centerGuid = body.append("div");
      outer.append("svg:defs").append("svg:marker").attr("id", "end-arrow").attr("viewBox", "0 -5 10 10").attr("refX", 5).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("svg:path").attr("d", "M0,-5L10,0L0,5L2,0").attr("stroke-width", "0px").attr("fill", function (d) {
        if (d && d.properties && d.properties.type && LinkStyles[d.properties.type] && LinkStyles[d.properties.type].stroke) {
          return LinkStyles[d.properties.type].stroke;
        }

        return "#ff0000";
      });
      var vis = outer.append("g");
      outer.on("wheel", function (d) {
        me.mapScale += external_d3_["event"].wheelDelta / (me.props.zoomFactor || 5000);
        redraw();
      });

      function redraw() {
        var {
          x = 0,
          y = 0
        } = me.mouseMoved || {};
        let ang = angle(1, 0, me.mapTranslate.x + x, me.mapTranslate.y + y);
        vis.attr("transform", ` scale(${me.mapScale || 1}) translate(${me.mapTranslate.x + x}, ${me.mapTranslate.y + y})`);
        body.attr("data-transform", `(${me.mapScale || 1})  (${me.mapTranslate.x + x}x, ${me.mapTranslate.y + y})y`);
        centerGuid.attr("style", `position:absolute; top: 10px; left:330px; height: 20px; width:3px; background-color: red; transform:rotate(${Math.abs(ang)}deg)`);
      }

      outer.on("mousemove", function (x, v) {
        if (me.panning) {
          redraw();
        }
      });
      outer.on("mousedown", function (d) {
        me.panning = true;
      });
      outer.on("mouseup", function (d) {
        me.panning = false;

        if (me.mouseMoved && me.mapTranslate) {
          me.mapTranslate = {
            x: me.mapTranslate.x + me.mouseMoved.x,
            y: me.mapTranslate.y + me.mouseMoved.y
          };
        }
      });
      redraw();
      return vis;
    }

    var graph = this.state.graph;
    graph.nodes.forEach(function (v) {
      if (me.props && me.props.minimizeTypes) {
        let propType = uiactions_GetNodeProp(v, nodetypes_NodeProperties.NODEType);

        if (!v.selected && me.props.minimizeTypes[propType]) {
          v.width = MIN_DIMENSIONAL_SIZE;
          v.height = MIN_DIMENSIONAL_SIZE;
          return;
        }
      }

      var bb = me.calculateNodeTextSize(getLabelText(v), pad);
      v.width = Math.max(MIN_DIMENSIONAL_SIZE, bb.width);
      v.height = Math.max(MIN_DIMENSIONAL_SIZE, bb.height);
    });
    graph.groups.forEach(function (g) {
      g.padding = pad;
    });
    force.nodes(graph.nodes).groups(graph.groups).links(graph.links).on("tick", tick);
    var group = svg.selectAll(".group").data(graph.groups).enter().append("rect").attr("rx", 8).attr("ry", 8).attr("class", "group").style("fill", function (d, i) {
      return Object.values(uiactions_NodeTypeColors)[i] || color(i);
    }).call(force.drag);
    var node = svg.selectAll(".node");
    this.$node = node;
    this.buildNode(graph, force, color);
    var link = svg.selectAll(".link").data(graph.links).enter().append("line").attr("class", "link").style("stroke", function (d) {
      if (d.selected) {
        return "#ff0000";
      }

      if (d && d.properties && d.properties.type === nodetypes_LinkType.FunctionConstraintLink && !d.properties[LinkPropertyKeys.VALID_CONSTRAINTS]) {
        return LinkStyles[nodetypes_LinkType.ErrorLink].stroke;
      } else if (d && d.properties && d.properties.type && LinkStyles[d.properties.type] && LinkStyles[d.properties.type].stroke) {
        return LinkStyles[d.properties.type].stroke;
      }

      return "#000";
    }).style("stroke-dasharray", function (d) {
      if (d && d.properties && d.properties.type === nodetypes_LinkType.FunctionConstraintLink && !d.properties[LinkPropertyKeys.VALID_CONSTRAINTS]) {
        return "5,5";
      }

      return "";
    }).style("d", function (d) {
      if (d && d.properties && d.properties.type === nodetypes_LinkType.FunctionConstraintLink && !d.properties[LinkPropertyKeys.VALID_CONSTRAINTS]) {
        return "M5 20 l215 0";
      }

      return "";
    }).style("stroke-width", function (d) {
      if (d && d.properties && d.properties.type && LinkStyles[d.properties.type] && LinkStyles[d.properties.type].strokeWidth) {
        return LinkStyles[d.properties.type].strokeWidth;
      }

      return Math.sqrt(d.value);
    });
    link.on("click", (d, index, els) => {
      if (me.props.onLinkClick && d) {
        me.props.onLinkClick({
          id: d.id,
          source: d.source.id,
          target: d.target.id
        }, els[index].getBoundingClientRect());
      }
    });
    link.on("mouseover", (d, index, els) => {
      if (me.props.onLinkHover && d) {
        me.props.onLinkHover({
          id: d.id,
          source: d.source.id,
          target: d.target.id
        }, els[index].getBoundingClientRect());
      }
    });
    var label = svg.selectAll(".label").data(graph.nodes).enter().append("foreignObject").attr("class", "label");
    label.on("click", (d, index, els) => {
      if (me.props.onNodeClick && d && d.id) {
        me.props.onNodeClick(d.id, els[index].getBoundingClientRect());
      }
    });
    var features = svg.selectAll(".features").data(graph.nodes).enter().append("g").attr("class", "features");
    features.append("rect").attr("width", function (d) {
      return d.selected ? 5 : 0;
    }).attr("height", function (d) {
      return d.height - 10;
    }).attr("x", 3).attr("y", 5).attr("rx", 5).attr("ry", 5).style("fill", function (d) {
      if (d.selected && me.props.selectedColor) {
        return me.props.selectedColor;
      }

      return color(graph.groups.length);
    });
    features.append("rect").attr("width", function (d) {
      return d.marked ? 15 : 0;
    }).attr("height", function (d) {
      return 15;
    }).attr("x", function (d) {
      return d.width - 5;
    }).attr("y", 5).attr("rx", 5).attr("ry", 5).style("fill", function (d) {
      if (d.marked && me.props.markedColor) {
        return me.props.markedColor;
      }

      return color(graph.groups.length);
    });
    var topdiv = label.append("xhtml:div").style("pointer-events", "none");
    topdiv.append("xhtml:object").attr("data", d => {
      if (d && d.properties && d.properties.nodeType && uiactions_NodeTypeColors[d.properties.nodeType]) {
        return GetNodeTypeIcon(d.properties.nodeType);
      }

      return "./css/svg/003-cupcake.svg";
    }).attr("type", n => "image/svg+xml").attr("width", function (d) {
      return iconSize;
    }).attr("height", function (d) {
      return iconSize;
    }).attr("x", 40).attr("y", 40).style("width", 40).style("height", 40);
    var titles = topdiv.append("xhtml:div").style("width", x => `${x.width - pad / 2}px`).style("white-space", "normal").style("text-align", "start") //.style('word-break', 'break-all')
    .style("height", x => `${x.height - pad / 2}px`).text(function (d) {
      return `${getLabelText(d)}`;
    }).call(force.drag);
    this.$force = force;
    this.setState({
      $node: node,
      $color: color
    });

    function getLabelText(d) {
      if (!d.selected) {
        if (d.properties && me.props.minimizeTypes && me.props.minimizeTypes[d.properties[nodetypes_NodeProperties.NODEType]]) {
          return "";
        }
      }

      return d && d.properties ? d.properties.text || d.name : d.name;
    }

    function createRectangle(source) {
      var temp = {
        x: source.x - source.width / 2,
        y: source.y - source.height / 2,
        X: source.x + source.width / 2,
        Y: source.y + source.height / 2
      };
      return new external_webcola_["Rectangle"](temp.x, temp.X, temp.y, temp.Y);
    }

    function rotate(source, degree = Math.PI / 2) {
      var {
        innerBounds,
        x,
        y
      } = source;

      if (!innerBounds) {
        innerBounds = {
          x: source.x - source.width / 2,
          y: source.y - source.height / 2,
          X: source.x + source.width / 2,
          Y: source.y + source.height / 2
        };
      }

      var rise = innerBounds.y - innerBounds.Y;
      var run = innerBounds.x - innerBounds.X;
      return Object.assign(innerBounds, {
        x: 1 + innerBounds.x,
        y: rise ? run / rise * 1 + innerBounds.y : innerBounds.y,
        X: 1 + innerBounds.X,
        Y: rise ? run / rise * 1 + innerBounds.Y : innerBounds.Y
      });
    }

    function tick() {
      if (me.$_nodes) {
        me.$_nodes.each(function (d) {
          var bb = me.calculateNodeTextSize(getLabelText(d), pad);

          if (!d.selected && d.properties && me.props.minimizeTypes && me.props.minimizeTypes[d.properties[nodetypes_NodeProperties.NODEType]]) {
            d.width = MIN_DIMENSIONAL_SIZE;
            d.height = MIN_DIMENSIONAL_SIZE;
          } else {
            d.width = Math.max(MIN_DIMENSIONAL_SIZE, bb.width);
            d.height = Math.max(MIN_DIMENSIONAL_SIZE, bb.height);
          }

          if (me.avoidOverlaps) d.innerBounds = d.bounds.inflate(-margin);
        });
      }

      if (me.$_nodes) {
        me.$_nodes.attr("width", function (d) {
          if (!d.selected && d.properties && me.props.minimizeTypes && me.props.minimizeTypes[d.properties[nodetypes_NodeProperties.NODEType]]) {
            return MIN_DIMENSIONAL_SIZE;
          }

          return d.width;
        }).attr("height", function (d) {
          if (!d.selected && d.properties && me.props.minimizeTypes && me.props.minimizeTypes[d.properties[nodetypes_NodeProperties.NODEType]]) {
            return MIN_DIMENSIONAL_SIZE;
          }

          return d.height;
        }).attr("x", function (d) {
          if (!d.selected && d.properties && me.props.minimizeTypes && me.props.minimizeTypes[d.properties[nodetypes_NodeProperties.NODEType]]) {
            return d.x - MIN_DIMENSIONAL_SIZE / 2;
          }

          return d.x - d.width / 2;
        }).attr("y", function (d) {
          if (!d.selected && d.properties && me.props.minimizeTypes && me.props.minimizeTypes[d.properties[nodetypes_NodeProperties.NODEType]]) {
            return d.y - MIN_DIMENSIONAL_SIZE / 2;
          }

          return d.y - d.height / 2;
        });
      } // if (me.avoidOverlapss)


      group.attr("x", function (d) {
        if (!d.bounds) {
          let min = d.leaves.minimum(x => x.x - x.width / 2);
          let max = d.leaves.maximum(x => x.x + x.width / 2);
          let width = max - min;
          return d.leaves.summation(x => x.x) / d.leaves.length - width / 2;
        }

        return d.bounds.x;
      }).attr("y", function (d) {
        if (!d.bounds) {
          let min = d.leaves.minimum(x => x.y - x.height / 2);
          let max = d.leaves.maximum(x => x.y + x.height / 2);
          let height = max - min;
          return d.leaves.summation(x => x.y) / d.leaves.length - height / 2;
        }

        return d.bounds.y;
      }).attr("width", function (d) {
        if (!d.bounds) {
          let min = d.leaves.minimum(x => x.x - x.width / 2);
          let max = d.leaves.maximum(x => x.x + x.width / 2);
          return max - min;
        }

        return d.bounds.width();
      }).attr("height", function (d) {
        if (!d.bounds) {
          let min = d.leaves.minimum(x => x.y - x.height / 2);
          let max = d.leaves.maximum(x => x.y + x.height / 2);
          return max - min;
        }

        return d.bounds.height();
      });
      link.each(function (d) {
        //  d.route = Cola.makeEdgeBetween(rotate(d.source), rotate(d.target, -Math.PI / 2), 5);
        if (!me.avoidOverlaps) {
          d.route = external_webcola_["makeEdgeBetween"](createRectangle(d.source), createRectangle(d.target), 5);
        } else {
          d.route = external_webcola_["makeEdgeBetween"](rotate(d.source), rotate(d.target, 0), 5);
        }
      });
      link.attr("x1", function (d) {
        return d.route.sourceIntersection.x;
      }).attr("y1", function (d) {
        return d.route.sourceIntersection.y;
      }).attr("x2", function (d) {
        return d.route.arrowStart.x;
      }).attr("y2", function (d) {
        return d.route.arrowStart.y;
      });
      features.attr("transform", function (d) {
        var y = d.y - d.height / 2;
        var x = d.x - d.width / 2;
        return `translate(${x},${y})`;
      });
      label.attr("x", function (d) {
        return d.x - d.width / 2;
      }).attr("y", function (d) {
        var innerbit = this.querySelector("div");
        var h = innerbit ? innerbit.getBoundingClientRect().height : 0;
        return d.y + h / 2 - d.height + -pad / 2 - iconSize;
      });
    }

    let initialUnconstrainedIterations = 100;
    let initialUserConstraintIterations = 15;
    let initialAllConstraintsIterations = 20;
    let gridSnapIterations = null;
    let keepRunning = true;
    let centerGraph = true;
    force.start(null, null, null, null, !options.once);
  }

  buildNode(graph, cola, color) {
    var me = this;
    var node = this.$node.data(cola.nodes(), x => x.id || x.name);
    var temp = node.enter().append("rect").attr("class", "node").attr("width", function (d) {
      return d.width;
    }).attr("height", function (d) {
      return d.height;
    }).attr("rx", 5).attr("ry", 5).style("fill", function (d) {
      if (d && d.properties && d.properties.nodeType && uiactions_NodeTypeColors[d.properties.nodeType]) {
        return uiactions_NodeTypeColors[d.properties.nodeType];
      }

      return color(graph.groups.length);
    }).on("click", (d, index, els) => {
      if (me.props.onNodeClick && d) {
        me.props.onNodeClick(d.id, els[index].getBoundingClientRect());
      }
    }).call(cola.drag);
    node.exit().remove();
    this.$_nodes = temp;
  }

  applyNodeVisualData(nn) {
    nn.width = 40;
    nn.height = 40;
    nn.name = nn.id;
    nn.fixed = false;
    return nn;
  }

  componentWillReceiveProps(props, state) {
    if (props.graph) {
      var {
        graph
      } = props;
      var draw = true; // d3.event.stopPropagation();

      this.$force.stop();

      if (graph.nodes && this.state && this.state.graph && this.state.graph.nodes) {
        var removedNodes = this.state.graph.nodes.relativeCompliment(graph.nodes, (x, y) => x.id === y).map(t => this.state.graph.nodes.indexOf(t));
        this.state.graph.nodes.removeIndices(removedNodes);
        var newNodes = graph.nodes.relativeCompliment(this.state.graph.nodes, (x, y) => x === y.id);
        let unanchored = {};

        if (props.selectedNodes) {
          props.selectedNodes.forEach(t => {
            unanchored = { ...unanchored,
              ...GetLinkedNodes(null, {
                id: t
              })
            };
          });
        }

        this.state.graph.nodes.forEach(v => {
          if (!unanchored[v.id]) {
            v.fixed = true;
          } else {
            v.fixed = false;
          }
        });
        newNodes.map(nn => {
          this.state.graph.nodes.push(this.applyNodeVisualData(duplicateNode(graph.nodeLib[nn])));
        });

        if (props.markedNodes) {
          this.state.graph.nodes.map(nn => {
            nn.marked = !!props.markedNodes.find(t => t == nn.id);
          });
        }

        if (props.selectedNodes) {
          this.state.graph.nodes.map(nn => {
            nn.selected = !!props.selectedNodes.find(t => {
              return t == nn.id;
            });
          });
        }

        this.state.graph.nodes.map(nn => {
          var nl = graph.nodeLib[nn.id];

          if (nl && nl.properties) {
            nn.properties = { ...nl.properties
            };
          } // if (graph.visibleNodes && graph.visibleNodes[nn.id]) {
          //   if (graph.visibleNodes[nn.id] === 2) nn.fixed = true;
          //   else {
          //     nn.fixed = false;
          //   }
          // }

        });
        draw = draw || newNodes.length || removedNodes.length;
      }

      if (graph.links && this.state && this.state.graph && this.state.graph.links) {
        let removedLinks = this.state.graph.links.relativeCompliment(graph.links, (x, y) => x.id === y).map(t => this.state.graph.links.indexOf(t));
        this.state.graph.links.removeIndices(removedLinks);
        let newLinks = graph.links.relativeCompliment(this.state.graph.links, (x, y) => x === y.id);
        newLinks.map(nn => {
          this.state.graph.links.push(mindmap_duplicateLink(graph.linkLib[nn], this.state.graph.nodes));
        });

        if (props.selectedLinks) {
          this.state.graph.links.map(nn => {
            nn.selected = !!props.selectedLinks.find(t => t.id === nn.id);
          });
        }

        this.state.graph.links.map(nn => {
          let nl = graph.linkLib[nn.id];

          if (nl && nl.properties) {
            nn.properties = { ...nl.properties
            };
          }
        });
        draw = draw || newLinks.length || removedLinks.length;
      }

      if (graph.groups && this.state && this.state.graph && this.state.graph.groups) {
        let graph_groups = graph.groups.filter(x => graph.groupLib[x].leaves || graph.groupLib[x].groups);
        let removedGroups = null;

        if (this.props.groupsDisabled) {
          removedGroups = [].interpolate(0, this.state.graph.groups.length, x => x);
        } else {
          removedGroups = this.state.graph.groups.relativeCompliment(graph_groups, (x, y) => x.id === y).map(t => this.state.graph.groups.indexOf(t));
        }

        this.state.graph.groups.removeIndices(removedGroups);

        if (!this.props.groupsDisabled) {
          let newGroups = graph_groups.relativeCompliment(this.state.graph.groups, (x, y) => x === y.id).filter(x => graph.groupLib[x] && (graph.groupLib[x].leaves || graph.groupLib[x].groups));
          newGroups.map(nn => {
            this.state.graph.groups.push(duplicateGroup(graph.groupLib[nn], this.state.graph.nodes));
          });
          graph_groups.forEach(group => {
            let g = this.state.graph.groups.find(x => x.id === group);
            applyGroup(g, graph.groupLib[group], this.state.graph.groups, this.state.graph.nodes, this.props.groupsDisabled); // (duplicateGroup(graph.groupLib[nn], this.state.graph.nodes))
          });
        } // this.state.graph.groups.map(group => {
        //     var _group = graph.groupLib[group.id];
        // })

      }

      if (draw) {
        this.draw({
          once: !(this.state.graph.nodes && this.state.graph.nodes.length)
        });
      }
    }
  }

  shouldComponentUpdate() {
    return false;
  }

  render() {
    return mindmap_jsx("div", {
      id: this.state.id,
      className: "mindmap",
      style: {
        minHeight: 946
      }
    });
  }

}

function mindmap_duplicateLink(nn, nodes) {
  return { ...nn,
    source: nodes.findIndex(x => x.id === nn.source),
    target: nodes.findIndex(x => x.id === nn.target)
  };
}

function applyGroup(mindmapgroup, _group, groups, nodes) {
  if (_group) {
    if (_group.leaves && _group.leaves.length) {
      mindmapgroup.leaves = mindmapgroup.leaves || [];
      mindmapgroup.leaves.length = 0;
      mindmapgroup.leaves.push(..._group.leaves.map(l => nodes.findIndex(x => x.id === l)));
    } else {
      delete mindmapgroup.leaves;
    }

    if (_group.groups && _group.groups.length) {
      mindmapgroup.groups = mindmapgroup.groups || [];
      mindmapgroup.groups.length = 0;
      mindmapgroup.groups.push(..._group.groups.map(l => groups.findIndex(x => x.id === l)));
    } else {
      delete mindmapgroup.groups;
    } // if (nn.leaves) {
    //     let leaves = nn.leaves.map(l => nodes.findIndex(x => x.id === l));
    //     temp.leaves = leaves;
    // }
    // if (groups && nn.groups) {
    //     let groups = nn.groups.map(l => groups.findIndex(x => x.id === l));
    //     temp.groups = groups;
    // }

  }
}

function duplicateGroup(nn, nodes, groups) {
  let temp = { ...nn
  };
  delete temp.leaves;
  delete temp.groups;
  return temp;
}

const throttle = (func, limit) => {
  let inThrottle;
  return function () {
    const args = arguments;
    const context = this;

    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};

function angle(cx, cy, ex, ey) {
  let vect1 = new Vector(ex, ey, 0);
  vect1 = vect1.normalisedVector();
  ex = vect1.getX();
  ey = vect1.getY();
  var dy = ey - cy;
  var dx = ex - cx;
  var theta = Math.atan2(dy, dx); // range (-PI, PI]

  theta *= 180 / Math.PI; // rads to degs, range (-180, 180]

  return theta;
}

var Vector = function () {
  function Vector(pX, pY, pZ) {
    this.setX(pX);
    this.setY(pY);
    this.setZ(pZ);
  }

  Vector.prototype.getX = function () {
    return this.mX;
  };

  Vector.prototype.setX = function (pX) {
    this.mX = pX;
  };

  Vector.prototype.getY = function () {
    return this.mY;
  };

  Vector.prototype.setY = function (pY) {
    this.mY = pY;
  };

  Vector.prototype.getZ = function () {
    return this.mZ;
  };

  Vector.prototype.setZ = function (pZ) {
    this.mZ = pZ;
  };

  Vector.prototype.add = function (v) {
    return new Vector(this.getX() + v.getX(), this.getY() + v.getY(), this.getZ() + v.getZ());
  };

  Vector.prototype.subtract = function (v) {
    return new Vector(this.getX() - v.getX(), this.getY() - v.getY(), this.getZ() - v.getZ());
  };

  Vector.prototype.multiply = function (scalar) {
    return new Vector(this.getX() * scalar, this.getY() * scalar, this.getZ() * scalar);
  };

  Vector.prototype.divide = function (scalar) {
    return new Vector(this.getX() / scalar, this.getY() / scalar, this.getZ() / scalar);
  };

  Vector.prototype.magnitude = function () {
    return Math.sqrt(this.getX() * this.getX() + this.getY() * this.getY() + this.getZ() * this.getZ());
  }; //this is the vector I have tried for the normalisation


  Vector.prototype.normalisedVector = function () {
    var vec = new Vector(this.getX(), this.getY(), this.getZ());
    return vec.divide(this.magnitude());
  };

  return Vector;
}();
// CONCATENATED MODULE: ./app/components/modelactivitymenu.js
var modelactivitymenu_REACT_ELEMENT_TYPE;

function modelactivitymenu_jsx(type, props, key, children) { if (!modelactivitymenu_REACT_ELEMENT_TYPE) { modelactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: modelactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }





















class modelactivitymenu_ModelActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, [uiactions_NodeTypes.Model]);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var is_agent = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.IsAgent);
    var is_parent = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.IsParent);
    var many_to_many_enabled = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexus);
    var permission_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Permission).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    return modelactivitymenu_jsx(sidemenucontainer, {
      active: active,
      tab: dashboard_PARAMETER_TAB,
      visual: "model-activities",
      title: titles_ModelActivityMenu
    }, void 0, modelactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? modelactivitymenu_jsx(formcontrol_FormControl, {}, void 0, modelactivitymenu_jsx(checkbox_CheckBox, {
      label: IsAgent,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.IsAgent] : "",
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsAgent,
          id: currentNode.id,
          value
        });
      }
    }), is_agent ? modelactivitymenu_jsx(selectinput_SelectInput, {
      label: UserModel,
      options: uiactions_NodesByType(state, uiactions_NodeTypes.Model).map(node => {
        return {
          value: node.id,
          title: GetNodeTitle(node)
        };
      }),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIUser],
          source: id,
          linkType: uiactions_LinkProperties.UserLink.type
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIUser,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.UserLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIUser] : ""
    }) : null, modelactivitymenu_jsx(checkbox_CheckBox, {
      label: IsUser,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.IsUser] : "",
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsUser,
          id: currentNode.id,
          value
        });
      }
    }), modelactivitymenu_jsx(checkbox_CheckBox, {
      label: IsOwnedByAgents,
      title: IsOwnedByAgentsDescriptions,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.IsOwnedByAgents] : "",
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsOwnedByAgents,
          id: currentNode.id,
          value
        });
      }
    }), modelactivitymenu_jsx(checkbox_CheckBox, {
      label: ManyToManyNexus,
      title: ManyToManyNexusDescription,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexus),
      onChange: value => {
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.ManyToManyNexus,
            id: currentNode.id,
            value
          }
        }]);
      }
    }), modelactivitymenu_jsx(checkbox_CheckBox, {
      label: IsCompositeInput,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.IsCompositeInput),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsCompositeInput,
          id: currentNode.id,
          value
        });
      }
    }), modelactivitymenu_jsx(checkbox_CheckBox, {
      label: ExcludeFromController,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExcludeFromController),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExcludeFromController,
          id: currentNode.id,
          value
        });
      }
    }), modelactivitymenu_jsx(checkboxproperty, {
      node: currentNode,
      property: nodetypes_NodeProperties.IsFetchOutput,
      title: IsFetchOutput
    }), many_to_many_enabled ? modelactivitymenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).map(x => {
        return {
          value: x.id,
          title: GetNodeTitle(x)
        };
      }),
      label: ManyToManyNexusModel,
      onChange: value => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexusTypes) || [];
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.ManyToManyNexusTypes,
            id: currentNode.id,
            value: [...types, value].unique(x => x)
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: value,
            source: id,
            properties: { ...uiactions_LinkProperties.ManyToManyLink
            }
          }
        }]);
      },
      value: ""
    }) : null) : null, modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ModelActions
    }), modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(ADD_DEFAULT_PROPERTIES, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...uiactions_LinkProperties.PropertyLink
            }
          }
        });
      },
      icon: "fa fa-puzzle-piece",
      title: SetDefaultProperties,
      description: SetDefaultPropertiesDescription
    }), modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_PROPERTY_NODE, {
          parent: Visual(state, SELECTED_NODE),
          properties: {
            [nodetypes_NodeProperties.UIAttributeType]: NodePropertyTypes.STRING
          },
          groupProperties: {},
          linkProperties: {
            properties: { ...uiactions_LinkProperties.PropertyLink
            }
          }
        });
      },
      icon: "fa fa-puzzle-piece",
      title: AddProperty,
      description: AddPropertyDescription
    }), modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        external_electron_["clipboard"].writeText(generateDataSeed(currentNode));
      },
      icon: "fa fa-puzzle-piece",
      title: CreateObjectDataSeed,
      description: CreateObjectDataSeed
    }), modelactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
      title: titles_QuickMethods,
      open: Visual(state, titles_QuickMethods),
      active: Visual(state, titles_QuickMethods),
      toggle: () => {
        this.props.toggleVisual(titles_QuickMethods);
      },
      icon: "fa fa-tag"
    }, void 0, modelactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: GetSpecificModels.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, GetSpecificModels);
      }
    }), modelactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: GetAllModels.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, GetAllModels);
      }
    }), modelactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: CreateLoginModels.type,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.executeGraphOperation(currentNode, CreateLoginModels);
      }
    }))), is_agent ? modelactivitymenu_jsx(selectinput_SelectInput, {
      label: PermissionType,
      options: permission_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.PermissionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIPermissions] : ""
    }) : null, currentNode ? modelactivitymenu_jsx(formcontrol_FormControl, {}, void 0, modelactivitymenu_jsx(checkbox_CheckBox, {
      label: IsParent,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.IsParent] : "",
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsParent,
          id: currentNode.id,
          value
        });
      }
    })) : null, is_parent ? modelactivitymenu_jsx(selectinput_SelectInput, {
      label: ParentTo,
      options: uiactions_NodesByType(state, uiactions_NodeTypes.Model).map(node => {
        return {
          value: node.id,
          title: GetNodeTitle(node)
        };
      }),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIChoiceNode],
          source: id,
          linkType: uiactions_LinkProperties.ParentLink.type
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIChoiceNode,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ParentLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIChoiceNode] : ""
    }) : null, modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, is_agent ? modelactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_PERMISSION_NODE, {
          parent: Visual(state, SELECTED_NODE),
          linkProperties: {
            properties: { ...uiactions_LinkProperties.PermissionLink
            }
          }
        });
      },
      icon: "fa fa-puzzle-piece",
      title: AddPermission,
      description: AddPermissionDescription
    }) : null)));
  }

}

/* harmony default export */ var modelactivitymenu = (UIConnect(modelactivitymenu_ModelActivityMenu));
// CONCATENATED MODULE: ./app/components/functionactivitymenu.js

var functionactivitymenu_REACT_ELEMENT_TYPE;

function functionactivitymenu_jsx(type, props, key, children) { if (!functionactivitymenu_REACT_ELEMENT_TYPE) { functionactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: functionactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














class functionactivitymenu_FunctionActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Function);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var agent_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, uiactions_NodeProperties.IsAgent)).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var function_types = Object.keys(MethodFunctions).map(funcKey => {
      return {
        title: MethodFunctions[funcKey].title || funcKey,
        value: funcKey
      };
    });
    return functionactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? functionactivitymenu_jsx(selectinput_SelectInput, {
      label: AgentOperator,
      options: agent_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIExtension],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtension,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.FunctionOperator
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIPermissions] : ''
    }) : null, currentNode ? functionactivitymenu_jsx(checkbox_CheckBox, {
      label: CustomFunction,
      title: CustomFunctionDescription,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseScopeGraph] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseScopeGraph,
          id: currentNode.id,
          value: value
        });
      }
    }) : null, currentNode && !currentNode.properties[uiactions_NodeProperties.UseScopeGraph] ? functionactivitymenu_jsx(selectinput_SelectInput, {
      label: FunctionTypes,
      options: function_types,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.FunctionType,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(APPLY_FUNCTION_CONSTRAINTS, {
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.FunctionType] : ''
    }) : null, currentNode ? functionactivitymenu_jsx(selectinput_SelectInput, {
      label: Methods,
      options: Object.keys(nodetypes_Methods).map(t => ({
        title: t,
        value: nodetypes_Methods[t]
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MethodType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.MethodType] : ''
    }) : null, currentNode ? functionactivitymenu_jsx(selectinput_SelectInput, {
      label: HttpMethod,
      options: Object.keys(HTTP_METHODS).map(t => ({
        title: t,
        value: HTTP_METHODS[t]
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id: currentNode.id,
          value,
          prop: nodetypes_NodeProperties.HttpMethod
        });
      },
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.HttpMethod)
    }) : null, currentNode ? functionactivitymenu_jsx(textinput_TextInput, {
      label: HttpRoute,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.HttpRoute),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id: currentNode.id,
          value,
          prop: nodetypes_NodeProperties.HttpRoute
        });
      }
    }) : null, functionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, currentNode && currentNode.properties[uiactions_NodeProperties.UseScopeGraph] ? functionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation([{
          operation: ESTABLISH_SCOPE
        }, {
          options: {
            id: currentNode.id
          }
        }]);
      },
      icon: 'fa fa-puzzle-piece',
      title: CustomFunction,
      description: CustomFunctionDescription
    }) : null, currentNode ? functionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_PARAMETER_NODE, {
          parent: Visual(state, SELECTED_NODE)
        });
      },
      icon: 'fa fa-puzzle-piece',
      title: AddParameter,
      description: AddParameterDescription
    }) : null, currentNode ? functionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_FUNCTION_OUTPUT_NODE, {
          parent: Visual(state, SELECTED_NODE)
        });
      },
      icon: 'fa fa-puzzle-piece',
      title: AddFunctionOutput,
      description: AddFunctionOutputDescription
    }) : null));
  }

}

/* harmony default export */ var functionactivitymenu = (UIConnect(functionactivitymenu_FunctionActivityMenu));
// CONCATENATED MODULE: ./app/components/propertyactivitymenu.js

var propertyactivitymenu_REACT_ELEMENT_TYPE;

function propertyactivitymenu_jsx(type, props, key, children) { if (!propertyactivitymenu_REACT_ELEMENT_TYPE) { propertyactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: propertyactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















class propertyactivitymenu_PropertyActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Property);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (currentNode) {
      var show_dependent = currentNode && currentNode.properties && currentNode.properties[uiactions_NodeProperties.UseUIDependsOn];
      ;
      var use_model_as_type = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UseModelAsType);
      var many_to_many_enabled = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexus);
      var property_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Property).filter(x => {
        return x.id !== currentNode.id;
      }).map(node => {
        return {
          value: node.id,
          title: GetNodeTitle(node)
        };
      });
    }

    return propertyactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? propertyactivitymenu_jsx(formcontrol_FormControl, {}, void 0, propertyactivitymenu_jsx(checkbox_CheckBox, {
      label: UseDependentProperty,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseUIDependsOn] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseUIDependsOn,
          id: currentNode.id,
          value
        });
      }
    }), show_dependent ? propertyactivitymenu_jsx(selectinput_SelectInput, {
      label: DependentProperty,
      options: property_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIDependsOn],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIDependsOn,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.DependsOnLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIDependsOn] : ''
    }) : null) : null, currentNode ? propertyactivitymenu_jsx(formcontrol_FormControl, {}, void 0, propertyactivitymenu_jsx(textinput_TextInput, {
      label: UIName,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIName] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIName,
          id: currentNode.id,
          value
        });
      }
    })) : null, currentNode ? propertyactivitymenu_jsx(formcontrol_FormControl, {}, void 0, propertyactivitymenu_jsx(checkbox_CheckBox, {
      label: UseInView,
      title: UseInView,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UseInView),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseInView,
          id: currentNode.id,
          value
        });
      }
    }), propertyactivitymenu_jsx(checkbox_CheckBox, {
      label: ManyToManyNexus,
      title: ManyToManyNexusDescription,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexus),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation([value ? null : {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: currentNode.properties[uiactions_NodeProperties.ManyToManyNexusType],
            source: id
          }
        }, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.ManyToManyNexus,
            id: currentNode.id,
            value
          }
        }, !value || !currentNode.properties[uiactions_NodeProperties.ManyToManyNexusType] ? null : {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: currentNode.properties[uiactions_NodeProperties.ManyToManyNexusType],
            source: id,
            properties: { ...uiactions_LinkProperties.ManyToManyLink
            }
          }
        }].filter(x => x));
      }
    }), propertyactivitymenu_jsx(selectinput_SelectInput, {
      options: Object.keys(GeneratedDataTypes).map(key => ({
        title: key,
        value: key
      })),
      label: PropertyGeneratedType,
      onChange: value => {
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.DataGenerationType,
            id: currentNode.id,
            value
          }
        }]);
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.DataGenerationType)
    }), many_to_many_enabled ? propertyactivitymenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.ManyToManyNexus)).map(x => {
        return {
          value: x.id,
          title: GetNodeTitle(x)
        };
      }),
      label: ManyToManyNexus,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation([{
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: currentNode.properties[uiactions_NodeProperties.ManyToManyNexusType],
            source: id
          }
        }, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.ManyToManyNexusType,
            id: currentNode.id,
            value
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: value,
            source: id,
            properties: { ...uiactions_LinkProperties.ManyToManyLink
            }
          }
        }]);
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexusType)
    }) : null, propertyactivitymenu_jsx(checkbox_CheckBox, {
      label: UseModelAsType,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseModelAsType] : '',
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation([value ? null : {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: currentNode.properties[uiactions_NodeProperties.UIModelType],
            source: id
          }
        }, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.UseModelAsType,
            id: currentNode.id,
            value
          }
        }, !value || !currentNode.properties[uiactions_NodeProperties.UIModelType] ? null : {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: currentNode.properties[uiactions_NodeProperties.UIModelType],
            source: id,
            properties: { ...uiactions_LinkProperties.ModelTypeLink
            }
          }
        }]);
      }
    }), !use_model_as_type ? propertyactivitymenu_jsx(selectinput_SelectInput, {
      options: Object.keys(uiactions_NodePropertyTypes).sort((a, b) => a.localeCompare(b)).map(x => {
        return {
          value: uiactions_NodePropertyTypes[x],
          title: x
        };
      }),
      label: PropertyValueType,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIAttributeType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIAttributeType] : ''
    }) : null, use_model_as_type ? propertyactivitymenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).map(x => {
        return {
          value: x.id,
          title: GetNodeTitle(x)
        };
      }),
      label: PropertyModelType,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation([{
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: currentNode.properties[uiactions_NodeProperties.UIModelType],
            source: id
          }
        }, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.UIModelType,
            id: currentNode.id,
            value
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: value,
            source: id,
            properties: { ...uiactions_LinkProperties.ModelTypeLink
            }
          }
        }]);
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIModelType] : ''
    }) : null, use_model_as_type ? propertyactivitymenu_jsx(checkbox_CheckBox, {
      label: IsReferenceList,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.IsReferenceList] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsReferenceList,
          id: currentNode.id,
          value
        });
      }
    }) : null) : null, propertyactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ModelActions
    }), propertyactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, propertyactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_ATTRIBUTE_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.AttributeLink
            }
          }
        });
      },
      icon: 'fa fa-puzzle-piece',
      title: AddAttribute,
      description: AddAttributeDescription
    })));
  }

}

/* harmony default export */ var propertyactivitymenu = (UIConnect(propertyactivitymenu_PropertyActivityMenu));
// CONCATENATED MODULE: ./app/components/selectinputproperty.js
var selectinputproperty_REACT_ELEMENT_TYPE;

function selectinputproperty_jsx(type, props, key, children) { if (!selectinputproperty_REACT_ELEMENT_TYPE) { selectinputproperty_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: selectinputproperty_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }








class selectinputproperty_SelectInputProperty extends external_react_["Component"] {
  render() {
    let {
      state,
      value,
      model,
      valueObj
    } = this.props;
    let currentNode = this.props.node;

    if (typeof valueObj === "object") {
      value = valueObj;
    }

    return selectinputproperty_jsx(selectinput_SelectInput, {
      onChange: _value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.LambdaInsertArguments),
          source: id
        });
        value[model] = _value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: nodetypes_NodeProperties.LambdaInsertArguments,
          id,
          value: value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: _value,
          source: id,
          properties: { ...uiactions_LinkProperties.LambdaInsertArguments
          }
        });
      },
      label: this.props.label,
      value: this.props.value,
      options: this.props.options
    });
  }

}

/* harmony default export */ var selectinputproperty = (UIConnect(selectinputproperty_SelectInputProperty));
// CONCATENATED MODULE: ./app/components/datachainactivitymenu.js


var datachainactivitymenu_REACT_ELEMENT_TYPE;

function datachainactivitymenu_jsx(type, props, key, children) { if (!datachainactivitymenu_REACT_ELEMENT_TYPE) { datachainactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: datachainactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















class datachainactivitymenu_DataChainActvityMenu extends external_react_["Component"] {
  getLambdaVariableTree() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    let lambdaVariables = null;

    if (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.CS)) {
      const methods = GetNodesLinkedTo(null, {
        id: currentNode.id,
        link: nodetypes_LinkType.DataChainLink,
        componentType: NodeTypes.Method
      });

      if (methods.length) {
        const functionType = uiactions_GetNodeProp(methods[0], uiactions_NodeProperties.FunctionType);
        const {
          lambda
        } = MethodFunctions[functionType];

        if (lambda && lambda.default) {
          const methodProps = GetMethodProps(methods[0]);
          lambdaVariables = datachainactivitymenu_jsx(buttonlist_ButtonList, {
            active: true,
            isSelected: () => true,
            items: Object.keys(lambda.default).filter(key => key !== "return").map(key => {
              return {
                title: `[${key}]: ${GetCodeName(methodProps[lambda.default[key]]) || lambda.default[key]}`,
                value: key,
                id: key
              };
            })
          });
        }
      }
    }

    return lambdaVariables;
  }

  render() {
    const {
      state
    } = this.props;
    const active = IsCurrentNodeA(state, uiactions_NodeTypes.DataChain);
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const dataChainFuncType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChainFunctionType);
    const showModel = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.model : false;
    const lambda = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.lambda : false;
    let inserts = [];

    if (lambda) {
      const lambdaText = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Lambda);
      inserts = getReferenceInserts(lambdaText || "").map(v => v.substr(2, v.length - 3)).unique(_insert => {
        const temp = _insert.split("@");

        const insert = temp.length > 1 ? temp[1] : temp[0];
        const args = insert.split("~").filter(x => x);
        const property = args[0];

        if (args.length > 1) {
          return args[1];
        }

        return property || _insert;
      }).map(_insert => {
        const temp = _insert.split("@");

        const insert = temp.length > 1 ? temp[1] : temp[0];
        const args = insert.split("~");
        const model = args[0];
        const property = args[1];
        let types = args.subset(1);

        if (!types.length) {
          types = [NodeTypes.Model];
        }

        const value = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.LambdaInsertArguments) || {};
        const nodes = property ? GetNodesLinkedTo(null, {
          id: value[model],
          link: nodetypes_LinkType.PropertyLink
        }) : uiactions_NodesByType(state, types); //  UIA.NodesByType(null, NodeTypes.Property);

        return datachainactivitymenu_jsx(selectinputproperty, {
          label: property ? `${model}.${property}` : model,
          model: property || model,
          valueObj: value,
          value: property ? value[property] : value[model],
          node: currentNode,
          options: nodes.toNodeSelect()
        });
      });
    }

    const showDataChainRef = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.dataref : false;
    const showNumber = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.number : false;
    const showProperty = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.property : false;
    const showNode1 = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.node_1 : false;
    const showValue = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.value : false;
    const showScreens = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.screen : false;
    const showMethods = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.method : false;
    const shownavigateMethod = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.navigateMethod : false;
    const showSelector = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.selector : false;
    const showSelectorProperty = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.selectorProperty : false;
    const showNode2 = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.node_2 : false;
    const stateKey = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.stateKey : false;
    const modelKey = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.modelKey : false;
    const viewModelKey = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.viewModelKey : false;
    const listkey = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.list : false;
    const dataChainReferences = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.datareferences : false;
    const useNavigationParms = DataChainFunctions[dataChainFuncType] ? DataChainFunctions[dataChainFuncType].ui.useParams : false;
    const datachainreferenceValues = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChainReferences) || {};
    const data_chain_entry = uiactions_GetDataChainEntryNodes().toNodeSelect();
    const selector_nodes = uiactions_NodesByType(state, NodeTypes.Selector).toNodeSelect();
    const selector_node_properties = Object.keys(SelectorPropertyKeys).map(v => ({
      title: v,
      value: SelectorPropertyKeys[v]
    }));
    const node_inputs = uiactions_NodesByType(state, NodeTypes.DataChain).filter(x => {
      return uiactions_GetNodeProp(x, nodetypes_NodeProperties.GroupParent) === uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) && x !== currentNode;
    }).toNodeSelect();
    const lists = uiactions_NodesByType(state, NodeTypes.Lists).toNodeSelect();
    const lambdaVariables = this.getLambdaVariableTree();
    return datachainactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, datachainactivitymenu_jsx(formcontrol_FormControl, {}, void 0, datachainactivitymenu_jsx(checkbox_CheckBox, {
      label: EntryPoint,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.EntryPoint),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.EntryPoint,
          id: currentNode.id,
          value: value
        });
      }
    }), datachainactivitymenu_jsx(checkboxproperty, {
      title: CSEntryPoint,
      node: currentNode,
      property: uiactions_NodeProperties.CSEntryPoint
    }), datachainactivitymenu_jsx(checkboxproperty, {
      title: CSharp,
      node: currentNode,
      property: uiactions_NodeProperties.CS
    }), datachainactivitymenu_jsx(checkbox_CheckBox, {
      label: AsOutput,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AsOutput),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.AsOutput,
          id: currentNode.id,
          value: value
        });
      }
    }), datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.DataChainFunctionType,
          id,
          value
        });
      },
      label: FunctionTypes,
      value: dataChainFuncType,
      options: Object.keys(DataChainFunctions).map(key => ({
        title: key,
        value: key
      }))
    }), showNumber ? datachainactivitymenu_jsx(textinput_TextInput, {
      onChange: value => {
        const id = currentNode.id;

        if (!isNaN(value)) {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.NumberParameter,
            id,
            value
          });
        }
      },
      label: titles_Number,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NumberParameter)
    }) : null, lambda ? datachainactivitymenu_jsx(textinput_TextInput, {
      textarea: true,
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Lambda,
          id,
          value
        });
      },
      label: Lambda,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Lambda)
    }) : null, lambda ? inserts : null, lambdaVariables, showModel ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIModelType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIModelType,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ModelTypeLink
          }
        });
      },
      label: Models,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIModelType),
      options: GetModelNodes().toNodeSelect()
    }) : null, showProperty ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Property),
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Property,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.PropertyLink
          }
        });
      },
      label: Property,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Property),
      options: GetModelPropertyChildren(uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIModelType)).toNodeSelect()
    }) : null, stateKey ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.StateKey),
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.StateKey,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.StateKey
          }
        });
      },
      label: StateKey,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.StateKey),
      options: uiactions_NodesByType(state, [NodeTypes.StateKey]).toNodeSelect()
    }) : null, modelKey ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ModelKey),
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ModelKey,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ModelKey
          }
        });
      },
      label: ModelKey,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ModelKey),
      options: uiactions_NodesByType(state, [NodeTypes.Model]).toNodeSelect()
    }) : null, viewModelKey ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ViewModelKey),
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ViewModelKey,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ViewModelKey
          }
        });
      },
      label: ViewModel,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ViewModelKey),
      options: uiactions_NodesByType(state, [NodeTypes.Screen]).toNodeSelect()
    }) : null, showDataChainRef ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          source: currentNode.properties[uiactions_NodeProperties.DataChainReference],
          target: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.DataChainReference,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          source: value,
          target: id,
          properties: { ...uiactions_LinkProperties.DataChainLink
          }
        });
      },
      label: `${DataChain}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChainReference),
      options: data_chain_entry
    }) : null, dataChainReferences ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id; // this.props.graphOperation(UIA.REMOVE_LINK_BETWEEN_NODES, {
        //   source:
        //     currentNode.properties[
        //       UIA.NodeProperties.DataChainReference
        //     ],
        //   target: id
        // });

        const currentValue = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChainReferences) || {};
        const freeKey = "abcdefghijklmnopqrstuvwxyz".split("").find(v => !currentValue[v]);
        currentValue[freeKey] = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.DataChainReferences,
          id,
          value: currentValue
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          source: value,
          target: id,
          properties: { ...uiactions_LinkProperties.DataChainLink
          }
        });
      },
      label: `${DataChain}`,
      value: Object.values(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChainReference) || {})[0],
      options: data_chain_entry
    }) : null, useNavigationParms ? datachainactivitymenu_jsx(checkbox_CheckBox, {
      label: UseNavigationParams,
      value: uiactions_GetNodeProp(currentNode, useNavigationParms),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: useNavigationParms,
          id: currentNode.id,
          value
        });
      }
    }) : null, dataChainReferences && datachainreferenceValues ? datachainactivitymenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: () => true,
      items: Object.keys(datachainreferenceValues).map(key => {
        return {
          title: `[${key}]: ${GetNodeTitle(datachainreferenceValues[key])}`,
          value: datachainreferenceValues[key],
          id: datachainreferenceValues[key]
        };
      }),
      onClick: item => {
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          source: item.value,
          target: currentNode.id
        });
        const currentValue = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.DataChainReference) || {};
        Object.keys(datachainreferenceValues).filter(v => datachainreferenceValues[v] === item.value).map(v => {
          delete currentValue[v];
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.DataChainReferences,
          id,
          value: currentValue
        });
      }
    }) : null, showSelector ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.Selector.bind(this, currentNode),
      label: `${Selector}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Selector),
      options: selector_nodes
    }) : null, showSelectorProperty ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.SelectorProperty.bind(this, currentNode),
      label: `${SelectorProperty}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.SelectorProperty),
      options: selector_node_properties
    }) : null, showScreens ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.Screen.bind(this, currentNode),
      label: `${Screen}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Screen),
      options: uiactions_NodesByType(state, NodeTypes.Screen).toNodeSelect()
    }) : null, showMethods ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.Method.bind(this, currentNode),
      label: `${Methods}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Method),
      options: uiactions_NodesByType(state, NodeTypes.Method).toNodeSelect()
    }) : null, shownavigateMethod ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.NavigationAction,
          id: currentNode.id,
          value
        });
      },
      label: `${NavigationAction}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NavigationAction),
      options: Object.keys(NavigateTypes).map(v => ({
        title: v,
        id: v,
        value: v
      }))
    }) : null, showNode1 ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.Input1.bind(this, currentNode),
      label: `${Input} 1`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ChainNodeInput1),
      options: node_inputs
    }) : null, listkey ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.List.bind(this, currentNode),
      label: `${List}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.List),
      options: lists
    }) : null, showNode2 ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: value => {
        const id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          source: currentNode.properties[uiactions_NodeProperties.ChainNodeInput2],
          target: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ChainNodeInput2,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          source: value,
          target: id,
          properties: { ...uiactions_LinkProperties.DataChainLink
          }
        });
      },
      label: `${Input} 2`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ChainNodeInput2),
      options: node_inputs
    }) : null, showValue ? datachainactivitymenu_jsx(selectinput_SelectInput, {
      onChange: DataChainContextMethods.Value.bind(this, currentNode),
      label: `${Value}`,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Value),
      options: node_inputs
    }) : null));
  }

}

/* harmony default export */ var datachainactivitymenu = (UIConnect(datachainactivitymenu_DataChainActvityMenu));
// CONCATENATED MODULE: ./app/components/aftereffectsactivitymenu.js

var aftereffectsactivitymenu_REACT_ELEMENT_TYPE;

function aftereffectsactivitymenu_jsx(type, props, key, children) { if (!aftereffectsactivitymenu_REACT_ELEMENT_TYPE) { aftereffectsactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: aftereffectsactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class aftereffectsactivitymenu_AfterEffectsActivityMenu extends external_react_["Component"] {
  getControls() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let result = [];
    let afterMethod = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AfterMethod);
    result.push(aftereffectsactivitymenu_jsx(selectinput_SelectInput, {
      label: Type,
      options: Object.keys(AFTER_EFFECTS).map(val => {
        return {
          value: val,
          title: val
        };
      }),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.AfterMethod,
          id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AfterMethod)
    }));
    let methodNode = GetMethodNode(state, currentNode.id);
    let methodProps = GetMethodProps(methodNode);

    if (afterMethod && AFTER_EFFECTS[afterMethod]) {
      let {
        templateKeys
      } = AFTER_EFFECTS[afterMethod];

      if (templateKeys) {
        Object.values(templateKeys).map(value => {
          let {
            key,
            nodeTypes,
            parent,
            useNodes,
            useMethodTypes,
            useString
          } = value;
          let setup = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AfterMethodSetup);

          if (!parent && !useNodes && !useMethodTypes && !useString) {
            result.push(aftereffectsactivitymenu_jsx(selectinput_SelectInput, {
              label: key,
              options: GetMethodNodeSelectOptions(methodProps),
              onChange: value => {
                var afterEffectSetup = SetAffterEffectProperty(currentNode, afterMethod, key, value);
                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  prop: uiactions_NodeProperties.AfterMethodSetup,
                  id: currentNode.id,
                  value: afterEffectSetup
                });
              },
              value: setup && setup[afterMethod] && setup[afterMethod][key] ? setup[afterMethod][key] : null
            }));
          } else if (setup && setup[afterMethod] && setup[afterMethod][parent]) {
            if (methodProps[setup[afterMethod][parent]]) {
              let parentNode = GetGraphNode(methodProps[setup[afterMethod][parent]]);

              if (parentNode) {
                let propertyNodes = GetLinkChain(state, {
                  id: parentNode.id,
                  links: [{
                    type: nodetypes_LinkType.PropertyLink,
                    direction: SOURCE
                  }]
                });
                result.push(aftereffectsactivitymenu_jsx(selectinput_SelectInput, {
                  label: key,
                  options: propertyNodes.toNodeSelect(),
                  onChange: value => {
                    var afterEffectSetup = SetAffterEffectProperty(currentNode, afterMethod, key, value);
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: uiactions_NodeProperties.AfterMethodSetup,
                      id: currentNode.id,
                      value: afterEffectSetup
                    });
                  },
                  value: setup && setup[afterMethod] && setup[afterMethod][key] ? setup[afterMethod][key] : null
                }));
              }
            }
          } else {
            let ae_nodes = uiactions_NodesByType(state, nodeTypes);
            let options = [];

            if (useNodes) {
              options = ae_nodes.toNodeSelect();
            } else if (useMethodTypes) {
              options = Object.keys(nodetypes_Methods).map(t => {
                return {
                  title: t,
                  value: nodetypes_Methods[t]
                };
              });
            } else if (useString) {
              options = Object.values(useString).map(t => {
                return {
                  title: t,
                  value: t
                };
              });
            }

            result.push(aftereffectsactivitymenu_jsx(selectinput_SelectInput, {
              label: key,
              options: options,
              onChange: value => {
                var afterEffectSetup = SetAffterEffectProperty(currentNode, afterMethod, key, value);
                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  prop: uiactions_NodeProperties.AfterMethodSetup,
                  id: currentNode.id,
                  value: afterEffectSetup
                });
              },
              value: setup && setup[afterMethod] && setup[afterMethod][key] ? setup[afterMethod][key] : null
            }));
          }
        });
      }
    }

    return result;
  }

  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.AfterEffect);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let controls = active ? this.getControls() : [];
    return aftereffectsactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? aftereffectsactivitymenu_jsx(formcontrol_FormControl, {}, void 0, controls) : null);
  }

}

/* harmony default export */ var aftereffectsactivitymenu = (UIConnect(aftereffectsactivitymenu_AfterEffectsActivityMenu));
// CONCATENATED MODULE: ./app/components/attributeformcontrol.js

var attributeformcontrol_REACT_ELEMENT_TYPE;

function attributeformcontrol_jsx(type, props, key, children) { if (!attributeformcontrol_REACT_ELEMENT_TYPE) { attributeformcontrol_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: attributeformcontrol_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class attributeformcontrol_AttributeFormControl extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Attribute);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var choice_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.ChoiceList).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var validation_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.ValidationList).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var show_choice = currentNode && currentNode.properties && currentNode.properties[uiactions_NodeProperties.UIAttributeType] == uiactions_NodeAttributePropertyTypes.CHOICE;
    var show_validations = Use(currentNode, uiactions_NodeProperties.UseUIValidations);
    var show_options = Use(currentNode, uiactions_NodeProperties.UseUIOptions);
    var show_extenions = Use(currentNode, uiactions_NodeProperties.UseUIExtensionList);
    var option_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.OptionList).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var extension_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.ExtensionType).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    return attributeformcontrol_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? attributeformcontrol_jsx(formcontrol_FormControl, {}, void 0, attributeformcontrol_jsx(textinput_TextInput, {
      label: UIName,
      title: UINameDescription,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIName] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIName,
          id: currentNode.id,
          value
        });
      }
    }), attributeformcontrol_jsx(selectinput_SelectInput, {
      options: Object.keys(uiactions_NodeAttributePropertyTypes).sort((a, b) => a.localeCompare(b)).map(x => {
        return {
          value: uiactions_NodeAttributePropertyTypes[x],
          title: x
        };
      }),
      label: PropertyValueType,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIAttributeType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIAttributeType] : ''
    }), show_choice ? attributeformcontrol_jsx(selectinput_SelectInput, {
      label: ChoiceTypes,
      options: choice_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIChoiceType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIChoiceType,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ChoiceLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIChoiceType] : ''
    }) : null, show_choice ? attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_CHOICE_TYPE, {});
      },
      icon: 'fa fa-puzzle-piece',
      title: AddChoice,
      description: AddChoiceDescription
    })) : null, attributeformcontrol_jsx(checkbox_CheckBox, {
      label: UISingular,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UISingular] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UISingular,
          id: currentNode.id,
          value
        });
      }
    }), attributeformcontrol_jsx(checkbox_CheckBox, {
      label: UseUIValidations,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseUIValidations] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseUIValidations,
          id: currentNode.id,
          value
        });
      }
    }), show_validations ? attributeformcontrol_jsx(selectinput_SelectInput, {
      label: ValidationTypes,
      options: validation_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIValidationType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIValidationType,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ValdationLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIValidationType] : ''
    }) : null, show_validations ? attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_VALIDATION_TYPE, {});
      },
      icon: 'fa fa-puzzle-piece',
      title: AddValidationList,
      description: AddValidationListDescription
    })) : null, attributeformcontrol_jsx(checkbox_CheckBox, {
      label: UseUIOptions,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseUIOptions] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseUIOptions,
          id: currentNode.id,
          value
        });
      }
    }), show_options ? attributeformcontrol_jsx(selectinput_SelectInput, {
      label: OptionsType,
      options: option_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIOptionType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIOptionType,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.OptionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIOptionType] : ''
    }) : null, show_options ? attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_OPTION_NODE, {});
      },
      icon: 'fa fa-puzzle-piece',
      title: AddOptionList,
      description: AddOptionListDescription
    })) : null, attributeformcontrol_jsx(checkbox_CheckBox, {
      label: UseUIExtensions,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseUIExtensionList] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseUIExtensionList,
          id: currentNode.id,
          value
        });
      }
    }), show_extenions ? attributeformcontrol_jsx(selectinput_SelectInput, {
      label: ExtensionTypes,
      options: extension_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIExtensionList],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtensionList,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExtensionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIExtensionList] : ''
    }) : null, show_extenions ? attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, attributeformcontrol_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_EXTENSION_LIST_NODE, {});
      },
      icon: 'fa fa-puzzle-piece',
      title: AddExtensionList,
      description: AddExtensionListDescription
    })) : null) : null);
  }

}

/* harmony default export */ var attributeformcontrol = (UIConnect(attributeformcontrol_AttributeFormControl));
// CONCATENATED MODULE: ./app/components/nodelist.js
var nodelist_REACT_ELEMENT_TYPE;

function nodelist_jsx(type, props, key, children) { if (!nodelist_REACT_ELEMENT_TYPE) { nodelist_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: nodelist_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















var nodelist_ref =
/*#__PURE__*/
nodelist_jsx("div", {});

class nodelist_NodeList extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    let nodeProperty = this.props.nodeProperty;
    let currentNode = this.props.node;

    if (!currentNode) {
      return nodelist_ref;
    }

    let linkType = this.props.linkType;
    let items = this.props.items; //  (UIA.GetNodeProp(currentNode, nodeProperty) || []).map(t => {
    //     let node = GetNode(UIA.GetCurrentGraph(state), t);
    //     if (node) {
    //         return {
    //             title: UIA.GetNodeTitle(node),
    //             id: node.id
    //         }
    //     }
    // });

    let {
      state
    } = this.props;
    return nodelist_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        var types = uiactions_GetNodeProp(currentNode, nodeProperty) || [];
        if (types && types.some) return item && types.some(x => x === item.id);
      },
      items: items,
      onClick: item => {
        if (this.props.removeLink) {
          this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
            target: item.value,
            source: currentNode.id
          });
        }

        if (this.props.removeNode) {
          this.props.graphOperation(REMOVE_NODE, {
            id: item.value
          });
        }
      }
    });
  }

}

/* harmony default export */ var nodelist = (UIConnect(nodelist_NodeList));
// CONCATENATED MODULE: ./app/components/permissionmenu.js
var permissionmenu_REACT_ELEMENT_TYPE;

function permissionmenu_jsx(type, props, key, children) { if (!permissionmenu_REACT_ELEMENT_TYPE) { permissionmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: permissionmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class permissionmenu_PermissionMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Condition);
    return permissionmenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, permissionmenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ModelActions
    }));
  }

}

/* harmony default export */ var permissionmenu = (UIConnect(permissionmenu_PermissionMenu));
// CONCATENATED MODULE: ./app/components/choiceactivitymenu.js

var choiceactivitymenu_REACT_ELEMENT_TYPE;

function choiceactivitymenu_jsx(type, props, key, children) { if (!choiceactivitymenu_REACT_ELEMENT_TYPE) { choiceactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: choiceactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }








class choiceactivitymenu_ChoiceActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ChoiceList);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var def = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIExtensionDefinition);
    return choiceactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, choiceactivitymenu_jsx("ul", {}, void 0, def ? Object.keys(def.definition).map((x, xi) => {
      return choiceactivitymenu_jsx("li", {}, `clist${x}-${xi}`, x);
    }) : null));
  }

}

/* harmony default export */ var choiceactivitymenu = (UIConnect(choiceactivitymenu_ChoiceActivityMenu));
// CONCATENATED MODULE: ./app/components/treeviewitemcontainer.js
var treeviewitemcontainer_REACT_ELEMENT_TYPE;

function treeviewitemcontainer_jsx(type, props, key, children) { if (!treeviewitemcontainer_REACT_ELEMENT_TYPE) { treeviewitemcontainer_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: treeviewitemcontainer_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class treeviewitemcontainer_TreeViewItemContainer extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-circle-o";
  }

  render() {
    return treeviewitemcontainer_jsx("li", {}, void 0, this.props.title, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/uiparameters.js
var uiparameters_REACT_ELEMENT_TYPE;

function uiparameters_jsx(type, props, key, children) { if (!uiparameters_REACT_ELEMENT_TYPE) { uiparameters_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: uiparameters_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















const NODE_MANAGEMENT_MENU = 'NODE_MANAGEMENT_MENU';
const NODE_MANAGEMENT = 'NODE_MANAGEMENT';

var uiparameters_ref =
/*#__PURE__*/
uiparameters_jsx("div", {});

class uiparameters_UIParameters extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      filter: ''
    };
  }

  render() {
    let me = this;
    let {
      state
    } = me.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Screen);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (!active) {
      return uiparameters_ref;
    }

    var graph = GetCurrentGraph(state);
    let filter = (this.state.filter || '').toLowerCase();
    let groups = GetNodes(state).filter(x => {
      if (!filter) {
        return false;
      }

      var str = this.toFilterString(x);
      return str.indexOf(filter) !== -1;
    }).groupBy(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType));
    let screenParameters = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ScreenParameters) || [];
    let body = screenParameters.map((t, index) => {
      return uiparameters_jsx(treeviewmenu_TreeViewMenu, {
        title: GetParameterName(t),
        hideArrow: true,
        icon: 'fa fa-terminal',
        onClick: () => {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: nodetypes_NodeProperties.ScreenParameters,
            id: currentNode.id,
            value: screenParameters.filter(x => x !== t)
          });
        }
      }, 'param' + index);
    }) || [];
    const UI_PARAMETERS = 'UI_PARAMETERS';
    const SCREEN_PARAMETERS = 'SCREEN_PARAMETERS';
    return uiparameters_jsx("div", {
      style: {
        position: 'relative'
      }
    }, void 0, uiparameters_jsx(mainsidebar_Header, {
      active: active,
      relative: true
    }, void 0, uiparameters_jsx(sidebar_SideBar, {
      relative: true,
      style: {
        paddingTop: 0
      }
    }, void 0, uiparameters_jsx(sidebarmenu_SideBarMenu, {}, void 0, uiparameters_jsx(treeviewmenu_TreeViewMenu, {
      title: `${titles_UIParameters}`,
      icon: 'fa fa-object-group',
      open: Visual(state, UI_PARAMETERS),
      active: Visual(state, UI_PARAMETERS),
      onClick: () => {
        this.props.toggleVisual(UI_PARAMETERS);
      }
    }, void 0, uiparameters_jsx(formcontrol_FormControl, {
      sidebarform: true
    }, void 0, uiparameters_jsx(textinput_TextInput, {
      value: Application(state, 'ui-parameter'),
      onClick: () => {
        let uiParameter = Application(state, 'ui-parameter');

        if (uiParameter) {
          let parameter = createScreenParameter(uiParameter);
          screenParameters.push(parameter);
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: nodetypes_NodeProperties.ScreenParameters,
            id: currentNode.id,
            value: screenParameters.unique(x => x.name)
          });
        }
      },
      onChange: value => {
        this.props.setApplication('ui-parameter', value);
      },
      inputgroup: true,
      placeholder: Filter
    })), uiparameters_jsx(treeviewmenu_TreeViewMenu, {
      icon: "fa fa-dot-circle-o",
      title: Menu,
      open: Visual(state, SCREEN_PARAMETERS),
      active: Visual(state, SCREEN_PARAMETERS),
      onClick: () => {
        this.props.toggleVisual(SCREEN_PARAMETERS);
      }
    }, void 0, body))))));
  }

}

/* harmony default export */ var uiparameters = (UIConnect(uiparameters_UIParameters));
// CONCATENATED MODULE: ./app/components/commandheader.js
var commandheader_REACT_ELEMENT_TYPE;

function commandheader_jsx(type, props, key, children) { if (!commandheader_REACT_ELEMENT_TYPE) { commandheader_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: commandheader_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }





class commandheader_CommandHeader extends external_react_["Component"] {
  icon() {
    if (this.props.open) {
      return this.props.icon || 'fa fa-angle-down';
    }

    return this.props.icon || 'fa fa-angle-left';
  }

  render() {
    return commandheader_jsx("div", {
      style: {
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        flex: 1,
        flexDirection: 'row'
      },
      onClick: () => {
        this.props.toggleVisual(this.props.visual);
      }
    }, void 0, commandheader_jsx("h4", {
      style: {
        flex: 1
      }
    }, void 0, this.props.title), commandheader_jsx("i", {
      className: `menu-icon ${this.icon()}`
    }));
  }

}

/* harmony default export */ var commandheader = (UIConnect(commandheader_CommandHeader));
// CONCATENATED MODULE: ./app/components/componentactivitymenu.js

var componentactivitymenu_REACT_ELEMENT_TYPE;

function componentactivitymenu_jsx(type, props, key, children) { if (!componentactivitymenu_REACT_ELEMENT_TYPE) { componentactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: componentactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }





















class componentactivitymenu_ComponentActivityMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  getComponentApi(prop_obj, key) {
    let {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (prop_obj && prop_obj.nodeProperty) {
      let componentApi = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ComponentApi);

      if (componentApi) {
        let selectedComponentApiProperty = key;
        let componentProperties = uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty);
        componentProperties = componentProperties || {};
        let {
          instanceType,
          model,
          isHandler,
          apiProperty,
          modelProperty
        } = componentProperties[selectedComponentApiProperty] || {};
        return [componentactivitymenu_jsx(commandheader, {
          title: apiProperty || Unknown,
          open: Visual(this.props.state, "apiProperty-title" + apiProperty),
          visual: "apiProperty-title" + apiProperty
        }), selectedComponentApiProperty ? componentactivitymenu_jsx(selectinput_SelectInput, {
          label: InstanceType,
          value: instanceType,
          options: Object.keys(InstanceTypes).map(t => ({
            title: t,
            value: InstanceTypes[t]
          })),
          onChange: value => {
            componentProperties[selectedComponentApiProperty] = componentProperties[selectedComponentApiProperty] || {};
            let temp = componentProperties[selectedComponentApiProperty];
            temp.instanceType = value;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: prop_obj.nodeProperty,
              id: currentNode.id,
              value: componentProperties
            });
          }
        }, `instanceType${apiProperty}`) : null, selectedComponentApiProperty && instanceType === InstanceTypes.ApiProperty ? componentactivitymenu_jsx(selectinput_SelectInput, {
          label: key,
          value: apiProperty,
          options: getComponentApiList(componentApi),
          onChange: value => {
            componentProperties[selectedComponentApiProperty] = componentProperties[selectedComponentApiProperty] || {};
            let temp = componentProperties[selectedComponentApiProperty];
            temp.apiProperty = value;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: prop_obj.nodeProperty,
              id: currentNode.id,
              value: componentProperties
            });
          }
        }, `apiProperty${apiProperty}`) : null, selectedComponentApiProperty && instanceType === InstanceTypes.ScreenInstance ? componentactivitymenu_jsx(selectinput_SelectInput, {
          label: Models,
          value: model,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Model).toNodeSelect(),
          onChange: value => {
            componentProperties[selectedComponentApiProperty] = componentProperties[selectedComponentApiProperty] || {};
            let temp = componentProperties[selectedComponentApiProperty];
            temp.model = value;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: prop_obj.nodeProperty,
              id: currentNode.id,
              value: componentProperties
            });
          }
        }, `model${apiProperty}`) : null, selectedComponentApiProperty && instanceType === InstanceTypes.ScreenInstance ? componentactivitymenu_jsx(selectinput_SelectInput, {
          options: GetNodesLinkedTo(GetRootGraph(state), {
            id: model,
            direction: SOURCE
          }).toNodeSelect(),
          onChange: val => {
            componentProperties[selectedComponentApiProperty] = componentProperties[selectedComponentApiProperty] || {};
            let temp = componentProperties[selectedComponentApiProperty];
            temp.modelProperty = val;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: prop_obj.nodeProperty,
              id: currentNode.id,
              value: componentProperties
            });
          },
          label: Property,
          value: modelProperty
        }, `modelProperty${apiProperty}`) : null, selectedComponentApiProperty ? componentactivitymenu_jsx(checkbox_CheckBox, {
          label: IsHandler,
          value: isHandler,
          onChange: value => {
            componentProperties[selectedComponentApiProperty] = componentProperties[selectedComponentApiProperty] || {};
            let temp = componentProperties[selectedComponentApiProperty];
            temp.isHandler = value;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: prop_obj.nodeProperty,
              id: currentNode.id,
              value: componentProperties
            });
          }
        }, `isHandler${apiProperty}`) : null].subset(0, Visual(this.props.state, "apiProperty-title" + apiProperty) ? 1000 : 1).filter(x => x);
      }
    }

    return null;
  }

  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentNode;
    let screenOption = currentNode ? GetConnectedNodeByType(state, currentNode.id, NodeTypes.ScreenOption) || GetConnectedNodeByType(state, currentNode.id, NodeTypes.ComponentNode, graph_methods_TARGET) : null;

    let _ui_type = uiactions_GetNodeProp(screenOption, uiactions_NodeProperties.UIType) || uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType);

    let componentTypes = ComponentTypes[_ui_type] || {};
    let componentType = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType);
    let components = [];

    if (componentTypes[componentType] && componentTypes[componentType].properties) {
      Object.keys(componentTypes[componentType].properties).map(key => {
        let prop_obj = componentTypes[componentType].properties[key];

        if (prop_obj && prop_obj.ui) {
          if (prop_obj.options) {
            components.push(componentactivitymenu_jsx(selectinput_SelectInput, {
              label: key,
              options: prop_obj.options.map(t => ({
                title: t,
                value: t
              })),
              value: uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty),
              onChange: value => {
                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  prop: prop_obj.nodeProperty,
                  id: currentNode.id,
                  value
                });
              }
            }, `${_ui_type} - ${componentType}- ${key}`));
          } else if (prop_obj.nodeTypes) {
            components.push(componentactivitymenu_jsx(selectinput_SelectInput, {
              label: key,
              options: uiactions_NodesByType(state, prop_obj.nodeTypes).filter(prop_obj.nodeFilter || (() => true)).toNodeSelect(),
              value: uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty),
              onChange: value => {
                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  prop: prop_obj.nodeProperty,
                  id: currentNode.id,
                  value
                });
              }
            }, `${_ui_type} - ${componentType}- ${key}`));
          } else if (prop_obj.boolean) {
            components.push(componentactivitymenu_jsx(checkbox_CheckBox, {
              label: " Use Parameter in url ",
              value: uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty),
              onChange: value => {
                this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                  prop: prop_obj.nodeProperty,
                  id: currentNode.id,
                  value
                });
              }
            }));
          } else if (prop_obj.parameterConfig) {
            components.push(this.getComponentApi(prop_obj, key));
          }
        }
      });
    }

    components = components.filter(x => x);
    return componentactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? componentactivitymenu_jsx(formcontrol_FormControl, {}, void 0, componentactivitymenu_jsx(textinput_TextInput, {
      label: Label,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Label),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Label,
          id: currentNode.id,
          value
        });
      }
    }), componentactivitymenu_jsx(selectinput_SelectInput, {
      label: UIType,
      options: Object.keys(UITypes).map(t => ({
        title: t,
        value: t
      })),
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIType,
          id: currentNode.id,
          value
        });
      }
    }), componentactivitymenu_jsx(selectinput_SelectInput, {
      label: ComponentType,
      options: Object.keys(componentTypes).map(t => ({
        title: t,
        value: t
      })),
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ComponentType,
          id: currentNode.id,
          value
        });
      }
    }), componentactivitymenu_jsx(selectproperty, {
      node: currentNode,
      title: ViewTypes,
      property: nodetypes_NodeProperties.ViewType,
      options: Object.keys(viewtypes_ViewTypes).map(v => ({
        title: v,
        value: viewtypes_ViewTypes[v],
        id: v
      }))
    })) : null, componentType && componentTypes && componentTypes[componentType] && componentTypes[componentType].layout ? componentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, componentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout()
        });
        this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
      },
      icon: "fa fa-puzzle-piece",
      title: SetupLayout,
      description: SetupLayout
    }), componentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: null
        });
        this.props.setVisual(MAIN_CONTENT, null);
      },
      icon: "fa fa-puzzle-piece",
      title: ClearLayout,
      description: ClearLayout
    }), componentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_COMPONENT_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          properties: {
            [uiactions_NodeProperties.UIType]: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType)
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ComponentLink
            }
          }
        });
        this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
      },
      icon: "fa fa-puzzle-piece",
      title: AddComponentNew,
      description: AddComponentNew
    }), uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType) === ComponentTypes.ReactNative.List.key ? componentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_COMPONENT_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          properties: {
            [uiactions_NodeProperties.UIType]: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIType)
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ListItem
            }
          }
        });
        this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
      },
      icon: "fa fa-puzzle-piece",
      title: SetListItem,
      description: SetListItem
    }) : null) : null,  false ? undefined : null);
  }

}

/* harmony default export */ var componentactivitymenu = (UIConnect(componentactivitymenu_ComponentActivityMenu));
// CONCATENATED MODULE: ./app/components/componentpropertymenu.js

var componentpropertymenu_REACT_ELEMENT_TYPE;

function componentpropertymenu_jsx(type, props, key, children) { if (!componentpropertymenu_REACT_ELEMENT_TYPE) { componentpropertymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: componentpropertymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


















class componentpropertymenu_ComponentPropertyMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = [uiactions_NodeTypes.ComponentNode, uiactions_NodeTypes.ScreenOption].some(v => v === uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType));
    let screenOption = currentNode ? GetConnectedNodeByType(state, currentNode.id, NodeTypes.ScreenOption) || GetConnectedNodeByType(state, currentNode.id, NodeTypes.ComponentNode, graph_methods_TARGET) : null;
    let componentTypes = ComponentTypes[uiactions_GetNodeProp(screenOption, uiactions_NodeProperties.UIType)] || {};
    let componentType = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType);
    let models = uiactions_NodesByType(state, NodeTypes.Model).toNodeSelect();
    let componentProps = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentProperties) || createComponentProperties();
    return componentpropertymenu_jsx(sidemenucontainer, {
      active: active,
      tab: dashboard_SCOPE_TAB,
      visual: "component-property-menu",
      title: titles_ComponentPropertyMenu
    }, void 0, componentpropertymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? componentpropertymenu_jsx(formcontrol_FormControl, {}, void 0, componentpropertymenu_jsx(selectinput_SelectInput, {
      label: Models,
      options: models,
      value: this.state.modelType,
      onChange: value => {
        this.setState({
          modelType: value
        });
      }
    }), componentpropertymenu_jsx(textinput_TextInput, {
      label: Property,
      value: this.state.modelProp,
      onChange: value => {
        this.setState({
          modelProp: value
        });
      }
    }), componentpropertymenu_jsx(selectinput_SelectInput, {
      label: InstanceType,
      value: this.state.instanceType,
      options: Object.keys(InstanceTypes).map(t => ({
        title: t,
        value: InstanceTypes[t]
      })),
      onChange: value => {
        this.setState({
          instanceType: value
        });
      }
    })) : null, componentType && componentTypes && componentTypes[componentType] ? componentpropertymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, componentpropertymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        if (this.state.modelType && this.state.modelProp) {
          if (hasComponentProperty(componentProps, this.state.modelProp)) {
            this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
              target: getComponentProperty(componentProps, this.state.modelProp),
              source: currentNode.id
            });
          }

          componentProps = addComponentProperty(componentProps, {
            instanceType: this.state.instanceType,
            modelType: this.state.modelType,
            modelProp: this.state.modelProp
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.ComponentProperties,
            id: currentNode.id,
            value: componentProps
          });
          this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
            target: this.state.modelType,
            source: currentNode.id,
            properties: { ...uiactions_LinkProperties.ComponentPropertyLink
            }
          });
        }
      },
      icon: 'fa fa-plus',
      title: Add,
      description: Add
    }), componentpropertymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        if (this.state.modelType && this.state.modelProp) {
          if (hasComponentProperty(componentProps, this.state.modelProp)) {
            this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
              target: getComponentProperty(componentProps, this.state.modelProp),
              source: currentNode.id
            });
          }

          componentProps = removeComponentProperty(componentProps, {
            instanceType: this.state.instanceType,
            modelType: this.state.modelType,
            modelProp: this.state.modelProp
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.ComponentProperties,
            id: currentNode.id,
            value: componentProps
          });
        }
      },
      icon: 'fa fa-plus',
      title: Remove,
      description: Remove
    })) : null, componentpropertymenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        return item.value === this.state.selectedItem;
      },
      items: getComponentPropertyList(uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentProperties)),
      onClick: item => {
        this.setState({
          modelType: getComponentProperty(componentProps, item.value),
          instanceType: getComponentProperty(componentProps, item.value, 'instanceTypes'),
          modelProp: item.value,
          selectedItem: item.value
        });
      }
    })));
  }

}

/* harmony default export */ var componentpropertymenu = (UIConnect(componentpropertymenu_ComponentPropertyMenu));
// CONCATENATED MODULE: ./app/components/modelfilteractivitymenu.js
var modelfilteractivitymenu_REACT_ELEMENT_TYPE;

function modelfilteractivitymenu_jsx(type, props, key, children) { if (!modelfilteractivitymenu_REACT_ELEMENT_TYPE) { modelfilteractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: modelfilteractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















class modelfilteractivitymenu_ModelFilterActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ModelFilter);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let nodes = uiactions_NodesByType(state, NodeTypes.Model).map(t => ({
      title: GetNodeTitle(t),
      value: t.id
    }));
    let agents = uiactions_NodesByType(state, NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent)).map(t => ({
      title: GetNodeTitle(t),
      value: t.id
    }));
    var input = currentNode ? modelfilteractivitymenu_jsx(selectinput_SelectInput, {
      label: Models,
      options: nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel),
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: nodetypes_NodeProperties.FilterModel,
          id: currentNode.id,
          value: value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ModelTypeLink
          }
        });
      },
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel)
    }) : null;
    var agentinput = currentNode ? modelfilteractivitymenu_jsx(selectinput_SelectInput, {
      label: Agents,
      options: agents,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterAgent),
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: nodetypes_NodeProperties.FilterAgent,
          id: currentNode.id,
          value: value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.AgentTypeLink
          }
        });
      },
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterAgent)
    }) : null;
    return modelfilteractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? modelfilteractivitymenu_jsx(formcontrol_FormControl, {}, void 0, input, agentinput) : null);
  }

}

/* harmony default export */ var modelfilteractivitymenu = (UIConnect(modelfilteractivitymenu_ModelFilterActivityMenu));
// CONCATENATED MODULE: ./app/components/componentapimenu.js
var componentapimenu_REACT_ELEMENT_TYPE;

function componentapimenu_jsx(type, props, key, children) { if (!componentapimenu_REACT_ELEMENT_TYPE) { componentapimenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: componentapimenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }











class componentapimenu_ComponentAPIMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = [uiactions_NodeTypes.ComponentNode, uiactions_NodeTypes.ScreenOption].some(v => v === uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType));
    return componentapimenu_jsx(sidemenucontainer, {
      active: active,
      tab: dashboard_SCOPE_TAB,
      visual: "component-api-menu",
      title: titles_ComponentAPIMenu
    }, void 0, componentapimenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, componentapimenu_jsx(checkboxproperty, {
      title: ExecuteButton,
      property: nodetypes_NodeProperties.ExecuteButton,
      node: currentNode
    })));
  }

}

/* harmony default export */ var componentapimenu = (UIConnect(componentapimenu_ComponentAPIMenu));
// CONCATENATED MODULE: ./app/components/validationactivitymenu.js
var validationactivitymenu_REACT_ELEMENT_TYPE;

function validationactivitymenu_jsx(type, props, key, children) { if (!validationactivitymenu_REACT_ELEMENT_TYPE) { validationactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: validationactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }








class validationactivitymenu_ValidationActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ValidationList);
    return validationactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, validationactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ValidationListActions
    }), validationactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, validationactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_VALIDATION_ITEM_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...uiactions_LinkProperties.ValidationLinkItem
            }
          }
        });
      },
      icon: 'fa fa-puzzle-piece',
      title: AddValidationItem,
      description: AddValidationItemDescription
    })));
  }

}

/* harmony default export */ var validationactivitymenu = (UIConnect(validationactivitymenu_ValidationActivityMenu));
// CONCATENATED MODULE: ./app/components/validationitemactivitymenu.js

var validationitemactivitymenu_REACT_ELEMENT_TYPE;

function validationitemactivitymenu_jsx(type, props, key, children) { if (!validationitemactivitymenu_REACT_ELEMENT_TYPE) { validationitemactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: validationitemactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class validationitemactivitymenu_ValidationItemFormControl extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ValidationListItem);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    return validationitemactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? validationitemactivitymenu_jsx(formcontrol_FormControl, {}, void 0, validationitemactivitymenu_jsx(selectinput_SelectInput, {
      options: Object.keys(uiactions_ValidationRules).sort((a, b) => a.localeCompare(b)).map(x => {
        return {
          value: uiactions_ValidationRules[x],
          title: x
        };
      }),
      label: ValidationType,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIValidationType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIValidationType] : ''
    })) : null);
  }

}

/* harmony default export */ var validationitemactivitymenu = (UIConnect(validationitemactivitymenu_ValidationItemFormControl));
// CONCATENATED MODULE: ./app/components/validatoractivitymenu.js
var validatoractivitymenu_REACT_ELEMENT_TYPE;

function validatoractivitymenu_jsx(type, props, key, children) { if (!validatoractivitymenu_REACT_ELEMENT_TYPE) { validatoractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: validatoractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













class validatoractivitymenu_ValidatorActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Validator);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var modelNodes = uiactions_NodesByType(state, uiactions_NodeTypes.Model).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    var functionNodes = uiactions_NodesByType(state, [uiactions_NodeTypes.Method, uiactions_NodeTypes.Function]).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    var agents = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent)).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    return validatoractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode && false ? validatoractivitymenu_jsx(formcontrol_FormControl, {}, void 0, validatoractivitymenu_jsx(selectinput_SelectInput, {
      options: modelNodes,
      label: Models,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ValidatorModel],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ValidatorModel,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ValidatorModelLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ValidatorModel] : ""
    }), validatoractivitymenu_jsx(selectinput_SelectInput, {
      options: agents,
      label: Agents,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ValidatorAgent],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ValidatorAgent,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ValidatorAgentLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ValidatorAgent] : ""
    }), validatoractivitymenu_jsx(selectinput_SelectInput, {
      options: functionNodes,
      label: Functions,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ValidatorFunction],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ValidatorFunction,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ValidatorFunctionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ValidatorFunction] : ""
    })) : null, validatoractivitymenu_jsx("button", {
      type: "submit",
      className: "btn btn-primary",
      onClick: () => {
        this.props.graphOperation(NEW_CONDITION_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ConditionLink
            }
          }
        });
      }
    }, void 0, AddCondition));
  }

}

/* harmony default export */ var validatoractivitymenu = (UIConnect(validatoractivitymenu_ValidatorActivityMenu));
// CONCATENATED MODULE: ./app/components/optionactivitymenu.js
var optionactivitymenu_REACT_ELEMENT_TYPE;

function optionactivitymenu_jsx(type, props, key, children) { if (!optionactivitymenu_REACT_ELEMENT_TYPE) { optionactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: optionactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }








class optionactivitymenu_OptionActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.OptionList);
    return optionactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, optionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: OptionListActions
    }), optionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, optionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_OPTION_ITEM_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...uiactions_LinkProperties.OptionItemLink
            }
          }
        });
      },
      icon: 'fa fa-puzzle-piece',
      title: AddOptionItem,
      description: AddOptionItemDescription
    })));
  }

}

/* harmony default export */ var optionactivitymenu = (UIConnect(optionactivitymenu_OptionActivityMenu));
// EXTERNAL MODULE: external "child_process"
var external_child_process_ = __webpack_require__("child_process");

// CONCATENATED MODULE: ./app/components/executorpropertymenu.js

var executorpropertymenu_REACT_ELEMENT_TYPE;

function executorpropertymenu_jsx(type, props, key, children) { if (!executorpropertymenu_REACT_ELEMENT_TYPE) { executorpropertymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: executorpropertymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




















var executorpropertymenu_ref =
/*#__PURE__*/
executorpropertymenu_jsx("i", {
  className: "fa fa-cube"
});

var executorpropertymenu_ref2 =
/*#__PURE__*/
executorpropertymenu_jsx("i", {
  className: "fa  fa-copy"
});

class executorpropertymenu_ExecutorPropertyMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Executor);
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var executor;

    if (currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExecutorModel)) {
      // var propertyNodes = getNodesByLinkType(graph, {
      //     id: UIA.GetNodeProp(currentNode, UIA.NodeProperties.ExecutorModel),
      //     direction: SOURCE,
      //     type: LinkType.PropertyLink
      // }).filter(x => UIA.GetNodeProp(x, NodeProperties.NODEType) !== NodeTypes.Model).toNodeSelect();
      var propertyNodes = GetModelPropertyChildren(uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExecutorModel)).toNodeSelect();
      executor = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor);
    }

    let addProperty = values => {
      let executor = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createExecutor();
      var operation = values.map(value => {
        var id = currentNode.id;
        executor = addValidatator(executor, {
          id: value
        });
        return [{
          operation: CHANGE_NODE_PROPERTY,
          options: function () {
            return {
              id: currentNode.id,
              prop: nodetypes_NodeProperties.Executor,
              value: executor,
              callback: _updatedExecutor => {
                executor = _updatedExecutor;
              }
            };
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: function () {
            return {
              target: value,
              source: id,
              properties: { ...uiactions_LinkProperties.ExecutorModelLink,
                ...createEventProp(LinkEvents.Remove, {
                  function: "OnRemoveExecutorPropConnection"
                })
              }
            };
          }
        }];
      }).flatten();
      this.props.graphOperation(operation);
    };

    return executorpropertymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? executorpropertymenu_jsx(formcontrol_FormControl, {}, void 0, executorpropertymenu_jsx("div", {
      className: "btn-group"
    }, void 0, executorpropertymenu_jsx("button", {
      onClick: () => {
        addProperty(propertyNodes.filter(x => !uiactions_GetNodeProp(x.value, nodetypes_NodeProperties.IsDefaultProperty)).map(t => {
          return t.value;
        }));
      },
      type: "button",
      title: AddAllProperties,
      className: "btn btn-default btn-flat"
    }, void 0, executorpropertymenu_ref), executorpropertymenu_jsx("button", {
      onClick: () => {
        if (executor && executor.properties) {
          Object.keys(executor.properties).map(key => {
            executor = addValidatator(executor, {
              id: key,
              validator: uuidv4(),
              validatorArgs: {
                type: ExecutorRules.Copy,
                ...ExecutorUI[ExecutorRules.Copy]
              }
            });
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            id: currentNode.id,
            prop: this.props.nodeProp || nodetypes_NodeProperties.Executor,
            value: executor
          });
        }
      },
      type: "button",
      title: ApplyCopyToAllProperties,
      className: "btn btn-default btn-flat"
    }, void 0, executorpropertymenu_ref2)), executorpropertymenu_jsx(selectinput_SelectInput, {
      options: propertyNodes,
      defaultSelectText: titles_SelectProperty,
      label: Property,
      onChange: v => addProperty([v]),
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ExecutorModel] : ""
    })) : null);
  }

}

/* harmony default export */ var executorpropertymenu = (UIConnect(executorpropertymenu_ExecutorPropertyMenu));
// CONCATENATED MODULE: ./app/components/configurationactivitymenu.js

var configurationactivitymenu_REACT_ELEMENT_TYPE;

function configurationactivitymenu_jsx(type, props, key, children) { if (!configurationactivitymenu_REACT_ELEMENT_TYPE) { configurationactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: configurationactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














class configurationactivitymenu_ConfigurationActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Configuration);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var graph = GetCurrentGraph(state);
    let appSettingComponents = [];
    let appSettings;

    if (graph) {
      appSettings = GetAppSettings(graph);
      appSettingComponents = Object.keys(appSettings || {}).map(key => {
        if (typeof appSettings[key] === 'boolean') {
          configurationactivitymenu_jsx(checkbox_CheckBox, {
            label: key,
            value: appSettings[key],
            onChange: value => {
              this.props.graphOperation(CHANGE_APP_SETTINGS, {
                prop: key,
                value: value
              });
            }
          }, key);
        }

        return configurationactivitymenu_jsx(textinput_TextInput, {
          label: key,
          value: appSettings[key],
          onChange: value => {
            this.props.graphOperation(CHANGE_APP_SETTINGS, {
              prop: key,
              value: value
            });
          }
        }, key);
      });
    }

    return configurationactivitymenu_jsx(tabpane_TabPane, {
      active: active,
      style: {
        maxHeight: 400,
        overflow: 'auto'
      }
    }, void 0, configurationactivitymenu_jsx(checkbox_CheckBox, {
      label: UseHttps,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UseHttps),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseHttps,
          id: currentNode.id,
          value
        });
      }
    }), Object.keys(ConfigurationProperties).map(key => {
      return configurationactivitymenu_jsx(textinput_TextInput, {
        label: key,
        value: uiactions_GetNodeProp(currentNode, key),
        onChange: value => {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: key,
            id: currentNode.id,
            value: value
          });
        }
      }, `${key}-asdf`);
    }), appSettingComponents);
  }

}

/* harmony default export */ var configurationactivitymenu = (UIConnect(configurationactivitymenu_ConfigurationActivityMenu));
// CONCATENATED MODULE: ./app/components/conditionactivitymenu.js

var conditionactivitymenu_REACT_ELEMENT_TYPE;

function conditionactivitymenu_jsx(type, props, key, children) { if (!conditionactivitymenu_REACT_ELEMENT_TYPE) { conditionactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: conditionactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














class conditionactivitymenu_ConditionActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Condition);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var conditionType = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ConditionType);
    var graph = GetCurrentGraph(state);
    var methods = currentNode ? GetLinkChain(state, {
      id: currentNode.id,
      links: [{
        type: nodetypes_LinkType.Condition,
        direction: graph_methods_TARGET
      }, {
        type: nodetypes_LinkType.FunctionOperator,
        direction: graph_methods_TARGET
      }]
    }) : [];
    let ref2_properties = [];
    let ref1_properties = [];
    let matchRef = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
    var model_options = [];
    var functions = methods.map(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)).filter(x => x);

    if (ConditionFunctionSetups[conditionType] && ConditionFunctionSetups[conditionType].functions && functions && functions.length === 1) {
      let {
        constraints
      } = ConditionFunctionSetups[conditionType].functions[functions[0]];

      if (constraints) {
        let methodProps = uiactions_GetNodeProp(methods[0], nodetypes_NodeProperties.MethodProps);
        model_options = Object.keys(constraints).filter(t => constraints[t].nodeTypes.indexOf(NodeTypes.Model) !== -1).map(x => {
          if (methodProps && methodProps[x]) {
            return {
              title: `${uiactions_GetNodeProp(GetNode(graph, methodProps[x]), nodetypes_NodeProperties.UIText) || x}(${x})`,
              value: x
            };
          }

          return {
            title: x,
            value: x
          };
        });

        if (methodProps) {
          var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};

          if (temp.ref2) {
            ref2_properties = this.getProperties(methodProps, temp, state, 'ref2');
          }

          if (temp.ref1) {
            ref1_properties = this.getProperties(methodProps, temp, state, 'ref1');
          }
        }
      }
    }

    return conditionactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, conditionactivitymenu_jsx(textinput_TextInput, {
      label: NodeLabel,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIText),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_TEXT, {
          id: currentNode.id,
          value
        });
      }
    }), conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: ConditionType,
      options: Object.keys(ConditionTypes).map(t => ({
        title: t,
        value: ConditionTypes[t]
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ConditionType,
          id: currentNode.id,
          value
        });
      },
      value: conditionType
    }), this.getMatchManyReferenceProperty({
      conditionType,
      model_options,
      currentNode,
      methods
    }), this.getEnumeration({
      conditionType,
      graph,
      model_options,
      currentNode,
      methods
    }), this.getMatchReferenceProperty({
      conditionType,
      model_options,
      currentNode,
      methods,
      graph
    }));
  }

  getProperties(methodProps, temp, state, key = 'ref2') {
    let refId = methodProps[temp[key]];
    let properties = [];
    let nodeProperties = GetModelPropertyNodes(refId);
    let currentNode = GetNodeById(refId);

    if (nodeProperties) {
      properties = nodeProperties.toNodeSelect();
    }

    let logicalChildren = GetLogicalChildren(currentNode.id);
    properties = [...properties, ...logicalChildren.toNodeSelect()];
    return properties;
  }

  getEnumeration(options) {
    var {
      conditionType,
      model_options,
      graph,
      currentNode,
      methods
    } = options;
    var {
      state
    } = this.props;
    var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.EnumerationReference) || {};

    if (conditionType !== ConditionTypes.InEnumerable) {
      return [];
    }

    let methodProps = uiactions_GetNodeProp(methods ? methods[0] : null, nodetypes_NodeProperties.MethodProps);
    var ref1_properties = [];
    var ref2_properties = [];
    var refManyToMany_properties = [];
    var permissionNode = GetLinkChain(state, {
      id: currentNode.id,
      links: [{
        type: nodetypes_LinkType.Condition,
        direction: graph_methods_TARGET
      }]
    })[0];
    var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.EnumerationReference) || {
      ref1: GetNodeProp(permissionNode, uiactions_NodeProperties.PermissionRequester)
    };

    if (temp.ref2) {
      ref2_properties = this.getProperties(methodProps, temp, state, 'ref2');
    }

    if (temp.ref1) {
      ref1_properties = this.getProperties(methodProps, temp, state, 'ref1');
    }

    if (temp[ConditionTypeParameters.RefManyToMany]) {
      refManyToMany_properties = this.getProperties(methodProps, temp, state, 'refManyToMany');
    }

    var enumeration = temp && temp[uiactions_NodeProperties.Enumeration] ? temp[uiactions_NodeProperties.Enumeration] : '';
    var allowed = temp && temp[uiactions_NodeProperties.AllowedEnumValues] ? temp[uiactions_NodeProperties.AllowedEnumValues] : [];
    var disallowed = [];

    if (enumeration) {
      var enumerationNode = GetNode(graph, enumeration);

      if (enumerationNode) {
        var enumerationValues = uiactions_GetNodeProp(enumerationNode, nodetypes_NodeProperties.Enumeration) || [];
        allowed = allowed.intersection(enumerationValues);
        disallowed = enumerationValues.relativeCompliment(allowed);
      }
    }

    let matchRef = { ...temp
    };
    var enumeration_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Enumeration).toNodeSelect();
    return [conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Reference,
      options: model_options,
      onChange: value => {
        temp.ref1 = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.EnumerationReference,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref1
    }), conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Property,
      options: ref1_properties,
      onChange: value => {
        temp.ref1Property = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.EnumerationReference,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref1Property
    }), currentNode ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Enumeration,
      options: enumeration_nodes,
      onChange: value => {
        var id = currentNode.id;
        let target = temp[uiactions_NodeProperties.Enumeration] || '';
        temp[uiactions_NodeProperties.Enumeration] = value;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target,
          source: id,
          linkType: uiactions_LinkProperties.EnumerationReferenceLink.type
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.EnumerationReference,
          id,
          value: temp
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.EnumerationReferenceLink
          }
        });
      },
      value: temp[uiactions_NodeProperties.Enumeration] || ''
    }, `${currentNode.id}-enum`) : null, conditionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: AllowedEnums
    }, `${currentNode.id}-allowed-enum-title`), allowed && allowed.length ? allowed.map(_enum => {
      return conditionactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          var disallowed = enumerationValues.relativeCompliment([...allowed].filter(x => x !== _enum));
          temp[uiactions_NodeProperties.AllowedEnumValues] = [...allowed].filter(x => x !== _enum);
          temp[uiactions_NodeProperties.DisallowedEnumValues] = disallowed;
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.EnumerationReference,
            id: currentNode.id,
            value: temp
          });
        }
      }, `allowed-${_enum}`, " ", _enum);
    }) : null, conditionactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: DisallowedEnums
    }, `${currentNode.id}-disalloweditem-title`), disallowed && disallowed.length ? disallowed.map(_enum => {
      return conditionactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          var disallowed = enumerationValues.relativeCompliment([...allowed, _enum].unique());
          temp[uiactions_NodeProperties.AllowedEnumValues] = [...allowed, _enum].unique();
          temp[uiactions_NodeProperties.DisallowedEnumValues] = disallowed;
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.EnumerationReference,
            id: currentNode.id,
            value: temp
          });
        }
      }, `disallowed-${_enum}`, " ", _enum);
    }) : null];
  }

  getMatchManyReferenceProperty(options) {
    var {
      conditionType,
      model_options,
      currentNode,
      methods
    } = options;
    var {
      state
    } = this.props;
    var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchManyReferenceParameter) || {};
    let methodProps = uiactions_GetNodeProp(methods ? methods[0] : null, nodetypes_NodeProperties.MethodProps);
    var ref1_properties = [];
    var ref2_properties = [];
    var refManyToMany_properties = [];
    var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchManyReferenceParameter) || {};

    if (temp.ref2) {
      ref2_properties = this.getProperties(methodProps, temp, state, 'ref2');
    }

    if (temp.ref1) {
      ref1_properties = this.getProperties(methodProps, temp, state, 'ref1');
    }

    if (temp[ConditionTypeParameters.RefManyToMany]) {
      refManyToMany_properties = this.getProperties(methodProps, temp, state, 'refManyToMany');
    }

    let matchRef = { ...temp
    };
    return [conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Reference,
      options: model_options,
      onChange: value => {
        temp.ref1 = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref1
    }) : null, matchRef.ref1 && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(checkbox_CheckBox, {
      label: UseId,
      value: matchRef.ref1UseId,
      onChange: value => {
        temp.ref1UseId = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      }
    }) : null, matchRef.ref1 && !temp.ref1UseId && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Property,
      options: ref1_properties,
      onChange: value => {
        temp.ref1Property = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref1Property
    }) : null, conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Reference,
      options: model_options,
      onChange: value => {
        temp.ref2 = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref2
    }) : null, matchRef.ref2 && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(checkbox_CheckBox, {
      label: UseId,
      value: matchRef.ref2UseId,
      onChange: value => {
        temp.ref2UseId = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      }
    }) : null, matchRef.ref2 && !temp.ref2UseId && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Property,
      options: ref2_properties,
      onChange: value => {
        temp.ref2Property = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref2Property
    }) : null, matchRef.ref1 && matchRef.ref2 && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: ManyToManyNexus,
      options: model_options,
      onChange: value => {
        temp[ConditionTypeParameters.RefManyToMany] = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef[ConditionTypeParameters.RefManyToMany]
    }) : null, matchRef.ref2 && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(checkbox_CheckBox, {
      label: ManyToManyExists,
      value: matchRef.refManyToManyExists,
      onChange: value => {
        temp.refManyToManyExists = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      }
    }) : null, matchRef.ref1 && matchRef.ref2 && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Property,
      options: refManyToMany_properties,
      onChange: value => {
        temp.refManyToManyProperty = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.refManyToManyProperty
    }) : null, matchRef.refManyToManyProperty && matchRef.ref1 && matchRef.ref2 && conditionType == ConditionTypes.MatchManyReferenceParameter ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      title: Condition,
      label: Condition,
      options: [...Object.keys(ConditionTypeOptions)].map(t => ({
        title: t,
        value: t
      })),
      value: matchRef.refManyToManyCondition,
      onChange: value => {
        temp.refManyToManyCondition = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MatchManyReferenceParameter,
          id: currentNode.id,
          value: temp
        });
      }
    }) : null].filter(x => x).map((x, index) => {
      return x;
    });
  }

  getMatchReferenceProperty(options) {
    var {
      conditionType,
      model_options,
      currentNode,
      methods
    } = options;

    if (conditionType !== ConditionTypes.MatchReference) {
      return null;
    }

    var {
      state
    } = this.props;
    var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
    let methodProps = uiactions_GetNodeProp(methods ? methods[0] : null, nodetypes_NodeProperties.MethodProps);
    var ref1_properties = [];
    var ref2_properties = [];
    var refManyToMany_properties = [];
    var propertyType = uiactions_NodeProperties.MatchReference;

    if (temp.ref2) {
      ref2_properties = this.getProperties(methodProps, temp, state, 'ref2');
    }

    if (temp.ref1) {
      ref1_properties = this.getProperties(methodProps, temp, state, 'ref1');
    }

    if (temp[ConditionTypeParameters.RefManyToMany]) {
      refManyToMany_properties = this.getProperties(methodProps, temp, state, 'refManyToMany');
    }

    let matchRef = { ...temp
    };
    return [conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Reference,
      options: model_options,
      onChange: value => {
        var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
        temp.ref1 = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: propertyType,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref1
    }), matchRef.ref1 ? conditionactivitymenu_jsx(checkbox_CheckBox, {
      label: UseId,
      value: matchRef.ref1UseId,
      onChange: value => {
        var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
        temp.ref1UseId = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: propertyType,
          id: currentNode.id,
          value: temp
        });
      }
    }) : null, matchRef.ref1 && !temp.ref1UseId ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Property,
      options: ref1_properties,
      onChange: value => {
        var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
        temp[ConditionTypeParameters.Ref1Property] = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: propertyType,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref1Property
    }) : null, conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Reference,
      options: model_options,
      onChange: value => {
        var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
        temp.ref2 = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: propertyType,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref2
    }), matchRef.ref2 ? conditionactivitymenu_jsx(checkbox_CheckBox, {
      label: UseId,
      value: matchRef.ref2UseId,
      onChange: value => {
        var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
        temp.ref2UseId = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: propertyType,
          id: currentNode.id,
          value: temp
        });
      }
    }) : null, matchRef.ref2 && !temp.ref2UseId ? conditionactivitymenu_jsx(selectinput_SelectInput, {
      label: Property,
      options: ref2_properties,
      onChange: value => {
        var temp = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MatchReference) || {};
        temp.ref2Property = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: propertyType,
          id: currentNode.id,
          value: temp
        });
      },
      value: matchRef.ref2Property
    }) : null].filter(x => x);
  }

}

/* harmony default export */ var conditionactivitymenu = (UIConnect(conditionactivitymenu_ConditionActivityMenu));
// CONCATENATED MODULE: ./app/components/parameteractivitymenu.js

var parameteractivitymenu_REACT_ELEMENT_TYPE;

function parameteractivitymenu_jsx(type, props, key, children) { if (!parameteractivitymenu_REACT_ELEMENT_TYPE) { parameteractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: parameteractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













class parameteractivitymenu_ParameterActivityMenu extends external_react_["Component"] {
  mustBeModel(currentNode) {
    var {
      state
    } = this.props;
    var links = getNodeLinks(GetCurrentGraph(state), currentNode.id, graph_methods_TARGET);

    for (var i = 0; i < links.length; i++) {
      var x = links[i];
      var constraint = GetLinkProperty(x, LinkPropertyKeys.CONSTRAINTS);

      if (constraint && constraint[FunctionConstraintKeys.IsModel]) {
        return true;
      }
    }

    return false;
  }

  mustBeProperty(currentNode) {
    var {
      state
    } = this.props;
    var links = getNodeLinks(GetCurrentGraph(state), currentNode.id, graph_methods_TARGET);

    for (var i = 0; i < links.length; i++) {
      var x = links[i];
      var constraint = GetLinkProperty(x, LinkPropertyKeys.CONSTRAINTS);

      if (constraint && constraint[FunctionConstraintKeys.IsProperty]) {
        return true;
      }
    }

    return false;
  }

  mustBeFunction(currentNode) {
    var {
      state
    } = this.props;
    var links = getNodeLinks(GetCurrentGraph(state), currentNode.id, graph_methods_TARGET);

    for (var i = 0; i < links.length; i++) {
      var x = links[i];
      var constraint = GetLinkProperty(x, LinkPropertyKeys.CONSTRAINTS);

      if (constraint && constraint[FunctionConstraintKeys.IsFunction]) {
        return true;
      }
    }

    return false;
  }

  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Parameter);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var linkedNodes = [];
    var nodes = [];

    if (currentNode && active) {
      linkedNodes = getNodesLinkedFrom(GetCurrentGraph(state), {
        id: currentNode.id
      });
      var musBeModel = this.mustBeModel(currentNode);

      if (musBeModel) {
        nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Model).map(node => {
          return {
            value: node.id,
            title: GetNodeTitle(node)
          };
        });
      } else if (this.mustBeProperty(currentNode)) {
        nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Property).map(node => {
          return {
            value: node.id,
            title: GetNodeTitle(node)
          };
        });
      } else if (this.mustBeFunction(currentNode)) {
        nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Function).map(node => {
          return {
            value: node.id,
            title: GetNodeTitle(node)
          };
        });
      }
    }

    return parameteractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode && linkedNodes.length === 0 ? parameteractivitymenu_jsx(selectinput_SelectInput, {
      label: ParameterType,
      options: Object.keys(uiactions_NodePropertyTypes).sort((a, b) => a.localeCompare(b)).map(x => {
        return {
          value: uiactions_NodePropertyTypes[x],
          title: x
        };
      }),
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.CodePropertyType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.CodePropertyType] : ''
    }) : null, currentNode ? parameteractivitymenu_jsx(selectinput_SelectInput, {
      label: ChoiceTypes,
      options: nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIChoiceNode],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIChoiceNode,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ChoiceLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIChoiceNode] : ''
    }) : null);
  }

}

/* harmony default export */ var parameteractivitymenu = (UIConnect(parameteractivitymenu_ParameterActivityMenu));
// CONCATENATED MODULE: ./app/components/optionitemformcontrol.js

var optionitemformcontrol_REACT_ELEMENT_TYPE;

function optionitemformcontrol_jsx(type, props, key, children) { if (!optionitemformcontrol_REACT_ELEMENT_TYPE) { optionitemformcontrol_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: optionitemformcontrol_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class optionitemformcontrol_OptionItemFormControl extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.OptionListItem);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var show_custom = currentNode && currentNode.properties && currentNode.properties[uiactions_NodeProperties.UseCustomUIOption];
    var custom_options = uiactions_NodesByType(state, uiactions_NodeTypes.OptionCustom).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    return optionitemformcontrol_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? optionitemformcontrol_jsx(formcontrol_FormControl, {}, void 0, optionitemformcontrol_jsx(checkbox_CheckBox, {
      label: UseCustomOption,
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UseCustomUIOption] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseCustomUIOption,
          id: currentNode.id,
          value
        });
      }
    }), show_custom ? optionitemformcontrol_jsx(selectinput_SelectInput, {
      options: custom_options,
      label: OptionsType,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIOptionTypeCustom],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIOptionTypeCustom,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.OptionCustomLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIOptionTypeCustom] : ''
    }) : optionitemformcontrol_jsx(selectinput_SelectInput, {
      options: Object.keys(uiactions_OptionsTypes).sort((a, b) => a.localeCompare(b)).map(x => {
        return {
          value: uiactions_OptionsTypes[x],
          title: x
        };
      }),
      label: OptionsType,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIOptionType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIOptionType] : ''
    }), show_custom ? optionitemformcontrol_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, optionitemformcontrol_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_CUSTOM_OPTION, {});
      },
      icon: 'fa fa-puzzle-piece',
      title: AddOptionList,
      description: AddOptionListDescription
    })) : null) : null);
  }

}

/* harmony default export */ var optionitemformcontrol = (UIConnect(optionitemformcontrol_OptionItemFormControl));
// CONCATENATED MODULE: ./app/components/executorpropertyactivitymenu.js

var executorpropertyactivitymenu_REACT_ELEMENT_TYPE;

function executorpropertyactivitymenu_jsx(type, props, key, children) { if (!executorpropertyactivitymenu_REACT_ELEMENT_TYPE) { executorpropertyactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: executorpropertyactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














var executorpropertyactivitymenu_ref =
/*#__PURE__*/
executorpropertyactivitymenu_jsx("div", {});

var executorpropertyactivitymenu_ref2 =
/*#__PURE__*/
executorpropertyactivitymenu_jsx("div", {});

class executorpropertyactivitymenu_ExecutorPropertyActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, this.props.nodeType || uiactions_NodeTypes.Executor);

    if (!active) {
      return executorpropertyactivitymenu_ref;
    }

    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var executor;

    if (active && currentNode && uiactions_GetNodeProp(currentNode, this.props.modelKey || uiactions_NodeProperties.ExecutorModel)) {
      executor = uiactions_GetNodeProp(currentNode, this.props.nodeProp || nodetypes_NodeProperties.Executor);
    }

    let _ui = this.props.ui || ExecutorUI;

    let propertyExecutors = executorpropertyactivitymenu_ref2;

    if (executor && executor.properties) {
      propertyExecutors = Object.keys(executor.properties).map(key => {
        let _validates = executor.properties[key];
        let visualKey = `ExecutorPropertyActivityMenu${key}-${currentNode.id}`;
        let temp = Object.keys(_validates && _validates.validators ? _validates.validators : {});
        let selectedValidationsCount = temp.length;
        let selectedValidations = temp.map(v => {
          let selK = `${visualKey}-selected-validation`;
          let selKInner = `${selK}-inne-${v}-r`;
          return executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
            title: _validates.validators && _validates.validators[v] && _validates.validators[v].type ? _validates.validators[v].type : v,
            open: Visual(state, selKInner),
            active: Visual(state, selKInner),
            toggle: () => {
              this.props.toggleVisual(selKInner);
            },
            icon: 'fa fa-tag'
          }, `${v}-v-v`, executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
            hideArrow: true,
            title: Remove,
            icon: 'fa fa-minus',
            onClick: () => {
              let id = currentNode.id;
              let validator = uiactions_GetNodeProp(currentNode, this.props.nodeProp || nodetypes_NodeProperties.Executor) || createValidator();
              let _validates = validator.properties[key];
              delete _validates.validators[v];
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: this.props.nodeProp || nodetypes_NodeProperties.Executor,
                value: validator
              });
            }
          }), executorpropertyactivitymenu_jsx(executoritem, {
            node: currentNode.id,
            property: key,
            validator: v
          }));
        });
        let validationUis = Object.keys(_ui).filter(x => !_validates || !_validates.validators || !_validates.validators[x]).reverse().map(executorUI => {
          return executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
            hideArrow: true,
            title: executorUI,
            icon: 'fa fa-plus-square-o',
            onClick: () => {
              let id = currentNode.id;
              var executor = uiactions_GetNodeProp(currentNode, this.props.nodeProp || nodetypes_NodeProperties.Executor) || createValidator();
              executor = addValidatator(executor, {
                id: key,
                validator: uuidv4(),
                validatorArgs: {
                  type: executorUI,
                  ..._ui[executorUI]
                }
              });
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: this.props.nodeProp || nodetypes_NodeProperties.Executor,
                value: executor
              });
            }
          }, `${executorUI}-afjlskf-asfd`);
        });
        return executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, visualKey),
          active: Visual(state, visualKey),
          title: GetNodeTitle(GetNode(graph, key)),
          toggle: () => {
            this.props.toggleVisual(visualKey);
          }
        }, visualKey, executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          hideArrow: true,
          title: RemoveExecution,
          icon: 'fa fa-minus',
          onClick: () => {
            let id = currentNode.id;
            this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
              target: key,
              source: id
            });
          }
        }), executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${SelectedExecutors}(${selectedValidationsCount})`,
          icon: 'fa  fa-list-ul',
          open: Visual(state, `${visualKey}-selected-executions`),
          active: Visual(state, `${visualKey}-selected-executions`),
          toggle: () => {
            this.props.toggleVisual(`${visualKey}-selected-executions`);
          }
        }, void 0, selectedValidations), executorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          title: SelectExecution,
          icon: 'fa fa-plus-circle',
          open: Visual(state, `${visualKey}-selectexecution`),
          active: Visual(state, `${visualKey}-selectexecution`),
          toggle: () => {
            this.props.toggleVisual(`${visualKey}-selectexecution`);
          }
        }, void 0, validationUis));
      });
      propertyExecutors = executorpropertyactivitymenu_jsx("div", {
        style: {
          position: 'relative'
        }
      }, void 0, executorpropertyactivitymenu_jsx(mainsidebar_Header, {}, void 0, executorpropertyactivitymenu_jsx(sidebar_SideBar, {
        style: {
          maxHeight: 600,
          overflowY: 'auto'
        }
      }, void 0, executorpropertyactivitymenu_jsx(sidebarmenu_SideBarMenu, {}, void 0, propertyExecutors))));
    }

    return propertyExecutors;
  }

}

/* harmony default export */ var executorpropertyactivitymenu = (UIConnect(executorpropertyactivitymenu_ExecutorPropertyActivityMenu));
// CONCATENATED MODULE: ./app/components/executoractivitymenu.js

var executoractivitymenu_REACT_ELEMENT_TYPE;

function executoractivitymenu_jsx(type, props, key, children) { if (!executoractivitymenu_REACT_ELEMENT_TYPE) { executoractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: executoractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













class executoractivitymenu_ExecutorActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Executor);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var modelNodes = uiactions_NodesByType(state, uiactions_NodeTypes.Model).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    var functionNodes = uiactions_NodesByType(state, [uiactions_NodeTypes.Function, uiactions_NodeTypes.Method]).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    var agents = uiactions_NodesByType(state, uiactions_NodeTypes.Model).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsAgent)).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    return executoractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? executoractivitymenu_jsx(formcontrol_FormControl, {}, void 0, executoractivitymenu_jsx(selectinput_SelectInput, {
      options: Object.keys(nodetypes_Methods).map(t => ({
        title: t,
        value: t
      })),
      label: Methods,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExecutorFunctionType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ExecutorFunctionType] : ''
    }), executoractivitymenu_jsx(selectinput_SelectInput, {
      options: modelNodes,
      label: Models,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ExecutorModel],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExecutorModel,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExecutorModelLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ExecutorModel] : ''
    }), executoractivitymenu_jsx(selectinput_SelectInput, {
      options: modelNodes,
      label: OutputModel,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ExecutorModelOutput],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExecutorModelOutput,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExecutorModelLink
          }
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExecutorModelOutput)
    }), executoractivitymenu_jsx(selectinput_SelectInput, {
      options: agents,
      label: Agents,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ExecutorAgent],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExecutorAgent,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExecutorAgentLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ExecutorAgent] : ''
    }), executoractivitymenu_jsx(selectinput_SelectInput, {
      options: functionNodes,
      label: Functions,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.ExecutorFunction],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExecutorFunction,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExecutorFunctionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ExecutorFunction] : ''
    })) : null);
  }

}

/* harmony default export */ var executoractivitymenu = (UIConnect(executoractivitymenu_ExecutorActivityMenu));
// CONCATENATED MODULE: ./app/components/validatorpropertymenu.js

var validatorpropertymenu_REACT_ELEMENT_TYPE;

function validatorpropertymenu_jsx(type, props, key, children) { if (!validatorpropertymenu_REACT_ELEMENT_TYPE) { validatorpropertymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: validatorpropertymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


















class validatorpropertymenu_ValidatorPropertyMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Validator);
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var validator;

    if (currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ValidatorModel)) {
      var propertyNodes = getNodesByLinkType(graph, {
        id: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ValidatorModel),
        direction: SOURCE,
        type: nodetypes_LinkType.PropertyLink
      }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) !== NodeTypes.Model).map(t => {
        return {
          title: GetNodeTitle(t),
          value: t.id
        };
      });
      validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator);
    }

    let propertyValidations = [];

    if (validator && validator.properties) {
      propertyValidations = Object.keys(validator.properties).map(key => {
        let visualKey = `ValidatorPropertyMenu${key}-${currentNode.id}`;
        return validatorpropertymenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, visualKey),
          active: Visual(state, visualKey),
          title: GetNodeTitle(GetNode(graph, key)),
          toggle: () => {
            this.props.toggleVisual(visualKey);
          }
        }, visualKey);
      });
      propertyValidations = validatorpropertymenu_jsx("div", {
        style: {
          position: 'relative'
        }
      }, void 0, validatorpropertymenu_jsx(mainsidebar_Header, {}, void 0, validatorpropertymenu_jsx(sidebar_SideBar, {}, void 0, validatorpropertymenu_jsx(sidebarmenu_SideBarMenu, {}, void 0, propertyValidations))));
    }

    return validatorpropertymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode && false ? validatorpropertymenu_jsx(formcontrol_FormControl, {}, void 0, validatorpropertymenu_jsx(selectinput_SelectInput, {
      options: propertyNodes,
      defaultSelectText: titles_SelectProperty,
      label: Property,
      onChange: value => {
        var id = currentNode.id;
        var validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator) || createValidator();
        validator = addValidatator(validator, {
          id: value
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id,
          prop: nodetypes_NodeProperties.Validator,
          value: validator
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ValidatorModelLink,
            ...createEventProp(LinkEvents.Remove, {
              function: 'OnRemoveValidationPropConnection'
            })
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ValidatorModel] : ''
    })) : null);
  }

}

/* harmony default export */ var validatorpropertymenu = (UIConnect(validatorpropertymenu_ValidatorPropertyMenu));
// CONCATENATED MODULE: ./app/components/validatoritem.js
var validatoritem_REACT_ELEMENT_TYPE;

function validatoritem_jsx(type, props, key, children) { if (!validatoritem_REACT_ELEMENT_TYPE) { validatoritem_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: validatoritem_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















var validatoritem_ref =
/*#__PURE__*/
validatoritem_jsx("div", {}, void 0, "reference");

var validatoritem_ref2 =
/*#__PURE__*/
validatoritem_jsx("div", {}, void 0, "item");

var validatoritem_ref3 =
/*#__PURE__*/
validatoritem_jsx("div", {});

class validatoritem_ValidatorItem extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Validator);
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var validator;
    var validatorItem;

    if (currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ValidatorModel)) {
      validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator);
      validatorItem = validator.properties[this.props.property].validators[this.props.validator];
    }

    if (validatorItem) {
      if (validatorItem.arguments && validatorItem.arguments.reference) {
        var {
          types
        } = validatorItem.arguments.reference;

        if (types) {
          let _nodes_types = uiactions_NodesByType(state, types).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.ExtensionType ? isUIExtensionEnumerable(x) : true);

          var validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator) || createValidator();
          let item = getValidatorItem(validator, {
            property: this.props.property,
            validator: this.props.validator
          });
          let editlist = [];

          if (item && item.node) {
            let node = GetNode(graph, item.node);

            switch (uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType)) {
              case NodeTypes.Enumeration:
                var enums = uiactions_GetNodeProp(node, nodetypes_NodeProperties.Enumeration) || [];
                editlist = enums.map(_enum => {
                  return validatoritem_jsx("div", {
                    className: `external-event ${item.enumeration && item.enumeration[_enum.id] ? 'bg-red' : 'bg-black'}`,
                    style: {
                      cursor: 'pointer'
                    },
                    onClick: () => {
                      item.enumeration = item.enumeration || {};
                      item.enumeration[_enum.id] = !item.enumeration[_enum.id];
                      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                        id: currentNode.id,
                        prop: nodetypes_NodeProperties.Validator,
                        value: validator
                      });
                    }
                  }, void 0, " ", _enum.value);
                });
                break;

              case NodeTypes.ExtensionType:
                var list_enums = GetUIExentionEnumeration(node);
                var list_key_field = GetUIExentionKeyField(node);
                editlist = list_enums.map(_enum => {
                  return validatoritem_jsx("div", {
                    className: `external-event ${item.extension && item.extension[_enum[list_key_field]] ? 'bg-red' : 'bg-black'}`,
                    style: {
                      cursor: 'pointer'
                    },
                    onClick: () => {
                      item.extension = item.extension || {};
                      item.extension[_enum[list_key_field]] = !item.extension[_enum[list_key_field]];
                      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                        id: currentNode.id,
                        prop: nodetypes_NodeProperties.Validator,
                        value: validator
                      });
                    }
                  }, void 0, " ", _enum[list_key_field]);
                });
                break;
            }
          }

          let formControll = validatoritem_jsx(formcontrol_FormControl, {}, void 0, validatoritem_jsx(selectinput_SelectInput, {
            options: _nodes_types.map(t => ({
              title: GetNodeTitle(t),
              value: t.id
            })),
            defaultSelectText: NodeType,
            label: Property,
            onChange: value => {
              var id = currentNode.id;
              var validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator) || createValidator();
              let item = getValidatorItem(validator, {
                property: this.props.property,
                validator: this.props.validator
              });
              let old_one = item.node;
              item.node = value;

              if (old_one) {
                this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
                  target: old_one,
                  source: id
                });
              }

              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.Validator,
                value: validator
              });
              this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
                target: value,
                source: id,
                properties: { ...uiactions_LinkProperties.ValidatorModelItemLink,
                  ...createEventProp(LinkEvents.Remove, {
                    property: this.props.property,
                    validator: this.props.validator,
                    function: 'OnRemoveValidationItemPropConnection',
                    node: item.node
                  })
                }
              });
            },
            value: validatorItem ? validatorItem.node : ''
          }), editlist);

          return formControll;
        }

        return validatoritem_ref;
      }

      return validatoritem_ref2;
    }

    return validatoritem_ref3;
  }

}

/* harmony default export */ var validatoritem = (UIConnect(validatoritem_ValidatorItem));
// CONCATENATED MODULE: ./app/components/validatorpropertyactivitymenu.js

var validatorpropertyactivitymenu_REACT_ELEMENT_TYPE;

function validatorpropertyactivitymenu_jsx(type, props, key, children) { if (!validatorpropertyactivitymenu_REACT_ELEMENT_TYPE) { validatorpropertyactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: validatorpropertyactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




















var validatorpropertyactivitymenu_ref =
/*#__PURE__*/
validatorpropertyactivitymenu_jsx("div", {});

class validatorpropertyactivitymenu_ValidatorPropertyActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Validator);
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var validator;

    if (active && currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ValidatorModel)) {
      validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator);
    }

    let propertyValidations = validatorpropertyactivitymenu_ref;

    if (validator && validator.properties) {
      propertyValidations = Object.keys(validator.properties).map(key => {
        let _validates = validator.properties[key];
        let visualKey = `ValidatorPropertyActivityMenu${key}-${currentNode.id}`;
        let selectedValidations = Object.keys(_validates && _validates.validators ? _validates.validators : {}).map(v => {
          let selK = `${visualKey}-selected-validation`;
          let selKInner = `${selK}-inne-${v}-r`;
          return validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
            title: _validates.validators && _validates.validators[v] && _validates.validators[v].type ? _validates.validators[v].type : v,
            open: Visual(state, selKInner),
            active: Visual(state, selKInner),
            toggle: () => {
              this.props.toggleVisual(selKInner);
            },
            icon: "fa fa-tag"
          }, `${v}-v-v`, validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
            hideArrow: true,
            title: Remove,
            icon: "fa fa-minus",
            onClick: () => {
              let id = currentNode.id;
              let validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator) || createValidator();
              let _validates = validator.properties[key];
              delete _validates.validators[v];
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.Validator,
                value: validator
              });
            }
          }), validatorpropertyactivitymenu_jsx(validatoritem, {
            node: currentNode.id,
            property: key,
            validator: v
          }));
        });
        let validationUis = Object.keys(ValidationUI).filter(x => !_validates || !_validates.validators || !_validates.validators[x]).reverse().map(valiationUi => {
          return validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
            hideArrow: true,
            title: valiationUi,
            icon: "fa fa-plus-square-o",
            onClick: () => {
              let id = currentNode.id;
              var validator = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Validator) || createValidator();
              validator = addValidatator(validator, {
                id: key,
                validator: uuidv4(),
                validatorArgs: {
                  type: valiationUi,
                  ...ValidationUI[valiationUi]
                }
              });
              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                id,
                prop: nodetypes_NodeProperties.Validator,
                value: validator
              });
            }
          }, `${valiationUi}-afjlskf-asfd`);
        });
        return validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, visualKey),
          active: Visual(state, visualKey),
          title: GetNodeTitle(GetNode(graph, key)),
          toggle: () => {
            this.props.toggleVisual(visualKey);
          }
        }, visualKey, validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          hideArrow: true,
          title: RemoveValidation,
          icon: "fa fa-minus",
          onClick: () => {
            let id = currentNode.id;
            this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
              target: key,
              source: id
            });
          }
        }), validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          title: SelectedValidations,
          icon: "fa  fa-list-ul",
          open: Visual(state, `${visualKey}-selected-validations`),
          active: Visual(state, `${visualKey}-selected-validations`),
          toggle: () => {
            this.props.toggleVisual(`${visualKey}-selected-validations`);
          }
        }, void 0, selectedValidations), validatorpropertyactivitymenu_jsx(treeviewmenu_TreeViewMenu, {
          title: SelectValidation,
          icon: "fa fa-plus-circle",
          open: Visual(state, `${visualKey}-selectvalidation`),
          active: Visual(state, `${visualKey}-selectvalidation`),
          toggle: () => {
            this.props.toggleVisual(`${visualKey}-selectvalidation`);
          }
        }, void 0, validationUis));
      });
      propertyValidations = validatorpropertyactivitymenu_jsx("div", {
        style: {
          position: "relative"
        }
      }, void 0, validatorpropertyactivitymenu_jsx(mainsidebar_Header, {}, void 0, validatorpropertyactivitymenu_jsx(sidebar_SideBar, {}, void 0, validatorpropertyactivitymenu_jsx(sidebarmenu_SideBarMenu, {}, void 0, propertyValidations))));
    }

    return propertyValidations;
  }

}

/* harmony default export */ var validatorpropertyactivitymenu = (UIConnect(validatorpropertyactivitymenu_ValidatorPropertyActivityMenu));
// CONCATENATED MODULE: ./app/components/ExtensionListActivityMenu.js
var ExtensionListActivityMenu_REACT_ELEMENT_TYPE;

function ExtensionListActivityMenu_jsx(type, props, key, children) { if (!ExtensionListActivityMenu_REACT_ELEMENT_TYPE) { ExtensionListActivityMenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: ExtensionListActivityMenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }










class ExtensionListActivityMenu_ExtensionListActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ExtensionTypeList);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var extentiontypes = uiactions_NodesByType(state, uiactions_NodeTypes.ExtensionType).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    return ExtensionListActivityMenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? ExtensionListActivityMenu_jsx(formcontrol_FormControl, {}, void 0, ExtensionListActivityMenu_jsx(selectinput_SelectInput, {
      options: extentiontypes,
      label: ExtensionOptions,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIExtension],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtension,
          id: currentNode.id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExtensionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIExtension] : ''
    })) : null, ExtensionListActivityMenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: ExtensionListTypeActions
    }), ExtensionListActivityMenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, ExtensionListActivityMenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_EXTENTION_NODE, {});
      },
      icon: 'fa fa-puzzle-piece',
      title: AddExtensionNode,
      description: AddExtensionNodeDescription
    })));
  }

}

/* harmony default export */ var components_ExtensionListActivityMenu = (UIConnect(ExtensionListActivityMenu_ExtensionListActivityMenu));
// CONCATENATED MODULE: ./app/components/sidebarbutton.js
var sidebarbutton_REACT_ELEMENT_TYPE;

function sidebarbutton_jsx(type, props, key, children) { if (!sidebarbutton_REACT_ELEMENT_TYPE) { sidebarbutton_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sidebarbutton_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



class sidebarbutton_SidebarButton extends external_react_["Component"] {
  title() {
    return this.props.title || '';
  }

  icon() {
    return this.props.icon || '';
  }

  render() {
    var me = this;
    return sidebarbutton_jsx("a", {
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      },
      className: "sidebar-toggle",
      "data-toggle": "push-menu",
      role: "button"
    }, void 0, sidebarbutton_jsx("span", {
      className: "sr-only"
    }, void 0, sidebarbutton_jsx("i", {
      className: this.icon()
    })));
  }

}
// CONCATENATED MODULE: ./app/components/permissionsactivitymenu.js

var permissionsactivitymenu_REACT_ELEMENT_TYPE;

function permissionsactivitymenu_jsx(type, props, key, children) { if (!permissionsactivitymenu_REACT_ELEMENT_TYPE) { permissionsactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: permissionsactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














class permissionsactivitymenu_PermissionActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Permission);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var is_agent = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.IsAgent);
    var permissions = currentNode ? { ...nodetypes_Methods,
      ...(currentNode.properties[uiactions_NodeProperties.UIPermissions] || {})
    } : null;
    var model_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Model).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var graph = GetCurrentGraph(state);
    var targetNodeId = graph && currentNode && currentNode.properties ? currentNode.properties[uiactions_NodeProperties.PermissionTarget] : "";
    var requestorNodeId = graph && currentNode && currentNode.properties ? currentNode.properties[uiactions_NodeProperties.PermissionRequester] : "";
    var propertyNodes = null;

    if (targetNodeId) {
      propertyNodes = getNodesByLinkType(graph, {
        id: targetNodeId,
        direction: SOURCE,
        type: nodetypes_LinkType.PropertyLink
      });
      if (propertyNodes) propertyNodes = propertyNodes.map(node => {
        return {
          value: node.id,
          title: GetNodeTitle(node)
        };
      });
    }

    var requestorPropertyNodes = null;

    if (requestorNodeId) {
      requestorPropertyNodes = getNodesByLinkType(graph, {
        id: requestorNodeId,
        direction: SOURCE,
        type: nodetypes_LinkType.PropertyLink
      });
      requestorPropertyNodes = requestorPropertyNodes.map(node => {
        return {
          value: node.id,
          title: GetNodeTitle(node)
        };
      });
    }

    var methodNode = currentNode ? GetLinkChainItem(state, {
      id: currentNode.id,
      links: [{
        direction: graph_methods_TARGET,
        type: nodetypes_LinkType.FunctionOperator
      }]
    }) : null;
    let methodProps = GetMethodOptions(uiactions_GetNodeProp(methodNode, nodetypes_NodeProperties.MethodProps));
    return permissionsactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode && false ? permissionsactivitymenu_jsx(checkbox_CheckBox, {
      title: OwnedResourcesDescription,
      label: OwnedResources,
      value: currentNode.properties[uiactions_NodeProperties.IsOwned],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsOwned,
          id: currentNode.id,
          value
        });
      }
    }) : null, permissions && false ? permissionsactivitymenu_jsx(formcontrol_FormControl, {}, void 0, Object.keys(permissions).map(key => {
      return permissionsactivitymenu_jsx(checkbox_CheckBox, {
        label: Permissions[key],
        value: permissions[key],
        onChange: value => {
          permissions[key] = value;
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.UIPermissions,
            id: currentNode.id,
            value: { ...permissions
            }
          });
        }
      }, `permissions-${key}`);
    })) : null, methodProps && methodProps.length && false ? permissionsactivitymenu_jsx(selectinput_SelectInput, {
      options: methodProps,
      label: PermissionValueType,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.PermissionValueType,
          id: currentNode.id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.PermissionValueType)
    }) : null, permissionsactivitymenu_jsx("button", {
      type: "submit",
      className: "btn btn-primary",
      onClick: () => {
        this.props.graphOperation(NEW_CONDITION_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ConditionLink
            }
          }
        });
      }
    }, void 0, AddCondition));
  }

}

/* harmony default export */ var permissionsactivitymenu = (UIConnect(permissionsactivitymenu_PermissionActivityMenu));
// CONCATENATED MODULE: ./app/components/referenceactivitymenu.js
var referenceactivitymenu_REACT_ELEMENT_TYPE;

function referenceactivitymenu_jsx(type, props, key, children) { if (!referenceactivitymenu_REACT_ELEMENT_TYPE) { referenceactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: referenceactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














class referenceactivitymenu_ReferenceActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = !!(Application(state, GRAPH_SCOPE) || []).length;
    var referencable_nodes = (uiactions_NodesByType(state, NodeTypes.Model, {
      useRoot: true
    }) || []).map(t => {
      return {
        title: GetNodeTitle(t),
        value: t.id
      };
    });
    return referenceactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, referenceactivitymenu_jsx(formcontrol_FormControl, {}, void 0, referenceactivitymenu_jsx(selectinput_SelectInput, {
      label: AddReference,
      options: referencable_nodes,
      onChange: id => {
        var node = GetNodeFromRoot(state, id);
        this.props.graphOperation([{
          operation: ADD_NEW_REFERENCE_NODE,
          options: {
            node,
            rootNode: GetRootGraph(state)
          }
        }]); // this.props.graphOperation(UIA.REMOVE_LINK_BETWEEN_NODES, {
        //     target: currentNode.properties[UIA.NodeProperties.UIDependsOn],
        //     source: id
        // })
        // this.props.graphOperation(UIA.CHANGE_NODE_PROPERTY, {
        //     prop: UIA.NodeProperties.UIDependsOn,
        //     id,
        //     value
        // });
        // this.props.graphOperation(UIA.ADD_LINK_BETWEEN_NODES, {
        //     target: value,
        //     source: id,
        //     properties: { ...UIA.LinkProperties.DependsOnLink }
        // });
      },
      value: ''
    })));
  }

}

/* harmony default export */ var referenceactivitymenu = (UIConnect(referenceactivitymenu_ReferenceActivityMenu));
// CONCATENATED MODULE: ./app/components/goomenu.js

var goomenu_REACT_ELEMENT_TYPE;

function goomenu_jsx(type, props, key, children) { if (!goomenu_REACT_ELEMENT_TYPE) { goomenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: goomenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




var goomenu_ref =
/*#__PURE__*/
goomenu_jsx("div", {});

var goomenu_ref2 =
/*#__PURE__*/
goomenu_jsx("span", {
  className: "hamburger hamburger-1"
});

var goomenu_ref3 =
/*#__PURE__*/
goomenu_jsx("span", {
  className: "hamburger hamburger-2"
});

var goomenu_ref4 =
/*#__PURE__*/
goomenu_jsx("span", {
  className: "hamburger hamburger-3"
});

class goomenu_NavBarButton extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      id: GUID()
    };
  }

  icon() {
    return this.props.icon || "fa fa-gears";
  }

  menuItems() {
    const result = [];
    const {
      menuItems
    } = this.props;

    if (menuItems) {
      const calcRow = n => 6 * n;

      let current = 0;
      const rows = [].interpolate(0, 4, calcRow).map(prev => {
        current = prev + current;
        return current;
      });

      const perRow = i => {
        const rth = rows.findIndex(value => i < value);
        const max = calcRow(rth);
        if (i - max > 0) return {
          val: i - max,
          rth,
          max
        };
        return {
          val: i,
          rth,
          max
        };
      };

      menuItems.forEach((mi, index) => {
        if (mi.onClick && mi.icon) {
          const pr = perRow(index);
          const radius = pr.rth * 59;
          const angle = pr.val / pr.max * 360 * (Math.PI / 180);
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          result.push(goomenu_jsx("a", {
            title: mi.title,
            className: "menu-item menu-button sin cos",
            onClick: mi.onClick,
            style: {
              pointerEvents: 'all',
              '--angle': angle,
              '--radius': 125,
              '--x': `${x}px`,
              '--y': `${y}px`
            }
          }, `goo-menu-${this.state.id}-icon-index-${index}`, " ", goomenu_jsx("i", {
            className: mi.icon
          }), " "));
        }
      });
    }

    return result;
  }

  render() {
    if (!this.props.visible) {
      return goomenu_ref;
    }

    const menuItems = this.menuItems();
    return goomenu_jsx("div", {
      className: "goo-menu container",
      style: {
        position: 'fixed',
        transition: 'all 200ms',
        top: this.props.top || 0,
        left: this.props.left || 0
      }
    }, void 0, goomenu_jsx("nav", {
      className: "menu",
      style: {
        pointerEvents: 'none'
      }
    }, void 0, goomenu_jsx("input", {
      type: "checkbox",
      onChange: () => {
        if (this.props.onToggle) {
          this.props.onToggle();
        }
      },
      checked: this.props.open,
      style: {
        pointerEvents: 'all'
      },
      href: "#",
      className: "menu-open",
      id: `${this.state.id}`
    }), goomenu_jsx("label", {
      className: "menu-open-button",
      htmlFor: `${this.state.id}`,
      style: {
        pointerEvents: 'all'
      }
    }, void 0, goomenu_ref2, goomenu_ref3, goomenu_ref4), menuItems));
  }

}

var goomenu_ref5 =
/*#__PURE__*/
goomenu_jsx("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  version: "1.1"
}, void 0, goomenu_jsx("defs", {}, void 0, goomenu_jsx("filter", {
  id: "shadowed-goo"
}, void 0, goomenu_jsx("feGaussianBlur", {
  in: "SourceGraphic",
  result: "blur",
  stdDeviation: "10"
}), goomenu_jsx("feColorMatrix", {
  in: "blur",
  mode: "matrix",
  values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7",
  result: "goo"
}), goomenu_jsx("feGaussianBlur", {
  in: "goo",
  stdDeviation: "3",
  result: "shadow"
}), goomenu_jsx("feColorMatrix", {
  in: "shadow",
  mode: "matrix",
  values: "0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 -0.2",
  result: "shadow"
}), goomenu_jsx("feOffset", {
  in: "shadow",
  dx: "1",
  dy: "1",
  result: "shadow"
}), goomenu_jsx("feComposite", {
  in2: "shadow",
  in: "goo",
  result: "goo"
}), goomenu_jsx("feComposite", {
  in2: "goo",
  in: "SourceGraphic",
  result: "mix"
})), goomenu_jsx("filter", {
  id: "goo"
}, void 0, goomenu_jsx("feGaussianBlur", {
  in: "SourceGraphic",
  result: "blur",
  stdDeviation: "10"
}), goomenu_jsx("feColorMatrix", {
  in: "blur",
  mode: "matrix",
  values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7",
  result: "goo"
}), goomenu_jsx("feComposite", {
  in2: "goo",
  in: "SourceGraphic",
  result: "mix"
}))));

class goomenu_GooMenuSVG extends external_react_["Component"] {
  render() {
    return goomenu_jsx("div", {
      style: {
        display: 'none'
      }
    }, void 0, goomenu_ref5);
  }

}
// CONCATENATED MODULE: ./app/components/choicelistitemactivitymenu.js

var choicelistitemactivitymenu_REACT_ELEMENT_TYPE;

function choicelistitemactivitymenu_jsx(type, props, key, children) { if (!choicelistitemactivitymenu_REACT_ELEMENT_TYPE) { choicelistitemactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: choicelistitemactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }









class choicelistitemactivitymenu_ChoiceListItemActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ChoiceList);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var def = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIExtensionDefinition);
    return choicelistitemactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, choicelistitemactivitymenu_jsx("ul", {}, void 0, def ? Object.keys(def.definition).map((x, xi) => {
      return choicelistitemactivitymenu_jsx("li", {}, `clist${x}-${xi}`, x);
    }) : null));
  }

}

/* harmony default export */ var choicelistitemactivitymenu = (UIConnect(choicelistitemactivitymenu_ChoiceListItemActivityMenu));
// CONCATENATED MODULE: ./app/components/modelfiltermenu.js
var modelfiltermenu_REACT_ELEMENT_TYPE;

function modelfiltermenu_jsx(type, props, key, children) { if (!modelfiltermenu_REACT_ELEMENT_TYPE) { modelfiltermenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: modelfiltermenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















var modelfiltermenu_ref =
/*#__PURE__*/
modelfiltermenu_jsx("i", {
  className: `fa  fa-flag-checkered`
});

var modelfiltermenu_ref2 =
/*#__PURE__*/
modelfiltermenu_jsx("i", {
  className: `fa  fa-flag-o`
});

class modelfiltermenu_ModelFilterMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ModelFilter);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let nodes = uiactions_NodesByType(state, NodeTypes.Model).map(t => ({
      title: GetNodeTitle(t),
      value: t.id
    }));
    var graph = GetCurrentGraph(state);
    let properties = [];
    let propnodes = [];

    if (currentNode) {
      let model = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel);
      propnodes = GetModelPropertyChildren(model);
      properties = propnodes.map(t => {
        return modelfiltermenu_jsx(checkbox_CheckBox, {
          label: GetNodeTitle(t),
          value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.FilterPropreties) ? uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.FilterPropreties)[t.id] : "",
          onChange: value => {
            let fprops = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.FilterPropreties) || {};
            fprops[t.id] = value;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.FilterPropreties,
              id: currentNode.id,
              value: fprops
            });
          }
        }, `checkbox-${t.id}`);
      });
    }

    return modelfiltermenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, modelfiltermenu_jsx("div", {
      className: "btn-group"
    }, void 0, modelfiltermenu_jsx("button", {
      title: SelectAll,
      onClick: () => {
        let fprops = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.FilterPropreties) || {};
        propnodes.map(node => {
          fprops[node.id] = true;
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.FilterPropreties,
          id: currentNode.id,
          value: fprops
        });
      },
      className: `btn btn-success`
    }, void 0, modelfiltermenu_ref), modelfiltermenu_jsx("button", {
      title: Clear,
      onClick: () => {
        let fprops = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.FilterPropreties) || {};
        propnodes.map(node => {
          fprops[node.id] = false;
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.FilterPropreties,
          id: currentNode.id,
          value: fprops
        });
      },
      className: `btn btn-default`
    }, void 0, modelfiltermenu_ref2)), currentNode ? modelfiltermenu_jsx(formcontrol_FormControl, {}, void 0, properties) : null);
  }

}

/* harmony default export */ var modelfiltermenu = (UIConnect(modelfiltermenu_ModelFilterMenu));
// CONCATENATED MODULE: ./app/components/datachainoperator.js

var datachainoperator_REACT_ELEMENT_TYPE;

function datachainoperator_jsx(type, props, key, children) { if (!datachainoperator_REACT_ELEMENT_TYPE) { datachainoperator_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: datachainoperator_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




















var datachainoperator_ref =
/*#__PURE__*/
datachainoperator_jsx("div", {});

class datachainoperator_DataChainOperator extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.DataChain);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (!active) {
      return datachainoperator_ref;
    }

    return datachainoperator_jsx(mainsidebar_Header, {
      active: active,
      relative: true
    }, void 0, datachainoperator_jsx(sidebar_SideBar, {
      style: {
        paddingTop: 0
      }
    }, void 0, datachainoperator_jsx(sidebarmenu_SideBarMenu, {}, void 0, datachainoperator_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      hideArrow: true,
      title: SplitDataChain,
      icon: 'fa fa-share-alt',
      onClick: () => {
        DataChainContextMethods.SplitDataChain.bind(this)(currentNode);
      }
    }), uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) ? datachainoperator_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      hideArrow: true,
      title: MergeChain,
      icon: 'fa fa-code-fork ',
      onClick: () => {
        let groupProperties = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) ? {
          id: uiactions_getGroup(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent)).id
        } : null;
        if (groupProperties) this.props.graphOperation(ADD_NEW_NODE, {
          nodeType: NodeTypes.DataChain,
          properties: {
            [nodetypes_NodeProperties.MergeChain]: true
          },
          groupProperties,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          }
        });
      }
    }) : null, uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) ? datachainoperator_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      hideArrow: true,
      title: StitchEnd,
      icon: 'fa fa-compress',
      onClick: () => {
        let groupProperties = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) ? {
          id: uiactions_getGroup(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent)).id
        } : null;

        if (groupProperties) {
          let groupExitNode = GetGroupProp(groupProperties.id, GroupProperties.GroupExitNode);
          let externalExitNode = GetGroupProp(groupProperties.id, GroupProperties.ExternalExitNode);

          if (externalExitNode) {
            this.props.graphOperation([{
              operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
              options: {
                target: externalExitNode,
                source: groupExitNode
              }
            }, {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,
              options: {
                target: externalExitNode,
                source: currentNode.id
              }
            }, {
              operation: CHANGE_NODE_PROPERTY,
              options: {
                id: externalExitNode,
                prop: nodetypes_NodeProperties.ChainParent,
                value: externalExitNode
              }
            }, {
              operation: UPDATE_GROUP_PROPERTY,
              options: {
                id: groupProperties.id,
                prop: GroupProperties.GroupExitNode,
                value: currentNode.id
              }
            }]);
          }
        }
      }
    }) : null, currentNode ? datachainoperator_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      hideArrow: true,
      title: AddDataChain,
      icon: 'fa fa-plus',
      onClick: () => {
        let groupProperties = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent) ? {
          id: uiactions_getGroup(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GroupParent)).id
        } : null;
        this.props.graphOperation(ADD_NEW_NODE, {
          parent: currentNode.id,
          nodeType: NodeTypes.DataChain,
          groupProperties,
          properties: {
            [nodetypes_NodeProperties.ChainParent]: currentNode.id
          },
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          }
        });
      }
    }) : null)));
  }

}

/* harmony default export */ var datachainoperator = (UIConnect(datachainoperator_DataChainOperator));
// CONCATENATED MODULE: ./app/components/themeproperties.js

var themeproperties_REACT_ELEMENT_TYPE;

function themeproperties_jsx(type, props, key, children) { if (!themeproperties_REACT_ELEMENT_TYPE) { themeproperties_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: themeproperties_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














var themeproperties_ref =
/*#__PURE__*/
themeproperties_jsx("div", {});

class themeproperties_ThemeProperties extends external_react_["Component"] {
  render() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (!currentNode || !IsCurrentNodeA(state, NodeTypes.Theme)) {
      return themeproperties_ref;
    }

    const nodeProperties = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Themes) || {};
    return themeproperties_jsx(mainsidebar_Header, {
      active: true,
      relative: true
    }, void 0, themeproperties_jsx(sidebar_SideBar, {
      style: {
        paddingTop: 0
      }
    }, void 0, themeproperties_jsx(sidebarmenu_SideBarMenu, {}, void 0, themeproperties_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "them_properties"),
      active: true,
      title: Themes,
      innerStyle: {
        maxHeight: 600,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("them_properties");
      }
    }, void 0, Object.keys(themes_Themes).sort().map(key => themeproperties_jsx(treeviewmenu_TreeViewMenu, {
      title: `${key}`,
      onClick: () => {
        this.props.graphOperation([{
          operation: UPDATE_NODE_PROPERTY,
          options: {
            id: currentNode.id,
            properties: {
              [nodetypes_NodeProperties.Themes]: { ...nodeProperties,
                [key]: !!!nodeProperties[key]
              }
            }
          }
        }]);
      },
      icon: nodeProperties[key] ? "fa fa-square" : "fa fa-square-o"
    }, `theme-props-${key}`))), themeproperties_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, `details`),
      active: true,
      title: Details,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual(`details`);
      }
    }, void 0, themeproperties_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, themeproperties_jsx(selectinput_SelectInput, {
      options: [].interpolate(0, 10, x => x).map(x => ({
        id: x,
        value: x,
        title: x
      })),
      label: Priority,
      onChange: value => {
        this.props.graphOperation([{
          operation: UPDATE_NODE_PROPERTY,

          options() {
            return {
              id: currentNode.id,
              properties: {
                [nodetypes_NodeProperties.Priority]: value
              }
            };
          }

        }]);
      },
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Priority)
    }))))));
  }

}

/* harmony default export */ var themeproperties = (UIConnect(themeproperties_ThemeProperties));
// CONCATENATED MODULE: ./app/components/currentnodeproperties.js

var currentnodeproperties_REACT_ELEMENT_TYPE;

function currentnodeproperties_jsx(type, props, key, children) { if (!currentnodeproperties_REACT_ELEMENT_TYPE) { currentnodeproperties_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: currentnodeproperties_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




















var currentnodeproperties_ref =
/*#__PURE__*/
currentnodeproperties_jsx("div", {});

class currentnodeproperties_CurrentNodeProperties extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (!currentNode) {
      return currentnodeproperties_ref;
    }

    let selectedLink = Visual(state, SELECTED_LINK);
    let currentLink = selectedLink ? GetLinkBetween(selectedLink.source, selectedLink.target, GetCurrentGraph()) : null;
    let linkProperties = currentLink ? currentLink.properties : {};
    let nodeProperties = currentNode.properties || {};
    return currentnodeproperties_jsx(mainsidebar_Header, {
      active: true,
      relative: true
    }, void 0, currentnodeproperties_jsx(sidebar_SideBar, {
      style: {
        paddingTop: 0
      }
    }, void 0, currentnodeproperties_jsx(sidebarmenu_SideBarMenu, {}, void 0, currentnodeproperties_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "CURRENT_NODE_PROPERTIES"),
      active: true,
      title: Properties,
      innerStyle: {
        maxHeight: 600,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("CURRENT_NODE_PROPERTIES");
      }
    }, void 0, Object.keys(nodeProperties).sort().map(key => {
      return currentnodeproperties_jsx(treeviewmenu_TreeViewMenu, {
        title: `${key}: ${JSON.stringify(nodeProperties[key])}`,
        hideArrow: true,
        onClick: () => {
          this.props.graphOperation([{
            operation: UPDATE_NODE_DIRTY,
            options: {
              id: currentNode.id,
              prop: key,
              value: !!!GetNodePropDirty(currentNode, key)
            }
          }]);
        },
        icon: GetNodePropDirty(currentNode, key) ? "fa fa-square" : "fa fa-square-o"
      }, `component-props-${key}`);
    })), currentnodeproperties_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "CURRENT_LINK_PROPERTIES"),
      active: true,
      title: LinkProperties,
      innerStyle: {
        maxHeight: 600,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("CURRENT_LINK_PROPERTIES");
      }
    }, void 0, Object.keys(linkProperties).sort().map(key => {
      return currentnodeproperties_jsx(treeviewmenu_TreeViewMenu, {
        title: `${key}: ${JSON.stringify(linkProperties[key])}`,
        hideArrow: true,
        onClick: () => {},
        icon: "fa fa-square-o"
      }, `link-props-${key}`);
    })))));
  }

}

/* harmony default export */ var currentnodeproperties = (UIConnect(currentnodeproperties_CurrentNodeProperties));
// CONCATENATED MODULE: ./app/components/slider.js
var slider_REACT_ELEMENT_TYPE;

function slider_jsx(type, props, key, children) { if (!slider_REACT_ELEMENT_TYPE) { slider_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: slider_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class slider_Slider extends external_react_["Component"] {
  min() {
    return this.props.min || "1";
  }

  max() {
    return this.props.max || "100";
  }

  value() {
    return this.props.value || '';
  }

  render() {
    return slider_jsx("div", {
      className: "slidecontainer"
    }, void 0, slider_jsx("input", {
      type: "range",
      min: this.min(),
      onChange: evt => {
        if (this.props.onChange && !isNaN(evt.target.value)) {
          this.props.onChange(parseFloat(evt.target.value));
        }
      },
      max: this.max(),
      value: this.value(),
      className: "slider"
    }));
  }

}
// CONCATENATED MODULE: ./app/components/dropdown.js
function dropdown_extends() { dropdown_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return dropdown_extends.apply(this, arguments); }

var dropdown_REACT_ELEMENT_TYPE;

function dropdown_jsx(type, props, key, children) { if (!dropdown_REACT_ELEMENT_TYPE) { dropdown_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: dropdown_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class dropdown_DropDownMenu extends external_react_["Component"] {
  menuType() {
    return 'messages-menu';
  }

  open() {
    return this.props.open ? 'open' : '';
  }

  ariaExpanded() {
    return this.props.open ? 'true' : 'false';
  }

  icon() {
    return this.props.icon || "fa fa-envelope-o";
  }

  label() {
    return null; //<span className="label label-success">4</span>
  }

  usermode() {
    return this.props.usermode;
  }

  usermenu() {
    return this.props.usermode ? 'user user-menu' : '';
  }

  userbody() {
    return this.props.usermode ? 'user user-body' : '';
  }

  userheader() {
    return this.props.usermode ? 'header' : 'header';
  }

  render() {
    var ops = {};

    if (this.props.width) {
      ops.style = {
        width: this.props.width
      };
    }

    return dropdown_jsx("li", {
      className: `dropdown ${this.usermenu()} ${this.menuType()} ${this.open()}`
    }, void 0, dropdown_jsx("a", {
      className: "dropdown-toggle",
      "data-toggle": "dropdown",
      "aria-expanded": this.ariaExpanded(),
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      }
    }, void 0, dropdown_jsx("i", {
      className: this.icon()
    }), this.label()), external_react_default.a.createElement("ul", dropdown_extends({
      className: "dropdown-menu"
    }, ops), this.props.headerText ? dropdown_jsx("li", {
      className: this.userheader()
    }, void 0, this.props.headerText) : null, this.props.header ? dropdown_jsx("li", {
      className: this.userheader()
    }, void 0, this.props.header) : null, this.usermode() ? dropdown_jsx("li", {
      className: this.userbody()
    }, void 0, dropdown_jsx("div", {
      className: "row"
    }, void 0, this.props.children)) : dropdown_jsx("li", {
      className: this.userbody()
    }, void 0, dropdown_jsx("ul", {
      className: "menu"
    }, void 0, this.props.children)), this.props.footer ? this.props.footer : null));
  }

}
// CONCATENATED MODULE: ./app/components/tabcontent.js
var tabcontent_REACT_ELEMENT_TYPE;

function tabcontent_jsx(type, props, key, children) { if (!tabcontent_REACT_ELEMENT_TYPE) { tabcontent_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: tabcontent_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class tabcontent_TabContent extends external_react_["Component"] {
  active() {
    return this.props.active ? 'active' : '';
  }

  render() {
    return tabcontent_jsx("div", {
      className: `tab-content`
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/userfooter.js
var userfooter_REACT_ELEMENT_TYPE;

function userfooter_jsx(type, props, key, children) { if (!userfooter_REACT_ELEMENT_TYPE) { userfooter_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: userfooter_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class userfooter_Tab extends external_react_["Component"] {
  active() {
    return this.props.active ? 'active' : '';
  }

  title() {
    return this.props.title || this.props.children || '{title}';
  }

  render() {
    return userfooter_jsx("li", {
      className: "user-footer"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/tabcontainer.js
var tabcontainer_REACT_ELEMENT_TYPE;

function tabcontainer_jsx(type, props, key, children) { if (!tabcontainer_REACT_ELEMENT_TYPE) { tabcontainer_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: tabcontainer_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class tabcontainer_TabContainer extends external_react_["Component"] {
  render() {
    return tabcontainer_jsx("div", {
      className: `nav-tabs-custom`
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/enumeratedtable.js
var enumeratedtable_REACT_ELEMENT_TYPE;

function enumeratedtable_jsx(type, props, key, children) { if (!enumeratedtable_REACT_ELEMENT_TYPE) { enumeratedtable_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: enumeratedtable_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class enumeratedtable_EnumeratedTable extends external_react_["Component"] {
  render() {
    var me = this;

    var dataFunc = me.props.dataFunc || (y => y || '');

    var rows = (me.props.data || []).map((x, xi) => {
      return enumeratedtable_jsx("tr", {}, `${xi}-row`, (me.props.columns || []).map((c, inde) => {
        return enumeratedtable_jsx("td", {}, `${inde}-${xi}-cell`, dataFunc(x[c.value], c.value, xi));
      }), (me.props.columnButtons || []).map((fx, inde) => {
        return enumeratedtable_jsx("td", {}, `${inde}-${xi}-cell-btn`, fx(x, xi));
      }));
    });
    var headers = (me.props.columns || []).map((x, index) => {
      return enumeratedtable_jsx("th", {}, `col-${index}`, x.title);
    });
    (me.props.columnButtons || []).map((fx, inde) => {
      headers.push(enumeratedtable_jsx("th", {}, `${inde}-cell-header`));
    });
    var ops = {};
    ops.style = {
      maxHeight: this.props.maxHeight || 500,
      overflowY: 'auto'
    };
    return external_react_default.a.createElement("div", ops, enumeratedtable_jsx("table", {
      className: "table table-bordered"
    }, void 0, enumeratedtable_jsx("tbody", {}, void 0, enumeratedtable_jsx("tr", {}, void 0, headers), rows)));
  }

}
// CONCATENATED MODULE: ./app/components/extensiondefinitionmenu.js

var extensiondefinitionmenu_REACT_ELEMENT_TYPE;

function extensiondefinitionmenu_jsx(type, props, key, children) { if (!extensiondefinitionmenu_REACT_ELEMENT_TYPE) { extensiondefinitionmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: extensiondefinitionmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


















const EXTENSION_DEFINITION_MENU = 'EXTENSION_DEFINITION_MENU';
const EDITMODE = 'EDITMODE';

var extensiondefinitionmenu_ref =
/*#__PURE__*/
extensiondefinitionmenu_jsx("i", {
  className: "fa fa-pencil-square"
});

var extensiondefinitionmenu_ref2 =
/*#__PURE__*/
extensiondefinitionmenu_jsx("i", {
  className: "fa fa-book"
});

var extensiondefinitionmenu_ref3 =
/*#__PURE__*/
extensiondefinitionmenu_jsx("i", {
  className: "fa fa-balance-scale"
});

var extensiondefinitionmenu_ref4 =
/*#__PURE__*/
extensiondefinitionmenu_jsx("i", {
  className: "fa fa-trash"
});

var extensiondefinitionmenu_ref5 =
/*#__PURE__*/
extensiondefinitionmenu_jsx("i", {
  className: `fa fa-anchor`
});

class extensiondefinitionmenu_ExtensionDefinitionMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      property: ''
    };
  }

  form() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ExtensionType) || IsCurrentNodeA(state, uiactions_NodeTypes.ChoiceList);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (active) {
      var def = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIExtensionDefinition);

      if (def) {}
    }

    return null;
  }

  editKey(k) {
    return `${k}-edit`;
  }

  tabKey(k) {
    return `${k}-tabkey`;
  }

  footer() {
    //
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ExtensionType) || IsCurrentNodeA(state, uiactions_NodeTypes.ChoiceList);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (active && currentNode) {
      var def = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIExtensionDefinition);
      var addBtn = def && def.config.isEnumeration ? extensiondefinitionmenu_jsx("div", {
        className: "pull-right"
      }, void 0, extensiondefinitionmenu_jsx("button", {
        type: "submit",
        className: "btn btn-primary",
        onClick: () => {
          def.config.list = [...def.config.list, {}];
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.UIExtensionDefinition,
            id: currentNode.id,
            value: { ...def
            }
          });
        }
      }, void 0, Add)) : null;
      var tab_key = currentNode ? this.tabKey(currentNode.id) : null;

      var btns = extensiondefinitionmenu_jsx("div", {
        className: "pull-left"
      }, void 0, extensiondefinitionmenu_jsx("div", {
        className: "btn-group"
      }, void 0, extensiondefinitionmenu_jsx("button", {
        onClick: () => this.props.setVisual(tab_key, ExtensionDefinition),
        type: "button",
        title: ExtensionDefinition,
        className: "btn btn-default btn-flat"
      }, void 0, extensiondefinitionmenu_ref), extensiondefinitionmenu_jsx("button", {
        onClick: () => this.props.setVisual(tab_key, ExtensionConfig),
        type: "button",
        title: ExtensionConfig,
        className: "btn btn-default btn-flat"
      }, void 0, extensiondefinitionmenu_ref2), extensiondefinitionmenu_jsx("button", {
        onClick: () => {
          if (!def) {
            def = createExtensionDefinition();
          }

          this.props.setVisual(tab_key, DependsOn);
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.UIExtensionDefinition,
            id: currentNode.id,
            value: def
          });
        },
        type: "button",
        title: DependsOn,
        className: "btn btn-default btn-flat"
      }, void 0, extensiondefinitionmenu_ref3)), extensiondefinitionmenu_jsx("div", {
        className: "btn-group"
      }, void 0, VisualEq(state, tab_key, ExtensionDefinition) ? extensiondefinitionmenu_jsx("button", {
        onClick: () => {
          if (this.state.property) {
            if (!def) {
              def = createExtensionDefinition();
            }

            def.definition[this.state.property] = defaultExtensionDefinitionType();
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.UIExtensionDefinition,
              id: currentNode.id,
              value: def
            });
            this.setState({
              property: ''
            });
          }
        },
        type: "button",
        className: "btn btn-default btn-flat"
      }, void 0, Add) : null));

      return extensiondefinitionmenu_jsx(userfooter_Tab, {}, void 0, btns, addBtn);
    }

    return null;
  }

  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var form = this.form();
    var footer = this.footer();
    var tab_key = currentNode ? this.tabKey(currentNode.id) : null;
    var def = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UIExtensionDefinition);
    var properties = currentNode ? uiactions_NodesByType(state, uiactions_NodeTypes.Property).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    }) : [];
    return extensiondefinitionmenu_jsx(tabpane_TabPane, {
      active: IsCurrentNodeA(state, uiactions_NodeTypes.ExtensionType)
    }, void 0, !VisualEq(state, tab_key, DependsOn) ? extensiondefinitionmenu_jsx(formcontrol_FormControl, {}, void 0, def ? extensiondefinitionmenu_jsx(checkbox_CheckBox, {
      label: Enumerable,
      value: def.config.isEnumeration,
      onChange: value => {
        def.config.isEnumeration = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtensionDefinition,
          id: currentNode.id,
          value: { ...def,
            config: { ...def.config
            }
          }
        });
      }
    }) : null, extensiondefinitionmenu_jsx(textinput_TextInput, {
      value: this.state.property,
      label: Property,
      onChange: val => {
        this.setState({
          property: val
        });
      }
    })) : null, def && VisualEq(state, tab_key, ExtensionConfig) ? extensiondefinitionmenu_jsx(enumeratedtable_EnumeratedTable, {
      columns: Object.keys(def.definition).map(key => {
        return {
          title: key,
          value: key
        };
      }),
      dataFunc: (x, key, index) => {
        return extensiondefinitionmenu_jsx(textinput_TextInput, {
          label: Value,
          value: x,
          onChange: value => {
            if (def.config.isEnumeration) {
              if (def.config && def.config.list && def.config.list[index]) {
                def.config.list[index][key] = value;
              }
            } else {
              if (def.config && def.config.dictionary) {
                def.config.dictionary[key] = value;
              }
            }

            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.UIExtensionDefinition,
              id: currentNode.id,
              value: { ...def,
                config: { ...def.config,
                  dictionary: { ...def.config.dictionary
                  },
                  list: [...def.config.list]
                }
              }
            });
          }
        });
      },
      columnButtons: def.config.isEnumeration ? [(x, xi) => {
        return extensiondefinitionmenu_jsx("div", {
          className: "pull-right"
        }, void 0, extensiondefinitionmenu_jsx("button", {
          onClick: () => {
            if (def.config.isEnumeration) {
              if (def.config && def.config.list && def.config.list[xi]) {
                def.config.list = [...def.config.list.filter((a, i) => i !== xi)];
              } // delete def.definition[x.name];
              // def.definition = { ...def.definition };


              this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                prop: uiactions_NodeProperties.UIExtensionDefinition,
                id: currentNode.id,
                value: { ...def
                }
              });
            }
          },
          className: "btn btn-block btn-default"
        }, void 0, extensiondefinitionmenu_ref4));
      }] : [],
      data: def.config.isEnumeration ? def.config.list.map(obj => {
        return { ...obj
        };
      }) : [{ ...def.config.dictionary
      }]
    }) : null, def && VisualEq(state, tab_key, ExtensionDefinition) ? extensiondefinitionmenu_jsx(enumeratedtable_EnumeratedTable, {
      columns: [{
        title: Name,
        value: 'name'
      }],
      columnButtons: [x => {
        return extensiondefinitionmenu_jsx("div", {
          className: "pull-right"
        }, void 0, extensiondefinitionmenu_jsx("div", {
          class: "btn-group"
        }, void 0, extensiondefinitionmenu_jsx("button", {
          title: KeyField,
          onClick: () => {
            def.config = { ...def.config,
              keyField: x.name
            };
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.UIExtensionDefinition,
              id: currentNode.id,
              value: { ...def
              }
            });
          },
          className: `btn   ${x.name === def.config.keyField ? 'btn-success' : 'btn-default'}`
        }, void 0, extensiondefinitionmenu_ref5), extensiondefinitionmenu_jsx("button", {
          onClick: () => {
            delete def.definition[x.name];
            def.definition = { ...def.definition
            };
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.UIExtensionDefinition,
              id: currentNode.id,
              value: { ...def
              }
            });
          },
          className: "btn btn-default"
        }, void 0, "x")));
      }],
      data: Object.keys(def.definition).map(key => {
        return {
          name: key
        };
      })
    }) : null, def && VisualEq(state, tab_key, DependsOn) ? extensiondefinitionmenu_jsx(formcontrol_FormControl, {}, void 0, extensiondefinitionmenu_jsx(checkbox_CheckBox, {
      label: DependsOn,
      title: DependsOnDescription,
      value: def.definition.dependsOn,
      onChange: value => {
        def.definition.dependsOn = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtensionDefinition,
          id: currentNode.id,
          value: { ...def,
            definition: { ...def.definition
            }
          }
        });
      }
    }), extensiondefinitionmenu_jsx(selectinput_SelectInput, {
      label: DependentProperty,
      title: DependentPropertyDescription,
      options: properties,
      value: def.definition.property,
      onChange: value => {
        def.definition.property = value;
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIChoiceType],
          source: id
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIChoiceType,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExtensionDependencyLink
          }
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtensionDefinition,
          id: currentNode.id,
          value: { ...def,
            definition: { ...def.definition
            }
          }
        });
      }
    }), extensiondefinitionmenu_jsx(textinput_TextInput, {
      label: MatchingValue,
      title: MatchingValueDescription,
      value: def.definition.match,
      onChange: value => {
        def.definition.match = value;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtensionDefinition,
          id: currentNode.id,
          value: { ...def,
            definition: { ...def.definition
            }
          }
        });
      }
    })) : null, footer);
  }

}

/* harmony default export */ var extensiondefinitionmenu = (UIConnect(extensiondefinitionmenu_ExtensionDefinitionMenu));
// CONCATENATED MODULE: ./app/components/methodactivitymenu.js

var methodactivitymenu_REACT_ELEMENT_TYPE;

function methodactivitymenu_jsx(type, props, key, children) { if (!methodactivitymenu_REACT_ELEMENT_TYPE) { methodactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: methodactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }














class methodactivitymenu_MethodActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Method);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var function_types = Object.keys(MethodFunctions).map(funcKey => {
      return {
        title: MethodFunctions[funcKey].title || funcKey,
        value: funcKey
      };
    });
    return methodactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode && !currentNode.properties[uiactions_NodeProperties.UseScopeGraph] ? methodactivitymenu_jsx(selectinput_SelectInput, {
      label: FunctionTypes,
      options: function_types,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.FunctionType,
          id: currentNode.id,
          value
        });
        this.props.updateMethodParameters(currentNode.id, value);
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.FunctionType] : ""
    }) : null, currentNode ? methodactivitymenu_jsx(selectinput_SelectInput, {
      label: Methods,
      options: Object.keys(nodetypes_Methods).map(t => ({
        title: t,
        value: nodetypes_Methods[t]
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.MethodType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.MethodType] : ""
    }) : null, currentNode ? methodactivitymenu_jsx(selectinput_SelectInput, {
      label: HttpMethod,
      options: Object.keys(HTTP_METHODS).map(t => ({
        title: t,
        value: HTTP_METHODS[t]
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id: currentNode.id,
          value,
          prop: nodetypes_NodeProperties.HttpMethod
        });
      },
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.HttpMethod)
    }) : null, currentNode ? methodactivitymenu_jsx(textinput_TextInput, {
      label: HttpRoute,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.HttpRoute),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id: currentNode.id,
          value,
          prop: nodetypes_NodeProperties.HttpRoute
        });
      }
    }) : null, currentNode ? methodactivitymenu_jsx(checkbox_CheckBox, {
      label: NotIncludeInController,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.NotIncludedInController,
          id: currentNode.id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NotIncludedInController)
    }) : null, currentNode ? methodactivitymenu_jsx(checkbox_CheckBox, {
      label: AsForm,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.AsForm,
          id: currentNode.id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AsForm)
    }) : null, currentNode && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AsForm) ? methodactivitymenu_jsx(checkbox_CheckBox, {
      label: CollectCookies,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.CollectCookies,
          id: currentNode.id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.CollectCookies)
    }) : null, currentNode ? methodactivitymenu_jsx(checkbox_CheckBox, {
      label: AsText,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.AsText,
          id: currentNode.id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AsText)
    }) : null, currentNode ? methodactivitymenu_jsx(checkbox_CheckBox, {
      label: NoApiPrefix,
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.NoApiPrefix,
          id: currentNode.id,
          value
        });
      },
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NoApiPrefix)
    }) : null, methodactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenu, {}, void 0, currentNode && currentNode.properties[uiactions_NodeProperties.UseScopeGraph] ? methodactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation([{
          operation: ESTABLISH_SCOPE
        }, {
          options: {
            id: currentNode.id
          }
        }]);
      },
      icon: "fa fa-puzzle-piece",
      title: CustomFunction,
      description: CustomFunctionDescription
    }) : null, currentNode ? methodactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_MODEL_ITEM_FILTER, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ModelItemFilter
            }
          }
        });
      },
      icon: "fa fa-puzzle-piece",
      title: AddModelItemFilter,
      description: AddModelItemFilterDescription
    }) : null, currentNode ? methodactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuItem, {
      onClick: () => {
        this.props.graphOperation(NEW_AFTER_METHOD, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.AfterMethod
            }
          },
          properties: {
            [nodetypes_NodeProperties.UIText]: `${uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIText)} After Effect`
          }
        });
      },
      icon: "fa fa-puzzle-piece",
      title: AddAfterMethods,
      description: AddAfterMethodsDescription
    }) : null));
  }

}

/* harmony default export */ var methodactivitymenu = (UIConnect(methodactivitymenu_MethodActivityMenu));
// CONCATENATED MODULE: ./app/components/methodpropertymenu.js

var methodpropertymenu_REACT_ELEMENT_TYPE;

function methodpropertymenu_jsx(type, props, key, children) { if (!methodpropertymenu_REACT_ELEMENT_TYPE) { methodpropertymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: methodpropertymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















class methodpropertymenu_MethodPropertyMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Method);
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var functionType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FunctionType);
    let functionObject = MethodFunctions[functionType];
    let methodparams = [];

    if (functionObject && functionObject.constraints) {
      methodparams = Object.values(functionObject.constraints).map(constraint => {
        let nodes = uiactions_NodesByType(state, constraint.nodeTypes).filter(node => {
          return !Object.keys(constraint).filter(x => x != 'key' && x !== 'nodeTypes').find(x => uiactions_GetNodeProp(node, x) !== constraint[x]);
        }).map(t => ({
          title: GetNodeTitle(t),
          value: t.id
        }));
        return methodpropertymenu_jsx(selectinput_SelectInput, {
          label: constraint.key,
          options: nodes,
          onChange: value => {
            var id = currentNode.id;
            let methodProps = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MethodProps) || {};
            let oldConnect = methodProps[constraint.key];
            methodProps[constraint.key] = value;
            this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
              target: oldConnect,
              source: id,
              linkType: uiactions_LinkProperties.FunctionOperator.type
            });
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.MethodProps,
              id: currentNode.id,
              value: methodProps
            });
            this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
              target: value,
              source: id,
              properties: { ...uiactions_LinkProperties.FunctionOperator
              }
            });
          },
          value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MethodProps) ? uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MethodProps)[constraint.key] : ''
        }, constraint.key);
      });
    }

    return methodpropertymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? methodpropertymenu_jsx(formcontrol_FormControl, {}, void 0, methodparams) : null);
  }

}

/* harmony default export */ var methodpropertymenu = (UIConnect(methodpropertymenu_MethodPropertyMenu));
// CONCATENATED MODULE: ./app/components/maestrodetailsmenu.js
var maestrodetailsmenu_REACT_ELEMENT_TYPE;

function maestrodetailsmenu_jsx(type, props, key, children) { if (!maestrodetailsmenu_REACT_ELEMENT_TYPE) { maestrodetailsmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: maestrodetailsmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















const MAESTRO_DETAILS_MENU = 'MAESTRO_DETAILS_MENU';

var maestrodetailsmenu_ref =
/*#__PURE__*/
maestrodetailsmenu_jsx("div", {});

class maestrodetailsmenu_MaestroDetailsMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Maestro);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var othernodes = currentNode ? getNodesLinkedTo(GetCurrentGraph(state), {
      id: currentNode.id
    }) : [];

    if (!active) {
      return maestrodetailsmenu_ref;
    }

    return maestrodetailsmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, MAESTRO_DETAILS_MENU),
      active: Visual(state, MAESTRO_DETAILS_MENU),
      title: MaestroDetails,
      toggle: () => {
        this.props.toggleVisual(MAESTRO_DETAILS_MENU);
      }
    }, void 0, othernodes.map((onode, index) => {
      return maestrodetailsmenu_jsx(treeviewitem_TreeViewItem, {
        title: `${GetNodeTitle(onode)}`,
        onClick: () => {
          var id = currentNode.id;
          this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
            target: onode.id,
            source: id
          });
        }
      }, `tree-view-item-maestro-details${index}`);
    }));
  }

}

/* harmony default export */ var maestrodetailsmenu = (UIConnect(maestrodetailsmenu_MaestroDetailsMenu));
// CONCATENATED MODULE: ./app/components/nodemanagement.js

var nodemanagement_REACT_ELEMENT_TYPE;

function nodemanagement_jsx(type, props, key, children) { if (!nodemanagement_REACT_ELEMENT_TYPE) { nodemanagement_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: nodemanagement_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }










const nodemanagement_NODE_MANAGEMENT_MENU = "NODE_MANAGEMENT_MENU";
const nodemanagement_NODE_MANAGEMENT = "NODE_MANAGEMENT";

class nodemanagement_NodeManagement extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      filter: ""
    };
  }

  toFilterString(node) {
    return `${uiactions_GetNodeProp(node, nodetypes_NodeProperties.CodeName)} ${node.id} ${uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIText)} ${uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType)}`.toLowerCase();
  }

  render() {
    let me = this;
    let {
      state
    } = me.props;
    var graph = GetCurrentGraph(state);
    let filter = (this.state.filter || "").toLowerCase();
    let groups = GetNodes(state).filter(x => {
      if (!filter || !x) {
        return false;
      }

      var str = this.toFilterString(x);
      return str.indexOf(filter) !== -1;
    }).groupBy(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType));
    let body = [];
    body = Object.keys(groups).sort((a, b) => a.localeCompare(b)).filter(group => groups[group].length).map((group, gi) => {
      let groupKey = `NodeManagement-${group}`;
      let groupNodes = Visual(state, groupKey) ? groups[group].subset(0, 100).sort((a, b) => uiactions_GetNodeProp(a, nodetypes_NodeProperties.UIText).localeCompare(uiactions_GetNodeProp(b, nodetypes_NodeProperties.UIText))).map((gn, gni) => {
        return nodemanagement_jsx(treeviewmenu_TreeViewMenu, {
          hideArrow: true,
          title: uiactions_GetNodeProp(gn, nodetypes_NodeProperties.UIText),
          icon: !uiactions_GetNodeProp(gn, nodetypes_NodeProperties.Pinned) ? "fa fa-circle-o" : "fa fa-check-circle-o",
          toggle: () => {
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.Pinned,
              id: gn.id,
              value: !uiactions_GetNodeProp(gn, nodetypes_NodeProperties.Pinned)
            });
          }
        }, `node-${group}-${gi}-${gni}`);
      }) : [];
      return nodemanagement_jsx(treeviewmenu_TreeViewMenu, {
        title: group,
        icon: "fa fa-dot-circle-o",
        open: Visual(state, groupKey),
        innerStyle: {
          maxHeight: 400,
          overflowY: "auto"
        },
        active: Visual(state, groupKey),
        right: nodemanagement_jsx("span", {
          className: "label label-primary "
        }, void 0, groups[group].length),
        toggle: () => {
          this.props.toggleVisual(groupKey);
        }
      }, `node-${group}-${gi}`, groupNodes);
    });
    return nodemanagement_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Nodes} ${graph ? Object.keys(graph.visibleNodes || {}).length : ""}`,
      icon: "fa fa-object-group",
      open: Visual(state, nodemanagement_NODE_MANAGEMENT),
      active: Visual(state, nodemanagement_NODE_MANAGEMENT),
      onClick: () => {
        this.props.toggleVisual(nodemanagement_NODE_MANAGEMENT);
      }
    }, void 0, nodemanagement_jsx(treeviewmenu_TreeViewMenu, {
      icon: "fa fa-dot-circle-o",
      title: Menu,
      open: Visual(state, nodemanagement_NODE_MANAGEMENT_MENU),
      active: Visual(state, nodemanagement_NODE_MANAGEMENT_MENU),
      onClick: () => {
        this.props.toggleVisual(nodemanagement_NODE_MANAGEMENT_MENU);
      }
    }, void 0, nodemanagement_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: ClearPinned,
      icon: "fa fa-times",
      onClick: () => {
        this.props.graphOperation(GetNodes(state).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.Pinned)).subset(0, 100).map(node => {
          return {
            operation: CHANGE_NODE_PROPERTY,
            options: {
              prop: uiactions_NodeProperties.Pinned,
              id: node.id,
              value: false
            }
          };
        }));
      }
    })), nodemanagement_jsx(formcontrol_FormControl, {
      sidebarform: true
    }, void 0, nodemanagement_jsx(textinput_TextInput, {
      value: this.state.filter,
      immediate: false,
      onChange: value => {
        this.setState({
          filter: value
        });
      },
      inputgroup: true,
      placeholder: Filter
    })), body);
  }

}

/* harmony default export */ var nodemanagement = (UIConnect(nodemanagement_NodeManagement));
// CONCATENATED MODULE: ./app/components/methodparameteremenu.js

var methodparameteremenu_REACT_ELEMENT_TYPE;

function methodparameteremenu_jsx(type, props, key, children) { if (!methodparameteremenu_REACT_ELEMENT_TYPE) { methodparameteremenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: methodparameteremenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




















const METHOD_PARAMETERS = 'METHOD_PARAMETERS';

var methodparameteremenu_ref =
/*#__PURE__*/
methodparameteremenu_jsx("br", {});

class methodparameteremenu_MethodParameterMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentNode;
    let screenOption = currentNode ? GetConnectedNodeByType(state, currentNode.id, NodeTypes.ScreenOption) || GetConnectedNodeByType(state, currentNode.id, NodeTypes.ComponentNode, graph_methods_TARGET) : null;

    let _ui_type = uiactions_GetNodeProp(screenOption, uiactions_NodeProperties.UIType);

    let componentTypes = ComponentTypes[_ui_type] || {};
    let componentType = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentType);
    let componentProperties = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentProperties);
    let componentPropertiesList = getComponentPropertyList(componentProperties);
    let components = [];
    let methodParams = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ClientMethodParameters) || {};
    let componentNodeProperties = GetComponentNodeProperties();

    if (componentTypes[componentType] && componentTypes[componentType].properties) {
      Object.keys(componentTypes[componentType].properties).map(key => {
        let prop_obj = componentTypes[componentType].properties[key];

        if (prop_obj && prop_obj.ui) {
          if (prop_obj.options) {
            let nodeproperty = uiactions_GetNodeProp(currentNode, prop_obj.nodeProperty);

            if (nodeproperty === APP_METHOD) {
              components.push(methodparameteremenu_jsx(selectinput_SelectInput, {
                label: ClientMethod,
                options: uiactions_NodesByType(state, NodeTypes.Method).toNodeSelect(),
                value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ClientMethod),
                onChange: value => {
                  let id = currentNode.id;
                  this.props.graphOperation([{
                    operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
                    options: {
                      target: currentNode.properties[nodetypes_NodeProperties.ClientMethod],
                      source: id
                    }
                  }, {
                    operation: CHANGE_NODE_PROPERTY,
                    options: {
                      prop: nodetypes_NodeProperties.ClientMethod,
                      id: currentNode.id,
                      value
                    }
                  }, {
                    operation: uiactions_ADD_LINK_BETWEEN_NODES,
                    options: {
                      target: value,
                      source: id,
                      properties: { ...uiactions_LinkProperties.ClientMethodLink
                      }
                    }
                  }]);
                }
              }, `${nodeproperty} - ${_ui_type} - ${componentType} - ${key}`));
              let methodId = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ClientMethod);

              if (methodId) {
                let method_parameters = GetMethodParameters(methodId);

                if (method_parameters) {
                  let {
                    parameters,
                    body
                  } = method_parameters;

                  if (body) {
                    let bodyparameters = `${nodeproperty} - ${_ui_type} - ${componentType} - parameter - body`;
                    let c_props = componentNodeProperties.find(x => x.id === getClientMethod(methodParams, key, 'body', 'component'));
                    let c_props_options = c_props && c_props.componentPropertiesList ? c_props.componentPropertiesList : [];
                    components.push(methodparameteremenu_jsx(treeviewmenu_TreeViewMenu, {
                      open: Visual(state, bodyparameters),
                      active: Visual(state, bodyparameters),
                      onClick: () => {
                        this.props.toggleVisual(bodyparameters);
                      },
                      title: Body,
                      icon: 'fa fa-tv'
                    }, 'body', methodparameteremenu_jsx(formcontrol_FormControl, {}, void 0, methodparameteremenu_jsx(selectinput_SelectInput, {
                      label: InstanceType,
                      value: getClientMethod(methodParams, key, 'body', 'instanceType'),
                      options: Object.keys(InstanceTypes).map(t => ({
                        title: t,
                        value: InstanceTypes[t]
                      })),
                      onChange: value => {
                        methodParams = updateClientMethod(methodParams, key, 'body', 'instanceType', value);
                        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                          prop: nodetypes_NodeProperties.ClientMethodParameters,
                          id: currentNode.id,
                          value: methodParams
                        });
                      }
                    }), methodparameteremenu_jsx(selectinput_SelectInput, {
                      label: Models,
                      value: getClientMethod(methodParams, key, 'body', 'component'),
                      options: componentNodeProperties.map(v => {
                        return {
                          title: GetCodeName(v.id),
                          value: v.id
                        };
                      }),
                      onChange: value => {
                        methodParams = updateClientMethod(methodParams, key, 'body', 'component', value);
                        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                          prop: nodetypes_NodeProperties.ClientMethodParameters,
                          id: currentNode.id,
                          value: methodParams
                        });
                      }
                    }), methodparameteremenu_jsx(selectinput_SelectInput, {
                      label: ComponentModel,
                      value: getClientMethod(methodParams, key, 'body', 'componentModel'),
                      options: c_props_options,
                      onChange: value => {
                        methodParams = updateClientMethod(methodParams, key, 'body', 'componentModel', value);
                        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                          prop: nodetypes_NodeProperties.ClientMethodParameters,
                          id: currentNode.id,
                          value: methodParams
                        });
                      }
                    }))));
                  }
                }
              }

              let screenParameters = uiactions_GetNodeProp(GetNodeById(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ClientMethod)), nodetypes_NodeProperties.ScreenParameters) || [];
              let treeMenu = screenParameters.map(v => {
                let innertree = `${nodeproperty} - ${_ui_type} - ${componentType} - parameter - ${GetParameterName(v)}`;
                let methodparameters = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MethodParameters) || {};
                let parameterProperty = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.MethodParameterProperty) || {};
                return methodparameteremenu_jsx(treeviewmenu_TreeViewMenu, {
                  title: `${GetParameterName(v)}`,
                  icon: 'fa fa-object-group',
                  open: Visual(state, innertree),
                  active: Visual(state, innertree),
                  onClick: () => {
                    this.props.toggleVisual(innertree);
                  }
                }, void 0, methodparameteremenu_jsx(formcontrol_FormControl, {}, void 0, methodparameteremenu_jsx(selectinput_SelectInput, {
                  label: GetParameterName(v),
                  options: componentPropertiesList,
                  value: methodparameters[v.id],
                  onChange: value => {
                    let parameters = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.MethodParameters) || {};
                    parameters[v.id] = value;
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: nodetypes_NodeProperties.MethodParameters,
                      id: currentNode.id,
                      value: parameters
                    });
                  }
                }, `${innertree}`), componentProperties && methodparameters && v && v.id && methodparameters[v.id] ? methodparameteremenu_jsx(selectinput_SelectInput, {
                  options: GetNodesLinkedTo(GetRootGraph(state), {
                    id: componentProperties.properties[methodparameters[v.id]],
                    direction: SOURCE
                  }).toNodeSelect(),
                  onChange: val => {
                    parameterProperty[methodparameters[v.id]] = val;
                    this.props.graphOperation(CHANGE_NODE_PROPERTY, {
                      prop: uiactions_NodeProperties.MethodParameterProperty,
                      id: currentNode.id,
                      value: parameterProperty
                    });
                  },
                  label: Property,
                  value: parameterProperty[methodparameters[v.id]]
                }) : null));
              });
              components.push(treeMenu);
            }
          }
        }
      });
    }

    return methodparameteremenu_jsx("div", {
      style: {
        position: 'relative'
      }
    }, void 0, methodparameteremenu_jsx(mainsidebar_Header, {
      notactive: !active,
      relative: true
    }, void 0, methodparameteremenu_jsx(sidebar_SideBar, {
      relative: true,
      style: {
        paddingTop: 0
      }
    }, void 0, methodparameteremenu_jsx(sidebarmenu_SideBarMenu, {}, void 0, methodparameteremenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${ClientMethod}`,
      icon: 'fa fa-object-group',
      open: Visual(state, METHOD_PARAMETERS),
      active: Visual(state, METHOD_PARAMETERS),
      onClick: () => {
        this.props.toggleVisual(METHOD_PARAMETERS);
      }
    }, void 0, methodparameteremenu_ref, components)))));
  }

}

/* harmony default export */ var methodparameteremenu = (UIConnect(methodparameteremenu_MethodParameterMenu));
// CONCATENATED MODULE: ./app/components/commonactivitymenu.js
var commonactivitymenu_REACT_ELEMENT_TYPE;

function commonactivitymenu_jsx(type, props, key, children) { if (!commonactivitymenu_REACT_ELEMENT_TYPE) { commonactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: commonactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }












class commonactivitymenu_CommonActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = !ExcludeDefaultNode[uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType)];
    return commonactivitymenu_jsx(sidemenucontainer, {
      active: active,
      tab: dashboard_PARAMETER_TAB,
      visual: "common-activty+menu",
      title: CommonProperties
    }, void 0, commonactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? commonactivitymenu_jsx(formcontrol_FormControl, {}, void 0, commonactivitymenu_jsx(textinput_TextInput, {
      label: CodeName,
      disabled: !CanChangeType(currentNode),
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.CodeName] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.CodeName,
          id: currentNode.id,
          value
        });
      }
    }), commonactivitymenu_jsx(textinput_TextInput, {
      label: ValueName,
      disabled: !CanChangeType(currentNode),
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.ValueName] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ValueName,
          id: currentNode.id,
          value
        });
      }
    }), commonactivitymenu_jsx(textinput_TextInput, {
      label: AgentName,
      disabled: !CanChangeType(currentNode),
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.AgentName] : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.AgentName,
          id: currentNode.id,
          value
        });
      }
    }), commonactivitymenu_jsx(textinput_TextInput, {
      label: HttpRoute,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.HttpRoute),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id: currentNode.id,
          value,
          prop: uiactions_NodeProperties.HttpRoute
        });
      }
    })) : null));
  }

}

/* harmony default export */ var commonactivitymenu = (UIConnect(commonactivitymenu_CommonActivityMenu));
// CONCATENATED MODULE: ./app/components/modelfilteritemactivitymenu.js
var modelfilteritemactivitymenu_REACT_ELEMENT_TYPE;

function modelfilteritemactivitymenu_jsx(type, props, key, children) { if (!modelfilteritemactivitymenu_REACT_ELEMENT_TYPE) { modelfilteritemactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: modelfilteritemactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



















class modelfilteritemactivitymenu_ModelFilterItemActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.ModelItemFilter);
    var propertyNodes = [];
    var graph = GetCurrentGraph(state);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (currentNode) {
      var methodNode = GetLinkChainItem(state, {
        id: currentNode.id,
        links: [{
          direction: graph_methods_TARGET,
          type: nodetypes_LinkType.ModelItemFilter
        }]
      });
      var node = null;
      var methodProps = GetMethodProps(methodNode);

      if (methodProps) {
        switch (GetFunctionType(methodNode)) {
          case functiontypes_FunctionTypes.Get_ManyToMany_Agent_Value__IListChild:
            node = GetNode(graph, methodProps[FunctionTemplateKeys.ManyToManyModel]);
            break;

          case functiontypes_FunctionTypes.Create_Object_Agent_Value__IListObject:
          case functiontypes_FunctionTypes.Get_Parent$Child_Agent_Value__IListChild:
          case functiontypes_FunctionTypes.Create_Parent$Child_Agent_Value__IListChild:
          case functiontypes_FunctionTypes.Create_Parent_Child_Agent_Value__Child:
          default:
            node = GetNode(graph, methodProps[FunctionTemplateKeys.ModelOutput] || methodProps[FunctionTemplateKeys.Model]);
            break;
        }
      }

      if (node) {
        let property_nodes = GetModelPropertyChildren(node.id);
        propertyNodes = [...property_nodes.toNodeSelect()];
      }
    }

    return modelfilteritemactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? modelfilteritemactivitymenu_jsx(formcontrol_FormControl, {}, void 0, modelfilteritemactivitymenu_jsx(textinput_TextInput, {
      label: NodeLabel,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIText),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_TEXT, {
          id: currentNode.id,
          value
        });
      }
    }), modelfilteritemactivitymenu_jsx(textinput_TextInput, {
      label: NodeType,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType),
      disabled: true
    }), modelfilteritemactivitymenu_jsx(selectinput_SelectInput, {
      options: propertyNodes,
      defaultSelectText: titles_SelectProperty,
      label: Property,
      onChange: value => {
        var id = currentNode.id;
        let filterModel = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.FilterModel) || createExecutor();
        filterModel = addValidatator(filterModel, {
          id: value
        });
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            id,
            prop: nodetypes_NodeProperties.FilterModel,
            value: filterModel
          }
        }, {
          operation: CHANGE_NODE_PROPERTY,
          options: {
            id,
            prop: nodetypes_NodeProperties.ModelItemFilter,
            value: node.id
          }
        }]);
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ModelItemFilter,
            ...createEventProp(LinkEvents.Remove, {
              function: 'OnRemoveModelFilterPropConnection'
            })
          }
        });
      },
      value: ''
    })) : null, modelfilteritemactivitymenu_jsx("button", {
      type: "submit",
      className: "btn btn-primary",
      onClick: () => {
        this.props.graphOperation(NEW_CONDITION_NODE, {
          parent: Visual(state, SELECTED_NODE),
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ConditionLink
            }
          }
        });
      }
    }, void 0, AddCondition));
  }

}

/* harmony default export */ var modelfilteritemactivitymenu = (UIConnect(modelfilteritemactivitymenu_ModelFilterItemActivityMenu));
// CONCATENATED MODULE: ./app/components/modelrelationshipmenu.js
var modelrelationshipmenu_REACT_ELEMENT_TYPE;

function modelrelationshipmenu_jsx(type, props, key, children) { if (!modelrelationshipmenu_REACT_ELEMENT_TYPE) { modelrelationshipmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: modelrelationshipmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















class modelrelationshipmenu_ModelRelationshipMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Model);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var hasLogicalChildren = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.HasLogicalChildren);
    var hasLogicalNieces = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.HasLogicalNieces);
    return modelrelationshipmenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? modelrelationshipmenu_jsx(formcontrol_FormControl, {}, void 0, modelrelationshipmenu_jsx(checkbox_CheckBox, {
      label: HasLogicalChildren,
      title: HasLogicalChildrenDescription,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.HasLogicalChildren),
      onChange: value => {
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.HasLogicalChildren,
            id: currentNode.id,
            value
          }
        }]);
      }
    }), hasLogicalChildren ? modelrelationshipmenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).map(x => {
        return {
          value: x.id,
          title: GetNodeTitle(x)
        };
      }),
      label: LogicalChildrenTypes,
      onChange: value => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalChildrenTypes) || [];
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.LogicalChildrenTypes,
            id: currentNode.id,
            value: [...types, value].unique(x => x)
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: value,
            source: id,
            properties: { ...uiactions_LinkProperties.LogicalChildren
            }
          }
        }]);
      },
      value: ''
    }) : null, hasLogicalChildren ? modelrelationshipmenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalChildrenTypes) || [];
        return item && types.some(x => x === item.id);
      },
      items: (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalChildrenTypes) || []).map(t => {
        let node = GetNode(GetCurrentGraph(state), t);

        if (node) {
          return {
            title: GetNodeTitle(node),
            id: node.id
          };
        }
      }),
      onClick: item => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalChildrenTypes) || [];
        var ids = types;

        if (types.some(t => item.id === t)) {
          ids = [...ids.filter(t => t !== item.id)].unique(x => x);
        } else {
          ids = [...ids, item.id].unique(x => x);
        }

        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.LogicalChildrenTypes,
            id: currentNode.id,
            value: ids
          }
        }, {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: item.id,
            source: id,
            properties: { ...uiactions_LinkProperties.LogicalChildren
            }
          }
        }]);
      }
    }) : null, modelrelationshipmenu_jsx(checkbox_CheckBox, {
      label: HasLogicalNieces,
      title: HasLogicalNiecesDescription,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.HasLogicalNieces),
      onChange: value => {
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.HasLogicalNieces,
            id: currentNode.id,
            value
          }
        }]);
      }
    }), hasLogicalNieces ? modelrelationshipmenu_jsx(selectinput_SelectInput, {
      options: uiactions_NodesByType(state, NodeTypes.Model).map(x => {
        return {
          value: x.id,
          title: GetNodeTitle(x)
        };
      }),
      label: LogicalNieceTypes,
      onChange: value => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalNieceTypes) || [];
        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.LogicalNieceTypes,
            id: currentNode.id,
            value: [...types, value].unique(x => x)
          }
        }, {
          operation: uiactions_ADD_LINK_BETWEEN_NODES,
          options: {
            target: value,
            source: id,
            properties: { ...uiactions_LinkProperties.LogicalNieces
            }
          }
        }]);
      },
      value: ''
    }) : null, hasLogicalNieces ? modelrelationshipmenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalNieceTypes) || [];
        return item && types.some(x => x === item.id);
      },
      items: (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalNieceTypes) || []).map(t => {
        let node = GetNode(GetCurrentGraph(state), t);

        if (node) {
          return {
            title: GetNodeTitle(node),
            id: node.id
          };
        }
      }),
      onClick: item => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.LogicalNieceTypes) || [];
        var ids = types;

        if (types.some(t => item.id === t)) {
          ids = [...ids.filter(t => t !== item.id)].unique(x => x);
        } else {
          ids = [...ids, item.id].unique(x => x);
        }

        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.LogicalNieceTypes,
            id: currentNode.id,
            value: ids
          }
        }, {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: item.id,
            source: id,
            properties: { ...uiactions_LinkProperties.LogicalNieces
            }
          }
        }]);
      }
    }) : null) : null, currentNode ? modelrelationshipmenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexusTypes) || [];
        return item && types.some(x => x === item.id);
      },
      items: (uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexusTypes) || []).map(t => {
        let node = GetNode(GetCurrentGraph(state), t);

        if (node) {
          return {
            title: GetNodeTitle(node),
            id: node.id
          };
        }
      }),
      onClick: item => {
        let id = currentNode.id;
        var types = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ManyToManyNexusTypes) || [];
        var ids = types;

        if (types.some(t => item.id === t)) {
          ids = [...ids.filter(t => t !== item.id)].unique(x => x);
        } else {
          ids = [...ids, item.id].unique(x => x);
        }

        this.props.graphOperation([{
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.ManyToManyNexusTypes,
            id: currentNode.id,
            value: ids
          }
        }, {
          operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
          options: {
            target: item.id,
            source: id,
            linkType: uiactions_LinkProperties.ManyToManyLink.type
          }
        }]);
      }
    }) : null);
  }

}

/* harmony default export */ var modelrelationshipmenu = (UIConnect(modelrelationshipmenu_ModelRelationshipMenu));
// CONCATENATED MODULE: ./app/components/radiobutton.js

var radiobutton_REACT_ELEMENT_TYPE;

function radiobutton_jsx(type, props, key, children) { if (!radiobutton_REACT_ELEMENT_TYPE) { radiobutton_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: radiobutton_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }











const radiobutton_NODE_MANAGEMENT = 'NODE_MANAGEMENT';
class radiobutton_RadioButton extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      filter: '',
      id: uuidv4()
    };
  }

  render() {
    let me = this;
    let values = this.props.values || [];
    return radiobutton_jsx("div", {
      className: "form-group"
    }, void 0, values.map((val, index) => {
      let {
        value,
        title
      } = val;
      return radiobutton_jsx("div", {
        className: "radio"
      }, `${index}-radio-${this.state.id}`, radiobutton_jsx("label", {}, void 0, radiobutton_jsx("input", {
        type: "radio",
        name: this.state.id,
        id: this.state.id,
        value: this.props.value === value,
        onChange: () => {
          this.props.onChange(value);
        },
        checked: this.props.value === value ? 'checked' : ''
      }), title));
    }));
  }

}
// CONCATENATED MODULE: ./app/components/depthchoice.js
var depthchoice_REACT_ELEMENT_TYPE;

function depthchoice_jsx(type, props, key, children) { if (!depthchoice_REACT_ELEMENT_TYPE) { depthchoice_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: depthchoice_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }











var depthchoice_ref =
/*#__PURE__*/
depthchoice_jsx("div", {});

class depthchoice_NodeManagement extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      filter: ''
    };
  }

  toFilterString(node) {
    return `${uiactions_GetNodeProp(node, nodetypes_NodeProperties.CodeName)} ${node.id} ${uiactions_GetNodeProp(node, nodetypes_NodeProperties.UIText)} ${uiactions_GetNodeProp(node, nodetypes_NodeProperties.NODEType)}`.toLowerCase();
  }

  render() {
    let me = this;
    let {
      state
    } = me.props;
    var graph = GetCurrentGraph(state);

    if (!graph) {
      return depthchoice_ref;
    }

    return depthchoice_jsx(box_Box, {
      title: Depth
    }, void 0, depthchoice_jsx(formcontrol_FormControl, {}, void 0, depthchoice_jsx(selectinput_SelectInput, {
      label: Type,
      options: [].interpolate(0, 7, x => ({
        title: 'Depth  ' + x,
        value: x
      })),
      onChange: val => {
        this.props.graphOperation([{
          operation: SET_DEPTH,
          options: {
            depth: val
          }
        }]);
      },
      value: graph.depth
    })));
  }

}

/* harmony default export */ var depthchoice = (UIConnect(depthchoice_NodeManagement));
// CONCATENATED MODULE: ./app/components/maestroactivitymenu.js
var maestroactivitymenu_REACT_ELEMENT_TYPE;

function maestroactivitymenu_jsx(type, props, key, children) { if (!maestroactivitymenu_REACT_ELEMENT_TYPE) { maestroactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: maestroactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















class maestroactivitymenu_MaestroActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Maestro);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var graph = GetCurrentGraph(state);
    var functions = uiactions_NodesByType(state, [uiactions_NodeTypes.Function, uiactions_NodeTypes.Method]).map(funcKey => {
      return {
        title: GetNodeTitle(funcKey),
        value: funcKey.id
      };
    });
    return maestroactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? maestroactivitymenu_jsx(selectinput_SelectInput, {
      label: Functions,
      options: functions,
      defaultSelectText: AddFunction,
      onChange: value => {
        let id = currentNode.id;
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.FunctionLink
          }
        });
        var inputVariables = getNodesLinkedTo(graph, {
          id: value,
          constraints: {
            [FunctionConstraintKeys.IsInputVariable]: true
          }
        });
        inputVariables.map(inputVariable => {
          this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
            source: inputVariable.id,
            target: id,
            properties: { ...uiactions_LinkProperties.FunctionVariable,
              [LinkPropertyKeys.FUNCTION_ID]: value
            }
          });
        });
      },
      value: ''
    }) : null);
  }

}

/* harmony default export */ var maestroactivitymenu = (UIConnect(maestroactivitymenu_MaestroActivityMenu));
// EXTERNAL MODULE: external "react-draggable"
var external_react_draggable_ = __webpack_require__("react-draggable");
var external_react_draggable_default = /*#__PURE__*/__webpack_require__.n(external_react_draggable_);

// CONCATENATED MODULE: ./app/nodepacks/AddNameDescription.js
/* harmony default export */ var AddNameDescription = (function (args = {}) {
  // node1
  let context = { ...args
  };
  return [function (graph) {
    return [{
      operation: "NEW_PROPERTY_NODE",
      options: {
        parent: context.node0,
        properties: {
          uiAttributeType: "STRING"
        },
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "property-link",
            "property-link": {}
          }
        },
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Name"
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_PROPERTY_NODE",
      options: {
        parent: context.node0,
        properties: {
          uiAttributeType: "STRING"
        },
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "property-link",
            "property-link": {}
          }
        },
        callback: function (node) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "Description"
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/TinyTweaks.js

/* harmony default export */ var TinyTweaks = (function (args = {}) {
  // node0,node1,node2,node3
  let context = {
    node0: args.component,
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    ...args
  };
  return [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {}
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["TopMenu", "MainMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/BasicApplicationLayout.js

/* harmony default export */ var BasicApplicationLayout = (function (args = {}) {
  // node0,node1,node2,node3,node4,node5
  let context = {
    node0: args.component,
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4(),
    ...args
  };
  return [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {
                componentType: "Content"
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"],
                componentType: "View"
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: [],
                componentType: "View"
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"],
                componentType: "View"
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {
                [context.node5]: context.node6
              },
              cellModel: {},
              properties: {
                tags: ["Main"],
                componentType: "View"
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/BasicDoubleSideColumn.js

/* harmony default export */ var BasicDoubleSideColumn = (function (args = {}) {
  // node0,node1,node2,node3,node4,node5,node6,node7,node8,node9,node10,node11
  let context = {
    node0: args.component,
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4(),
    node6: uuidv4(),
    node7: uuidv4(),
    node8: uuidv4(),
    node9: uuidv4(),
    node10: uuidv4(),
    node11: uuidv4(),
    ...args
  };
  return [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node6]: {
              [context.node7]: {},
              [context.node8]: {
                [context.node9]: {},
                [context.node10]: {},
                [context.node11]: {}
              }
            }
          },
          properties: {
            [context.node6]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node7]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node8]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node9]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node10]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node11]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: 150
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/components/modelcontextmenu.js
var modelcontextmenu_REACT_ELEMENT_TYPE;

function modelcontextmenu_jsx(type, props, key, children) { if (!modelcontextmenu_REACT_ELEMENT_TYPE) { modelcontextmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: modelcontextmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }























const modelcontextmenu_CONDITION_FILTER_MENU_PARAMETER = 'condition-filter-menu-parameter';
const modelcontextmenu_DATA_SOURCE = 'DATA_SOURCE';

class modelcontextmenu_ModelContextMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let display = Visual(state, CONTEXT_MENU_MODE) ? 'block' : 'none';
    let nodeType = Visual(state, CONTEXT_MENU_MODE) ? uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) : null;
    let menuMode = Visual(state, CONTEXT_MENU_MODE);

    let exit = () => {
      this.props.setVisual(CONTEXT_MENU_MODE, null);
    };

    return modelcontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: true,
      active: true,
      title: Condition,
      toggle: () => {}
    }, void 0, modelcontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: SelectProperties,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.PropertyLink);
      }
    }));
  }

}

/* harmony default export */ var modelcontextmenu = (UIConnect(modelcontextmenu_ModelContextMenu));
// CONCATENATED MODULE: ./app/components/componentnodemenu.js
var componentnodemenu_REACT_ELEMENT_TYPE;

function componentnodemenu_jsx(type, props, key, children) { if (!componentnodemenu_REACT_ELEMENT_TYPE) { componentnodemenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: componentnodemenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }























const componentnodemenu_CONDITION_FILTER_MENU_PARAMETER = 'condition-filter-menu-parameter';
const componentnodemenu_DATA_SOURCE = 'DATA_SOURCE';

class componentnodemenu_ComponentNodeMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    let exit = () => {
      this.props.setVisual(CONTEXT_MENU_MODE, null);
    };

    return componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      open: true,
      active: true,
      title: Select,
      toggle: () => {}
    }, void 0, componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentInternalApi,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentInternalApi);
      }
    }), componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentExternalApi,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentExternalApi);
      }
    }), componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentExternalConnection,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentExternalConnection);
      }
    }), componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentApiConnection,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentApiConnection);
      }
    }), componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.Component,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.Component);
      }
    }), componentnodemenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ScreenOptions,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ScreenOptions);
      }
    }));
  }

}

/* harmony default export */ var componentnodemenu = (UIConnect(componentnodemenu_ComponentNodeMenu));
// CONCATENATED MODULE: ./app/components/conditioncontextmenu.js
var conditioncontextmenu_REACT_ELEMENT_TYPE;

function conditioncontextmenu_jsx(type, props, key, children) { if (!conditioncontextmenu_REACT_ELEMENT_TYPE) { conditioncontextmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: conditioncontextmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }























const conditioncontextmenu_CONDITION_FILTER_MENU_PARAMETER = "condition-filter-menu-parameter";
const conditioncontextmenu_DATA_SOURCE = "DATA_SOURCE";

var conditioncontextmenu_ref =
/*#__PURE__*/
conditioncontextmenu_jsx("div", {});

var conditioncontextmenu_ref2 =
/*#__PURE__*/
conditioncontextmenu_jsx(sidebarheader_SideBarHeader, {
  title: "Parameters"
});

class conditioncontextmenu_ConditionContextMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let display = Visual(state, CONTEXT_MENU_MODE) ? "block" : "none";
    let nodeType = Visual(state, CONTEXT_MENU_MODE) ? uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) : null;
    let menuMode = Visual(state, CONTEXT_MENU_MODE);

    let exit = () => {
      this.props.setVisual(CONTEXT_MENU_MODE, null);
    };

    let {
      models,
      interestingNode
    } = this.getModels();

    if (!interestingNode || !models) {
      return conditioncontextmenu_ref;
    }

    let methodFunctionValidation = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Condition); // UIA.GetMethodFunctionValidation(permissionNode.id);

    let methodFunctionType = GetMethodFunctionType(interestingNode.id);
    let param_list_key = `${currentNode.id} ${methodFunctionType}`;
    let selectedParameter = Visual(state, param_list_key);
    return conditioncontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: this.state.opened,
      active: true,
      title: Condition,
      toggle: () => {
        this.setState({
          opened: !this.state.opened
        });
      }
    }, void 0, conditioncontextmenu_ref2, conditioncontextmenu_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        return item && selectedParameter === item.id;
      },
      items: models,
      onClick: item => {
        let methodValidationForParameter = addMethodValidationForParamter(methodFunctionValidation, methodFunctionType, item.id);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Condition,
          id: currentNode.id,
          value: methodValidationForParameter
        });
        this.props.setVisual(param_list_key, item.id);
      }
    }));
  }

  getModels() {
    var {
      state
    } = this.props;
    let methodDefinition;
    let methodProps;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let methodDefinitionKey = this.props.methodDefinitionKey;
    let interestingNode;

    if (currentNode) {
      switch (methodDefinitionKey) {
        case PERMISSION:
          interestingNode = uiactions_GetPermissionNode(currentNode.id);
          break;

        case FILTER:
          interestingNode = uiactions_GetModelItemFilter(currentNode.id);
          break;

        case VALIDATION:
          interestingNode = uiactions_GetValidationNode(currentNode.id);
          break;

        default:
          interestingNode = uiactions_GetPermissionNode(currentNode.id);

          if (interestingNode) {
            methodDefinitionKey = PERMISSION;
          } else {
            interestingNode = uiactions_GetModelItemFilter(currentNode.id);

            if (interestingNode) {
              methodDefinitionKey = FILTER;
            } else {
              interestingNode = uiactions_GetValidationNode(currentNode.id);

              if (interestingNode) {
                methodDefinitionKey = VALIDATION;
              }
            }
          }

          break;
      }

      if (interestingNode) {
        methodDefinition = interestingNode ? GetMethodDefinition(interestingNode.id) : null;
        methodProps = GetMethodsProperties(interestingNode.id);
      }
    }

    if (methodDefinition && methodDefinition[methodDefinitionKey] && methodDefinition[methodDefinitionKey].params && methodDefinition[methodDefinitionKey].params.length) {} else if (this.props.view && currentNode) {
      interestingNode = uiactions_GetDataSourceNode(currentNode.id);

      if (!interestingNode) {
        return {};
      }

      methodProps = {
        [conditioncontextmenu_DATA_SOURCE]: uiactions_GetNodeProp(interestingNode, nodetypes_NodeProperties.UIModelType)
      };
    } else {
      return {};
    }

    let filterParameters = GetMethodPermissionParameters(interestingNode.id, true);
    let id = currentNode.id;
    let models = [];

    if (methodDefinition) {
      models = methodDefinition[methodDefinitionKey].params.map(t => {
        if (typeof t === "object") {
          return t.key;
        }

        return t;
      }).map(t => {
        return {
          title: `${GetNodeTitle(methodProps[t])} (${t})`,
          value: t,
          id: t
        };
      });
    } else if (this.props.view) {
      models = GetModelNodes().toNodeSelect();
    }

    return {
      models,
      methodProps,
      interestingNode
    };
  }

}

/* harmony default export */ var conditioncontextmenu = (UIConnect(conditioncontextmenu_ConditionContextMenu));
// CONCATENATED MODULE: ./app/components/datachaincontextmenu.js

var datachaincontextmenu_REACT_ELEMENT_TYPE;

function datachaincontextmenu_jsx(type, props, key, children) { if (!datachaincontextmenu_REACT_ELEMENT_TYPE) { datachaincontextmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: datachaincontextmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

























const datachaincontextmenu_CONDITION_FILTER_MENU_PARAMETER = "condition-filter-menu-parameter";
const datachaincontextmenu_DATA_SOURCE = "DATA_SOURCE";

class datachaincontextmenu_DataChainContextMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    let display = Visual(state, CONTEXT_MENU_MODE) ? "block" : "none";
    let nodeType = Visual(state, CONTEXT_MENU_MODE) ? uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) : null;
    let menuMode = Visual(state, CONTEXT_MENU_MODE);

    let exit = () => {
      this.props.setVisual(CONTEXT_MENU_MODE, null);
    };

    return datachaincontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      title: DataChain,
      open: Visual(state, `datachaincontextmenu`),
      toggle: () => {
        this.props.toggleVisual(`datachaincontextmenu`);
      }
    }, void 0, datachaincontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: SplitDataChain,
      hideArrow: true,
      icon: "fa  fa-share-alt",
      onClick: () => {
        DataChainContextMethods.SplitDataChain.bind(this)(currentNode);
        exit();
      }
    }, "split-data-chain"), datachaincontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: Snip,
      hideArrow: true,
      icon: "fa fa-taxi",
      onClick: () => {
        DataChainContextMethods.SnipDataChain.bind(this)(currentNode);
        exit();
      }
    }, "mindmap"), datachaincontextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, datachaincontextmenu_jsx(selectproperty, {
      title: DataChainCollection,
      link: nodetypes_LinkProperties.DataChainCollection,
      options: uiactions_NodesByType(this.props.state, NodeTypes.DataChainCollection).toNodeSelect(),
      node: currentNode,
      property: nodetypes_NodeProperties.DataChainCollection
    })));
  }

}

/* harmony default export */ var datachaincontextmenu = (UIConnect(datachaincontextmenu_DataChainContextMenu));
// CONCATENATED MODULE: ./app/components/viewtypecontextmenu.js
var viewtypecontextmenu_REACT_ELEMENT_TYPE;

function viewtypecontextmenu_jsx(type, props, key, children) { if (!viewtypecontextmenu_REACT_ELEMENT_TYPE) { viewtypecontextmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: viewtypecontextmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }








class viewtypecontextmenu_ViewTypeMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    return viewtypecontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: true,
      active: true,
      title: Select,
      toggle: () => {}
    }, void 0, viewtypecontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentInternalApi,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentInternalApi);
      }
    }), viewtypecontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentExternalApi,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentExternalApi);
      }
    }), viewtypecontextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.DefaultViewType,
      hideArrow: true,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.DefaultViewType);
      }
    }));
  }

}

/* harmony default export */ var viewtypecontextmenu = (UIConnect(viewtypecontextmenu_ViewTypeMenu));
// CONCATENATED MODULE: ./app/nodepacks/FourColumn.js

/* harmony default export */ var FourColumn = (function (args = {}) {
  // node0,node1,node2,node3,node4,node5
  let context = {
    node0: args.component,
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4(),
    node6: uuidv4(),
    node7: uuidv4(),
    ...args
  };
  return [function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {},
                [context.node7]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellModel": {},
              "properties": {},
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": null
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu", "Header", "TopMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": []
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "LeftContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node6]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryMain"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node7]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "RightContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {},
                [context.node7]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellModel": {},
              "properties": {},
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": null
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu", "Header", "TopMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": []
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "LeftContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node6]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryMain"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node7]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "RightContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {},
                [context.node7]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellModel": {},
              "properties": {},
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": null
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu", "Header", "TopMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": []
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "LeftContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node6]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryMain"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node7]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "RightContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {},
                [context.node7]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellModel": {},
              "properties": {},
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": null
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu", "Header", "TopMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": []
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "LeftContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node6]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryMain"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node7]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "RightContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {},
                [context.node7]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellModel": {},
              "properties": {},
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": null
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu", "Header", "TopMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": []
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "LeftContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node6]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryMain"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node7]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": "100%",
                "borderStyle": "solid",
                "borderWidth": 1,
                "width": "25%"
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["SideContainer", "RightContainer"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/ThreeColumn.js

/* harmony default export */ var ThreeColumn = (function (args = {}) {
  // node0,node1,node2,node3,node4,node5
  let context = {
    node0: args.component,
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4(),
    node6: uuidv4(),
    ...args
  };
  return [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node6]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["RightContainer", "SideContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node6]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["RightContainer", "SideContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node6]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["RightContainer", "SideContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Layout",
        id: context.node0,
        value: {
          layout: {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {
                [context.node4]: {},
                [context.node5]: {},
                [context.node6]: {}
              }
            }
          },
          properties: {
            [context.node1]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                flexDirection: "column"
              },
              children: {},
              cellModel: {},
              properties: {},
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node2]: {
              style: {
                display: "flex",
                flex: null,
                height: null,
                borderStyle: "solid",
                borderWidth: 1,
                width: null
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["MainMenu", "Header", "TopMenu"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node3]: {
              style: {
                display: "flex",
                flex: 1,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1
              },
              children: {},
              cellModel: {},
              properties: {
                tags: []
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node4]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["SideContainer", "LeftContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node5]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["Main"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            },
            [context.node6]: {
              style: {
                display: "flex",
                flex: null,
                height: "100%",
                borderStyle: "solid",
                borderWidth: 1,
                width: "33%"
              },
              children: {},
              cellModel: {},
              properties: {
                tags: ["RightContainer", "SideContainer"]
              },
              cellModelProperty: {},
              cellRoot: {},
              cellEvents: {}
            }
          }
        }
      }
    }];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/UpdateUserExecutor.js
/* harmony default export */ var UpdateUserExecutor = (function (args = {}) {
  // node0,node1,node2
  //
  let context = { ...args,
    node0: args.executor,
    node1: args.model,
    node2: args.property
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node0,
        prop: "Executor",
        value: {
          properties: {
            [context.node1]: {
              validators: {
                [context.node2]: {
                  type: "copy",
                  code: {
                    csharp: "copy"
                  },
                  arguments: {
                    value: {
                      type: "STRING",
                      nodeType: "model-property"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node1,
        source: context.node0,
        properties: {
          type: "executor-model",
          "executor-model": {},
          on: {
            remove: [function (graph) {
              return [{
                function: "OnRemoveExecutorPropConnection"
              }];
            }]
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        id: context.node0,
        prop: "Executor",
        value: {
          properties: {
            [context.node1]: {
              validators: {
                [context.node2]: {
                  type: "copy",
                  code: {
                    csharp: "copy"
                  },
                  arguments: {
                    value: {
                      type: "STRING",
                      nodeType: "model-property"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/layouts/GridHeaderMainMenuMain.js


/* harmony default export */ var GridHeaderMainMenuMain = (function (args = {}) {
  // node0,node1,node2,node3,node4,node5
  //
  let context = { ...args,
    node0: args.component,
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4()
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {
                [context.node3]: {},
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": ""
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["main-screen"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {},
              "name": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {
                [context.node2]: ""
              },
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["main-screen-container"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["Header"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {
                [context.node3]: {},
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": ""
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["main-screen"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {},
              "name": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {
                [context.node2]: ""
              },
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["main-screen-container"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["Header"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {
                [context.node3]: {},
                [context.node4]: {},
                [context.node5]: {}
              }
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": ""
              },
              "children": {},
              "cellModel": {},
              "properties": {
                "tags": ["main-screen"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {},
              "name": {}
            },
            [context.node2]: {
              "style": {
                "display": "flex",
                "flex": null,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {
                [context.node2]: ""
              },
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["main-screen-container"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["Header"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainMenu"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            },
            [context.node5]: {
              "style": {
                "display": "flex",
                "flex": 1,
                "height": null,
                "borderStyle": "solid",
                "borderWidth": 1
              },
              "children": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["Main"]
              },
              "cellModelProperty": {},
              "cellRoot": {},
              "cellEvents": {}
            }
          }
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node4,
        value: false
      };
    }
  }, {
    operation: 'CHANGE_NODE_PROPERTY',
    options: function () {
      return {
        prop: 'Pinned',
        id: context.node5,
        value: false
      };
    }
  }];
  let applyViewPackages = [];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/layouts/ListItemGrid.js
/* eslint-disable func-names */


ListItemGrid.title = 'Applies a list item layout';
ListItemGrid.description = 'Assuming that this will be used in a grid layout';
ListItemGrid.callingArguments = ['mainContent', 'secondaryContent', 'detailContent', 'mainButton', 'secondaryButton'].map(v => ({
  name: v,
  field: v,
  value: v,
  title: v
}));
function ListItemGrid(args = {}) {
  // node0,node1,node2,node3,node4,node5,node6,node7,node8,node9,node10,node11,node12,node13,node14
  //
  if (!args.component) {
    throw new Error('No component set');
  }

  const context = { ...args,
    node0: args.component || uuidv4(),
    node1: uuidv4(),
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4(),
    node6: uuidv4(),
    node7: args.mainContent || uuidv4(),
    node8: uuidv4(),
    node9: uuidv4(),
    node10: args.secondaryContent || uuidv4(),
    node11: uuidv4(),
    node12: args.detailContent || uuidv4(),
    node13: args.mainButton || uuidv4(),
    node14: args.secondaryButton || uuidv4()
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const result = [function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }, function (graph) {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Layout",
        "id": context.node0,
        "value": {
          "layout": {
            [context.node1]: {
              [context.node2]: {},
              [context.node3]: {},
              [context.node4]: {},
              [context.node5]: {},
              [context.node6]: {}
            }
          },
          "properties": {
            [context.node1]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flexDirection": "column"
              },
              "children": {},
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["ListItem"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node2]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node2]: context.node7
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node9
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node3]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node3]: context.node10
              },
              "componentApi": {
                "error": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "success": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property"
                },
                "value": {
                  "instanceType": "SelectorInstance",
                  "selector": context.node8,
                  "handlerType": "property",
                  "dataChain": context.node11
                }
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {}
            },
            [context.node4]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node4]: context.node12
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["DetailContent"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node5]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node5]: context.node13
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["MainButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            },
            [context.node6]: {
              "style": {
                "borderStyle": "solid",
                "borderWidth": 1,
                "flex": null,
                "height": null
              },
              "children": {
                [context.node6]: context.node14
              },
              "cellRoot": {},
              "name": {},
              "cellModel": {},
              "properties": {
                "tags": ["SecondaryButton"]
              },
              "cellModelProperty": {},
              "cellEvents": {},
              "componentApi": {}
            }
          }
        }
      }
    }];
  }];
  const clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node2,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node3,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node4,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node5,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node6,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node7,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node8,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node9,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node10,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node11,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node12,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node13,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node14,
        value: false
      };
    }

  }];
  const applyViewPackages = [];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
}
// CONCATENATED MODULE: ./app/components/functionexecutor.js

var functionexecutor_REACT_ELEMENT_TYPE;

function functionexecutor_jsx(type, props, key, children) { if (!functionexecutor_REACT_ELEMENT_TYPE) { functionexecutor_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: functionexecutor_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/destructuring-assignment */

/* eslint-disable react/prop-types */









class functionexecutor_FunctionExecutor extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  getComponents() {
    const {
      state,
      node
    } = this.props;
    let componentNodes = node ? GetConnectedNodesByType(state, node.id, NodeTypes.ComponentNode, SOURCE) : [];
    componentNodes = [...componentNodes, ...GetNodesByProperties({
      [uiactions_NodeProperties.NODEType]: NodeTypes.ComponentNode,
      [uiactions_NodeProperties.SharedComponent]: true
    }, null, state), ...GetNodesByProperties({
      [uiactions_NodeProperties.NODEType]: NodeTypes.ViewType
    }, null, state)];
    return componentNodes;
  }

  render() {
    const {
      targetFunction,
      state,
      node
    } = this.props;
    const nodes = this.getComponents().toNodeSelect();
    return functionexecutor_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, targetFunction.title),
      active: true,
      title: this.props.title,
      innerStyle: {
        maxHeight: 500,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual(targetFunction.title);
      }
    }, void 0, targetFunction.callingArguments.map(arg => functionexecutor_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, arg.name, functionexecutor_jsx(selectinput_SelectInput, {
      options: nodes,
      label: arg.name,
      onChange: value => {
        this.setState({
          [arg.name]: value
        });
      },
      value: this.state[arg.name]
    }))), functionexecutor_jsx(treeviewmenu_TreeViewMenu, {
      title: targetFunction.title,
      description: targetFunction.description,
      onClick: () => {
        const funcArgs = {};
        targetFunction.callingArguments.forEach(arg => {
          funcArgs[arg.name] = this.state[arg.name] || null;
        });
        this.props.graphOperation(targetFunction({
          component: node.id,
          ...funcArgs
        }));
      }
    }));
  }

}

/* harmony default export */ var functionexecutor = (UIConnect(functionexecutor_FunctionExecutor));
// CONCATENATED MODULE: ./app/components/layoutoptions.js
var layoutoptions_REACT_ELEMENT_TYPE;

function layoutoptions_jsx(type, props, key, children) { if (!layoutoptions_REACT_ELEMENT_TYPE) { layoutoptions_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: layoutoptions_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/destructuring-assignment */

/* eslint-disable react/prop-types */
















class layoutoptions_LayoutOptions extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  getComponents() {
    const {
      state,
      node
    } = this.props;
    let componentNodes = node ? GetConnectedNodesByType(state, node.id, NodeTypes.ComponentNode, SOURCE) : [];
    componentNodes = [...componentNodes, ...GetNodesByProperties({
      [uiactions_NodeProperties.NODEType]: NodeTypes.ComponentNode,
      [uiactions_NodeProperties.SharedComponent]: true
    }, null, state), ...GetNodesByProperties({
      [uiactions_NodeProperties.NODEType]: NodeTypes.ViewType
    }, null, state)];
    return componentNodes;
  }

  render() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));

    const layoutoptions = () => layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "layoutoptions"),
      active: true,
      title: Layout,
      innerStyle: {
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("layoutoptions");
      }
    }, void 0, layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      title: "Set Tiny Tweaks Layout",
      onClick: () => {
        this.props.graphOperation(TinyTweaks({
          component: currentNode.id
        }));
      }
    }), layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      title: "Basic Application Layout",
      onClick: () => {
        this.props.graphOperation(BasicApplicationLayout({
          component: currentNode.id
        }));
      }
    }), layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      title: "Basic Double Side Column",
      onClick: () => {
        this.props.graphOperation(BasicDoubleSideColumn({
          component: currentNode.id
        }));
      }
    }), layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      title: "Four Column",
      onClick: () => {
        this.props.graphOperation(FourColumn({
          component: currentNode.id
        }));
      }
    }), layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      title: "Three Column",
      onClick: () => {
        this.props.graphOperation(ThreeColumn({
          component: currentNode.id
        }));
      }
    }), layoutoptions_jsx(treeviewmenu_TreeViewMenu, {
      title: "Header MainMenu Main",
      onClick: () => {
        this.props.graphOperation(GridHeaderMainMenuMain({
          component: currentNode.id
        }));
      }
    }), layoutoptions_jsx(functionexecutor, {
      node: currentNode,
      title: ListItemGrid.title,
      targetFunction: ListItemGrid
    }));

    return layoutoptions();
  }

}

/* harmony default export */ var components_layoutoptions = (UIConnect(layoutoptions_LayoutOptions));
// CONCATENATED MODULE: ./app/nodepacks/NavigateBack.js

/* harmony default export */ var nodepacks_NavigateBack = (function (args = {
  name: "Replace Name"
}) {
  // node2
  // name
  let context = { ...args,
    node2: args.eventMethodInstance
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Data Chain " + args.name + " Go Back"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: null,
        properties: {
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Navigate To"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "NavigationAction",
        id: context.node1,
        value: "Back"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "go back"
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node0,
        source: context.node2,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/AddButtonToComponent.js


/* harmony default export */ var nodepacks_AddButtonToComponent = (function (args = {}) {
  // node0
  //
  if (!args.component) {
    throw "missing component";
  }

  let context = { ...args,
    node0: args.component
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node0,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO",
          ...viewPackages
        },
        linkProperties: {
          properties: {
            type: "component",
            stroke: "#B7245C",
            component: {}
          }
        },
        callback: function (node, graph, group) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node1,
        value: args.componentType || "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: args.componentType || "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentApi",
        linkProperties: {
          properties: {
            type: "component-internal-api",
            "component-internal-api": {}
          }
        },
        parent: context.node1,
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false,
          UseAsValue: true,
          ...viewPackages
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentExternalApi",
        parent: context.node1,
        linkProperties: {
          properties: {
            type: "component-external-api",
            "component-external-api": {}
          }
        },
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false,
          ...viewPackages
        },
        callback: function (node, graph, group) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node2,
        target: context.node3,
        properties: {
          type: "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node3,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CONNECT_TO_TITLE_SERVICE",
      options: {
        id: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethod",
        properties: {
          EventType: "onClick",
          text: "onClick",
          ...viewPackages
        },
        links: [function (graph) {
          return [{
            target: context.node1,
            linkProperties: {
              properties: {
                type: "EventMethod",
                EventMethod: {}
              }
            }
          }];
        }],
        callback: function (node) {
          context.node4 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethodInstance",
        parent: context.node4,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventMethodInstance",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: "onClick Instance",
          Pinned: false,
          ...viewPackages,
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },
        callback: function (node, graph, group) {
          context.node5 = node.id;
          context.group1 = group;
        }
      }
    }];
  }];
  let clearPinned = !args.clearPinned ? [] : [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/GetScreenValueParameter.js



/* harmony default export */ var GetScreenValueParameter = (function (args = {}) {
  //
  // screen
  if (!args.screen) {
    throw "missing screen argument";
  }

  let context = { ...args
  };
  let {
    viewPackages = {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4()
    }
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get Parameter Id for " + args.screen + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => useParameters()"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get params"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node2,
        value: "x => x.id"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "get "
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node2,
        value: "x => x.value"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "get value"
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: UPDATE_NODE_PROPERTY,
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }, {
    operation: UPDATE_NODE_PROPERTY,
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }, {
    operation: UPDATE_NODE_PROPERTY,
    options: function () {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/ConnectDataChainToCompontApiConnector.js


/* harmony default export */ var ConnectDataChainToCompontApiConnector = (function (args = {}) {
  // node0,node1
  //
  if (!args.componentApiConnector) {
    throw "no component api connector";
  }

  if (!args.dataChain) {
    throw "no data chain";
  }

  let context = { ...args
  };
  let {
    viewPackages = {
      [nodetypes_NodeProperties.ViewPackage]: uuidv4()
    }
  } = args;
  let applyViewPackages = [];
  let result = [function (graph) {
    context.node0 = args.componentApiConnector();
    context.node1 = args.dataChain();
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node0,
        target: context.node1,
        properties: {
          type: "ComponentApiConnection",
          ComponentApiConnection: {}
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/AddComponent.js

/* harmony default export */ var AddComponent = (function (args = {}) {
  // node0
  //
  if (!args.component) {
    throw "missing component";
  }

  let context = { ...args,
    node0: args.component
  };
  let {
    viewPackages = {}
  } = args;
  let result = [function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node0,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO"
        },
        linkProperties: {
          properties: {
            type: "component",
            stroke: "#B7245C",
            component: {}
          }
        },
        callback: function (node, graph, group) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node1,
        value: args.componentType || "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: args.componentType || "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentApi",
        linkProperties: {
          properties: {
            type: "component-internal-api",
            "component-internal-api": {}
          }
        },
        parent: context.node1,
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false,
          UseAsValue: true
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentExternalApi",
        parent: context.node1,
        linkProperties: {
          properties: {
            type: "component-external-api",
            "component-external-api": {}
          }
        },
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false
        },
        callback: function (node, graph, group) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node2,
        target: context.node3,
        properties: {
          type: "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node3,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CONNECT_TO_TITLE_SERVICE",
      options: {
        id: context.node3
      }
    }];
  }];
  let clearPinned = !args.clearPinned ? [] : [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }];
  return [...result, ...clearPinned, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/DataChain_SelectPropertyValue.js


/* harmony default export */ var DataChain_SelectPropertyValue = (function (args = {}) {
  // node0,node3,node4
  // name
  if (!args.name) {
    throw "missing name argument";
  }

  let context = { ...args,
    node0: args.dataChain,
    node3: args.model,
    node4: args.property
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Pass"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "" + args.name + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node0,
        nodeType: "data-chain",
        groupProperties: {
          GroupEntryNode: context.node0,
          GroupExitNode: context.node0
        },
        properties: {
          Pinned: false,
          ChainParent: context.node0
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        links: [],
        callback: function (node, graph, group) {
          context.node1 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node1,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node1,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node1,
        value: "x => x ? x.object : null"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "get object"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        parent: context.node1,
        nodeType: "data-chain",
        groupProperties: {
          id: context.group0
        },
        properties: {
          ChainParent: context.node1
        },
        linkProperties: {
          properties: {
            type: "data-chain-link",
            "data-chain-link": {}
          }
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node2,
        value: "Model - Property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "uiModelType",
        id: context.node2,
        value: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node3,
        source: context.node2,
        properties: {
          type: "model-type-link",
          "model-type-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node2,
        value: "get model property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node2
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Property",
        id: context.node2,
        value: context.node4
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node4,
        source: context.node2,
        properties: {
          type: "property-link",
          "property-link": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node2,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/ReattachComponent.js




/* harmony default export */ var nodepacks_ReattachComponent = (function (args = {}) {
  // node0
  let result = []; //

  if (!args.component) {
    throw "missing component";
  }

  if (!args.base) {
    throw "missing base";
  }

  if (!args.parent) {
    throw "missing parent";
  }

  let context = { ...args
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let graph = GetCurrentGraph();
  let component_parent_link = GetLinkBetween(context.parent, context.component, graph);
  result.push({
    operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
    options: {
      source: context.parent,
      target: context.component
    }
  });
  result.push({
    operation: uiactions_ADD_LINK_BETWEEN_NODES,
    options: {
      target: args.component,
      source: args.base,
      properties: { ...component_parent_link.properties
      }
    }
  });
  let baseInternalApisNodes = GetNodesLinkedTo(graph, {
    id: context.base,
    link: nodetypes_LinkType.ComponentInternalApi
  });
  let parentInternalApis = GetNodesLinkedTo(graph, {
    id: context.parent,
    link: nodetypes_LinkType.ComponentInternalApi
  });
  let tocreate = parentInternalApis.relativeCompliment(baseInternalApisNodes, (x, y) => {
    return GetCodeName(x) === GetCodeName(y);
  });
  result.push(...tocreate.map(internalApi => {
    return $addComponentApiNodes(context.base, GetNodeTitle(internalApi), internalApi.id);
  }).flatten());
  let exteranlApiNodes = GetNodesLinkedTo(graph, {
    id: context.component,
    link: nodetypes_LinkType.ComponentExternalApi,
    direction: SOURCE
  });
  let previousLinked = {};
  exteranlApiNodes.map(externalApiNode => {
    let internalApiComponents = GetNodesLinkedTo(graph, {
      id: externalApiNode.id,
      link: nodetypes_LinkType.ComponentExternalConnection,
      direction: SOURCE
    });
    internalApiComponents.map(internalApiComponent => {
      let isThereAConnection = parentInternalApis.find(parentInternalApi => GetLinkBetween(externalApiNode.id, parentInternalApi.id, graph));
      previousLinked[GetNodeTitle(externalApiNode)] = previousLinked[GetNodeTitle(externalApiNode)] || [];

      if (isThereAConnection) {
        previousLinked[GetNodeTitle(externalApiNode)].push({
          id: externalApiNode.id,
          properties: isThereAConnection.properties
        });
      }

      result.push({
        operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
        options: {
          source: externalApiNode.id,
          target: internalApiComponent.id
        }
      });
    });
  });
  result.push(function (graph) {
    let res = [];
    baseInternalApisNodes = GetNodesLinkedTo(graph, {
      id: context.base,
      link: nodetypes_LinkType.ComponentInternalApi
    });

    for (var i in previousLinked) {
      let baseInternalApiNode = baseInternalApisNodes.find(v => GetNodeTitle(v) === i.id);

      if (baseInternalApiNode) {
        previousLinked[i].map(pl => {
          res.push({
            operation: uiactions_ADD_LINK_BETWEEN_NODES,
            options: {
              target: baseInternalApiNode.id,
              source: pl.id,
              properties: { ...pl.properties
              }
            }
          });
        });
      }
    }

    return res;
  });
  return result;
});
// CONCATENATED MODULE: ./app/nodepacks/AddTitleToComponent.js


/* harmony default export */ var nodepacks_AddTitleToComponent = (function (args = {}) {
  // node0
  if (!args.component) {
    throw "no component";
  } //


  let context = { ...args,
    node0: args.component
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_COMPONENT_NODE",
      options: {
        parent: context.node0,
        groupProperties: {},
        properties: {
          UIType: "ElectronIO"
        },
        linkProperties: {
          properties: {
            type: "component",
            component: {}
          }
        },
        callback: function (node, graph, group) {
          context.node1 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node1,
        value: "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Button"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentApi",
        linkProperties: {
          properties: {
            type: "component-internal-api",
            "component-internal-api": {}
          }
        },
        parent: context.node1,
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false,
          UseAsValue: true
        },
        callback: function (node, graph, group) {
          context.node2 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentExternalApi",
        parent: context.node1,
        linkProperties: {
          properties: {
            type: "component-external-api",
            "component-external-api": {}
          }
        },
        groupProperties: {},
        properties: {
          text: "label",
          Pinned: false
        },
        callback: function (node, graph, group) {
          context.node3 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node2,
        target: context.node3,
        properties: {
          type: "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node3,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CONNECT_TO_TITLE_SERVICE",
      options: {
        id: context.node3
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethod",
        properties: {
          EventType: "onClick",
          text: "onClick"
        },
        links: [null],
        callback: function (node) {
          context.node4 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "EventMethodInstance",
        parent: context.node4,
        groupProperties: {},
        linkProperties: {
          properties: {
            type: "EventMethodInstance",
            EventMethodInstance: {}
          }
        },
        properties: {
          text: "onClick Instance",
          Pinned: false,
          AutoDelete: {
            properties: {
              nodeType: "component-api-connector"
            }
          }
        },
        callback: function (node, graph, group) {
          context.node5 = node.id;
          context.group1 = group;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node1,
        value: "Image"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "component-type",
        id: context.node1,
        value: "Title"
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentApi",
        linkProperties: {
          properties: {
            type: "component-internal-api",
            "component-internal-api": {}
          }
        },
        parent: context.node1,
        groupProperties: {},
        properties: {
          text: "value",
          Pinned: false,
          UseAsValue: true
        },
        callback: function (node, graph, group) {
          context.node6 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_NEW_NODE",
      options: {
        nodeType: "ComponentExternalApi",
        parent: context.node1,
        linkProperties: {
          properties: {
            type: "component-external-api",
            "component-external-api": {}
          }
        },
        groupProperties: {},
        properties: {
          text: "value",
          Pinned: false
        },
        callback: function (node, graph, group) {
          context.node7 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        source: context.node6,
        target: context.node7,
        properties: {
          type: "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Label",
        id: context.node1,
        value: "Title"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node1,
        value: "Title"
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node2,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node3,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node4,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node5,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node6,
        value: false
      };
    }
  }, {
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node7,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node1,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node3,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node4,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node5,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node6,
        properties: viewPackages
      };
    }
  }, {
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node7,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/CreateSetViewModelDataChain.js


/* harmony default export */ var CreateSetViewModelDataChain = (function (args = {}) {
  // node1
  // model
  if (!args.model) {
    throw "missing model argument";
  }

  let context = { ...args,
    node1: args.modelId
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Data Chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node0,
        value: "x => Models.#{model}"
      }
    }];
  }, function (graph) {
    return [{
      operation: "REMOVE_LINK_BETWEEN_NODES",
      options: {
        source: context.node0
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "LambdaInsertArguments",
        id: context.node0,
        value: {
          model: context.node1
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "ADD_LINK_BETWEEN_NODES",
      options: {
        target: context.node1,
        source: context.node0,
        properties: {
          type: "LambdaInsertArguments",
          LambdaInsertArguments: {}
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Set View Model To " + args.model + ""
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/nodepacks/AttachDataChainsToViewTypeViewModel.js







let AttachDataChainsToViewTypeViewModel_func = function (args = {
  viewType
}) {
  // node0,node1
  //
  if (!args.viewType) {
    throw "missing viewType";
  }

  let graph = GetCurrentGraph();
  let {
    viewType
  } = args;
  let viewModelNode = GetComponentExternalApiNode(ComponentApiTypes.ViewModel, viewType);
  let property = GetNodesLinkedTo(graph, {
    id: viewType,
    link: nodetypes_LinkType.DefaultViewType
  }).find(x => [NodeTypes.Property].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType)));
  let model = GetNodesLinkedTo(graph, {
    id: viewType,
    link: nodetypes_LinkType.DefaultViewType
  }).find(x => [NodeTypes.Model].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType)));

  if (property) {
    model = GetNodeLinkedTo(graph, {
      id: property.id,
      link: nodetypes_LinkType.ModelTypeLink
    }) || model;
  }

  let result = [];

  if (viewModelNode) {
    let dataChains = GetNodesLinkedTo(graph, {
      id: viewModelNode.id,
      link: nodetypes_LinkType.DataChainLink
    });

    if (!dataChains.length) {
      let _context = null;
      result.push(...CreateSetViewModelDataChain({
        model: GetNodeTitle(model),
        modelId: model.id,
        callback: node => {
          _context = node;
        }
      }), {
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: function () {
          return {
            source: viewModelNode.id,
            target: _context.entry,
            properties: { ...nodetypes_LinkProperties.DataChainLink
            }
          };
        }
      });
    }
  }

  return result;
};

AttachDataChainsToViewTypeViewModel_func.description = "Appends a data chain to a view type component, which will default the view Model to the type of model that the component expects";
/* harmony default export */ var AttachDataChainsToViewTypeViewModel = (AttachDataChainsToViewTypeViewModel_func);
// CONCATENATED MODULE: ./app/nodepacks/SetInnerApiValueToLocalContextInLists.js




let SetInnerApiValueToLocalContextInLists_func = function () {
  // node0,node1
  //
  let result = [];
  let lists = uiactions_NodesByType(null, NodeTypes.ComponentNode).filter(x => [ComponentTypeKeys.List, ComponentTypeKeys.MultiSelectList, ComponentTypeKeys.SingleSelect].some(v => v === uiactions_GetNodeProp(x, nodetypes_NodeProperties.ComponentType)));

  if (lists && lists.length) {
    lists.map(list => {
      let valueApiNode = GetComponentApiNode(ComponentApiTypes.Value, list.id);

      if (valueApiNode) {
        result.push({
          operation: CHANGE_NODE_PROPERTY,
          options: {
            id: valueApiNode.id,
            prop: nodetypes_NodeProperties.AsLocalContext,
            value: true
          }
        });
      }
    });
  }

  return result;
};

SetInnerApiValueToLocalContextInLists_func.description = "Sets the inner api component value to use the local context.";
/* harmony default export */ var SetInnerApiValueToLocalContextInLists = (SetInnerApiValueToLocalContextInLists_func);
// CONCATENATED MODULE: ./app/nodepacks/SetupApiBetweenComponents.js




let SetupApiBetweenComponents_func = function (args = {}) {
  //
  let result = [];

  if (!args.component_a) {
    throw "missing component_a";
  }

  if (!args.component_b) {
    throw "missing component_b";
  }

  if (!args.component_a.id) {
    throw "missing component_a.id";
  }

  if (!args.component_b.id) {
    throw "missing component_b.id";
  }

  if (!args.component_a.external) {
    throw "missing component_a.external";
  }

  if (!args.component_a.internal) {
    throw "missing component_a.internal";
  }

  if (!args.component_b.external) {
    throw "missing component_b.external";
  }

  if (!args.component_b.internal) {
    throw "missing component_b.internal";
  }

  let {
    viewPackages
  } = args;
  result.push(function (graph) {
    let result = [];
    let a_id = getId(args.component_a.id);
    let b_id = getId(args.component_b.id);
    let a_external_id = getId(args.component_a.external);
    let b_external_id = getId(args.component_b.external);
    let a_internal_id = getId(args.component_a.internal);
    let b_internal_id = getId(args.component_b.internal);
    let componentA = GetNodeById(a_id, graph);
    let componentB = GetNodeById(b_id, graph);
    let componentA_external_node = GetComponentExternalApiNode(a_external_id, componentA.id, graph);
    let componentB_external_node = GetComponentExternalApiNode(b_external_id, componentB.id, graph);
    let componentB_internal_node = GetComponentApiNode(b_internal_id, componentB.id, graph);
    let componentA_internal_node = GetComponentApiNode(a_internal_id, componentA.id, graph);

    if (componentA && componentB) {
      if (!componentA_external_node) {
        result.push({
          operation: ADD_NEW_NODE,
          options: function () {
            return {
              nodeType: NodeTypes.ComponentExternalApi,
              parent: componentA.id,
              groupProperties: {},
              properties: { ...viewPackages,
                [nodetypes_NodeProperties.UIText]: a_external_id
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentExternalApi
                }
              },
              callback: node => {
                componentA_external_node = node;
              }
            };
          }
        });
      }

      if (!componentA_internal_node) {
        result.push({
          operation: ADD_NEW_NODE,
          options: function () {
            return {
              nodeType: NodeTypes.ComponentApi,
              parent: componentA.id,
              groupProperties: {},
              properties: { ...viewPackages,
                [nodetypes_NodeProperties.UIText]: a_internal_id
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                }
              },
              callback: node => {
                componentA_internal_node = node;
              }
            };
          }
        });
      }

      result.push({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: function (graph) {
          let thereIsAnExistingLink = existsLinkBetween(graph, {
            source: componentA_internal_node.id,
            target: componentA_external_node.id
          });
          if (!thereIsAnExistingLink) return {
            source: componentA_internal_node.id,
            target: componentA_external_node.id,
            properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
            }
          };
          return null;
        }
      });

      if (!componentB_external_node) {
        result.push({
          operation: ADD_NEW_NODE,
          options: function () {
            return {
              nodeType: NodeTypes.ComponentExternalApi,
              parent: componentB.id,
              groupProperties: {},
              properties: { ...viewPackages,
                [nodetypes_NodeProperties.UIText]: b_external_id
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentExternalApi
                }
              },
              callback: node => {
                componentB_external_node = node;
              }
            };
          }
        });
      }

      if (!componentB_internal_node) {
        result.push({
          operation: ADD_NEW_NODE,
          options: function () {
            return {
              nodeType: NodeTypes.ComponentApi,
              parent: componentB.id,
              groupProperties: {},
              properties: { ...viewPackages,
                [nodetypes_NodeProperties.UIText]: b_internal_id
              },
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                }
              },
              callback: node => {
                componentB_internal_node = node;
              }
            };
          }
        });
      }

      result.push({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: function (graph) {
          let thereIsAnExistingLink = existsLinkBetween(graph, {
            source: componentB_internal_node.id,
            target: componentB_external_node.id
          });
          if (!thereIsAnExistingLink) return {
            source: componentB_internal_node.id,
            target: componentB_external_node.id,
            properties: { ...nodetypes_LinkProperties.ComponentInternalConnection
            }
          };
          return null;
        }
      });
      result.push({
        operation: uiactions_ADD_LINK_BETWEEN_NODES,
        options: function (graph) {
          let thereIsAnExistingLink = existsLinkBetween(graph, {
            source: componentB_external_node.id,
            target: componentA_internal_node.id
          });
          if (!thereIsAnExistingLink) return {
            source: componentB_external_node.id,
            target: componentA_internal_node.id,
            properties: { ...nodetypes_LinkProperties.ComponentExternalConnection
            }
          };
          return null;
        }
      });
    }

    return result;
  });
  return result;
};

function getId(val) {
  if (typeof val === "function") {
    return val();
  }

  return val;
}

SetupApiBetweenComponents_func.description = "Sets the inner api component value to use the local context.";
/* harmony default export */ var SetupApiBetweenComponents = (SetupApiBetweenComponents_func);
// CONCATENATED MODULE: ./app/nodepacks/CreateFormInput.js






function createForm(args = {
  modelProperty: null,
  parent: null,
  uiType: null,
  sharedComponent: false,
  viewType: false
}) {
  //
  if (args.parent) {
    if (!args.uiType) {
      args.uiType = uiactions_GetNodeProp(args.parent, nodetypes_NodeProperties.UIType);
    }
  } //


  if (!args.modelProperty) {
    throw "missing a modelProperty";
  }

  if (!args.viewType) {
    throw "missing a viewType";
  }

  if (!args.parent) {
    throw "missing a parent";
  }

  if (!args.uiType) {
    throw "missing uiType";
  }

  let context = { ...args
  };
  let result = [];
  let {
    parent,
    modelProperty,
    sharedComponent,
    viewComponentType,
    viewType,
    uiType
  } = context;
  let useModelInstance = [viewtypes_ViewTypes.Get, viewtypes_ViewTypes.GetAll, viewtypes_ViewTypes.Delete].some(v => viewType === v);
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  result.push({
    operation: NEW_COMPONENT_NODE,
    options: function () {
      // Check if the property has a default view to use for different types of situations
      return {
        parent,
        groupProperties: {},
        properties: { ...viewPackages,
          [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(modelProperty)}`,
          [nodetypes_NodeProperties.UIType]: uiType,
          [nodetypes_NodeProperties.Label]: GetNodeTitle(modelProperty),
          [nodetypes_NodeProperties.ComponentType]: sharedComponent || viewComponentType,
          [nodetypes_NodeProperties.UsingSharedComponent]: !!sharedComponent,
          [nodetypes_NodeProperties.Pinned]: false,
          [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance
        },
        linkProperties: {
          properties: { ...uiactions_LinkProperties.ComponentLink
          }
        },
        callback: component => {
          if (args.callback) {
            args.callback(component);
          }
        }
      };
    }
  });
  return result;
}

createForm.description = "Create a form based on a modelProperty";
/* harmony default export */ var CreateFormInput = (createForm);
// CONCATENATED MODULE: ./app/nodepacks/CreateForm.js








function CreateForm_createForm(args = {
  model: null,
  component: null,
  viewName: null
}) {
  //
  args.viewType = uiactions_GetNodeProp(args.component, nodetypes_NodeProperties.ViewType) || args.viewType;
  args.uiType = uiactions_GetNodeProp(args.component, nodetypes_NodeProperties.UIType) || args.uiType; //

  if (!args.component) {
    throw "missing component";
  }

  if (!args.viewName) {
    throw "view Name";
  }

  if (!args.viewType) {
    throw "missing a viewType";
  }

  if (!args.uiType) {
    throw "missing uiType";
  }

  let context = { ...args
  };
  let result = [];
  let {
    viewPackages,
    uiType,
    viewType
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let isSharedComponent = uiactions_GetNodeProp(args.component, nodetypes_NodeProperties.SharedComponent);
  let useModelInstance = [viewtypes_ViewTypes.Get, viewtypes_ViewTypes.GetAll, viewtypes_ViewTypes.Delete].some(v => viewType === v);
  let properties = GetModelPropertyChildren(args.model).filter(x => !uiactions_GetNodeProp(x, nodetypes_NodeProperties.IsDefaultProperty));
  let formComponent = null;
  result.push({
    operation: NEW_COMPONENT_NODE,
    options: function (currentGraph) {
      return {
        callback: screenComponent => {
          formComponent = screenComponent.id;
        },
        parent: context.component,
        properties: { ...viewPackages,
          [nodetypes_NodeProperties.UIText]: `${context.viewName}`,
          [nodetypes_NodeProperties.UIType]: uiType,
          [nodetypes_NodeProperties.ViewType]: viewType,
          [nodetypes_NodeProperties.SharedComponent]: isSharedComponent,
          [nodetypes_NodeProperties.ComponentType]: ComponentTypes[uiType].Form.key,
          [nodetypes_NodeProperties.InstanceType]: useModelInstance ? InstanceTypes.ModelInstance : InstanceTypes.ScreenInstance
        },
        groupProperties: {},
        linkProperties: {
          properties: { ...nodetypes_LinkProperties.ComponentLink
          }
        }
      };
    }
  });
  properties.map(property => {
    let componentProperty = null;
    result.push(function (graph) {
      return [...CreateFormInput({
        modelProperty: property.id,
        parent: formComponent,
        viewType,
        viewPackages,
        graph,
        callback: node => {
          componentProperty = node;
        }
      })];
    }, ...["value", "viewModel"].map(api => {
      return SetupApiBetweenComponents({
        viewPackages: { ...viewPackages,
          [nodetypes_NodeProperties.Pinned]: false
        },
        component_a: {
          id: () => args.component,
          external: api,
          internal: api
        },
        component_b: {
          id: () => formComponent,
          external: api,
          internal: api
        }
      });
    }).flatten(), ...["value", "viewModel"].map(api => {
      return SetupApiBetweenComponents({
        viewPackages: { ...viewPackages,
          [nodetypes_NodeProperties.Pinned]: false
        },
        component_a: {
          id: () => formComponent,
          external: api,
          internal: api
        },
        component_b: {
          id: () => componentProperty.id,
          external: api,
          internal: api
        }
      });
    }).flatten(), ...["error", "success", "placeholder", "label"].map(api => {
      return SetupApiBetweenComponents({
        viewPackages: { ...viewPackages,
          [nodetypes_NodeProperties.Pinned]: false
        },
        component_a: {
          id: () => formComponent,
          external: "value",
          internal: "value"
        },
        component_b: {
          id: () => componentProperty.id,
          external: api,
          internal: api
        }
      });
    }).flatten());
  });
  return result;
}

CreateForm_createForm.description = "Create a form based on a model";
/* harmony default export */ var CreateForm = (CreateForm_createForm);
// CONCATENATED MODULE: ./app/nodepacks/CopyPermissionConditions.js



function CopyPermissionConditions_CopyPermissionConditions(args = {
  permission
}) {
  let {
    permission,
    node
  } = args;
  let conditions = GetNodesLinkedTo(GetCurrentGraph(), {
    id: permission,
    link: nodetypes_LinkType.Condition
  }).map(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.Condition));
  let method = GetNodesLinkedTo(GetCurrentGraph(), {
    id: permission,
    link: nodetypes_LinkType.FunctionOperator
  }).find(x => x);
  let currentConditions = GetNodesLinkedTo(GetCurrentGraph(), {
    id: node,
    link: nodetypes_LinkType.Condition
  });
  let currentNodeMethod = GetNodesLinkedTo(GetCurrentGraph(), {
    id: node,
    link: nodetypes_LinkType.FunctionOperator
  }).find(x => x);
  let functionType = uiactions_GetNodeProp(method, nodetypes_NodeProperties.FunctionType);
  let currentNodeMethodFunctionType = uiactions_GetNodeProp(currentNodeMethod, nodetypes_NodeProperties.FunctionType);
  let result = [];
  currentConditions.map(cc => {
    result.push({
      operation: REMOVE_NODE,
      options: function () {
        return {
          id: cc.id
        };
      }
    });
  });
  conditions.map(condition => {
    result.push({
      operation: ADD_NEW_NODE,
      options: function () {
        let temp = JSON.parse(JSON.stringify(condition));
        temp.methods[currentNodeMethodFunctionType] = temp.methods[functionType];
        if (functionType !== currentNodeMethodFunctionType) delete temp.methods[functionType];
        return {
          nodeType: NodeTypes.Condition,
          properties: {
            [nodetypes_NodeProperties.Condition]: temp,
            [nodetypes_NodeProperties.Pinned]: false
          },
          parent: node,
          groupProperties: {},
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.ConditionLink
            }
          }
        };
      }
    });
  });
  return result;
}
// CONCATENATED MODULE: ./app/nodepacks/_create_get_view_model.js



function create_get_view_model(args = {
  viewModel: null
}) {
  // node1
  if (!args.viewModel) {
    throw "missing view model argument";
  } // model


  if (!args.model) {
    throw "missing model argument";
  }

  let context = { ...args,
    node1: args.viewModel
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    return [{
      operation: "NEW_NODE",
      options: {
        callback: function (node) {
          context.node0 = node.id;
        }
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Add View Model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "action"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "attribute-property"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "nodeType",
        id: context.node0,
        value: "data-chain"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "EntryPoint",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "AsOutput",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "DataChainFunctionType",
        id: context.node0,
        value: "Lambda"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Lambda",
        id: context.node0,
        value: "x => " + args.model + ""
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_TEXT",
      options: {
        id: context.node0,
        value: "Get View Model"
      }
    }];
  }, function (graph) {
    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Pinned",
        id: context.node0,
        value: true
      }
    }];
  }, function (graph) {
    return [{
      operation: "NEW_LINK",
      options: {
        target: context.node0,
        source: context.node1,
        properties: {
          type: "data-chain-link",
          "data-chain-link": {},
          singleLink: true,
          nodeTypes: ["data-chain"]
        }
      }
    }];
  }];
  let clearPinned = [{
    operation: "CHANGE_NODE_PROPERTY",
    options: function () {
      return {
        prop: "Pinned",
        id: context.node1,
        value: false
      };
    }
  }];
  let applyViewPackages = [{
    operation: "UPDATE_NODE_PROPERTY",
    options: function () {
      return {
        id: context.node0,
        properties: viewPackages
      };
    }
  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
}

create_get_view_model.description = 'Creates a data chain that will return a defined string.';
/* harmony default export */ var _create_get_view_model = (create_get_view_model);
// CONCATENATED MODULE: ./app/nodepacks/validation/NameLikeValidation.js




function NameLikeValidation(args = {
  condition: null,
  property: null
}) {
  // node0,node1,node2,node3,node4,node5
  if (!args.condition) {
    throw "missing condition";
  } //


  if (!args.methodType) {
    throw "missing method type";
  }

  let context = { ...args,
    node0: args.condition,
    node1: args.property,
    node2: uuidv4(),
    node3: uuidv4(),
    node4: uuidv4(),
    node5: uuidv4()
  };
  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  let result = [function (graph) {
    let previousCondition = uiactions_GetNodeProp(GetNodeById(context.condition, graph), nodetypes_NodeProperties.Condition);
    let properties = {};

    if (previousCondition && previousCondition.methods && previousCondition.methods[context.methodType] && previousCondition.methods[context.methodType][context.methodKey] && previousCondition.methods[context.methodType][context.methodKey].properties) {
      properties = previousCondition.methods[context.methodType][context.methodKey].properties;
    }

    return [{
      operation: "CHANGE_NODE_PROPERTY",
      options: {
        prop: "Condition",
        id: context.node0,
        value: {
          methods: {
            [context.methodType]: {
              model: {
                properties: { ...properties,
                  [context.node1]: {
                    validators: {
                      [context.node2]: {
                        type: "minLengthEqual",
                        code: {
                          csharp: "MinAttribute"
                        },
                        template: "./app/templates/validation/validation_generic.tpl",
                        arguments: {
                          value: {
                            type: "INT",
                            nodeType: "model-property"
                          },
                          condition: {
                            type: "INT",
                            nodeType: null,
                            equals: true,
                            defaultValue: 0
                          }
                        },
                        condition: context.minLength || "3"
                      },
                      [context.node3]: {
                        type: "maxlengthEqual",
                        code: {
                          csharp: "MaximumLengthAttribute"
                        },
                        template: "./app/templates/validation/validation_generic.tpl",
                        arguments: {
                          value: {
                            type: "INT",
                            nodeType: "model-property"
                          },
                          condition: {
                            type: "INT",
                            nodeType: null,
                            equals: true,
                            defaultValue: 0
                          }
                        },
                        condition: context.maxLength || "50"
                      },
                      [context.node4]: {
                        type: "alphaonlywithspaces",
                        code: {
                          csharp: "AlphaOnlyWithSpacesAttribute"
                        },
                        template: "./app/templates/validation/validation_generic.tpl",
                        arguments: {
                          value: {
                            type: "STRING",
                            nodeType: "model-property"
                          }
                        }
                      },
                      [context.node5]: {
                        type: "isNotNull",
                        code: {
                          csharp: "IsNotNullAttribute"
                        },
                        template: "./app/templates/validation/validation_generic.tpl",
                        arguments: {
                          value: {
                            type: "STRING",
                            nodeType: "model-property"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }];
  }];
  let clearPinned = [];
  let applyViewPackages = [];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
}

NameLikeValidation.title = "Name List Validation";
NameLikeValidation.description = "Minimum length 3, Max length 50 and just alpha chars.";
/* harmony default export */ var validation_NameLikeValidation = (NameLikeValidation);
// CONCATENATED MODULE: ./app/nodepacks/validation/DescriptionLikeValidation.js





function DescriptionLikeValidation(args) {
  // node0,node1,node2,node3,node4,node5
  return validation_NameLikeValidation({ ...args,
    maxLength: 500
  });
}

DescriptionLikeValidation.title = "Description List Validation";
DescriptionLikeValidation.description = "Minimum length 3, Max length 500 and just alpha chars.";
/* harmony default export */ var validation_DescriptionLikeValidation = (DescriptionLikeValidation);
// CONCATENATED MODULE: ./app/nodepacks/ClearExecutor.js



function ClearExecutor(args = {
  currentNode
}) {
  let {
    currentNode
  } = args;
  var propertyNodes = GetModelPropertyChildren(uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ExecutorModel), {
    skipLogicalChildren: true
  }).toNodeSelect();
  return ClearExecutor_addProperty(propertyNodes.filter(x => !uiactions_GetNodeProp(x.value, nodetypes_NodeProperties.IsDefaultProperty)).map(t => {
    return t.value;
  }), currentNode);
}
ClearExecutor.description = "Clears all executors";

let ClearExecutor_addProperty = (values, currentNode) => {
  let executor = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor) || createExecutor();
  var operation = values.map(value => {
    var id = currentNode.id;
    executor = addValidatator(executor, {
      id: value
    });
    return [{
      operation: CHANGE_NODE_PROPERTY,
      options: function () {
        return {
          id: currentNode.id,
          prop: nodetypes_NodeProperties.Executor,
          value: null
        };
      }
    }];
  }).flatten();
  return operation;
};
// CONCATENATED MODULE: ./app/nodepacks/AddMenuToComponent.js
/* eslint-disable func-names */


/* harmony default export */ var AddMenuToComponent = (function (args = {}) {
  // node0,node1
  // menu_name, menu_name, index, menu_name, navigate_function
  if (!args.menu_name) {
    throw new Error('missing menu_name argument');
  }

  if (!args.navigate_function) {
    throw new Error('missing navigate_function argument');
  }

  if (!args.menuGeneration) {
    throw new Error('missing menuGeneration argument');
  }

  if (!args.component) {
    throw new Error('missing component arguments');
  }

  let {
    viewPackages
  } = args;
  viewPackages = {
    [nodetypes_NodeProperties.ViewPackage]: uuidv4(),
    ...(viewPackages || {})
  };
  const context = { ...args,
    uiType: args.uiType || "ElectronIO",
    node0: args.component,
    node1: viewPackages[nodetypes_NodeProperties.ViewPackage]
  };
  const result = [function () {
    return [{
      "operation": "NEW_COMPONENT_NODE",
      "options": {
        "parent": context.node0,
        "groupProperties": {},
        "properties": {
          "UIType": context.uiType,
          "view-package": viewPackages[nodetypes_NodeProperties.ViewPackage]
        },
        "linkProperties": {
          "properties": {
            "type": "component",
            "stroke": "#B7245C",
            "component": {}
          }
        },
        "callback": function (node) {
          context.node2 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "component-type",
        "id": context.node2,
        "value": "Button"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node2,
        "value": "Button"
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "nodeType": "ComponentApi",
        "linkProperties": {
          "properties": {
            "type": "component-internal-api",
            "component-internal-api": {}
          }
        },
        "parent": context.node2,
        "groupProperties": {},
        "properties": {
          "text": "label",
          "Pinned": false,
          "UseAsValue": true,
          "view-package": context.node1
        },
        "callback": function (node, graph, group) {
          context.node3 = node.id;
          context.group0 = group;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "nodeType": "ComponentExternalApi",
        "parent": context.node2,
        "linkProperties": {
          "properties": {
            "type": "component-external-api",
            "component-external-api": {}
          }
        },
        "groupProperties": {},
        "properties": {
          "text": "label",
          "Pinned": false,
          "view-package": context.node1
        },
        "callback": function (node) {
          context.node4 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node3,
        "target": context.node4,
        "properties": {
          "type": "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node4,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CONNECT_TO_TITLE_SERVICE",
      "options": {
        "id": context.node4
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "nodeType": "EventMethod",
        "properties": {
          "EventType": "onClick",
          "text": "onClick",
          "view-package": context.node1
        },
        "links": [{
          target: context.node2,
          linkProperties: {
            properties: { ...nodetypes_LinkProperties.EventMethod
            }
          }
        }],
        "callback": function (node) {
          context.node5 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "nodeType": "EventMethodInstance",
        "parent": context.node5,
        "groupProperties": {},
        "linkProperties": {
          "properties": {
            "type": "EventMethodInstance",
            "EventMethodInstance": {}
          }
        },
        "properties": {
          "text": "onClick Instance",
          "Pinned": false,
          "view-package": context.node1,
          "AutoDelete": {
            "properties": {
              "nodeType": "component-api-connector"
            }
          }
        },
        "callback": function (node, graph, group) {
          context.node6 = node.id;
          context.group1 = group;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node2,
        "value": `${args.menu_name}`
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "component-type",
        "id": context.node2,
        "value": "Menu"
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "nodeType": "ComponentApi",
        "linkProperties": {
          "properties": {
            "type": "component-internal-api",
            "component-internal-api": {}
          }
        },
        "parent": context.node2,
        "groupProperties": {},
        "properties": {
          "text": "value",
          "Pinned": false,
          "UseAsValue": true
        },
        "callback": function (node) {
          context.node7 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "nodeType": "ComponentExternalApi",
        "parent": context.node2,
        "linkProperties": {
          "properties": {
            "type": "component-external-api",
            "component-external-api": {}
          }
        },
        "groupProperties": {},
        "properties": {
          "text": "value",
          "Pinned": false
        },
        "callback": function (node) {
          context.node8 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_LINK_BETWEEN_NODES",
      "options": {
        "source": context.node7,
        "target": context.node8,
        "properties": {
          "type": "component-internal-connection",
          "component-internal-connection": {}
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node8,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node9 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node9,
        "value": `${args.menu_name} Menu Data Source`
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node9,
        "value": "data-chain"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "EntryPoint",
        "id": context.node9,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node9,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node9,
        "value": "Pass"
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "parent": context.node9,
        "nodeType": "data-chain",
        "groupProperties": {
          "GroupEntryNode": context.node9,
          "GroupExitNode": context.node9
        },
        "properties": {
          "Pinned": false,
          "ChainParent": context.node9
        },
        "linkProperties": {
          "properties": {
            "type": "data-chain-link",
            "data-chain-link": {}
          }
        },
        "links": [],
        "callback": function (node, graph, group) {
          context.node10 = node.id;
          context.group2 = group;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node10,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node10,
        "value": context.buildMethod || "Lambda"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node10,
        "value": `${context.menuGeneration}`
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node10,
        "value": "return menu"
      }
    }];
  }, function () {
    return [{
      "operation": "ADD_NEW_NODE",
      "options": {
        "parent": context.node10,
        "nodeType": "data-chain",
        "groupProperties": {
          "id": context.group2
        },
        "properties": {
          "ChainParent": context.node10
        },
        "linkProperties": {
          "properties": {
            "type": "data-chain-link",
            "data-chain-link": {}
          }
        },
        "callback": function (node) {
          context.node11 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node11,
        "value": "convert to graph"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "AsOutput",
        "id": context.node11,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node11,
        "value": "Lambda"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node11,
        "value": "array => {\n    let graph = RedGraph.create();\n\n    array.map(item => {\n        RedGraph.addNode(graph, item, null);\n    }).forEach(item => {\n        if (item && item.parent) {\n            RedGraph.addLink(graph, item.parent, item.id)\n        }\n    });\n    return graph;\n}"
      }
    }];
  }, function () {
    return [{
      "operation": "NEW_LINK",
      "options": {
        "target": context.node9,
        "source": context.node8,
        "properties": {
          "type": "data-chain-link",
          "data-chain-link": {},
          "singleLink": true,
          "nodeTypes": ["data-chain"]
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node6,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "NEW_NODE",
      "options": {
        "callback": function (node) {
          context.node12 = node.id;
        }
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_TEXT",
      "options": {
        "id": context.node12,
        "value": `${args.menu_name} Navigate To Pages`
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "nodeType",
        "id": context.node12,
        "value": "data-chain"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "EntryPoint",
        "id": context.node12,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "AsOutput",
        "id": context.node12,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "DataChainFunctionType",
        "id": context.node12,
        "value": "Lambda"
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Pinned",
        "id": context.node12,
        "value": true
      }
    }];
  }, function () {
    return [{
      "operation": "CHANGE_NODE_PROPERTY",
      "options": {
        "prop": "Lambda",
        "id": context.node12,
        "value": `${args.navigate_function}`
      }
    }];
  }, function () {
    return [{
      "operation": "NEW_LINK",
      "options": {
        "target": context.node12,
        "source": context.node6,
        "properties": {
          "type": "data-chain-link",
          "data-chain-link": {},
          "singleLink": true,
          "nodeTypes": ["data-chain"]
        }
      }
    }];
  }];
  const clearPinned = [{
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node1,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node2,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node3,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node4,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node5,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node6,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node7,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node8,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node9,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node10,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node11,
        value: false
      };
    }

  }, {
    operation: 'CHANGE_NODE_PROPERTY',

    options() {
      return {
        prop: 'Pinned',
        id: context.node12,
        value: false
      };
    }

  }];
  const applyViewPackages = [{
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node2,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node3,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node4,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node5,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node6,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node7,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node8,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node9,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node10,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node11,
        properties: viewPackages
      };
    }

  }, {
    operation: 'UPDATE_NODE_PROPERTY',

    options() {
      return {
        id: context.node12,
        properties: viewPackages
      };
    }

  }];
  return [...result, ...clearPinned, ...applyViewPackages, function () {
    if (context.callback) {
      context.entry = context.node0;
      context.callback(context);
    }

    return [];
  }];
});
// CONCATENATED MODULE: ./app/constants/menu.js
/* eslint-disable import/prefer-default-export */
 // import { titleService } from "../templates/electronio/v1/app/actions/util"

const standardNavigate = () => `(id) => {
  navigate.Go({ route: routes[id] })(GetDispatch(), GetState());
}`;

const MenuTreeOptions = {
  ScreenMenu: {
    menuGeneration: () => `() => {
      return Object.keys(routes).filter(v => routes[v].indexOf(':') === -1).map(v => ({ id: v, title: titleService.get(v), parent: null }));
    }`,
    navigate_function: standardNavigate
  },
  ModelMethodMenu: {
    menuGeneration: () => `()=>true`,
    navigate_function: standardNavigate,
    buildMethod: DataChainFunctionKeys.ModelMethodMenu
  }
};
// CONCATENATED MODULE: ./app/components/contextmenu.js

var contextmenu_REACT_ELEMENT_TYPE;

function contextmenu_jsx(type, props, key, children) { if (!contextmenu_REACT_ELEMENT_TYPE) { contextmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: contextmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/destructuring-assignment */

/* eslint-disable func-names */

/* eslint-disable default-case */

/* eslint-disable no-shadow */

 // The default












































































const contextmenu_DATA_SOURCE = "DATA_SOURCE";

var contextmenu_ref =
/*#__PURE__*/
contextmenu_jsx(viewtypecontextmenu, {});

var contextmenu_ref2 =
/*#__PURE__*/
contextmenu_jsx(modelcontextmenu, {});

var contextmenu_ref3 =
/*#__PURE__*/
contextmenu_jsx(componentnodemenu, {});

var contextmenu_ref4 =
/*#__PURE__*/
contextmenu_jsx(conditioncontextmenu, {});

var contextmenu_ref5 =
/*#__PURE__*/
contextmenu_jsx(datachaincontextmenu, {});

var _ref6 =
/*#__PURE__*/
contextmenu_jsx(components_layoutoptions, {});

var _ref7 =
/*#__PURE__*/
contextmenu_jsx("span", {
  "aria-hidden": "true"
}, void 0, "\xD7");

class contextmenu_ContextMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  getMenuMode(mode) {
    const result = [...this.generalMenu()];

    const exit = () => {
      this.props.setVisual(CONTEXT_MENU_MODE, null);
    };

    switch (mode) {
      case "layout":
        result.push(contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: true,
          active: true,
          title: Layout,
          toggle: () => {}
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Layout,
          icon: "fa fa-taxi",
          onClick: () => {
            this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
            exit();
          }
        }, "layoutview"), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: titles_MindMap,
          icon: "fa fa-taxi",
          onClick: () => {
            this.props.setVisual(MAIN_CONTENT, MIND_MAP);
            exit();
          }
        }, "mindmap"), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: titles_CodeView,
          icon: "fa fa-taxi",
          onClick: () => {
            this.props.setVisual(MAIN_CONTENT, CODE_VIEW);
            exit();
          }
        }, "codeview")));
        break;

      default:
        result.push(this.getContextMenu());
        break;
    }

    result.push(...this.eventMenu());
    result.push(...this.apiMenu());
    result.push(...this.operations());
    result.push(this.minimizeMenu());
    result.push(...this.linkOperations());
    result.push(this.hideTypeMenu());
    return result.filter(x => x);
  }

  linkOperations() {
    const result = [];
    const {
      state
    } = this.props;
    const selectedLink = Visual(state, SELECTED_LINK);

    if (selectedLink) {
      const link = getLinkInstance(GetCurrentGraph(), {
        target: selectedLink.target,
        source: selectedLink.source
      });

      if (link) {
        result.push(...[contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          active: true,
          title: LinkType,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          open: Visual(state, LinkType),
          toggle: () => {
            this.props.toggleVisual(LinkType);
          }
        }, LinkType, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: Object.keys(nodetypes_LinkType).sort().map(v => ({
            title: v,
            value: nodetypes_LinkType[v],
            id: nodetypes_LinkType[v]
          })),
          label: LinkType,
          onChange: value => {},
          value: GetLinkProperty(link, LinkPropertyKeys.TYPE)
        })))]);
        const linkType = GetLinkProperty(link, LinkPropertyKeys.TYPE);

        switch (GetLinkProperty(link, LinkPropertyKeys.TYPE)) {
          case nodetypes_LinkType.Component:
            result.push(contextmenu_jsx(treeviewmenu_TreeViewMenu, {
              open: Visual(state, `linkType coponent`),
              active: true,
              title: linkType,
              innerStyle: {
                maxHeight: 300,
                overflowY: "auto"
              },
              toggle: () => {
                this.props.toggleVisual(`linkType coponent`);
              }
            }, `${linkType}${selectedLink.id} componenttag`, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(checkbox_CheckBox, {
              label: AsForm,
              onChange: value => {
                this.props.graphOperation([{
                  operation: UPDATE_LINK_PROPERTY,

                  options() {
                    return {
                      id: link.id,
                      prop: LinkPropertyKeys.AsForm,
                      value
                    };
                  }

                }]);
              },
              value: GetLinkProperty(link, LinkPropertyKeys.AsForm)
            }))));
            break;

          case nodetypes_LinkType.Style:
            result.push(contextmenu_jsx(treeviewmenu_TreeViewMenu, {
              open: Visual(state, `linkType coponent`),
              active: true,
              title: linkType,
              innerStyle: {
                maxHeight: 300,
                overflowY: "auto"
              },
              toggle: () => {
                this.props.toggleVisual(`linkType coponent`);
              }
            }, `${linkType}${selectedLink.id} componenttag`, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
              options: Object.keys(ComponentTags).map(x => ({
                id: x,
                value: x,
                title: x
              })),
              label: LinkType,
              onChange: value => {
                this.props.graphOperation([{
                  operation: UPDATE_LINK_PROPERTY,

                  options() {
                    return {
                      id: link.id,
                      prop: LinkPropertyKeys.ComponentTag,
                      value
                    };
                  }

                }]);
              },
              value: GetLinkProperty(link, LinkPropertyKeys.ComponentTag)
            })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
              options: Object.keys(StyleTags).map(x => ({
                id: x,
                value: x,
                title: x
              })),
              label: LinkType,
              onChange: value => {
                this.props.graphOperation([{
                  operation: UPDATE_LINK_PROPERTY,

                  options() {
                    return {
                      id: link.id,
                      prop: LinkPropertyKeys.ComponentStyle,
                      value
                    };
                  }

                }]);
              },
              value: GetLinkProperty(link, LinkPropertyKeys.ComponentStyle)
            }))));
            break;

          case nodetypes_LinkType.ComponentExternalConnection:
          case nodetypes_LinkType.EventMethodInstance:
          case nodetypes_LinkType.ComponentExternalApi:
          default:
            const skip = false; // if (LinkType.ComponentExternalApi === linkType) {
            //   if (
            //     ![NodeTypes.ViewType].some(
            //       v =>
            //         v === UIA.GetNodeProp(link.source, NodeProperties.NODEType)
            //     ) &&
            //     ![NodeTypes.ViewType].some(
            //       v =>
            //         v === UIA.GetNodeProp(link.target, NodeProperties.NODEType)
            //     )
            //   ) {
            //     skip = true;
            //   }
            // }

            if (!skip) result.push(contextmenu_jsx(treeviewmenu_TreeViewMenu, {
              open: Visual(state, linkType),
              active: true,
              title: linkType,
              innerStyle: {
                maxHeight: 300,
                overflowY: "auto"
              },
              toggle: () => {
                this.props.toggleVisual(linkType);
              }
            }, `${linkType}${selectedLink.id}`, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(checkbox_CheckBox, {
              label: LinkPropertyKeys.InstanceUpdate,
              value: GetLinkProperty(link, LinkPropertyKeys.InstanceUpdate),
              onChange: value => {
                this.props.graphOperation([{
                  operation: UPDATE_LINK_PROPERTY,

                  options() {
                    return {
                      id: link.id,
                      prop: LinkPropertyKeys.InstanceUpdate,
                      value
                    };
                  }

                }]);
              }
            }))));
            break;
        }
      }
    }

    return result;
  }

  hideTypeMenu() {
    const HIDE_TYPE_MENU = "HIDE_TYPE_MENU";
    const {
      state
    } = this.props;
    return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, HIDE_TYPE_MENU),
      active: true,
      title: HideTypeMenu,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual(HIDE_TYPE_MENU);
      }
    }, void 0, Object.keys(NodeTypes).sort().map(type => contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: type,
      icon: Hidden(state, NodeTypes[type]) ? "fa fa-circle-o" : "fa fa-check-circle-o",
      toggle: () => {
        this.props.toggleHideByTypes(NodeTypes[type]);
      }
    }, `node-${type}`)));
  }

  minimizeMenu() {
    const MINIMIZE_MENU = "MINIMIZE_MENU";
    const {
      state
    } = this.props;
    return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, MINIMIZE_MENU),
      active: true,
      title: MinimizeTypeMenu,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual(MINIMIZE_MENU);
      }
    }, void 0, Object.keys(NodeTypes).sort().map(type => contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: type,
      icon: !Minimized(state, NodeTypes[type]) ? "fa fa-circle-o" : "fa fa-check-circle-o",
      toggle: () => {
        this.props.toggleMinimized(NodeTypes[type]);
      }
    }, `node-${type}`)));
  }

  generalMenu() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const graph = GetCurrentGraph();
    return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "GENERAL_MENU"),
      active: true,
      title: Operations,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("GENERAL_MENU");
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "dccollections"),
      active: true,
      title: Collections,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("dccollections");
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Update",
      active: true,
      onClick: () => {
        this.props.graphOperation(CollectionDataChainsIntoCollections());
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Clear",
      active: true,
      onClick: () => {
        this.props.graphOperation(uiactions_NodesByType(null, NodeTypes.DataChainCollection).map(v => ({
          operation: REMOVE_NODE,
          options: {
            id: v.id
          }
        })));
      }
    })), uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) === NodeTypes.Permission ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, `${NodeTypes.Permission} ${Operations}`),
      active: true,
      title: `Permission ${Operations}`,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual(`${NodeTypes.Permission} ${Operations}`);
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      onClick: () => {
        const permissions = uiactions_NodesByType(null, NodeTypes.Permission);
        const result = [];
        permissions.filter(x => x.id !== currentNode.id).filter(x => {
          const methodNode = uiactions_GetMethodNode(x.id);
          const currentMethodNode = uiactions_GetMethodNode(currentNode.id);
          return GetMethodNodeProp(methodNode.id, FunctionTemplateKeys.Agent) === GetMethodNodeProp(currentMethodNode.id, FunctionTemplateKeys.Agent);
        }).map(permission => {
          result.push(...CopyPermissionConditions_CopyPermissionConditions({
            permission: currentNode.id,
            node: permission.id
          }));
        });
        this.props.graphOperation(result);
      },
      title: CopyToAll
    })) : null, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "modelfilter OPERATIONS"),
      active: true,
      title: `Model Filter ${Operations}`,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("modelfilter OPERATIONS");
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      title: `${SelectAll} on all nodes`,
      onClick: () => {
        const filters = uiactions_NodesByType(null, NodeTypes.ModelFilter);
        filters.map(filter => {
          const model = uiactions_GetNodeProp(filter, nodetypes_NodeProperties.FilterModel);
          const propnodes = GetModelPropertyChildren(model);
          const fprops = uiactions_GetNodeProp(filter, uiactions_NodeProperties.FilterPropreties) || {};
          propnodes.map(node => {
            fprops[node.id] = true;
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.FilterPropreties,
            id: filter.id,
            value: fprops
          });
        });
      }
    })), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "method OPERATIONS"),
      active: true,
      title: `Method ${Operations}`,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("method OPERATIONS");
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      title: "Add Filters to GetAll",
      onClick: () => {
        this.props.graphOperation(AddFiltersToGetAll({}));
      }
    })), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "executor OPERATIONS"),
      active: true,
      title: `Executor ${Operations}`,
      innerStyle: {
        maxHeight: 300,
        overflowY: "auto"
      },
      toggle: () => {
        this.props.toggleVisual("executor OPERATIONS");
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      title: "Have all properties",
      description: "Executors will have all properties added in executor.",
      onClick: () => {
        const executors = uiactions_NodesByType(null, NodeTypes.Executor);
        const result = [];
        executors.map(executor => {
          const steps = AddAllPropertiesToExecutor({
            currentNode: executor
          });
          result.push(...steps);
        });
        this.props.graphOperation(result);
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      title: nodepacks_AddCopyPropertiesToExecutor.title,
      description: nodepacks_AddCopyPropertiesToExecutor.description,
      onClick: () => {
        const executors = uiactions_NodesByType(null, NodeTypes.Executor);
        const result = [];
        executors.map(executor => {
          const steps = nodepacks_AddCopyPropertiesToExecutor({
            currentNode: executor,
            executor: uiactions_GetNodeProp(executor, nodetypes_NodeProperties.Executor)
          });
          result.push(...steps);
        });
        this.props.graphOperation(result);
      }
    })), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Modify Update Links",
      active: true,
      onClick: () => {
        this.props.graphOperation(ModifyUpdateLinks());
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: NodeTypes.ComponentApi,
      open: Visual(state, NodeTypes.ComponentApi),
      active: true,
      onClick: () => {
        this.props.toggleVisual(NodeTypes.ComponentApi);
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Value(s) To Local Context",
      description: SetInnerApiValueToLocalContextInLists.description,
      active: true,
      onClick: () => {
        this.props.graphOperation(SetInnerApiValueToLocalContextInLists());
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Create Component Api",
      open: Visual(state, "Create Component Api"),
      active: true,
      onClick: () => {
        this.props.toggleVisual("Create Component Api");
      }
    }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
      label: `${Component} A`,
      options: uiactions_NodesByType(this.props.state, NodeTypes.ComponentNode).sort((a, b) => GetNodeTitle(a).localeCompare(GetNodeTitle(b))).toNodeSelect(),
      onChange: value => {
        this.setState({
          componentA: value
        });
      },
      value: this.state.componentA
    })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
      immediate: true,
      label: `${ExternalApi} A`,
      placeholder: `${ExternalApi} A`,
      onChange: value => {
        this.setState({
          externalApiA: value
        });
      },
      value: this.state.externalApiA
    })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
      immediate: true,
      label: `${InternalApi} A`,
      placeholder: InternalApi,
      onChange: value => {
        this.setState({
          internalApiA: value
        });
      },
      value: this.state.internalApiA
    })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
      label: `${Component} B`,
      options: uiactions_NodesByType(this.props.state, NodeTypes.ComponentNode).filter(x => existsLinkBetween(graph, {
        source: this.state.componentA,
        target: x.id
      })).toNodeSelect(),
      onChange: value => {
        this.setState({
          componentB: value
        });
      },
      value: this.state.componentB
    })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
      immediate: true,
      label: `${ExternalApi} B`,
      placeholder: `${ExternalApi} B`,
      onChange: value => {
        this.setState({
          externalApiB: value
        });
      },
      value: this.state.externalApiB
    })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
      immediate: true,
      label: `${InternalApi} B`,
      placeholder: `${InternalApi} B`,
      onChange: value => {
        this.setState({
          internalApiB: value
        });
      },
      value: this.state.internalApiB
    })), this.state.componentA && this.state.componentB && this.state.externalApiB && this.state.internalApiB && this.state.internalApiA && this.state.externalApiA ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Setup Api Between Components",
      description: SetupApiBetweenComponents.description,
      active: true,
      onClick: () => {
        this.props.graphOperation(SetupApiBetweenComponents({
          component_a: {
            id: this.state.componentA,
            external: this.state.externalApiA,
            internal: this.state.internalApiA
          },
          component_b: {
            id: this.state.componentB,
            external: this.state.externalApiB,
            internal: this.state.internalApiB
          }
        }));
      }
    }) : null)), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: "Create Dashboard",
      open: Visual(state, `Create Dashboard`),
      active: true,
      onClick: () => {
        // this.props.graphOperation(GetModelViewModelForList({}));
        this.props.toggleVisual(`Create Dashboard`);
      }
    }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
      immediate: true,
      label: Name,
      placeholder: EnterName,
      onChange: value => {
        this.setState({
          dashboard: value
        });
      },
      value: this.state.dashboard
    })), this.state.dashboard ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: Execute,
      onClick: () => {
        this.props.graphOperation(CreateDashboard_1({
          name: this.state.dashboard
        }));
        this.setState({
          dashboard: ""
        });
      }
    }) : null))];
  }

  operations() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const currentNodeType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType);
    let temp;

    const layoutoptions = () => contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, "ScreenOptionOperations"),
      active: true,
      title: Layout,
      innerStyle: {
        maxHeight: 600,
        overflowY: "auto"
      },
      onClick: () => {
        this.setState({
          secondaryMenu: SecondaryOptions.LayoutOptions
        });
      }
    });

    const viewTypeModel = currentNode ? GetViewTypeModel(currentNode.id) : null;

    switch (currentNodeType) {
      case NodeTypes.DataChainCollection:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          active: true,
          title: AddDataChainCollection,
          onClick: () => {
            if (!GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.DataChainCollection,
              direction: SOURCE
            }).some(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.NODEType) === currentNodeType)) {
              this.props.graphOperation([{
                operation: ADD_NEW_NODE,

                options() {
                  return {
                    nodeType: NodeTypes.DataChainCollection,
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.DataChainCollection
                      }
                    },
                    parent: currentNode.id,
                    properties: {
                      [nodetypes_NodeProperties.UIText]: currentNodeType
                    }
                  };
                }

              }]);
            }
          }
        }))];

      case NodeTypes.Screen:
        const viewType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ViewType);

        switch (viewType) {
          case viewtypes_ViewTypes.GetAll:
          case viewtypes_ViewTypes.Get:
          case viewtypes_ViewTypes.Create:
          case viewtypes_ViewTypes.Update:
            const screenModel = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Model);
            return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
              open: Visual(state, "OPERATIONS"),
              active: true,
              title: Operations,
              innerStyle: {
                maxHeight: 300,
                overflowY: "auto"
              },
              toggle: () => {
                this.props.toggleVisual("OPERATIONS");
              }
            }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
              title: "Connect",
              open: Visual(state, `Connect`),
              active: true,
              onClick: () => {
                this.props.toggleVisual(`Connect`);
              }
            }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
              label: Methods,
              options: uiactions_NodesByType(this.props.state, NodeTypes.Method).filter(x => (MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {}).method === viewType).filter(x => {
                if (screenModel) {
                  const modelOutput = GetMethodNodeProp(x, FunctionTemplateKeys.ModelOutput) || GetMethodNodeProp(x, FunctionTemplateKeys.Model);
                  return modelOutput === screenModel;
                }

                return true;
              }).toNodeSelect(),
              onChange: value => {
                this.setState({
                  method: value
                });
              },
              value: this.state.method
            })), [viewtypes_ViewTypes.GetAll, viewtypes_ViewTypes.Get].some(v => v === viewType) ? contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
              label: NavigateTo,
              options: uiactions_NodesByType(this.props.state, NodeTypes.Screen).filter(x => {
                if (viewType === viewtypes_ViewTypes.Get) {
                  return uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewType) === viewtypes_ViewTypes.Update;
                }

                return uiactions_GetNodeProp(x, nodetypes_NodeProperties.ViewType) === viewtypes_ViewTypes.Get;
              }).filter(x => {
                if (screenModel) {
                  const modelOutput = uiactions_GetNodeProp(x, nodetypes_NodeProperties.Model);
                  return modelOutput === screenModel;
                }

                return true;
              }).toNodeSelect(),
              onChange: value => {
                this.setState({
                  navigateTo: value
                });
              },
              value: this.state.navigateTo
            })) : null, viewType === viewtypes_ViewTypes.Update ? contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
              label: ComponentDidMount,
              options: uiactions_NodesByType(this.props.state, NodeTypes.Method).filter(x => (MethodFunctions[uiactions_GetNodeProp(x, nodetypes_NodeProperties.FunctionType)] || {}).method === viewtypes_ViewTypes.Get).filter(x => {
                if (screenModel) {
                  const modelOutput = GetMethodNodeProp(x, FunctionTemplateKeys.ModelOutput) || GetMethodNodeProp(x, FunctionTemplateKeys.Model);
                  return modelOutput === screenModel;
                }

                return true;
              }).toNodeSelect(),
              onChange: value => {
                this.setState({
                  componentDidMountMethod: value
                });
              },
              value: this.state.componentDidMountMethod
            })) : null, this.state.method ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
              title: Execute,
              onClick: () => {
                let commands = [];

                switch (viewType) {
                  case viewtypes_ViewTypes.Get:
                    commands = ScreenConnectGet({
                      method: this.state.method,
                      node: currentNode.id,
                      navigateTo: this.state.navigateTo
                    });
                    break;

                  case viewtypes_ViewTypes.GetAll:
                    commands = ScreenConnectGetAll({
                      method: this.state.method,
                      node: currentNode.id,
                      navigateTo: this.state.navigateTo
                    });
                    break;

                  case viewtypes_ViewTypes.Create:
                    commands = ScreenConnectCreate({
                      method: this.state.method,
                      node: currentNode.id
                    });
                    break;

                  case viewtypes_ViewTypes.Update:
                    commands = ScreenConnectUpdate({
                      method: this.state.method,
                      componentDidMountMethod: this.state.componentDidMountMethod,
                      node: currentNode.id
                    });
                }

                commands.push(() => CollectionDataChainsIntoCollections());
                this.props.graphOperation([...commands]);
              }
            }) : null))];
        }

        break;

      case NodeTypes.DataChain:
        // DataChain_SelectPropertyValue
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Select Model Property",
          open: Visual(state, `Select Model Property`),
          active: true,
          onClick: () => {
            // this.props.graphOperation(GetModelViewModelForList({}));
            this.props.toggleVisual(`Select Model Property`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
          label: Name,
          immediate: true,
          onChange: value => {
            this.setState({
              name: value
            });
          },
          value: this.state.name
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Models,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Model).toNodeSelect(),
          onChange: value => {
            this.setState({
              model: value
            });
          },
          value: this.state.model
        })), this.state.model ? contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Properties,
          options: GetModelPropertyChildren(this.state.model).toNodeSelect(),
          onChange: value => {
            this.setState({
              property: value
            });
          },
          value: this.state.property
        })) : null, this.state.model && this.state.name && this.state.property ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Execute,
          onClick: () => {
            this.props.graphOperation([...DataChain_SelectPropertyValue({
              name: this.state.name,
              dataChain: currentNode.id,
              model: this.state.model,
              property: this.state.property
            })]);
          }
        }) : null))];

      case NodeTypes.ComponentApiConnector:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Assign Screen Value Parameter",
          open: Visual(state, `Assign Screen Value Parmater`),
          active: true,
          onClick: () => {
            // this.props.graphOperation(GetModelViewModelForList({}));
            this.props.toggleVisual(`Assign Screen Value Parmater`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Screen,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Screen).toNodeSelect(),
          onChange: value => {
            this.setState({
              screen: value
            });
          },
          value: this.state.screen
        })), this.state.screen ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Execute,
          onClick: () => {
            this.props.graphOperation([...GetScreenValueParameter({
              screen: GetNodeTitle(this.state.screen),
              callback: dataChain => {
                temp = dataChain;
              }
            }), ...ConnectDataChainToCompontApiConnector({
              dataChain() {
                return temp.entry;
              },

              componentApiConnector() {
                return currentNode.id;
              }

            })]);
          }
        }) : null))];

      case NodeTypes.EventMethodInstance:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Navigate Back After",
          onClick: () => {
            this.props.graphOperation(nodepacks_NavigateBack({
              eventMethodInstance: currentNode.id,
              name: `${GetNodeTitle(currentNode)}`
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Navigate to screen",
          open: Visual(state, `Navigate to screen`),
          active: true,
          onClick: () => {
            // this.props.graphOperation(GetModelViewModelForList({}));
            this.props.toggleVisual(`Navigate to screen`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Screen,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Screen).toNodeSelect(),
          onChange: value => {
            this.setState({
              screen: value
            });
          },
          value: this.state.screen
        })), this.state.screen ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Execute",
          onClick: () => {
            let _navigateContext = null;
            this.props.graphOperation([...CreateNavigateToScreenDC({
              screen: this.state.screen,
              node: currentNode.id,
              callback: navigateContext => {
                _navigateContext = navigateContext;
              }
            })]);
          }
        }) : null))];

      case NodeTypes.LifeCylceMethodInstance:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Add Store Model Array Standard Handler",
          onClick: () => {
            const methodCall = GetNodeMethodCall(currentNode.id);

            if (methodCall) {
              let model = GetMethodProps(methodCall.id) || GetMethodProps(methodCall.id, FunctionTemplateKeys.Model);

              if (model) {
                model = model[FunctionTemplateKeys.ModelOutput] || model[FunctionTemplateKeys.Model];

                if (model) {
                  this.props.graphOperation(StoreModelArrayStandard({
                    model,
                    state_key: `${GetNodeTitle(model)} State`
                  }));
                }
              }
            }
          }
        }))];

      case NodeTypes.ComponentExternalApi:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "AddModelPropertyGetterDC"),
          title: "Add Model Property Getter",
          active: true,
          onClick: () => {
            this.props.toggleVisual("AddModelPropertyGetterDC");
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Models,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Model).toNodeSelect(),
          onChange: value => {
            this.setState({
              model: value
            });
          },
          value: this.state.model
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Models,
          options: GetModelPropertyChildren(this.state.model).toNodeSelect(),
          onChange: value => {
            this.setState({
              property: value
            });
          },
          value: this.state.property
        })), this.state.model && this.state.property ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Execute",
          onClick: () => {
            this.props.graphOperation([...CreateModelPropertyGetterDC({
              model: this.state.model,
              property: this.state.property,
              propertyName: GetNodeTitle(this.state.property),
              modelName: GetNodeTitle(this.state.model),
              callback: context => {
                temp = context.entry;
              }
            }), {
              operation: uiactions_ADD_LINK_BETWEEN_NODES,

              options() {
                return {
                  source: currentNode.id,
                  target: temp,
                  properties: { ...nodetypes_LinkProperties.DataChainLink
                  }
                };
              }

            }]);
          }
        }) : null), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Connect to Title Service",
          active: true,
          onClick: () => {
            this.props.graphOperation([{
              operation: CONNECT_TO_TITLE_SERVICE,
              options: {
                id: currentNode.id
              }
            }]);
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Attach View Model Data Chain"),
          title: "Attach View Model Data Chain",
          description: _create_get_view_model.description,
          active: true,
          onClick: () => {
            this.props.toggleVisual("Attach View Model Data Chain");
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
          label: ViewModel,
          placeholder: ViewModel,
          onChange: value => {
            this.setState({
              viewModelName: value
            });
          },
          value: this.state.viewModelName
        })), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Attach View Model Data Chain",
          active: true,
          onClick: () => {
            this.props.graphOperation([..._create_get_view_model({
              viewModel: currentNode.id,
              model: this.state.viewModelName
            })]);
          }
        })), GetNodeTitle(currentNode) === "viewModel" ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Setup View Model On Screen",
          open: Visual(state, `Setup View Model On Screen`),
          active: true,
          onClick: () => {
            // this.props.graphOperation(GetModelViewModelForList({}));
            this.props.toggleVisual(`Setup View Model On Screen`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Models,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Model).toNodeSelect(),
          onChange: value => {
            this.setState({
              model: value
            });
          },
          value: this.state.model
        })), this.state.model ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Execute",
          onClick: () => {
            this.props.graphOperation(GetModelViewModelForList({
              model: this.state.model,
              modelViewName: GetNodeTitle(this.state.model),
              viewModel: currentNode.id
            }));
          }
        }) : null) : null)];

      case NodeTypes.Executor:
        // UpdateUserExecutor
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${Add} Update User`,
          onClick: () => {
            this.props.graphOperation(UpdateUserExecutor({
              node0: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Have all properties",
          onClick: () => {
            const steps = AddAllPropertiesToExecutor({
              currentNode
            });
            this.props.graphOperation(steps);
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Clear all properties",
          onClick: () => {
            const steps = ClearExecutor({
              currentNode
            });
            this.props.graphOperation(steps);
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: nodepacks_AddCopyPropertiesToExecutor.title,
          description: nodepacks_AddCopyPropertiesToExecutor.description,
          onClick: () => {
            const result = nodepacks_AddCopyPropertiesToExecutor({
              currentNode,
              executor: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Executor)
            });
            this.props.graphOperation(result);
          }
        }))];

      case NodeTypes.Condition:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "condition OPERATIONS"),
          active: true,
          title: `Condition ${Operations}`,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("condition OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Validations"),
          active: true,
          title: "Validations",
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("Validations");
          }
        }, void 0, " ", contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Key,
          options: Object.keys(FunctionTemplateKeys).map(x => ({
            title: x,
            value: FunctionTemplateKeys[x],
            id: FunctionTemplateKeys[x]
          })),
          onChange: value => {
            this.setState({
              key: value
            });
          },
          value: this.state.key
        })), this.state.key ? contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Properties,
          options: GetModelPropertyChildren(GetFunctionMethodKey(uiactions_GetValidationNode(currentNode.id)), this.state.key).toNodeSelect(),
          onChange: value => {
            this.setState({
              property: value
            });
          },
          value: this.state.property
        })) : null, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          active: true,
          title: validation_NameLikeValidation.title,
          description: validation_NameLikeValidation.description,
          onClick: () => {
            const validation = uiactions_GetValidationNode(currentNode.id);
            const methodNode = uiactions_GetMethodNode(validation ? validation.id : null);
            const result = validation_NameLikeValidation({
              condition: currentNode.id,
              property: this.state.property,
              methodKey: this.state.key,
              methodType: uiactions_GetNodeProp(methodNode, nodetypes_NodeProperties.FunctionType)
            });
            this.props.graphOperation(result);
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          active: true,
          title: validation_DescriptionLikeValidation.title,
          description: validation_DescriptionLikeValidation.description,
          onClick: () => {
            const validation = uiactions_GetValidationNode(currentNode.id);
            const methodNode = uiactions_GetMethodNode(validation ? validation.id : null);
            const result = validation_DescriptionLikeValidation({
              condition: currentNode.id,
              property: this.state.property,
              methodKey: this.state.key,
              methodType: uiactions_GetNodeProp(methodNode, nodetypes_NodeProperties.FunctionType)
            });
            this.props.graphOperation(result);
          }
        })))];

      case NodeTypes.Model:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "OPERATIONS"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("OPERATIONS");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${Add} Name|Description`,
          onClick: () => {
            this.props.graphOperation(AddNameDescription({
              node0: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Create Claim Service(Agent)",
          onClick: () => {
            const claimService = GetNodeByProperties({
              [nodetypes_NodeProperties.NODEType]: NodeTypes.ClaimService
            });

            if (!claimService) {
              let claimServiceExecutor = null;
              this.props.graphOperation([...CreateStandardClaimService({
                modelName: GetNodeTitle(currentNode),
                model: currentNode.id,
                user: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIUser),
                callback: claimServiceContext => {
                  claimServiceExecutor = claimServiceContext.executor;
                }
              }), function (currentGraph) {
                const steps = nodepacks_AddCopyPropertiesToExecutor({
                  currentNode: claimServiceExecutor,
                  executor: uiactions_GetNodeProp(claimServiceExecutor, nodetypes_NodeProperties.Executor, currentGraph)
                });
                return steps;
              }], null, 'standard-claim-service');
            }
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Setup Fetch Result",
          onClick: () => {
            const connectedNodes = GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.FetchServiceOuput
            });

            if (connectedNodes.length) {
              this.props.graphOperation(CreatePropertiesForFetch({
                id: currentNode.id
              }));
            }
          }
        }))];

      case NodeTypes.ScreenOption:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "ComponentNode"),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("ComponentNode");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddButtonToComponent,
          onClick: () => {
            this.props.graphOperation(nodepacks_AddButtonToComponent({
              component: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: "Add Text",
          onClick: () => {
            this.props.graphOperation(nodepacks_AddButtonToComponent({
              componentType: ComponentTypeKeys.Text,
              component: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Add Menu"),
          active: true,
          title: AddMenu,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("Add Menu");
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: OptionsType,
          options: Object.keys(MenuTreeOptions).map(v => ({
            title: v,
            value: v,
            id: v
          })),
          onChange: value => {
            this.setState({
              menuTreeOption: value
            });
          },
          value: this.state.menuTreeOption
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
          label: Name,
          onChange: value => {
            this.setState({
              menuName: value
            });
          },
          value: this.state.menuName
        })), this.state.menuName && MenuTreeOptions[this.state.menuTreeOption] ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddMenu,
          onClick: () => {
            if (this.state.menuName && MenuTreeOptions[this.state.menuTreeOption]) {
              this.props.graphOperation(AddMenuToComponent({
                menu_name: this.state.menuName,
                uiType: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIType),
                navigate_function: MenuTreeOptions[this.state.menuTreeOption].navigate_function(),
                menuGeneration: MenuTreeOptions[this.state.menuTreeOption].menuGeneration(),
                buildMethod: MenuTreeOptions[this.state.menuTreeOption].buildMethod,
                component: currentNode.id
              }));
            }
          }
        }) : null)), layoutoptions()];

      case NodeTypes.ComponentNode:
        const componentType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ComponentType);
        const uiType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIType);
        let parent = null;

        if (ComponentTypes[uiType] && ComponentTypes[uiType][componentType] && ComponentTypes[uiType][componentType].layout && Visual(state, "Reattach Component")) {
          const graph = GetCurrentGraph();
          parent = GetParentComponent(currentNode); //  GetNodesLinkedTo(graph, {
          //   id: currentNode.id,
          //   link: LinkType.Component,
          //   direction: TARGET
          // })[0];
        }

        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Styling"),
          active: true,
          title: Styling,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("Styling");
          }
        }, void 0, layoutoptions(), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Create Form"),
          active: true,
          title: "Create Form",
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("Create Form");
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
          immediate: true,
          label: Name,
          placeholder: EnterName,
          onChange: value => {
            this.setState({
              viewName: value
            });
          },
          value: this.state.viewName
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: Models,
          options: uiactions_NodesByType(this.props.state, NodeTypes.Model).toNodeSelect(),
          onChange: value => {
            this.setState({
              model: value
            });
          },
          value: this.state.model
        })), contextmenu_jsx(treeviewbuttongroup_TreeViewButtonGroup, {}, void 0, contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
          title: "Create Form",
          onClick: () => {
            this.props.graphOperation(CreateForm({
              component: currentNode.id,
              model: this.state.model,
              viewName: this.state.viewName
            }));
          },
          icon: "fa fa-plus"
        }))), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddDataChain,
          onClick: () => {
            this.props.graphOperation([{
              operation: ADD_NEW_NODE,

              options() {
                return {
                  nodeType: NodeTypes.DataChain,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.DataChainLink
                    }
                  },
                  parent: currentNode.id,
                  properties: {
                    [nodetypes_NodeProperties.UIText]: `data chain`
                  },
                  groupProperties: {}
                };
              }

            }]);
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddSelector,
          onClick: () => {
            this.props.graphOperation([{
              operation: ADD_NEW_NODE,

              options() {
                return {
                  nodeType: NodeTypes.Selector,
                  linkProperties: {
                    properties: { ...nodetypes_LinkProperties.SelectorLink
                    }
                  },
                  parent: currentNode.id,
                  properties: {
                    [nodetypes_NodeProperties.UIText]: `select internal variables`,
                    [nodetypes_NodeProperties.SelectorType]: nodetypes_SelectorType.InternalProperties
                  },
                  groupProperties: {}
                };
              }

            }]);
          }
        })), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "ComponentNode"),
          active: true,
          title: Layout,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("ComponentNode");
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddLifeCylceEvents,
          onClick: () => {
            this.props.graphOperation(SCREEN_COMPONENT_EVENTS.filter(x => !GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.LifeCylceMethod
            }).find(_y => uiactions_GetNodeProp(_y, nodetypes_NodeProperties.Event) === x)).map(t => ({
              operation: ADD_NEW_NODE,

              options() {
                return {
                  nodeType: NodeTypes.LifeCylceMethod,
                  properties: {
                    [nodetypes_NodeProperties.EventType]: t,
                    [nodetypes_NodeProperties.Pinned]: false,
                    [nodetypes_NodeProperties.UIText]: `${t}`
                  },
                  links: [{
                    target: currentNode.id,
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.LifeCylceMethod
                      }
                    }
                  }]
                };
              }

            })));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddButtonToComponent,
          onClick: () => {
            this.props.graphOperation(nodepacks_AddButtonToComponent({
              component: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddTitleToComponent,
          onClick: () => {
            this.props.graphOperation(nodepacks_AddTitleToComponent({
              component: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, `${currentNodeType} eventtype`),
          active: true,
          title: AddEvent,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(`${currentNodeType} eventtype`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: Object.keys(ComponentEvents).map(v => ({
            title: v,
            id: v,
            value: v
          })),
          label: Select,
          onChange: value => {
            this.setState({
              eventType: value
            });
          },
          value: this.state.eventType
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: [true, false].map(v => ({
            title: `${v}`,
            id: v,
            value: v
          })),
          label: IncludeEventHandler,
          onChange: value => {
            this.setState({
              eventTypeHandler: value
            });
          },
          value: this.state.eventTypeHandler
        })), this.state.eventType ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddEvent,
          onClick: () => {
            const properties = GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.DefaultViewType
            }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Property);
            this.props.graphOperation(nodepacks_AddEvent({
              component: currentNode.id,
              eventType: this.state.eventType,
              eventTypeHandler: properties.length ? this.state.eventTypeHandler : false,
              property: properties.length ? properties[0].id : null
            }));
          }
        }) : null), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Adding Component"),
          active: true,
          title: AddComponentNew,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("Adding Component");
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: Object.keys(ComponentTypes.ReactNative).map(v => ({
            title: v,
            id: v,
            value: v
          })),
          label: ComponentType,
          onChange: value => {
            this.setState({
              componentType: value
            });
          },
          value: this.state.componentType
        })), this.state.componentType ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${Add} ${this.state.componentType}`,
          onClick: () => {
            this.props.graphOperation(AddComponent({
              component: currentNode.id,
              componentType: this.state.componentType
            }));
          }
        }) : null), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, "Reattach Component"),
          active: true,
          title: ReattachComponent,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual("Reattach Component");
          }
        }, void 0, parent ? contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: GetNodesLinkedTo(GetCurrentGraph(), {
            id: parent.id,
            link: nodetypes_LinkType.Component
          }).filter(x => x.id !== currentNode.id).toNodeSelect(),
          label: ComponentType,
          onChange: value => {
            this.setState({
              component: value
            });
          },
          value: this.state.component
        })) : null, parent && this.state.component ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Execute,
          onClick: () => {
            this.props.graphOperation(nodepacks_ReattachComponent({
              component: this.state.component,
              base: currentNode.id,
              parent: parent.id
            }));
          }
        }) : null))];

      case NodeTypes.Validator:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, NodeTypes.Validator),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(NodeTypes.Validator);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: uiactions_NodesByType(this.props.state, NodeTypes.Validator).toNodeSelect().filter(x => x.id !== currentNode.id),
          label: CopyValidationConditions,
          onChange: value => {
            this.setState({
              validator: value
            });
          },
          value: this.state.validator
        })), this.state.validator ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Execute,
          onClick: () => {
            const conditions = GetNodesLinkedTo(GetCurrentGraph(), {
              id: this.state.validator,
              link: nodetypes_LinkType.Condition
            }).map(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.Condition));
            const method = GetNodesLinkedTo(GetCurrentGraph(), {
              id: this.state.validator,
              link: nodetypes_LinkType.FunctionOperator
            }).find(x => x);
            const currentConditions = GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.Condition
            });
            const currentNodeMethod = GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.FunctionOperator
            }).find(x => x);
            const functionType = uiactions_GetNodeProp(method, nodetypes_NodeProperties.FunctionType);
            const currentNodeMethodFunctionType = uiactions_GetNodeProp(currentNodeMethod, nodetypes_NodeProperties.FunctionType);
            const result = [];
            currentConditions.map(cc => {
              result.push({
                operation: REMOVE_NODE,

                options() {
                  return {
                    id: cc.id
                  };
                }

              });
            });
            conditions.map(condition => {
              result.push({
                operation: ADD_NEW_NODE,

                options() {
                  const temp = JSON.parse(JSON.stringify(condition));
                  temp.methods[currentNodeMethodFunctionType] = temp.methods[functionType];
                  delete temp.methods[functionType];
                  return {
                    nodeType: NodeTypes.Condition,
                    properties: {
                      [nodetypes_NodeProperties.Condition]: temp
                    },
                    parent: currentNode.id,
                    groupProperties: {},
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.ConditionLink
                      }
                    }
                  };
                }

              });
            });
            this.props.graphOperation(result);
          }
        }) : null)];

      case NodeTypes.ModelFilter:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, NodeTypes.ModelFilter),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(NodeTypes.ModelFilter);
          }
        })];

      case NodeTypes.Permission:
        // getNodePropertyGuids()
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, NodeTypes.Permission),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(NodeTypes.Permission);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: uiactions_NodesByType(this.props.state, NodeTypes.Permission).toNodeSelect().filter(x => x.id !== currentNode.id),
          label: CopyPermissionConditions,
          onChange: value => {
            this.setState({
              permission: value
            });
          },
          value: this.state.permission
        })), this.state.permission ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Execute,
          onClick: () => {
            const result = CopyPermissionConditions_CopyPermissionConditions({
              permission: this.state.permission,
              node: currentNode.id
            });
            this.props.graphOperation(result);
          }
        }) : null, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          active: true,
          onClick: () => {
            const permissions = uiactions_NodesByType(null, NodeTypes.Permission);
            const result = [];
            permissions.filter(x => x.id !== currentNode.id).map(permission => {
              result.push(...CopyPermissionConditions_CopyPermissionConditions({
                permission: currentNode.id,
                node: permission.id
              }));
            });
            this.props.graphOperation(result);
          },
          title: CopyToAll
        }))];

      case NodeTypes.ViewType:
        return [contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, currentNodeType),
          active: true,
          title: Operations,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(currentNodeType);
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, `${currentNodeType} eventtype`),
          active: true,
          title: AddEvent,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(`${currentNodeType} eventtype`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: Object.keys(ComponentEvents).map(v => ({
            title: v,
            id: v,
            value: v
          })),
          label: Select,
          onChange: value => {
            this.setState({
              eventType: value
            });
          },
          value: this.state.eventType
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          options: [true, false].map(v => ({
            title: `${v}`,
            id: v,
            value: v
          })),
          label: IncludeEventHandler,
          onChange: value => {
            this.setState({
              eventTypeHandler: value
            });
          },
          value: this.state.eventTypeHandler
        })), this.state.eventType ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddEvent,
          onClick: () => {
            const properties = GetNodesLinkedTo(GetCurrentGraph(), {
              id: currentNode.id,
              link: nodetypes_LinkType.DefaultViewType
            }).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.NODEType) === NodeTypes.Property);
            this.props.graphOperation(nodepacks_AddEvent({
              component: currentNode.id,
              eventType: this.state.eventType,
              eventTypeHandler: properties.length ? this.state.eventTypeHandler : false,
              property: properties.length ? properties[0].id : null
            }));
          }
        }) : null), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: AddSharedViewModel,
          description: AttachDataChainsToViewTypeViewModel.description,
          onClick: () => {
            this.props.graphOperation(AttachDataChainsToViewTypeViewModel({
              viewType: currentNode.id
            }));
          }
        }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, `setup view type`),
          active: true,
          title: SetupViewType,
          innerStyle: {
            maxHeight: 300,
            overflowY: "auto"
          },
          toggle: () => {
            this.props.toggleVisual(`setup view type`);
          }
        }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: LoadModelsOnComponentMount,
          options: GetFunctionToLoadModels(currentNode).toNodeSelect(),
          onChange: value => {
            this.setState({
              functionToLoadModels: value
            });
          },
          value: this.state.functionToLoadModels
        })), contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(selectinput_SelectInput, {
          label: MethodThatValidationComesFrom,
          options: GetValidationMethodForViewTypes(currentNode).toNodeSelect(),
          onChange: value => {
            this.setState({
              validationMethod: value
            });
          },
          value: this.state.validationMethod
        })), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: Execute,
          description: "Setup ViewType",
          onClick: () => {
            this.props.graphOperation(SetupViewTypeFor({
              node: currentNode.id,
              validationMethod: this.state.validationMethod,
              functionToLoadModels: this.state.functionToLoadModels,
              eventType: 'onChange',
              eventTypeHandler: true
            }));
          }
        })))];
    }

    return [];
  }

  apiMenu() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const currentNodeType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType);

    switch (currentNodeType) {
      case NodeTypes.DataChain:
        return [this.getDataChainContextMenu()];

      case NodeTypes.ComponentNode:
        const componentType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ComponentType);

        switch (componentType) {
          case "Button":
            return [this.getButtonApiMenu(currentNode)];

          default:
            return [this.getGenericComponentApiMenu(currentNode)];
        }

        break;

      default:
        break;
    }

    return [];
  }

  eventMenu() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const currentNodeType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType);

    switch (currentNodeType) {
      case NodeTypes.ComponentNode:
        const componentType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.ComponentType);

        switch (componentType) {
          case "Menu":
          case "Button":
            return [this.getButtonEventMenu(currentNode)];
        }

        break;
    }

    return [];
  }

  getContextMenu() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const currentNodeType = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType);

    switch (currentNodeType) {
      case NodeTypes.ComponentNode:
      case NodeTypes.Screen:
      case NodeTypes.ScreenOption:
      case NodeTypes.EventMethodInstance:
      default:
        return this.getGenericLinks(currentNode);
    }
  }

  getViewTypes() {
    return contextmenu_ref;
  }

  getButtonApiMenu(currentNode) {
    const {
      state
    } = this.props;
    return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, titles_ComponentAPIMenu),
      active: true,
      title: titles_ComponentAPIMenu,
      toggle: () => {
        this.props.toggleVisual(titles_ComponentAPIMenu);
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} Label`,
      onClick: () => {
        this.props.addComponentApiNodes(currentNode.id, "label");
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} Value`,
      onClick: () => {
        this.props.addComponentApiNodes(currentNode.id, "value");
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} ViewModel`,
      onClick: () => {
        this.props.addComponentApiNodes(currentNode.id, "viewModel");
      }
    }));
  }

  getGenericComponentApiMenu(currentNode) {
    const {
      state
    } = this.props;
    return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, titles_ComponentAPIMenu),
      active: true,
      title: titles_ComponentAPIMenu,
      toggle: () => {
        this.props.toggleVisual(titles_ComponentAPIMenu);
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} Label`,
      onClick: () => {
        this.props.addComponentApiNodes(currentNode.id, "label");
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} Value`,
      onClick: () => {
        this.props.addComponentApiNodes(currentNode.id, "value");
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} Custom`,
      open: Visual(state, "Custom Api Menu"),
      active: true,
      onClick: () => {
        // this.props.addComponentApiNodes(currentNode.id, "value");
        this.props.toggleVisual("Custom Api Menu");
      }
    }, void 0, contextmenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, contextmenu_jsx(textinput_TextInput, {
      immediate: true,
      label: Name,
      placeholder: EnterName,
      onChange: value => {
        this.setState({
          customApi: value
        });
      },
      value: this.state.customApi
    })), this.state.customApi ? contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: `${Add} ${this.state.customApi}`,
      onClick: () => {
        this.props.addComponentApiNodes(currentNode.id, this.state.customApi);
      }
    }) : null));
  }

  getButtonEventMenu(currentNode) {
    const {
      state
    } = this.props;

    switch (uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.UIType)) {
      case UITypes.ReactNative:
        return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: Visual(state, Events),
          active: true,
          title: Events,
          toggle: () => {
            this.props.toggleVisual(Events);
          }
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${Add} onPress`,
          onClick: () => {
            this.props.addComponentEventTo(currentNode.id, "onPress");
          }
        }));
        break;

      case UITypes.ElectronIO:
        return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          open: true,
          active: true,
          title: Events,
          toggle: () => {}
        }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
          title: `${Add} onClick`,
          onClick: () => {
            this.props.addComponentEventTo(currentNode.id, "onClick");
          }
        }));
        break;
    }
  }

  getComponentExternalMenu(currentNode) {
    const {
      state
    } = this.props;
    return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: true,
      active: true,
      title: Select,
      open: Visual(state, Select),
      toggle: () => {
        this.props.toggleVisual(Select);
      }
    }, void 0, contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.ComponentExternalConnection,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.ComponentExternalConnection);
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.SelectorLink,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.SelectorLink);
      }
    }), contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: nodetypes_LinkType.DataChainLink,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(currentNode.id, nodetypes_LinkType.DataChainLink);
      }
    }));
  }

  getGenericLinks(current) {
    if (!current || !current.id) {
      return [];
    }

    const {
      state
    } = this.props;
    const linkTypes = GetNodesLinkTypes(current.id);
    return contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      active: true,
      title: Select,
      open: Visual(state, Select),
      toggle: () => {
        this.props.toggleVisual(Select);
      }
    }, void 0, linkTypes.map(linkType => contextmenu_jsx(treeviewmenu_TreeViewMenu, {
      title: linkType,
      onClick: () => {
        this.props.togglePinnedConnectedNodesByLinkType(current.id, linkType);
      }
    }, linkType)));
  }

  getModelMenu() {
    return contextmenu_ref2;
  }

  getComponentNodeMenu() {
    return contextmenu_ref3;
  }

  getConditionMenu() {
    return contextmenu_ref4;
  }

  getDataChainContextMenu() {
    return contextmenu_ref5;
  }

  getDefaultMenu() {
    const {
      state
    } = this.props;
    const graph = GetCurrentGraph(state);
    return contextmenu_jsx(treeviewbuttongroup_TreeViewButtonGroup, {}, void 0, contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
      title: ClearMarked,
      onClick: () => {
        clearMarked();
      },
      icon: "fa  fa-stop"
    }), contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
      title: SelectAllConnected,
      onClick: () => {
        this.props.selectAllConnected(Visual(state, SELECTED_NODE));
      },
      icon: "fa fa-arrows-alt"
    }), contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
      title: SelectViewPackage,
      onClick: () => {
        this.props.selectAllInViewPackage(Visual(state, SELECTED_NODE));
      },
      icon: "fa fa-shopping-cart"
    }), contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
      title: PinSelected,
      onClick: () => {
        this.props.pinSelected();
      },
      icon: "fa fa-map-pin"
    }), contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
      title: UnPinSelected,
      onClick: () => {
        this.props.unPinSelected();
      },
      icon: "fa fa-houzz"
    }), contextmenu_jsx(treeviewgroupbutton_TreeViewGroupButton, {
      title: `${DeleteAllSelected}(${graph ? graph.selected : "0"})`,
      onClick: () => {
        this.props.deleteAllSelected();
      },
      icon: "fa fa-minus"
    }));
  }

  setSecondaryMenu(menu) {
    this.setState({
      secondaryMenu: menu
    });
  }

  getDoubleWideContent() {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (currentNode) {
      switch (this.state.secondaryMenu) {
        case SecondaryOptions.LayoutOptions:
          return _ref6;
      }
    }

    return null;
  }

  render() {
    const {
      state
    } = this.props;

    const exit = () => {
      this.props.setVisual(CONTEXT_MENU_MODE, null);
    };

    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const display = Visual(state, CONTEXT_MENU_MODE) ? "block" : "none";
    const nodeType = Visual(state, CONTEXT_MENU_MODE) ? uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) : null;
    const menuMode = Visual(state, CONTEXT_MENU_MODE);
    const menuitems = this.getMenuMode(menuMode);
    const defaultMenus = this.getDefaultMenu();
    return contextmenu_jsx(external_react_draggable_default.a, {
      handle: ".draggable-header,.draggable-footer"
    }, void 0, contextmenu_jsx("div", {
      className: "context-menu modal-dialog modal-info",
      style: {
        zIndex: 1000,
        position: "fixed",
        width: this.state.secondaryMenu ? 500 : 250,
        display,
        top: 250,
        left: 500
      }
    }, void 0, contextmenu_jsx("div", {
      className: "modal-content"
    }, void 0, contextmenu_jsx("div", {
      className: "modal-header draggable-header"
    }, void 0, contextmenu_jsx("button", {
      type: "button",
      onClick: () => {
        exit();
      },
      className: "close",
      "data-dismiss": "modal",
      "aria-label": "Close"
    }, void 0, _ref7)), contextmenu_jsx("div", {
      className: "modal-body",
      style: {
        padding: 0
      }
    }, void 0, contextmenu_jsx("div", {
      className: this.state.secondaryMenu ? "" : "row",
      style: this.state.secondaryMenu ? {
        display: 'flex'
      } : {}
    }, void 0, contextmenu_jsx("div", {
      className: this.state.secondaryMenu ? "" : "col-md-12",
      style: this.state.secondaryMenu ? {
        width: '50%'
      } : {}
    }, void 0, contextmenu_jsx(genericpropertycontainer, {
      active: true,
      title: "asdf",
      subTitle: "afaf",
      nodeType: nodeType
    }, void 0, defaultMenus, menuitems)), this.state.secondaryMenu ? contextmenu_jsx("div", {
      style: {
        width: '50%'
      }
    }, void 0, contextmenu_jsx(genericpropertycontainer, {
      active: true,
      title: "asdf",
      subTitle: "afaf",
      nodeType: nodeType
    }, void 0, this.getDoubleWideContent())) : null)), contextmenu_jsx("div", {
      className: "modal-footer draggable-footer"
    }, void 0, contextmenu_jsx("button", {
      type: "button",
      onClick: () => {
        exit();
      },
      className: "btn btn-outline pull-left",
      "data-dismiss": "modal"
    }, void 0, "Close")))));
  }

}

/* harmony default export */ var contextmenu = (UIConnect(contextmenu_ContextMenu));
// CONCATENATED MODULE: ./app/components/controllerdetailsmenu.js
var controllerdetailsmenu_REACT_ELEMENT_TYPE;

function controllerdetailsmenu_jsx(type, props, key, children) { if (!controllerdetailsmenu_REACT_ELEMENT_TYPE) { controllerdetailsmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: controllerdetailsmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















const CONTROLLER_DETAILS_MENU = 'CONTROLLER_DETAILS_MENU';

var controllerdetailsmenu_ref =
/*#__PURE__*/
controllerdetailsmenu_jsx("div", {});

class controllerdetailsmenu_ControllerDetailsMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Maestro);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var othernodes = currentNode ? getNodesLinkedTo(GetCurrentGraph(state), {
      id: currentNode.id
    }) : [];

    if (!active) {
      return controllerdetailsmenu_ref;
    }

    return controllerdetailsmenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, CONTROLLER_DETAILS_MENU),
      active: Visual(state, CONTROLLER_DETAILS_MENU),
      title: MaestroDetails,
      toggle: () => {
        this.props.toggleVisual(CONTROLLER_DETAILS_MENU);
      }
    }, void 0, othernodes.map((onode, index) => {
      return controllerdetailsmenu_jsx(treeviewitem_TreeViewItem, {
        title: `${GetNodeTitle(onode)}`,
        onClick: () => {
          var id = currentNode.id;
          this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
            target: onode.id,
            source: id
          });
        }
      }, `tree-view-item-controller-details${index}`);
    }));
  }

}

/* harmony default export */ var controllerdetailsmenu = (UIConnect(controllerdetailsmenu_ControllerDetailsMenu));
// CONCATENATED MODULE: ./app/components/controlleractivitymenu.js
var controlleractivitymenu_REACT_ELEMENT_TYPE;

function controlleractivitymenu_jsx(type, props, key, children) { if (!controlleractivitymenu_REACT_ELEMENT_TYPE) { controlleractivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: controlleractivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















class controlleractivitymenu_ControllerActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Controller);
    var graph = GetCurrentGraph(state);
    var functions = uiactions_NodesByType(state, uiactions_NodeTypes.Maestro).map(funcKey => {
      return {
        title: GetNodeTitle(funcKey),
        value: funcKey.id
      };
    });
    return controlleractivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, currentNode ? controlleractivitymenu_jsx(selectinput_SelectInput, {
      label: Maestros,
      options: functions,
      defaultSelectText: AddMaestros,
      onChange: value => {
        let id = currentNode.id;
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.MaestroLink
          }
        });
      },
      value: ''
    }) : null, currentNode ? controlleractivitymenu_jsx(textinput_TextInput, {
      label: CodeUser,
      value: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.CodeUser),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          id: currentNode.id,
          value,
          prop: nodetypes_NodeProperties.CodeUser
        });
      }
    }) : null);
  }

}

/* harmony default export */ var controlleractivitymenu = (UIConnect(controlleractivitymenu_ControllerActivityMenu));
// CONCATENATED MODULE: ./app/components/permissionsdependentactivitymenu.js

var permissionsdependentactivitymenu_REACT_ELEMENT_TYPE;

function permissionsdependentactivitymenu_jsx(type, props, key, children) { if (!permissionsdependentactivitymenu_REACT_ELEMENT_TYPE) { permissionsdependentactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: permissionsdependentactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













class permissionsdependentactivitymenu_PermissionDependencyActivityMenu extends external_react_["Component"] {
  getTargetNodes(graph, currentNode) {
    let targetPropertyNodes = [];

    if (currentNode) {
      targetPropertyNodes = getNodesByLinkType(graph, {
        id: currentNode.id,
        direction: SOURCE,
        type: nodetypes_LinkType.PermissionDependencyPropertyManyToManyLink
      });

      if (!targetPropertyNodes.length) {
        targetPropertyNodes = getNodesByLinkType(graph, {
          id: currentNode.id,
          direction: SOURCE,
          type: nodetypes_LinkType.PermissionDependencyProperty
        });
      }
    }

    return targetPropertyNodes;
  }

  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.PermissionDependency);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var is_agent = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.IsAgent);
    var enumeration_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.Enumeration).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var extension_nodes = uiactions_NodesByType(state, uiactions_NodeTypes.ExtensionType).map(node => {
      return {
        value: node.id,
        title: GetNodeTitle(node)
      };
    });
    var graph = GetCurrentGraph(state);
    var extensionNodeId = currentNode && currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIExtension] : '';
    var ext_allowed = (currentNode && currentNode.properties ? currentNode.properties[uiactions_NodeProperties.AllowedExtensionValues] : []) || [];
    var ext_disallowed = [];

    if (extensionNodeId) {
      var extensionNode = GetNode(graph, extensionNodeId);

      if (extensionNode) {
        var def = uiactions_GetNodeProp(extensionNode, uiactions_NodeProperties.UIExtensionDefinition);

        if (def && def.config) {
          if (def.config.isEnumeration) {
            var extensionValues = def.config.list.map(t => {
              return t[def.config.keyField || Object.keys(t)[0]];
            });
            ext_allowed = ext_allowed.intersection(extensionValues);
            ext_disallowed = extensionValues.relativeCompliment(ext_allowed);
          }
        }
      }
    }

    var enumeration = currentNode && currentNode.properties ? currentNode.properties[uiactions_NodeProperties.Enumeration] : '';
    var allowed = (currentNode && currentNode.properties ? currentNode.properties[uiactions_NodeProperties.AllowedEnumValues] : []) || [];
    var disallowed = [];

    if (enumeration) {
      var enumerationNode = GetNode(graph, enumeration);

      if (enumerationNode) {
        var enumerationValues = uiactions_GetNodeProp(enumerationNode, nodetypes_NodeProperties.Enumeration) || [];
        allowed = allowed.intersection(enumerationValues);
        disallowed = enumerationValues.relativeCompliment(allowed);
      }
    }

    let targetPropertyNodes = this.getTargetNodes(graph, currentNode);
    let targetNodeType = null;
    let targetPropertyNode = null;

    if (targetPropertyNodes.length) {
      targetPropertyNode = targetPropertyNodes[0];
      targetNodeType = uiactions_GetNodeProp(targetPropertyNode, uiactions_NodeProperties.UIAttributeType);
    }

    return permissionsdependentactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, permissionsdependentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: PermissionsDependencyAttribute
    }), currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.BOOLEAN ? permissionsdependentactivitymenu_jsx(checkbox_CheckBox, {
      title: UseEqualDescription,
      label: UseEqual,
      value: currentNode.properties[uiactions_NodeProperties.UseEqual],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseEqual,
          id: currentNode.id,
          value
        });
      }
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.BOOLEAN && uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.UseEqual) ? permissionsdependentactivitymenu_jsx(selectinput_SelectInput, {
      title: IsEqualToDescription,
      label: IsEqualTo,
      options: ['true', 'false'].map(t => ({
        title: t,
        value: t
      })),
      value: currentNode.properties[uiactions_NodeProperties.IsEqualTo],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsEqualTo,
          id: currentNode.id,
          value
        });
      }
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.LISTOFSTRINGS ? permissionsdependentactivitymenu_jsx(checkbox_CheckBox, {
      title: IncludedInListDescription,
      label: IncludedInList,
      value: currentNode.properties[uiactions_NodeProperties.IncludedInList],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IncludedInList,
          id: currentNode.id,
          value
        });
      }
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.LISTOFSTRINGS ? permissionsdependentactivitymenu_jsx(checkbox_CheckBox, {
      title: ExcludedFromListDescription,
      label: ExcludedFromList,
      value: currentNode.properties[uiactions_NodeProperties.ExcludedFromList],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.ExcludedFromList,
          id: currentNode.id,
          value
        });
      }
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING ? permissionsdependentactivitymenu_jsx(checkbox_CheckBox, {
      title: UseEnumeration,
      label: UseEnumeration,
      value: currentNode.properties[uiactions_NodeProperties.UseEnumeration],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseEnumeration,
          id: currentNode.id,
          value
        });
      }
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING ? permissionsdependentactivitymenu_jsx(checkbox_CheckBox, {
      title: UseUIExtensions,
      label: UseUIExtensions,
      value: currentNode.properties[uiactions_NodeProperties.UseExtension],
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UseExtension,
          id: currentNode.id,
          value
        });
      }
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING && currentNode.properties[uiactions_NodeProperties.UseExtension] ? permissionsdependentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: AllowedEnums
    }) : null, active && ext_allowed && ext_allowed.length && currentNode && currentNode.properties[uiactions_NodeProperties.UseExtension] ? ext_allowed.map(_enum => {
      return permissionsdependentactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.AllowedExtensionValues,
            id: currentNode.id,
            value: [...ext_allowed].filter(x => x !== _enum)
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.DisallowedExtensionValues,
            id: currentNode.id,
            value: extensionValues.relativeCompliment([...ext_allowed].filter(x => x !== _enum))
          });
        }
      }, `ext_allowed-${_enum}`, " ", _enum);
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING && currentNode.properties[uiactions_NodeProperties.UseExtension] ? permissionsdependentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: DisallowedEnums
    }) : null, active && ext_disallowed && ext_disallowed.length && currentNode && currentNode.properties[uiactions_NodeProperties.UseExtension] ? ext_disallowed.map(_enum => {
      return permissionsdependentactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.AllowedExtensionValues,
            id: currentNode.id,
            value: [...ext_allowed, _enum].unique()
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.DisallowedExtensionValues,
            id: currentNode.id,
            value: extensionValues.relativeCompliment([...ext_allowed, _enum].unique())
          });
        }
      }, `ext_disallowed-${_enum}`, " ", _enum);
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING && currentNode.properties[uiactions_NodeProperties.UseExtension] ? permissionsdependentactivitymenu_jsx(selectinput_SelectInput, {
      label: Extensions,
      options: extension_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.UIExtension],
          source: id,
          linkType: uiactions_LinkProperties.ExtensionLink.type
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.UIExtension,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.ExtensionLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.UIExtension] : ''
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING && currentNode.properties[uiactions_NodeProperties.UseEnumeration] ? permissionsdependentactivitymenu_jsx(selectinput_SelectInput, {
      label: Enumeration,
      options: enumeration_nodes,
      onChange: value => {
        var id = currentNode.id;
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          target: currentNode.properties[uiactions_NodeProperties.Enumeration],
          source: id,
          linkType: uiactions_LinkProperties.EnumerationLink.type
        });
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Enumeration,
          id,
          value
        });
        this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
          target: value,
          source: id,
          properties: { ...uiactions_LinkProperties.EnumerationLink
          }
        });
      },
      value: currentNode.properties ? currentNode.properties[uiactions_NodeProperties.Enumeration] : ''
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING && currentNode.properties[uiactions_NodeProperties.UseEnumeration] ? permissionsdependentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: AllowedEnums
    }) : null, active && allowed && allowed.length && currentNode && currentNode.properties[uiactions_NodeProperties.UseEnumeration] ? allowed.map(_enum => {
      return permissionsdependentactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          var disallowed = enumerationValues.relativeCompliment([...allowed].filter(x => x !== _enum));
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.AllowedEnumValues,
            id: currentNode.id,
            value: [...allowed].filter(x => x !== _enum)
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.DisallowedEnumValues,
            id: currentNode.id,
            value: disallowed
          });
        }
      }, `allowed-${_enum}`, " ", _enum);
    }) : null, currentNode && targetPropertyNode && targetNodeType == uiactions_NodePropertyTypes.STRING && currentNode.properties[uiactions_NodeProperties.UseEnumeration] ? permissionsdependentactivitymenu_jsx(controlsidebarmenu_ControlSideBarMenuHeader, {
      title: DisallowedEnums
    }) : null, active && disallowed && disallowed.length && currentNode && currentNode.properties[uiactions_NodeProperties.UseEnumeration] ? disallowed.map(_enum => {
      return permissionsdependentactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          var disallowed = enumerationValues.relativeCompliment([...allowed, _enum].unique());
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.AllowedEnumValues,
            id: currentNode.id,
            value: [...allowed, _enum].unique()
          });
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.DisallowedEnumValues,
            id: currentNode.id,
            value: disallowed
          });
        }
      }, `disallowed-${_enum}`, " ", _enum);
    }) : null);
  }

}

/* harmony default export */ var permissionsdependentactivitymenu = (UIConnect(permissionsdependentactivitymenu_PermissionDependencyActivityMenu));
// CONCATENATED MODULE: ./app/components/dropdownmenuitem.js
var dropdownmenuitem_REACT_ELEMENT_TYPE;

function dropdownmenuitem_jsx(type, props, key, children) { if (!dropdownmenuitem_REACT_ELEMENT_TYPE) { dropdownmenuitem_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: dropdownmenuitem_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class dropdownmenuitem_DropDownMenuItem extends external_react_["Component"] {
  icon() {
    return this.props.icon || "fa fa-envelope-o";
  }

  render() {
    return dropdownmenuitem_jsx("li", {}, void 0, dropdownmenuitem_jsx("a", {
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      }
    }, void 0, dropdownmenuitem_jsx("div", {
      className: "pull-left"
    }, void 0, dropdownmenuitem_jsx("i", {
      style: {
        fontSize: 34
      },
      className: this.icon()
    })), dropdownmenuitem_jsx("h4", {}, void 0, this.props.title), dropdownmenuitem_jsx("p", {}, void 0, this.props.description)));
  }

}
// CONCATENATED MODULE: ./app/components/graphmenu.js
var graphmenu_REACT_ELEMENT_TYPE;

function graphmenu_jsx(type, props, key, children) { if (!graphmenu_REACT_ELEMENT_TYPE) { graphmenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: graphmenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }







const GRAPH_MENU = 'GRAPH_MENU';

class graphmenu_GraphMenu extends external_react_["Component"] {
  render() {
    var me = this;
    var {
      state
    } = me.props;
    return graphmenu_jsx(dropdown_DropDownMenu, {
      icon: 'fa fa-cart-plus',
      open: Visual(state, GRAPH_MENU),
      onClick: () => {
        this.props.toggleVisual(GRAPH_MENU);
      }
    }, void 0, graphmenu_jsx(dropdownmenuitem_DropDownMenuItem, {
      icon: "fa fa-plus",
      title: AddNewSection,
      onClick: () => {
        this.props.addNewSubGraph();
      },
      description: AddNewSectionDescription
    }));
  }

}

/* harmony default export */ var graphmenu = (UIConnect(graphmenu_GraphMenu));
// CONCATENATED MODULE: ./app/components/sectionlist.js
var sectionlist_REACT_ELEMENT_TYPE;

function sectionlist_jsx(type, props, key, children) { if (!sectionlist_REACT_ELEMENT_TYPE) { sectionlist_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sectionlist_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }







const SECTION_LIST = 'SECTION_LIST';

class sectionlist_SectionList extends external_react_["Component"] {
  render() {
    let me = this;
    let {
      state
    } = me.props;
    let sections = [];
    let subGraphs = GetSubGraphs(state);
    let rootGraph = GetRootGraph(state);

    if (subGraphs) {
      subGraphs.map(sg => {
        sections.push(sectionlist_jsx(treeviewitem_TreeViewItem, {
          title: sg.title || Unknown,
          right: sectionlist_jsx("span", {
            className: "label label-primary pull-right"
          }, void 0, sg.nodes.length),
          onClick: () => {
            me.props.setApplication(GRAPH_SCOPE, [sg.id]);
          }
        }, sg.id));
      });
    }

    let body = sections;

    if (rootGraph) {
      body = sectionlist_jsx(treeviewmenu_TreeViewMenu, {
        hideIcon: true,
        right: sectionlist_jsx("span", {
          className: "label label-primary pull-right"
        }, void 0, rootGraph.nodes.length),
        title: rootGraph.title || Unknown,
        hideArrow: true,
        open: true,
        active: true,
        onClick: () => {
          me.props.setApplication(GRAPH_SCOPE, null);
        }
      }, void 0, sections);
    }

    return sectionlist_jsx(treeviewmenu_TreeViewMenu, {
      title: Sections,
      icon: 'fa fa-cart-plus',
      open: Visual(state, SECTION_LIST),
      active: Visual(state, SECTION_LIST),
      onClick: () => {
        this.props.toggleVisual(SECTION_LIST);
      }
    }, void 0, body);
  }

}

/* harmony default export */ var sectionlist = (UIConnect(sectionlist_SectionList));
// CONCATENATED MODULE: ./app/components/enumerationactivitymenu.js
var enumerationactivitymenu_REACT_ELEMENT_TYPE;

function enumerationactivitymenu_jsx(type, props, key, children) { if (!enumerationactivitymenu_REACT_ELEMENT_TYPE) { enumerationactivitymenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: enumerationactivitymenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }
















class enumerationactivitymenu_EnumerationActivityMenu extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Enumeration);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));
    var enums = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Enumeration) || [];
    return enumerationactivitymenu_jsx(tabpane_TabPane, {
      active: active
    }, void 0, enumerationactivitymenu_jsx(enumerationeditmenu_EnumerationEditMenu, {
      onComplete: val => {
        if (val) {
          var enums = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Enumeration) || [];
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.Enumeration,
            id: currentNode.id,
            value: [...enums, {
              value: val,
              id: uuidv4()
            }].unique(x => x.value)
          });
        }
      }
    }), active && enums && enums.length ? enums.map(_enum => {
      return enumerationactivitymenu_jsx("div", {
        className: "external-event bg-red",
        style: {
          cursor: 'pointer'
        },
        onClick: () => {
          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: uiactions_NodeProperties.Enumeration,
            id: currentNode.id,
            value: [...enums].filter(x => x !== _enum)
          });
        }
      }, _enum.id, " ", _enum && _enum.id ? _enum.value : _enum);
    }) : null);
  }

}

/* harmony default export */ var enumerationactivitymenu = (UIConnect(enumerationactivitymenu_EnumerationActivityMenu));
// CONCATENATED MODULE: ./app/components/sectionedit.js
var sectionedit_REACT_ELEMENT_TYPE;

function sectionedit_jsx(type, props, key, children) { if (!sectionedit_REACT_ELEMENT_TYPE) { sectionedit_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: sectionedit_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }













class sectionedit_SectionEdit extends external_react_["Component"] {
  render() {
    var {
      state
    } = this.props;
    var section = GetCurrentScopedGraph(state);
    return sectionedit_jsx(formcontrol_FormControl, {
      sidebarform: true
    }, void 0, sectionedit_jsx(textinput_TextInput, {
      value: section ? section.title : '',
      onChange: value => {
        this.props.graphOperation(UPDATE_GRAPH_TITLE, {
          text: value
        });
      },
      inputgroup: true,
      placeholder: titles_SectionEdit
    }));
  }

}

/* harmony default export */ var sectionedit = (UIConnect(sectionedit_SectionEdit));
// CONCATENATED MODULE: ./app/components/topviewer.js
var topviewer_REACT_ELEMENT_TYPE;

function topviewer_jsx(type, props, key, children) { if (!topviewer_REACT_ELEMENT_TYPE) { topviewer_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: topviewer_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }








class topviewer_TopViewer extends external_react_["Component"] {
  active() {
    return !!this.props.active;
  }

  render() {
    var style = {
      position: 'relative',
      width: '100%'
    };
    let active = this.active();
    let height = 600;
    return topviewer_jsx("div", {
      style: style
    }, void 0, topviewer_jsx("div", {
      style: {
        position: 'absolute',
        width: '100%',
        transition: 'all 1s',
        pointerEvents: active ? 'all' : 'none',
        top: active ? 0 : '-2000px',
        backgroundColor: '#dd4b39d2'
      }
    }, void 0, this.props.children));
  }

}
// EXTERNAL MODULE: external "react-syntax-highlighter"
var external_react_syntax_highlighter_ = __webpack_require__("react-syntax-highlighter");
var external_react_syntax_highlighter_default = /*#__PURE__*/__webpack_require__.n(external_react_syntax_highlighter_);

// CONCATENATED MODULE: ./node_modules/react-syntax-highlighter/dist/esm/styles/hljs/docco.js
/* harmony default export */ var docco = ({
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "color": "#000",
    "background": "#f8f8ff"
  },
  "hljs-comment": {
    "color": "#408080",
    "fontStyle": "italic"
  },
  "hljs-quote": {
    "color": "#408080",
    "fontStyle": "italic"
  },
  "hljs-keyword": {
    "color": "#954121"
  },
  "hljs-selector-tag": {
    "color": "#954121"
  },
  "hljs-literal": {
    "color": "#954121"
  },
  "hljs-subst": {
    "color": "#954121"
  },
  "hljs-number": {
    "color": "#40a070"
  },
  "hljs-string": {
    "color": "#219161"
  },
  "hljs-doctag": {
    "color": "#219161"
  },
  "hljs-selector-id": {
    "color": "#19469d"
  },
  "hljs-selector-class": {
    "color": "#19469d"
  },
  "hljs-section": {
    "color": "#19469d"
  },
  "hljs-type": {
    "color": "#19469d"
  },
  "hljs-params": {
    "color": "#00f"
  },
  "hljs-title": {
    "color": "#458",
    "fontWeight": "bold"
  },
  "hljs-tag": {
    "color": "#000080",
    "fontWeight": "normal"
  },
  "hljs-name": {
    "color": "#000080",
    "fontWeight": "normal"
  },
  "hljs-attribute": {
    "color": "#000080",
    "fontWeight": "normal"
  },
  "hljs-variable": {
    "color": "#008080"
  },
  "hljs-template-variable": {
    "color": "#008080"
  },
  "hljs-regexp": {
    "color": "#b68"
  },
  "hljs-link": {
    "color": "#b68"
  },
  "hljs-symbol": {
    "color": "#990073"
  },
  "hljs-bullet": {
    "color": "#990073"
  },
  "hljs-built_in": {
    "color": "#0086b3"
  },
  "hljs-builtin-name": {
    "color": "#0086b3"
  },
  "hljs-meta": {
    "color": "#999",
    "fontWeight": "bold"
  },
  "hljs-deletion": {
    "background": "#fdd"
  },
  "hljs-addition": {
    "background": "#dfd"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
});
// CONCATENATED MODULE: ./app/components/tab.js
var tab_REACT_ELEMENT_TYPE;

function tab_jsx(type, props, key, children) { if (!tab_REACT_ELEMENT_TYPE) { tab_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: tab_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class tab_Tab extends external_react_["Component"] {
  active() {
    return this.props.active ? 'active' : '';
  }

  title() {
    return this.props.title || this.props.children || '{title}';
  }

  render() {
    return tab_jsx("li", {
      className: this.active()
    }, void 0, tab_jsx("a", {
      "data-toggle": "tab",
      onClick: () => {
        if (this.props.onClick) {
          this.props.onClick();
        }
      },
      "aria-expanded": "true"
    }, void 0, this.title()));
  }

}
// CONCATENATED MODULE: ./app/components/tabs.js
var tabs_REACT_ELEMENT_TYPE;

function tabs_jsx(type, props, key, children) { if (!tabs_REACT_ELEMENT_TYPE) { tabs_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: tabs_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class tabs_Tabs extends external_react_["Component"] {
  render() {
    return tabs_jsx("ul", {
      className: "nav nav-tabs"
    }, void 0, this.props.children);
  }

}
// CONCATENATED MODULE: ./app/components/codeview.js

var codeview_REACT_ELEMENT_TYPE;

function codeview_jsx(type, props, key, children) { if (!codeview_REACT_ELEMENT_TYPE) { codeview_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: codeview_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }



























const MODEL_CODE = "MODEL_CODE";
const SELECTED_CODE_TYPE = "SELECTED_CODE_TYPE";
const CLASS_KEY = "CLASS_KEY";
const CODE_VIEW_TAB = "CODE_VIEW_TAB";

class codeview_CodeView extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  active() {
    return !!this.props.active;
  }

  render() {
    var {
      state
    } = this.props;
    let active = this.active();
    let codeString = "";
    let info = Visual(state, MODEL_CODE) || null;
    let graphRoot = GetRootGraph(state);
    let namespace = graphRoot ? graphRoot[GraphKeys.NAMESPACE] : null;
    let projectname = graphRoot ? graphRoot[GraphKeys.PROJECTNAME] : null;
    let clientside_theme = graphRoot ? graphRoot[GraphKeys.THEME] : null;
    let colorscheme = graphRoot ? graphRoot[GraphKeys.COLORSCHEME] : null;
    let server_side_setup = graphRoot ? graphRoot[GraphKeys.SERVER_SIDE_SETUP] : null;
    let controllers = [];
    let generatedContent = null;

    if (state && graphRoot && active) {
      var viewTab = Visual(state, CODE_VIEW_TAB);
      var classKey = this.state[Visual(state, CODE_VIEW_TAB)];
      var temp = generator_Generator.generate({
        type: viewTab,
        key: classKey,
        state
      });
      generatedContent = temp;

      if (temp && temp[classKey]) {
        codeString = temp[classKey].template;
      }
    }

    var code_types = [NodeTypes.Controller, NodeTypes.Model, NodeTypes.ExtensionType, NodeTypes.Maestro, ...Object.values(GeneratedTypes)];
    let modelType = Visual(state, CODE_VIEW_TAB);
    let models = [];

    if (generatedContent) {
      Object.keys(generatedContent).map(gcKey => {
        models.push({
          id: gcKey,
          title: generatedContent[gcKey].name,
          value: generatedContent[gcKey].name
        });
      });
    }

    return codeview_jsx(topviewer_TopViewer, {
      active: active
    }, void 0, codeview_jsx("section", {
      className: "content"
    }, void 0, codeview_jsx("div", {
      className: "row"
    }, void 0, codeview_jsx("div", {
      className: "col-md-2"
    }, void 0, codeview_jsx(box_Box, {
      primary: true,
      title: Project
    }, void 0, codeview_jsx(textinput_TextInput, {
      onChange: val => {
        this.props.setRootGraph(GraphKeys.NAMESPACE, val);
        this.props.setAppsettingsAssemblyPrefixes(val);
      },
      label: NameSpace,
      value: namespace
    }), codeview_jsx(textinput_TextInput, {
      onChange: val => {
        this.props.setRootGraph(GraphKeys.PROJECTNAME, val);
      },
      label: ProjectName,
      value: projectname
    }), codeview_jsx(textinput_TextInput, {
      onChange: val => {
        this.props.setRootGraph(GraphKeys.COLORSCHEME, val);
      },
      label: ColorScheme,
      value: colorscheme
    }), codeview_jsx(selectinput_SelectInput, {
      label: ServerSideSetup,
      options: Object.keys(IdentityManagement).map(t => {
        return {
          title: t,
          value: IdentityManagement[t]
        };
      }),
      onChange: value => {
        this.props.setRootGraph(GraphKeys.SERVER_SIDE_SETUP, value);
      },
      value: server_side_setup
    }), codeview_jsx(selectinput_SelectInput, {
      label: Theme,
      options: Object.keys(themes_Themes).map(t => {
        return {
          title: t,
          value: t
        };
      }),
      onChange: value => {
        this.props.setRootGraph(GraphKeys.THEME, value);
      },
      value: clientside_theme
    })), codeview_jsx(box_Box, {
      primary: true,
      title: CodeTypes
    }, void 0, codeview_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        return item && this.state[Visual(state, CODE_VIEW_TAB)] === item.id;
      },
      items: models,
      onClick: item => {
        this.setState({
          [Visual(state, CODE_VIEW_TAB)]: item.id
        });
      }
    }))), codeview_jsx("div", {
      className: "col-md-10"
    }, void 0, codeview_jsx(tabcontainer_TabContainer, {}, void 0, codeview_jsx(tabs_Tabs, {}, void 0, code_types ? code_types.map(ct => {
      return codeview_jsx(tab_Tab, {
        active: VisualEq(state, CODE_VIEW_TAB, ct),
        title: ct,
        onClick: () => {
          this.props.setVisual(CODE_VIEW_TAB, ct);
        }
      }, ct);
    }) : null)), codeview_jsx(tabcontent_TabContent, {}, void 0, codeview_jsx(tabpane_TabPane, {
      active: Visual(state, CODE_VIEW_TAB)
    }, void 0, codeview_jsx(box_Box, {
      title: Code,
      primary: true,
      maxheight: 700
    }, void 0, codeString ? codeview_jsx(external_react_syntax_highlighter_default.a, {
      language: "csharp",
      style: docco
    }, void 0, codeString) : null)))))));
  }

}

/* harmony default export */ var codeview = (UIConnect(codeview_CodeView));
// CONCATENATED MODULE: ./app/components/layoutcreator.js

var layoutcreator_REACT_ELEMENT_TYPE;

function layoutcreator_jsx(type, props, key, children) { if (!layoutcreator_REACT_ELEMENT_TYPE) { layoutcreator_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: layoutcreator_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }


class layoutcreator_LayoutCreator extends external_react_["Component"] {
  buildLayoutTree(layoutObj, currentRoot) {
    let result = [];
    let {
      layout,
      properties
    } = layoutObj;

    if (!currentRoot) {
      currentRoot = layout;
    }

    Object.keys(currentRoot).map((item, index) => {
      result.push(this.createSection(layoutObj, item, currentRoot[item], index + 1));
    });
    return result;
  }

  createSection(layoutObj, item, currentRoot, index) {
    let {
      properties
    } = layoutObj;
    let style = properties[item].style || {};
    let tree = Object.keys(currentRoot).length ? this.buildLayoutTree(layoutObj, currentRoot) : null;
    let overrides = {};

    if (this.props.selectedCell === item) {
      overrides = {
        backgroundColor: '#ffffff33'
      };
    }

    overrides.padding = 10;
    return layoutcreator_jsx("div", {
      onClick: e => {
        if (this.props.onSelectionClick) {
          this.props.onSelectionClick(item);
          e.stopPropagation();
          e.preventDefault();
          return false;
        }
      },
      style: { ...style,
        ...overrides
      }
    }, item, tree || index);
  }

  render() {
    let colors = 'dd4b39-3a405a-fff2f2-e8e8e8-857885'.split('-').map(t => `#${t}`);
    let layoutObj = this.props.layout;
    let tree = null;

    if (layoutObj) {
      tree = this.buildLayoutTree(layoutObj);
    }

    return layoutcreator_jsx("div", {
      style: {
        display: 'flex',
        height: '100%',
        borderStyle: 'solid',
        borderWidth: 1,
        borderColor: colors[2],
        ...this.props.style
      }
    }, void 0, tree);
  }

}
// EXTERNAL MODULE: ./app/components/typeahead.css
var typeahead = __webpack_require__("./app/components/typeahead.css");

// CONCATENATED MODULE: ./app/components/typeahead.js
var typeahead_REACT_ELEMENT_TYPE;

function typeahead_jsx(type, props, key, children) { if (!typeahead_REACT_ELEMENT_TYPE) { typeahead_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: typeahead_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }




class typeahead_Typeahead extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  label() {
    return this.props.label || "{label}";
  }

  immediate() {
    return this.props.immediate || false;
  }

  value() {
    if (this.immediate()) {
      return this.props.value || "";
    }

    return this.state.value || "";
  }

  placeholder() {
    return this.props.placeholder || "";
  }

  disabled() {
    return this.props.disabled ? "disabled" : "";
  }

  componentDidMount() {
    if (!this.immediate()) {
      this.setState({
        value: this.props.value
      });
    }
  }

  componentDidUpdate(prevProps) {
    if (!this.immediate()) {
      if (!this.state.focus) if (this.state.value !== this.props.value) {
        this.setState({
          value: this.props.value
        });
      }
    }
  }

  render() {
    return typeahead_jsx("div", {
      className: typeahead["typeahead"]
    }, void 0, typeahead_jsx(textinput_TextInput, {
      value: this.state.value,
      label: this.label(),
      placeholder: this.placeholder(),
      disabled: this.disabled(),
      immediate: true,
      onFocus: () => {
        this.setState({
          focus: true
        });
      },
      onBlur: () => {
        this.setState({
          focus: false
        });

        if (!this.immediate()) {
          if (this.props.onChange) {
            if (this.state.value !== this.props.value) this.props.onChange(this.state.value || "");
          }
        }
      },
      onChange: value => {
        if (this.immediate()) {
          if (this.props.onChange) {
            this.props.onChange(value);
          }
        } else {
          this.setState({
            value
          });
        }
      },
      onChangeText: value => {
        if (this.immediate()) {
          if (this.props.onChange) {
            this.props.onChange(value);
          }
        }

        this.setState({
          value
        });
      }
    }), this.props.options && this.props.options.length ? typeahead_jsx("div", {
      className: typeahead["typeaheadContainer"],
      onMouseOut: () => {
        this.setState({
          hovering: false
        });
      },
      onMouseOver: () => {
        this.setState({
          hovering: true
        });
      }
    }, void 0, this.props.options.filter(v => this.value() && (this.state.focus || this.state.hovering)).filter(v => {
      const res = `${v.title}`.toLowerCase().indexOf(`${this.value()}`.toLowerCase()) !== -1;
      return res;
    }).map((option, index) => {
      let ops = typeahead_jsx("div", {
        title: option.title,
        className: "external-event",
        style: {
          cursor: 'pointer',
          overflow: 'hidden',
          whiteSpace: 'nowrap',
          textOverflow: 'ellipsis'
        },
        onClick: () => {
          if (this.props.onChange) {
            this.props.onChange(option.value);
            this.setState({
              value: option.value
            });
          }
        }
      }, `allowed-${index}`, this.props.renderItem ? this.props.renderItem(option) : option.title);

      return ops;
    })) : null);
  }

}
// CONCATENATED MODULE: ./app/components/layoutview.js

var layoutview_REACT_ELEMENT_TYPE;

function layoutview_jsx(type, props, key, children) { if (!layoutview_REACT_ELEMENT_TYPE) { layoutview_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: layoutview_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/button-has-type */

/* eslint-disable react/destructuring-assignment */

/* eslint-disable react/sort-comp */

/* eslint-disable jsx-a11y/click-events-have-key-events */

/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */



















var layoutview_ref =
/*#__PURE__*/
layoutview_jsx("i", {
  className: "fa  fa-angle-left"
});

var layoutview_ref2 =
/*#__PURE__*/
layoutview_jsx("i", {
  className: "fa fa-angle-right"
});

class layoutview_LayoutView extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  active() {
    return !!this.props.active;
  }

  getComponentApi(cellChildren) {
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const nodeLayout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout);
    const selectedCell = this.state.selectedCell;

    if (cellChildren && cellChildren[selectedCell]) {
      const childComponent = cellChildren[selectedCell];
      const componentApi = uiactions_GetNodeProp(GetNodeById(childComponent), nodetypes_NodeProperties.ComponentApi);

      if (componentApi) {
        const selectedComponentApiProperty = this.state.componentApi ? this.state.componentApi[selectedCell] : null;
        const cellProperties = GetCellProperties(nodeLayout, this.state.selectedCell);
        cellProperties.componentApi = cellProperties.componentApi || {};
        const {
          instanceType,
          model,
          selector,
          handlerType,
          dataChain,
          modelProperty
        } = cellProperties.componentApi[selectedComponentApiProperty] || {};
        const model_obj = GetNodeById(model);
        const temp_model = uiactions_GetNodeProp(model_obj, uiactions_NodeProperties.Model);
        const properties = GetNodesLinkedTo(GetRootGraph(state), {
          id: temp_model,
          direction: SOURCE
        }).toNodeSelect();
        return [layoutview_jsx(selectinput_SelectInput, {
          label: titles_ComponentAPIMenu,
          value: selectedComponentApiProperty,
          options: getComponentApiList(componentApi),
          onChange: value => {
            this.setState({
              componentApi: { ...(this.state.componentApi || {}),
                [selectedCell]: value
              }
            });
          }
        }), selectedComponentApiProperty && instanceType === InstanceTypes.ScreenInstance ? layoutview_jsx(selectinput_SelectInput, {
          label: HandlerType,
          value: handlerType,
          options: Object.keys(HandlerTypes).map(t => ({
            title: t,
            value: HandlerTypes[t]
          })),
          onChange: value => {
            cellProperties.componentApi[selectedComponentApiProperty] = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const temp = cellProperties.componentApi[selectedComponentApiProperty];
            const old = temp.handlerType;
            temp.handlerType = value;
            this.props.graphOperation([{
              operation: CHANGE_NODE_PROPERTY,
              options: {
                prop: uiactions_NodeProperties.Layout,
                id: currentNode.id,
                value: nodeLayout
              }
            }]);
          }
        }) : null, selectedComponentApiProperty ? layoutview_jsx(selectinput_SelectInput, {
          label: InstanceType,
          value: instanceType,
          options: Object.keys(InstanceTypes).map(t => ({
            title: t,
            value: InstanceTypes[t]
          })),
          onChange: value => {
            cellProperties.componentApi[selectedComponentApiProperty] = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const temp = cellProperties.componentApi[selectedComponentApiProperty];
            temp.instanceType = value;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.Layout,
              id: currentNode.id,
              value: nodeLayout
            });
          }
        }) : null, selectedComponentApiProperty && instanceType === InstanceTypes.Selector ? layoutview_jsx(selectinput_SelectInput, {
          label: Selector,
          value: selector,
          options: uiactions_NodesByType(state, NodeTypes.Selector).toNodeSelect(),
          onChange: value => {
            cellProperties.componentApi[selectedComponentApiProperty] = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const temp = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const old = temp.selector;
            temp.selector = value;
            this.props.graphOperation([{
              operation: REMOVE_LINK_BETWEEN_NODES,
              options: {
                target: old,
                source: currentNode.id
              }
            }, {
              operation: ADD_LINK_BETWEEN_NODES,
              options: {
                target: value,
                source: currentNode.id,
                properties: { ...uiactions_LinkProperties.ComponentApi,
                  selector: true
                }
              }
            }, {
              operation: CHANGE_NODE_PROPERTY,
              options: {
                prop: uiactions_NodeProperties.Layout,
                id: currentNode.id,
                value: nodeLayout
              }
            }]);
          }
        }) : null, selectedComponentApiProperty && instanceType === InstanceTypes.ScreenInstance ? layoutview_jsx(selectinput_SelectInput, {
          label: Models,
          value: model,
          options: uiactions_NodesByType(state, NodeTypes.ViewModel).toNodeSelect(),
          onChange: value => {
            cellProperties.componentApi[selectedComponentApiProperty] = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const temp = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const old = temp.model;
            temp.model = value;
            this.props.graphOperation([{
              operation: REMOVE_LINK_BETWEEN_NODES,
              options: {
                target: old,
                source: currentNode.id
              }
            }, {
              operation: ADD_LINK_BETWEEN_NODES,
              options: {
                target: value,
                source: currentNode.id,
                properties: { ...uiactions_LinkProperties.ComponentApi,
                  model: true
                }
              }
            }, {
              operation: CHANGE_NODE_PROPERTY,
              options: {
                prop: uiactions_NodeProperties.Layout,
                id: currentNode.id,
                value: nodeLayout
              }
            }]);
          }
        }) : null, selectedComponentApiProperty && instanceType === InstanceTypes.ScreenInstance ? layoutview_jsx(selectinput_SelectInput, {
          options: properties,
          onChange: val => {
            cellProperties.componentApi[selectedComponentApiProperty] = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const temp = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const old = temp.modelProperty;
            temp.modelProperty = val;
            this.props.graphOperation([{
              operation: REMOVE_LINK_BETWEEN_NODES,
              options: {
                target: old,
                source: currentNode.id
              }
            }, {
              operation: ADD_LINK_BETWEEN_NODES,
              options: {
                target: value,
                source: currentNode.id,
                properties: { ...uiactions_LinkProperties.ComponentApi,
                  modelProperty: true
                }
              }
            }, {
              operation: CHANGE_NODE_PROPERTY,
              options: {
                prop: uiactions_NodeProperties.Layout,
                id: currentNode.id,
                value: nodeLayout
              }
            }]);
          },
          label: Property,
          value: modelProperty
        }) : null, selectedComponentApiProperty ? layoutview_jsx(selectinput_SelectInput, {
          options: uiactions_GetDataChainEntryNodes().toNodeSelect(),
          onChange: val => {
            cellProperties.componentApi[selectedComponentApiProperty] = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const temp = cellProperties.componentApi[selectedComponentApiProperty] || {};
            const id = currentNode.id;
            this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
              target: temp.dataChain,
              source: id,
              properties: {
                cell: selectedCell,
                selectedComponentApiProperty
              }
            });
            temp.dataChain = val;
            this.props.graphOperation(CHANGE_NODE_PROPERTY, {
              prop: uiactions_NodeProperties.Layout,
              id: currentNode.id,
              value: nodeLayout
            });

            if (val) {
              this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
                target: val,
                source: id,
                properties: { ...uiactions_LinkProperties.DataChainLink,
                  cell: selectedCell,
                  selectedComponentApiProperty
                }
              });
            }
          },
          label: DataChain,
          value: dataChain
        }) : null].filter(x => x);
      }
    }

    return null;
  }

  render() {
    const {
      state
    } = this.props;
    const active = this.active();
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    let componentNodes = currentNode ? GetConnectedNodesByType(state, currentNode.id, NodeTypes.ComponentNode, SOURCE) : [];
    componentNodes = [...componentNodes, ...GetNodesByProperties({
      [nodetypes_NodeProperties.NODEType]: NodeTypes.ComponentNode,
      [nodetypes_NodeProperties.SharedComponent]: true
    }, null, state), ...GetNodesByProperties({
      [nodetypes_NodeProperties.NODEType]: NodeTypes.ViewType
    }, null, state)];
    const namespace = "namespace";
    const nodeLayout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout);
    let cellProperties;
    let cellStyle = null;
    let cellChildren = null;
    let cellModel = null;
    let cellModelProperty = null;
    let cellRoot = null;
    let cellEvents = null;
    let selectedLayoutRoot = null;

    if (nodeLayout && this.state.selectedCell) {
      cellProperties = GetCellProperties(nodeLayout, this.state.selectedCell);

      if (cellProperties) {
        cellStyle = cellProperties.style;
        cellProperties.children = cellProperties.children || {};
        cellProperties.name = cellProperties.name || {};
        cellChildren = cellProperties.children;
        cellProperties.cellModel = cellProperties.cellModel || {};
        cellModel = cellProperties.cellModel;
        cellProperties.properties = cellProperties.properties || {};
        cellProperties.cellModelProperty = cellProperties.cellModelProperty || {};
        cellModelProperty = cellProperties.cellModelProperty;
        cellProperties.cellRoot = cellProperties.cellRoot || {};
        cellRoot = cellProperties.cellRoot;
        cellProperties.cellEvents = cellProperties.cellEvents || {};
        cellEvents = cellProperties.cellEvents;
      }

      selectedLayoutRoot = FindLayoutRoot(this.state.selectedCell, nodeLayout.layout) || nodeLayout.layout;
    }

    const componentProperties = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.ComponentProperties);
    const componentPropertiesList = getComponentPropertyList(componentProperties);

    const onUpdateComponentTags = item => {
      const layout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout();
      cellProperties.properties.tags = cellProperties.properties.tags || [];

      if (cellProperties.properties.tags.find(v => v === item.value)) {
        const index = cellProperties.properties.tags.findIndex(v => v === item.value);
        cellProperties.properties.tags.splice(index, 1);
      } else {
        cellProperties.properties.tags.push(item.value);
      }

      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
        prop: uiactions_NodeProperties.Layout,
        id: currentNode.id,
        value: layout
      });
    };

    return layoutview_jsx(topviewer_TopViewer, {
      active: active
    }, void 0, layoutview_jsx("section", {
      className: "content"
    }, void 0, layoutview_jsx("div", {
      className: "row"
    }, void 0, layoutview_jsx("div", {
      className: "col-md-2"
    }, void 0, layoutview_jsx("div", {
      className: "btn-group"
    }, void 0, layoutview_jsx("button", {
      type: "button",
      onClick: () => {
        let layout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout();
        layout = ReorderCellLayout(layout, this.state.selectedCell);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      className: "btn btn-default btn-flat"
    }, void 0, layoutview_ref), layoutview_jsx("button", {
      type: "button",
      onClick: () => {
        let layout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout();
        layout = ReorderCellLayout(layout, this.state.selectedCell, 1);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      className: "btn btn-default btn-flat"
    }, void 0, layoutview_ref2)), layoutview_jsx(box_Box, {
      primary: true,
      maxheight: 350,
      title: Layout
    }, void 0, this.state.selectedCell ? layoutview_jsx("button", {
      onClick: event => {
        let layout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout();
        layout = RemoveCellLayout(layout, this.state.selectedCell);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
        this.setState({
          selectedCell: null
        });
        event.stopPropagation();
        return null;
      }
    }, void 0, "Remove Selected") : null, layoutview_jsx(selectinput_SelectInput, {
      options: [].interpolate(1, 20, t => ({
        title: t,
        value: t
      })),
      onChange: val => {
        let layout = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout) || CreateLayout();
        layout = SetCellsLayout(layout, val, this.state.selectedCell);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Sections,
      value: Object.keys(selectedLayoutRoot || {}).length
    }), cellChildren ? layoutview_jsx(selectinput_SelectInput, {
      options: componentNodes.toNodeSelect(),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellChildren[this.state.selectedCell] = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Component,
      value: cellChildren[this.state.selectedCell]
    }) : null, cellProperties && cellProperties.name && this.state.selectedCell ? layoutview_jsx(textinput_TextInput, {
      immediate: true,
      onChange: val => {
        const layout = nodeLayout || CreateLayout();

        if (!cellProperties.name !== "object") {
          cellProperties.name = {};
        }

        cellProperties.name[this.state.selectedCell] = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Name,
      value: cellProperties.name[this.state.selectedCell]
    }) : null, cellStyle ? layoutview_jsx(selectinput_SelectInput, {
      options: ["column", "row"].map(t => ({
        title: t,
        value: t
      })),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellStyle.flexDirection = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: FlexDirection,
      value: cellStyle.flexDirection
    }) : null, cellStyle ? layoutview_jsx(selectinput_SelectInput, {
      options: [].interpolate(0, 12, t => ({
        title: t,
        value: t
      })),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        if (!parseInt(val)) cellStyle.flex = null;else cellStyle.flex = parseInt(val);
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Flex,
      value: cellStyle.flex
    }) : null, cellStyle ? layoutview_jsx(selectinput_SelectInput, {
      options: ["flex-start", "flex-end", "center", "space-between"].map(t => ({
        title: t,
        value: t
      })),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellStyle.justifyContent = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: "justify-content",
      value: cellStyle.justifyContent
    }) : null, cellStyle ? layoutview_jsx(selectinput_SelectInput, {
      options: ["flex-start", "flex-end", "center", "stretch"].map(t => ({
        title: t,
        value: t
      })),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellStyle.alignItems = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: "align-items",
      value: cellStyle.alignItems
    }) : null, cellStyle ? layoutview_jsx(textinput_TextInput, {
      immediate: true,
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        let percentage = 0;

        if ((val || "").indexOf("%") !== -1) {
          percentage = "%";
        }

        cellStyle.height = val === "" ? null : `${parseInt(val) + percentage}`;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Height,
      value: cellStyle.height
    }) : null, cellStyle ? layoutview_jsx(textinput_TextInput, {
      immediate: true,
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        let percentage = 0;

        if ((val || "").indexOf("%") !== -1) {
          percentage = "%";
        }

        cellStyle.width = val === "" ? null : `${parseInt(val) + percentage}`;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Width,
      value: cellStyle.width
    }) : null, cellChildren && cellChildren[this.state.selectedCell] ? this.getComponentApi(cellChildren) : null, cellChildren && cellChildren[this.state.selectedCell] ? layoutview_jsx(checkbox_CheckBox, {
      label: UseAsRoot,
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellRoot[this.state.selectedCell] = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      value: cellRoot[this.state.selectedCell]
    }) : null, cellChildren && cellChildren[this.state.selectedCell] && componentPropertiesList && componentPropertiesList.length ? layoutview_jsx(selectinput_SelectInput, {
      options: componentPropertiesList,
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellModel[this.state.selectedCell] = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Models,
      value: cellModel[this.state.selectedCell]
    }) : null, cellModel && cellModel[this.state.selectedCell] && componentPropertiesList && componentPropertiesList.length ? layoutview_jsx(selectinput_SelectInput, {
      options: GetNodesLinkedTo(GetRootGraph(state), {
        id: getComponentProperty(componentProperties, cellModel[this.state.selectedCell]),
        direction: SOURCE
      }).toNodeSelect(),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellModelProperty[this.state.selectedCell] = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: Property,
      value: cellModelProperty[this.state.selectedCell]
    }) : null), layoutview_jsx(box_Box, {
      maxheight: 350,
      title: Properties
    }, void 0, cellProperties && cellProperties.properties ? layoutview_jsx(typeahead_Typeahead, {
      options: ["Content", "Container", "View"].map(t => ({
        title: t,
        value: t
      })),
      onChange: val => {
        const layout = nodeLayout || CreateLayout();
        cellProperties.properties.componentType = val;
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Layout,
          id: currentNode.id,
          value: layout
        });
      },
      label: ComponentType,
      value: cellProperties.properties.componentType
    }) : null, cellProperties && cellProperties.properties ? layoutview_jsx(textinput_TextInput, {
      label: ComponentTag,
      title: ComponentTag,
      inputgroup: true,
      immediate: true,
      value: this.state.componentTag,
      onChange: value => {
        this.setState({
          componentTag: value
        });
      },
      onClick: () => {
        const {
          componentTag
        } = this.state;
        onUpdateComponentTags({
          id: componentTag,
          value: componentTag,
          title: componentTag
        });
      }
    }) : null, cellProperties && cellProperties.properties ? layoutview_jsx(buttonlist_ButtonList, {
      active: true,
      isSelected: item => {
        if (cellProperties.properties) {
          return (cellProperties.properties.tags || []).some(v => v === item.value);
        }

        return false;
      },
      items: [...(cellProperties.properties.tags || []), ...Object.keys(ComponentTags)].unique().map(x => ({
        id: x,
        value: x,
        title: x
      })),
      onClick: onUpdateComponentTags
    }) : null), layoutview_jsx(box_Box, {
      maxheight: 500,
      title: Style
    }, void 0, layoutview_jsx(formcontrol_FormControl, {}, void 0, layoutview_jsx(textinput_TextInput, {
      value: this.state.filter,
      immediate: true,
      onChange: value => {
        this.setState({
          filter: value
        });
      },
      placeholder: Filter
    })), this.getStyleSelect(), cellStyle ? this.selectedStyle(value => {
      cellStyle[this.state.selectedStyleKey] = value;
      const layout = nodeLayout || CreateLayout();
      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
        prop: uiactions_NodeProperties.Layout,
        id: currentNode.id,
        value: layout
      });
    }, cellStyle[this.state.selectedStyleKey]) : null, cellStyle ? this.getCurrentStyling(cellStyle) : null)), layoutview_jsx("div", {
      className: "col-md-10"
    }, void 0, layoutview_jsx(layoutcreator_LayoutCreator, {
      selectedCell: this.state.selectedCell,
      layout: uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Layout),
      onSelectionClick: item => {
        this.setState({
          selectedCell: this.state.selectedCell !== item ? item : null
        });
      },
      style: {
        height: 500
      }
    })))));
  }

  selectedStyle(callback, value) {
    if (this.state.selectedStyleKey) {
      switch (this.state.selectedStyleKey) {
        default:
          return layoutview_jsx(formcontrol_FormControl, {}, void 0, layoutview_jsx(textinput_TextInput, {
            value: value,
            label: this.state.selectedStyleKey,
            immediate: true,
            onChange: callback,
            placeholder: Filter
          }));
      }
    }

    return null;
  }

  getStyleSelect() {
    if (this.state.filter) {
      return layoutview_jsx("ul", {
        style: {
          padding: 2,
          maxHeight: 200,
          overflowY: "auto"
        }
      }, void 0, Object.keys(StyleLib.js).filter(x => x.indexOf(this.state.filter) !== -1).map(key => layoutview_jsx("li", {
        className: "treeview",
        style: {
          padding: 3,
          cursor: "pointer"
        },
        label: "Style",
        onClick: () => {
          this.setState({
            selectedStyleKey: key,
            filter: ""
          });
        }
      }, key, key)));
    }

    return [];
  }

  getCurrentStyling(currentStyle) {
    if (currentStyle) {
      return layoutview_jsx("ul", {
        style: {
          padding: 2,
          maxHeight: 200,
          overflowY: "auto"
        }
      }, void 0, Object.keys(currentStyle).map(key => layoutview_jsx("li", {
        className: "treeview",
        style: {
          padding: 3,
          cursor: "pointer"
        },
        onClick: () => {
          this.setState({
            selectedStyleKey: key,
            filter: ""
          });
        }
      }, key, "[", key, "]: ", currentStyle[key])));
    }

    return [];
  }

}

/* harmony default export */ var layoutview = (UIConnect(layoutview_LayoutView));
// CONCATENATED MODULE: ./app/components/colorinput.js


class colorinput_ColorInput extends textinput_TextInput {
  constructor(props) {
    super(props);
    this.inputType = 'color';
  }

}
// CONCATENATED MODULE: ./app/components/gridplacementfield.js

var gridplacementfield_REACT_ELEMENT_TYPE;

function gridplacementfield_jsx(type, props, key, children) { if (!gridplacementfield_REACT_ELEMENT_TYPE) { gridplacementfield_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: gridplacementfield_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable jsx-a11y/click-events-have-key-events */

/* eslint-disable jsx-a11y/no-static-element-interactions */

/* eslint-disable no-nested-ternary */

/* eslint-disable react/button-has-type */

/* eslint-disable react/destructuring-assignment */

/* eslint-disable react/prop-types */












class gridplacementfield_GridPlacementField extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    const currentNode = this.props.node;
    const tags = this.props.tags || [];
    const gridSetup = this.props.gridSetup || {};
    const {
      gridTemplateColumns = "",
      gridTemplateRows = "",
      name = "",
      mediaSizes = {},
      gridPlacement
    } = gridSetup;
    const gridRowCount = gridTemplateRows ? gridTemplateRows.split(' - ').join('-').split(' ').filter(x => x).length || 1 : 1;
    const columns = gridTemplateColumns.split(" ").filter(x => x);
    const square = {
      display: "flex",
      flex: 1,
      height: this.props.squareHeight || 24,
      width: this.props.squareHeight || 24,
      border: "solid 1px #414141",
      ...(this.state.currentSection ? {
        cursor: "pointer"
      } : {})
    };
    const gridplacement = gridPlacement || [].interpolate(0, Math.max(columns * gridRowCount, 100), () => "");
    return gridplacementfield_jsx("div", {
      className: "row"
    }, void 0, gridplacementfield_jsx("div", {
      className: "col-md-3"
    }, void 0, gridplacementfield_jsx(textinput_TextInput, {
      label: Name,
      title: Name,
      value: name,
      onChange: value => {
        this.props.onChange({ ...gridSetup,
          name: value
        });
      }
    }), gridplacementfield_jsx(textinput_TextInput, {
      label: GridTemplateColumns,
      title: GridTemplateColumns,
      value: gridTemplateColumns,
      onChange: value => {
        this.props.onChange({ ...gridSetup,
          gridTemplateColumns: value
        });
      }
    }), gridplacementfield_jsx(textinput_TextInput, {
      label: GridTemplateRows,
      title: GridTemplateRows,
      value: gridTemplateRows,
      onChange: value => {
        this.props.onChange({ ...gridSetup,
          gridTemplateRows: value
        });
      }
    }), gridplacementfield_jsx(typeahead_Typeahead, {
      label: GridAreas,
      title: GridAreas,
      options: tags.map(x => ({
        title: x,
        id: x,
        value: x
      })),
      value: this.state.currentSection,
      onChange: value => {
        this.setState({
          currentSection: value
        });
      }
    })), gridplacementfield_jsx("div", {
      className: "col-md-6"
    }, void 0, gridplacementfield_jsx("div", {
      style: {
        display: "flex",
        flex: "1",
        flexDirection: "column"
      }
    }, void 0, [].interpolate(0, gridRowCount, row => gridplacementfield_jsx("div", {
      style: {
        display: "flex",
        flexDirection: "row"
      }
    }, void 0, columns.map((_, col) => gridplacementfield_jsx("div", {
      title: gridplacement[row * columns.length + col],
      style: { ...square,
        ...(gridplacement[row * columns.length + col] === this.state.currentSection ? {
          backgroundColor: Colors.SelectedNode
        } : gridplacement[row * columns.length + col] ? {
          backgroundColor: Colors.MarkedNode
        } : {})
      },
      onClick: () => {
        if (this.state.currentSection) {
          if (gridplacement[row * columns.length + col] !== this.state.currentSection) {
            gridplacement[row * columns.length + col] = this.state.currentSection;
          } else {
            gridplacement[row * columns.length + col] = "";
          }

          this.props.onChange({ ...gridSetup,
            gridTemplateColumns,
            gridTemplateRows,
            gridPlacement: gridplacement
          });
        }
      }
    }, void 0, gridplacement[row * columns.length + col] || '')), ' ')))), gridplacementfield_jsx("div", {
      className: "col-md-3"
    }, void 0, Object.keys(MediaQueries).map(mediaSize => gridplacementfield_jsx(checkbox_CheckBox, {
      label: mediaSize,
      title: mediaSize,
      value: mediaSizes[mediaSize],
      onChange: value => {
        this.props.onChange({ ...gridSetup,
          mediaSizes: { ...mediaSizes,
            [mediaSize]: value
          }
        });
      }
    }, `mediasize-${mediaSize}`))));
  }

}
// CONCATENATED MODULE: ./app/components/themeview.js

var themeview_REACT_ELEMENT_TYPE;

function themeview_jsx(type, props, key, children) { if (!themeview_REACT_ELEMENT_TYPE) { themeview_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: themeview_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable react/prop-types */

/* eslint-disable react/button-has-type */

/* eslint-disable react/sort-comp */

/* eslint-disable jsx-a11y/click-events-have-key-events */

/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */























const THEME_VIEW_TAB = 'theme-view-tab';

var themeview_ref =
/*#__PURE__*/
themeview_jsx("div", {});

var themeview_ref2 =
/*#__PURE__*/
themeview_jsx("i", {
  className: "fa fa-times"
});

var themeview_ref3 =
/*#__PURE__*/
themeview_jsx("i", {
  className: "fa fa-times"
});

var themeview_ref4 =
/*#__PURE__*/
themeview_jsx("i", {
  className: "fa fa-times"
});

class themeview_ThemeView extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {
      quickColor: '',
      bindAll: true,
      mediaSize: MediaQueries["Extra devices"]
    };
  }

  active() {
    return !!this.props.active;
  }

  getEditBoxes(formType, mediaSize, formTheme, themeColors, config, themeVariables, filterFunc) {
    // ComponentTags
    if (formType && mediaSize) {
      return Object.values(StyleLib.css).filter(v => filterFunc(`${v.label}`)).map(field => {
        const {
          placeholder,
          key,
          type
        } = field;
        let {
          label
        } = field;
        label = `${label}`;
        formType = `${formType}${this.getAttrSelector()}`;

        const onChange = value => {
          if (!formTheme[formType]) {
            formTheme[formType] = {};
          }

          if (!formTheme[formType][mediaSize]) {
            formTheme[formType][mediaSize] = {};
          }

          if (!formTheme[formType][mediaSize][key]) {
            formTheme[formType][mediaSize][key] = {};
          }

          formTheme[formType][mediaSize][key] = value;
          Object.keys(MediaQueries).forEach(ms => {
            if (!formTheme[formType][ms]) {
              formTheme[formType][ms] = {};
            }

            if (this.state.bindAll) {
              formTheme[formType][ms][key] = value;
            } else {
              formTheme[formType][ms][key] = formTheme[formType][ms][key] || value;
            }
          });
          this.props.updateGraph('spaceTheme', formTheme);
        };

        const fieldValue = formTheme[formType] && formTheme[formType][mediaSize] ? formTheme[formType][mediaSize][key] : null;

        if (type === 'color') {
          return themeview_jsx(selectinput_SelectInput, {
            value: fieldValue,
            label: label,
            title: label,
            color: themeColors ? themeColors[`${fieldValue}`.split('--').join('')] : null,
            onChange: onChange,
            options: Object.keys(ThemeColors).map(d => ({
              title: d,
              value: `--${d}`
            }))
          }, `field-color-${key}`);
        }

        const use = key;
        const variableNameParts = `${label.split(':')[0]}`.split('-').map(v => v.toLowerCase());

        if (!variableNameParts.some(v => use.toLowerCase().indexOf(v) === -1)) {
          return themeview_jsx(typeahead_Typeahead, {
            value: fieldValue,
            label: use,
            title: use,
            onChange: onChange,
            options: themeVariables.variables.filter(t => !variableNameParts.some(v => t.variable.toLowerCase().indexOf(v) === -1)).map(d => ({
              title: d.variable,
              value: d.variable
            }))
          }, `field-font-family-${use}`);
        }

        return themeview_jsx(textinput_TextInput, {
          value: fieldValue,
          label: label,
          title: label,
          onChange: onChange,
          placeholder: placeholder
        }, `field-${key}`);
      });
    }

    return [];
  }

  getAttrSelector() {
    let selector = '';
    Object.keys(CssPseudoSelectors).filter(v => this.state[v]).sort().forEach(v => {
      selector += v;
    });
    return selector;
  }

  getSpaceFields(formType, mediaSize, formTheme, themeColors = {}, themeVariables, filterFunc) {
    // ComponentTags
    if (formType && mediaSize) {
      return Object.values(StyleLib.css).filter(v => filterFunc(`${v.label}`)).map(field => {
        const {
          placeholder,
          key,
          type
        } = field;
        let {
          label
        } = field;
        label = `${label}`;
        formType = `${formType}${this.getAttrSelector()}`;

        const onChange = value => {
          value = `${value || ''}`;

          if (!formTheme[formType]) {
            formTheme[formType] = {};
          }

          if (!formTheme[formType][mediaSize]) {
            formTheme[formType][mediaSize] = {};
          }

          if (!formTheme[formType][mediaSize][key]) {
            formTheme[formType][mediaSize][key] = {};
          }

          formTheme[formType][mediaSize][key] = value;
          Object.keys(MediaQueries).forEach(ms => {
            if (!formTheme[formType][ms]) {
              formTheme[formType][ms] = {};
            }

            if (this.state.bindAll) {
              formTheme[formType][ms][key] = value;
            } else {
              formTheme[formType][ms][key] = formTheme[formType][ms][key] || value;
            }
          });
          this.props.updateGraph('spaceTheme', formTheme);
        };

        const fieldValue = formTheme[formType] && formTheme[formType][mediaSize] ? formTheme[formType][mediaSize][key] : null;

        if (type === 'color') {
          return themeview_jsx(selectinput_SelectInput, {
            value: fieldValue,
            label: label,
            title: label,
            color: themeColors ? themeColors[`${fieldValue}`.split('--').join('')] : null,
            onChange: onChange,
            options: Object.keys(ThemeColors).map(d => ({
              title: d,
              value: `--${d}`
            }))
          }, `field-color-${key}`);
        }

        const use = key;
        const variableNameParts = `${label.split(':')[0]}`.split('-').map(v => v.toLowerCase());

        if (!variableNameParts.some(v => use.toLowerCase().indexOf(v) === -1)) {
          return themeview_jsx(typeahead_Typeahead, {
            value: fieldValue,
            label: use,
            title: use,
            onChange: onChange,
            options: themeVariables.variables.filter(t => !variableNameParts.some(v => t.variable.toLowerCase().indexOf(v) === -1)).map(d => ({
              title: d.variable,
              value: d.variable
            }))
          }, `field-font-family-${use}`);
        }

        return themeview_jsx(textinput_TextInput, {
          value: fieldValue,
          label: label,
          title: label,
          onChange: onChange,
          placeholder: placeholder
        }, `field-${key}`);
      });
    }

    return [];
  }

  render() {
    const active = this.active();
    const graph = GetCurrentGraph();

    if (!graph) {
      return themeview_ref;
    }

    const {
      state
    } = this.props;
    const {
      spaceTheme = {}
    } = graph;
    const {
      themeColors = {},
      themeColorUses = {},
      themeOtherUses = {},
      themeGridPlacements = {
        grids: []
      },
      themeFonts = {
        fonts: []
      },
      themeVariables = {
        variables: []
      }
    } = graph;
    const colors = Object.keys(ThemeColors).map(color => {
      if (themeColors) {
        return [themeview_jsx(colorinput_ColorInput, {
          value: themeColors[color],
          immediate: true,
          label: `${color} : ${themeColors[color]}`,
          onChange: value => {
            this.props.updateGraph('themeColors', { ...themeColors,
              [color]: value
            });
            const quickColor = [ThemeColors.primary, ThemeColors.secondary, ThemeColors.tertiary, ThemeColors.quanternary, ThemeColors.quinary].map(v => {
              if (!themeColors[v]) {
                return `000000`;
              }

              return themeColors[v].split('#').join('');
            }).join('-');
            this.setState({
              quickColor
            });
          },
          placeholder: color
        }, `color-${color}`)];
      }

      return null;
    }).filter(x => x);
    const colorUses = Object.keys(ColorUses).map(use => {
      if (themeColors) {
        return themeview_jsx(selectinput_SelectInput, {
          value: themeColorUses ? themeColorUses[use] : null,
          label: use,
          title: use,
          color: themeColors && themeColorUses ? themeColors[themeColorUses[use]] : null,
          onChange: value => {
            this.props.updateGraph('themeColorUses', { ...themeColorUses,
              [use]: value
            });
          },
          options: Object.keys(ThemeColors).map(d => ({
            title: d,
            value: d
          }))
        }, `field-color-${use}`);
      }

      return null;
    }).filter(x => x);
    const otherUses = Object.keys(themes_OtherUses).map(use => {
      if (themeOtherUses) {
        const variableNameParts = ['font', 'size'];

        if (!variableNameParts.some(v => use.toLowerCase().indexOf(v) === -1)) {
          return themeview_jsx(typeahead_Typeahead, {
            value: themeOtherUses ? themeOtherUses[use] : null,
            label: use,
            title: use,
            onChange: value => {
              this.props.updateGraph('themeOtherUses', { ...themeOtherUses,
                [use]: value
              });
            },
            options: themeVariables.variables.filter(t => !variableNameParts.some(v => t.variable.toLowerCase().indexOf(v) === -1)).map(d => ({
              title: d.variable,
              value: d.variable
            }))
          }, `field-font-family-${use}`);
        }

        if (use.indexOf('FontFamily') !== -1) {
          return themeview_jsx(selectinput_SelectInput, {
            value: themeOtherUses ? themeOtherUses[use] : null,
            label: use,
            title: use,
            onChange: value => {
              this.props.updateGraph('themeOtherUses', { ...themeOtherUses,
                [use]: value
              });
            },
            options: themeFonts.fonts.map(d => ({
              title: d.fontCssVar,
              value: d.fontCssVar
            }))
          }, `field-font-family-${use}`);
        }

        return themeview_jsx(textinput_TextInput, {
          value: themeOtherUses ? themeOtherUses[use] : null,
          label: use,
          title: use,
          color: themeOtherUses ? themeOtherUses[use] : null,
          onChange: value => {
            this.props.updateGraph('themeOtherUses', { ...themeOtherUses,
              [use]: value
            });
          }
        }, `field-color-${use}`);
      }

      return null;
    }).filter(x => x);
    const htmlElementGroup = this.state.sectionType ? HTMLElementGroups.find(f => f.name === this.state.sectionType) : null;
    let sectionTypeOptions = [];

    if (htmlElementGroup) {
      sectionTypeOptions = Object.keys(htmlElementGroup.type).map(v => ({
        title: v,
        value: v,
        id: v
      }));
    }

    return themeview_jsx(topviewer_TopViewer, {
      active: active
    }, void 0, themeview_jsx("section", {
      className: "content"
    }, void 0, themeview_jsx("div", {
      className: "row"
    }, void 0, themeview_jsx("div", {
      className: "col-md-2"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 600,
      title: Style
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, themeview_jsx(selectinput_SelectInput, {
      options: Object.keys(MediaQueries).map(v => ({
        title: v,
        value: v,
        id: v
      })),
      label: MediaSizes,
      onChange: value => {
        this.setState({
          mediaSize: value
        });
      },
      value: this.state.mediaSize
    }), themeview_jsx(checkbox_CheckBox, {
      label: BindAll,
      onChange: value => {
        this.setState({
          bindAll: value
        });
      },
      value: this.state.bindAll
    }), themeview_jsx(textinput_TextInput, {
      value: this.state.quickColor,
      immediate: true,
      label: QuickColor,
      onChange: value => {
        if (value) {
          const pcolors = value.split('-');

          if (pcolors && pcolors.length === 5) {
            if (!pcolors.some(v => v.split('').some(y => `0123456789abcdef`.indexOf(y) === -1))) {
              const newTheme = { ...themeColors
              };
              [ThemeColors.primary, ThemeColors.secondary, ThemeColors.tertiary, ThemeColors.quanternary, ThemeColors.quinary].forEach((col, index) => {
                if (pcolors[index]) {
                  newTheme[col] = `#${pcolors[index]}`;
                }
              });
              this.props.updateGraph('themeColors', newTheme);
            }
          }
        }

        this.setState({
          quickColor: value
        });
      },
      placeholder: "######-######-######-######-######"
    }), Object.keys(CssPseudoSelectors).sort().map(key => themeview_jsx(checkbox_CheckBox, {
      label: key,
      onChange: value => {
        this.setState({
          [key]: value
        });
      },
      value: this.state[key]
    }, `check-box-${key}`)), themeview_jsx("button", {
      className: "btn btn-default btn-flat",
      onClick: () => {
        const temp = {
          // 'themeColors': {},
          // 'themeColorUses': {},
          'themeOtherUses': {} // 'themeFonts': { fonts: [] },
          // 'themeVariables': { variables: [] }

        };
        Object.keys(temp).map(v => {
          this.props.updateGraph(v, temp[v]);
        });
      }
    }, void 0, "Clear")))), themeview_jsx("div", {
      className: "col-md-10"
    }, void 0, themeview_jsx(tabcontainer_TabContainer, {}, void 0, themeview_jsx(tabs_Tabs, {}, void 0, themeview_jsx(tab_Tab, {
      active: VisualEq(state, THEME_VIEW_TAB, 'Variables'),
      title: 'Variables',
      onClick: () => {
        this.props.setVisual(THEME_VIEW_TAB, 'Variables');
      }
    }), themeview_jsx(tab_Tab, {
      active: VisualEq(state, THEME_VIEW_TAB, 'Grid Placement'),
      title: 'Grid Placement',
      onClick: () => {
        this.props.setVisual(THEME_VIEW_TAB, 'Grid Placement');
      }
    }), themeview_jsx(tab_Tab, {
      active: VisualEq(state, THEME_VIEW_TAB, 'Others'),
      title: 'Others',
      onClick: () => {
        this.props.setVisual(THEME_VIEW_TAB, 'Others');
      }
    }))), themeview_jsx(tabcontent_TabContent, {}, void 0, themeview_jsx(tabpane_TabPane, {
      active: VisualEq(state, THEME_VIEW_TAB, 'Variables')
    }, void 0, themeview_jsx("div", {
      className: "col-md-12"
    }, void 0, themeview_jsx("div", {
      className: "row"
    }, void 0, themeview_jsx("div", {
      className: "col-md-6"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 350,
      title: Fonts
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, themeview_jsx(textinput_TextInput, {
      value: this.state.fontName,
      label: `${Font} ${Name}`,
      title: `${Font} ${Name}`,
      immediate: true,
      onChange: value => {
        this.setState({
          fontName: value
        });
      }
    }), themeview_jsx(textinput_TextInput, {
      value: this.state.font,
      label: Font,
      title: Font,
      immediate: true,
      onChange: value => {
        this.setState({
          font: value
        });
      }
    }), themeview_jsx("div", {
      className: "row"
    }, void 0, themeview_jsx("div", {
      className: "col-md-6"
    }, void 0, themeview_jsx(textinput_TextInput, {
      value: this.state.fontCss,
      label: FontCss,
      title: FontCss,
      immediate: true,
      onChange: value => {
        this.setState({
          fontCss: value
        });
      }
    })), themeview_jsx("div", {
      className: "col-md-6"
    }, void 0, themeview_jsx(textinput_TextInput, {
      value: this.state.fontCssVar,
      label: FontCssVar,
      immediate: true,
      title: FontCssVar,
      onChange: value => {
        if (value && value.indexOf('--') === -1) {
          value = `--${value}`;
        }

        this.setState({
          fontCssVar: value
        });
      }
    }))), this.state.font && this.state.fontCss && this.state.fontName && this.state.fontCssVar ? themeview_jsx("button", {
      className: "btn btn-primary",
      onClick: event => {
        if (this.state.font && this.state.fontCss && this.state.fontCssVar) {
          themeFonts.fonts = [{
            font: this.state.font,
            fontCss: this.state.fontCss,
            fontCssVar: this.state.fontCssVar,
            fontName: this.state.fontName
          }, ...themeFonts.fonts].unique(v => v.font + v.fontName);
          this.props.updateGraph('themeFonts', { ...themeFonts
          });
          this.setState({
            font: ''
          });
        }

        event.stopPropagation();
        return false;
      }
    }, void 0, "Ok") : null, themeview_jsx(buttonlist_ButtonList, {
      active: true,
      items: themeFonts.fonts.map(v => ({
        title: v.font,
        id: v.font,
        ...v
      })),
      renderItem: item => themeview_jsx("div", {
        className: "col-md-12",
        style: {
          display: 'flex',
          alignItems: 'center'
        }
      }, void 0, themeview_jsx("div", {
        className: "col-md-10"
      }, void 0, themeview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, item.font), themeview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, item.fontCss), themeview_jsx("h6", {
        style: {
          margin: 0
        }
      }, void 0, item.fontCssVar), themeview_jsx("h6", {
        style: {
          margin: 0
        }
      }, void 0, item.fontName)), themeview_jsx("div", {
        className: "col-md-2"
      }, void 0, themeview_jsx("button", {
        className: "btn btn-default btn-flat",
        onClick: () => {
          themeFonts.fonts = themeFonts.fonts.filter(x => x.font !== item.id);
          this.props.updateGraph('themeFonts', { ...themeFonts
          });
        }
      }, void 0, themeview_ref2))),
      onClick: item => {
        this.setState({ ...item
        });
      }
    })))), themeview_jsx("div", {
      className: "col-md-6"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 350,
      title: "Variables"
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, themeview_jsx(textinput_TextInput, {
      value: this.state.variable,
      label: Variable,
      title: Variable,
      immediate: true,
      onChange: value => {
        if (value && value.indexOf('--') === -1) {
          value = `--${value}`;
        }

        this.setState({
          variable: value
        });
      }
    }), themeview_jsx(textinput_TextInput, {
      value: this.state.variableValue,
      label: Value,
      title: Value,
      immediate: true,
      onChange: value => {
        this.setState({
          variableValue: value
        });
      }
    }), this.state.variable && this.state.variableValue ? themeview_jsx("button", {
      className: "btn btn-primary",
      onClick: event => {
        if (this.state.variable && this.state.variableValue) {
          themeVariables.variables = [{
            variable: this.state.variable,
            variableValue: this.state.variableValue
          }, ...themeVariables.variables].unique(v => v.variable);
          this.props.updateGraph('themeVariables', { ...themeVariables
          });
        }

        event.stopPropagation();
        return false;
      }
    }, void 0, "Ok") : null, themeview_jsx(buttonlist_ButtonList, {
      active: true,
      items: themeVariables.variables.map(v => ({
        title: v.variable,
        id: v.variable,
        ...v
      })),
      renderItem: item => themeview_jsx("div", {
        className: "col-md-12",
        style: {
          display: 'flex',
          alignItems: 'center'
        }
      }, void 0, themeview_jsx("div", {
        className: "col-md-10"
      }, void 0, themeview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, item.variable), themeview_jsx("h6", {
        style: {
          margin: 0
        }
      }, void 0, item.variableValue)), themeview_jsx("div", {
        className: "col-md-2"
      }, void 0, themeview_jsx("button", {
        className: "btn btn-default btn-flat",
        onClick: () => {
          themeVariables.variables = themeVariables.variables.filter(x => x.variable !== item.id);
          this.props.updateGraph('themeVariables', { ...themeVariables
          });
        }
      }, void 0, themeview_ref3))),
      onClick: () => {}
    }))))))), themeview_jsx(tabpane_TabPane, {
      active: VisualEq(state, THEME_VIEW_TAB, 'Grid Placement')
    }, void 0, themeview_jsx("div", {
      className: "row"
    }, void 0, themeview_jsx("div", {
      className: "col-md-3"
    }, void 0, themeview_jsx(box_Box, {
      title: `${titles_GridPlacement}`
    }, void 0, themeview_jsx(textinput_TextInput, {
      value: this.state.gridGroup,
      label: `${titles_GridPlacement} ${Name}`,
      immediate: true,
      inputgroup: true,
      title: `${titles_GridPlacement} ${Name}`,
      onChange: value => {
        this.setState({
          gridGroup: value
        });
      },
      onClick: () => {
        let {
          gridGroup
        } = this.state;

        if (gridGroup && gridGroup.trim()) {
          gridGroup = gridGroup.trim();
          this.props.updateGraph('themeGridPlacements', {
            grids: [{
              id: GUID(),
              name: gridGroup,
              gridTemplateColumns: "",
              gridTemplateRows: "",
              gridPlacement: null
            }, ...themeGridPlacements.grids]
          });
        }
      }
    }), themeview_jsx(buttonlist_ButtonList, {
      active: true,
      items: themeGridPlacements.grids.map(v => ({
        title: v.name,
        ...v
      })),
      isSelected: v => v.id === this.state.currentGrid,
      renderItem: item => themeview_jsx("div", {
        className: "col-md-12",
        style: {
          display: 'flex',
          alignItems: 'center'
        }
      }, void 0, themeview_jsx("div", {
        className: "col-md-10"
      }, void 0, themeview_jsx("h4", {
        style: {
          margin: 0
        }
      }, void 0, item.name), themeview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, item.gridTemplateColumns), themeview_jsx("h6", {
        style: {
          margin: 0
        }
      }, void 0, item.gridTemplateRows)), themeview_jsx("div", {
        className: "col-md-2"
      }, void 0, themeview_jsx("button", {
        className: "btn btn-default btn-flat",
        onClick: () => {
          themeGridPlacements.grids = themeGridPlacements.grids.filter(x => x.id !== item.id);
          this.props.updateGraph('themeGridPlacements', { ...themeGridPlacements,
            grids: themeGridPlacements.grids
          });
        }
      }, void 0, themeview_ref4))),
      onClick: item => {
        this.setState({
          currentGrid: item.id
        });
      }
    }))), themeview_jsx("div", {
      className: "col-md-9"
    }, void 0, themeview_jsx(box_Box, {
      title: titles_GridPlacement
    }, void 0, themeview_jsx(gridplacementfield_GridPlacementField, {
      squareHeight: 100,
      gridSetup: themeGridPlacements.grids.find(x => x.id === this.state.currentGrid),
      onChange: setup => {
        this.props.updateGraph('themeGridPlacements', { ...themeGridPlacements,
          grids: [setup, ...themeGridPlacements.grids.filter(x => x.id !== setup.id)]
        });
      },
      tags: Object.keys(ComponentTags)
    }))))), themeview_jsx(tabpane_TabPane, {
      active: VisualEq(state, THEME_VIEW_TAB, 'Others')
    }, void 0, themeview_jsx("div", {
      className: "row"
    }, void 0, themeview_jsx("div", {
      className: "col-md-2"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 500,
      title: Style
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, colors))), themeview_jsx("div", {
      className: "col-md-2"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 500,
      title: ColorUse
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, colorUses))), themeview_jsx("div", {
      className: "col-md-2"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 500,
      title: OtherUses
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, otherUses))), themeview_jsx("div", {
      className: "col-md-2"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 500,
      title: SpaceTheme,
      onSearch: search => {
        this.setState({
          spaceSearch: search
        });
      }
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, themeview_jsx(typeahead_Typeahead, {
      options: Object.keys(ComponentTags).map(v => ({
        title: v,
        value: v,
        id: v
      })),
      label: "Spaces",
      onChange: value => {
        this.setState({
          componentTag: value
        });
      },
      value: this.state.componentTag
    }), this.getSpaceFields(this.state.componentTag, this.state.mediaSize, spaceTheme, themeColors, themeVariables, f => this.state.spaceSearch && f.toLowerCase().indexOf(this.state.spaceSearch.toLowerCase()) !== -1), themeview_jsx("div", {
      style: {
        height: 300
      }
    })))), themeview_jsx("div", {
      className: "col-md-2"
    }, void 0, themeview_jsx(box_Box, {
      maxheight: 500,
      title: this.state.sectionType || 'Search',
      onSearch: search => {
        this.setState({
          [`search-${this.state.sectionType || 'search'}`]: search
        });
      }
    }, void 0, themeview_jsx(formcontrol_FormControl, {}, void 0, themeview_jsx(selectinput_SelectInput, {
      options: HTMLElementGroups.map(v => ({
        title: v.name,
        value: v.name,
        id: v.name
      })),
      label: "Section Types",
      onChange: value => {
        this.setState({
          sectionType: value
        });
      },
      value: this.state.sectionType
    }), this.state.sectionType ? themeview_jsx(selectinput_SelectInput, {
      options: sectionTypeOptions,
      label: this.state.sectionType,
      onChange: value => {
        this.setState({
          [this.state.sectionType]: value
        });
      },
      value: this.state[this.state.sectionType]
    }) : null, this.getEditBoxes(this.state[this.state.sectionType], this.state.mediaSize, spaceTheme, themeColors, HTMLElementGroups.find(f => f.name === this.state.sectionType), themeVariables, f => this.state[`search-${this.state.sectionType}`] && f.toLowerCase().indexOf(`${this.state[`search-${this.state.sectionType}`]}`.toLowerCase()) !== -1)))))))))));
  }

}

/* harmony default export */ var themeview = (UIConnect(themeview_ThemeView));
// CONCATENATED MODULE: ./app/service/translationservice.js
/* eslint-disable compat/compat */

/* eslint-disable prefer-destructuring */

const memory = {};
function translationservice(sourceText, sourceLang, targetLang) {
  if (memory[sourceText] && memory[sourceText][sourceLang] && memory[sourceText][sourceLang][targetLang]) {
    return Promise.resolve(memory[sourceText][sourceLang][targetLang]);
  }

  const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${LanguagesCode[sourceLang]}&tl=${LanguagesCode[targetLang]}&dt=t&q=${encodeURI(sourceText)}`;
  return fetch(url).then(res => {
    return res.json().then(translation => {
      memory[sourceText] = memory[sourceText] || {};
      memory[sourceText][sourceLang] = memory[sourceText][sourceLang] || {};
      memory[sourceText][sourceLang][targetLang] = translation[0][0][0];
      return translation[0][0][0];
    });
  }).catch(e => console.log(e));
}
// CONCATENATED MODULE: ./app/components/translationview.js

var translationview_REACT_ELEMENT_TYPE;

function translationview_jsx(type, props, key, children) { if (!translationview_REACT_ELEMENT_TYPE) { translationview_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: translationview_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }

/* eslint-disable promise/catch-or-return */

/* eslint-disable promise/always-return */

/* eslint-disable react/destructuring-assignment */

/* eslint-disable react/no-unused-state */

/* eslint-disable class-methods-use-this */

/* eslint-disable react/button-has-type */

/* eslint-disable react/sort-comp */

/* eslint-disable jsx-a11y/click-events-have-key-events */

/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */




















var translationview_ref =
/*#__PURE__*/
translationview_jsx("div", {});

var translationview_ref2 =
/*#__PURE__*/
translationview_jsx("i", {
  className: "fa fa-paste"
});

class translationview_TranslationView extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  active() {
    return !!this.props.active;
  }

  getTranslation(item, language) {
    if (item && item.properties && item.properties.languages) {
      return `${language}: ${item.properties.languages[language]}`;
    }

    return `${language}: ${Unknown}`;
  }

  render() {
    const active = this.active();
    const graph = GetCurrentGraph();

    if (!graph) {
      return translationview_ref;
    }

    const {
      languageTitles = {
        titles: {}
      }
    } = graph;
    const nodesForTranslation = uiactions_NodesByType(null, [NodeTypes.Model, NodeTypes.ComponentNode, NodeTypes.Screen, NodeTypes.ScreenOption].filter(x => !this.state[x])).filter(x => this.state.OnlyUntranslated ? !languageTitles.titles[x.id] : true).filter(x => this.state.titleSearch && `${uiactions_GetNodeProp(x, uiactions_NodeProperties.Label)} ${x.id} ${GetNodeTitle(x)}`.toLowerCase().indexOf(this.state.titleSearch.toLowerCase()) !== -1);
    return translationview_jsx(topviewer_TopViewer, {
      active: active
    }, void 0, translationview_jsx("section", {
      className: "content"
    }, void 0, translationview_jsx("div", {
      className: "row"
    }, void 0, translationview_jsx("div", {
      className: "col-md-3"
    }, void 0, translationview_jsx(box_Box, {
      maxheight: 600,
      title: Input,
      onSearch: search => {
        this.setState({
          titleSearch: search
        });
      }
    }, void 0, translationview_jsx(checkbox_CheckBox, {
      label: OnlyUntranslated,
      onChange: value => {
        this.setState({
          OnlyUntranslated: value
        });
      },
      value: this.state.OnlyUntranslated
    }), [NodeTypes.Model, NodeTypes.ComponentNode, NodeTypes.Screen, NodeTypes.ScreenOption].map(nodeType => {
      return translationview_jsx(checkbox_CheckBox, {
        label: `Exclude ${nodeType}`,
        onChange: value => {
          this.setState({
            [nodeType]: value
          });
        },
        value: this.state[nodeType]
      }, `node-type-${nodeType}`);
    }), translationview_jsx(buttonlist_ButtonList, {
      active: true,
      items: nodesForTranslation.map(v => languageTitles.titles[v.id] || {
        title: GetNodeTitle(v),
        id: v.id,
        properties: {}
      }).sort((a, b) => GetNodeTitle(a.id).localeCompare(GetNodeTitle(b.id))),
      renderItem: item => translationview_jsx("div", {
        className: "col-md-12",
        style: {
          display: 'flex',
          alignItems: 'center'
        }
      }, void 0, translationview_jsx("div", {
        className: "col-md-10"
      }, void 0, translationview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, GetNodeTitle(item.id)), translationview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, this.getTranslation(item, nodetypes_Languages["US-English"])), translationview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, this.getTranslation(item, nodetypes_Languages["NB-Norsk"])), translationview_jsx("h5", {
        style: {
          margin: 0
        }
      }, void 0, this.getTranslation(item, nodetypes_Languages["FR-Francais"]))), translationview_jsx("div", {
        className: "col-md-2"
      }, void 0, this.state.copied ? translationview_jsx("button", {
        className: "btn btn-default btn-flat",
        onClick: event => {
          languageTitles.titles[item.id] = {
            properties: JSON.parse(JSON.stringify(this.state.copied)).properties,
            id: item.id,
            title: GetNodeTitle(item.id)
          };
          this.props.updateGraph('languageTitles', { ...languageTitles
          });
          event.stopPropagation();
          return null;
        }
      }, void 0, translationview_ref2) : null)),
      onClick: item => {
        item.properties.languages = item.properties.languages || {};

        if (item && item.properties && item.properties.languages && !item.properties.languages[nodetypes_Languages["US-English"]]) {
          item.properties.languages[nodetypes_Languages["US-English"]] = GetNodeTitle(item.id);
        }

        this.setState({
          selectedId: item.id,
          item: { ...item
          }
        });
      }
    }))), translationview_jsx("div", {
      className: "col-md-3"
    }, void 0, this.state.selectedId ? translationview_jsx(box_Box, {
      maxheight: 600,
      title: Input
    }, void 0, translationview_jsx(formcontrol_FormControl, {}, void 0, translationview_jsx("h2", {
      style: {
        marginTop: 0,
        marginBottom: 0,
        paddingTop: 0,
        paddingBottom: 0
      }
    }, void 0, GetNodeTitle(this.state.selectedId)), translationview_jsx("h3", {
      style: {
        marginTop: 0,
        marginBottom: 0,
        paddingTop: 0,
        paddingBottom: 0
      }
    }, void 0, uiactions_GetNodeProp(this.state.selectedId, uiactions_NodeProperties.NODEType)), translationview_jsx("h4", {}, void 0, uiactions_GetNodeProp(this.state.selectedId, uiactions_NodeProperties.NODEType) === NodeTypes.ComponentNode ? uiactions_GetNodeProp(this.state.selectedId, uiactions_NodeProperties.ComponentType) : ''), Object.keys(nodetypes_Languages).map(language => {
      return translationview_jsx(textinput_TextInput, {
        value: this.state.item && this.state.item.properties && this.state.item.properties.languages ? this.state.item.properties.languages[language] : '',
        immediate: true,
        label: language,
        onChanged: value => {
          if (language === nodetypes_Languages["US-English"]) {
            if (value) {
              const {
                item
              } = this.state;
              translationservice(value, nodetypes_Languages["US-English"], nodetypes_Languages["FR-Francais"]).then(res => {
                item.properties.languages[nodetypes_Languages["FR-Francais"]] = res;
                return translationservice(value, nodetypes_Languages["US-English"], nodetypes_Languages["NB-Norsk"]).then(ress => {
                  item.properties.languages[nodetypes_Languages["NB-Norsk"]] = ress;
                  this.setState({
                    item: { ...item
                    }
                  });
                });
              });
            }
          }
        },
        onChange: value => {
          const {
            item
          } = this.state;
          item.properties = item.properties || {};
          item.properties.languages = item.properties.languages || {};
          item.properties.languages[language] = value;
          this.setState({
            item: { ...item
            }
          });
        },
        placeholder: language
      });
    })), translationview_jsx("div", {
      className: "btn-group"
    }, void 0, translationview_jsx("button", {
      className: "btn btn-default btn-primary",
      onClick: event => {
        languageTitles.titles[this.state.selectedId] = { ...this.state.item
        };
        this.props.updateGraph('languageTitles', { ...languageTitles
        });
        event.stopPropagation();
        return null;
      }
    }, void 0, "Set"), translationview_jsx("button", {
      className: "btn btn-default btn-primary",
      onClick: event => {
        this.setState({
          copied: JSON.parse(JSON.stringify(this.state.item))
        });
        return null;
      }
    }, void 0, "Copy"), this.state.copied ? translationview_jsx("button", {
      className: "btn btn-default btn-primary",
      onClick: event => {
        languageTitles.titles[item.id] = {
          properties: JSON.parse(JSON.stringify(this.state.copied)).properties,
          id: item.id,
          title: GetNodeTitle(item.id)
        };
        this.props.updateGraph('languageTitles', { ...languageTitles
        });
        event.stopPropagation();
        return null;
      }
    }, void 0, "Paste") : null, this.state.copied ? translationview_jsx("button", {
      className: "btn btn-default btn-primary",
      onClick: event => {
        if (confirm('Are you sure')) {
          nodesForTranslation.map(item => {
            languageTitles.titles[item.id] = {
              properties: JSON.parse(JSON.stringify(this.state.copied)).properties,
              id: item.id,
              title: GetNodeTitle(item.id)
            };
          });
          this.props.updateGraph('languageTitles', { ...languageTitles
          });
        }

        return null;
      }
    }, void 0, "Paste All") : null)) : null))));
  }

}

/* harmony default export */ var translationview = (UIConnect(translationview_TranslationView));
// CONCATENATED MODULE: ./app/components/gridareaselect.js

var gridareaselect_REACT_ELEMENT_TYPE;

function gridareaselect_jsx(type, props, key, children) { if (!gridareaselect_REACT_ELEMENT_TYPE) { gridareaselect_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: gridareaselect_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }









class gridareaselect_GridAreaSelect extends external_react_["Component"] {
  render() {
    let currentNode = this.props.node;
    let tags = uiactions_GetNodeProp(currentNode, this.props.property || nodetypes_NodeProperties.GridAreas) || [];
    return gridareaselect_jsx(buttonlist_ButtonList, {
      label: this.props.title || GridAreas,
      title: this.props.title || GridAreas,
      active: true,
      items: Object.keys(ComponentTags).map(x => ({
        id: x,
        value: x,
        title: x
      })),
      value: uiactions_GetNodeProp(currentNode, this.props.property || nodetypes_NodeProperties.GridAreas),
      isSelected: item => {
        if (tags) {
          return (tags || []).some(v => v === item.value);
        }

        return false;
      },
      onClick: item => {
        if (tags.find(v => v === item.value)) {
          let index = tags.findIndex(v => v === item.value);
          tags.splice(index, 1);
        } else {
          tags.push(item.value);
        }

        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: this.props.property || nodetypes_NodeProperties.GridAreas,
          id: currentNode.id,
          value: tags
        });
      }
    });
  }

}

/* harmony default export */ var gridareaselect = (UIConnect(gridareaselect_GridAreaSelect));
// CONCATENATED MODULE: ./app/components/gridplacement.js
var gridplacement_REACT_ELEMENT_TYPE;

function gridplacement_jsx(type, props, key, children) { if (!gridplacement_REACT_ELEMENT_TYPE) { gridplacement_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: gridplacement_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }











var gridplacement_ref =
/*#__PURE__*/
gridplacement_jsx("div", {});

var gridplacement_ref2 =
/*#__PURE__*/
gridplacement_jsx("i", {
  className: "fa  fa-times"
});

class gridplacement_GridPlacement extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    const currentNode = this.props.node;
    const tags = uiactions_GetNodeProp(currentNode, this.props.property || nodetypes_NodeProperties.GridAreas) || [];
    const cellStyle = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.Style) || {};

    if (cellStyle && !cellStyle.gridTemplateColumns) {
      return gridplacement_ref;
    }

    const gridColumns = cellStyle.gridTemplateColumns;
    const gridRowCount = parseInt(uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GridRowCount) || 1, 10);
    const columns = gridColumns.split(" ").filter(x => x);
    const square = {
      display: "flex",
      flex: 1,
      height: 24,
      border: "solid 1px #414141",
      ...(this.state.currentSection ? {
        cursor: "pointer"
      } : {})
    };
    const gridplacement = uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.GridPlacement) || [].interpolate(0, 100, t => "");
    return gridplacement_jsx("div", {}, void 0, gridplacement_jsx(selectinput_SelectInput, {
      label: GridAreas,
      title: GridAreas,
      options: tags.map(x => ({
        title: x,
        id: x,
        value: x
      })),
      value: this.state.currentSection,
      onChange: value => {
        this.setState({
          currentSection: value
        });
      }
    }), gridplacement_jsx("div", {
      style: {
        paddingBottom: 5
      }
    }, void 0, gridplacement_jsx("div", {
      className: "btn-group"
    }, void 0, gridplacement_jsx("button", {
      className: "btn btn-default bg-olive btn-flat",
      onClick: () => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: this.props.property || nodetypes_NodeProperties.GridPlacement,
          id: currentNode.id,
          value: null
        });
      }
    }, void 0, gridplacement_ref2))), gridplacement_jsx("div", {
      style: {
        display: "flex",
        flex: "1",
        flexDirection: "column"
      }
    }, void 0, [].interpolate(0, gridRowCount, row => gridplacement_jsx("div", {
      style: {
        display: "flex",
        flexDirection: "row"
      }
    }, void 0, columns.map((_, col) => gridplacement_jsx("div", {
      title: gridplacement[row * columns.length + col],
      style: { ...square,
        ...(gridplacement[row * columns.length + col] === this.state.currentSection ? {
          backgroundColor: Colors.SelectedNode
        } : gridplacement[row * columns.length + col] ? {
          backgroundColor: Colors.MarkedNode
        } : {})
      },
      onClick: () => {
        if (this.state.currentSection) {
          if (gridplacement[row * columns.length + col] !== this.state.currentSection) {
            gridplacement[row * columns.length + col] = this.state.currentSection;
          } else {
            gridplacement[row * columns.length + col] = "";
          }

          this.props.graphOperation(CHANGE_NODE_PROPERTY, {
            prop: this.props.property || nodetypes_NodeProperties.GridPlacement,
            id: currentNode.id,
            value: gridplacement
          });
        }
      }
    })), " "))));
  }

}

/* harmony default export */ var components_gridplacement = (UIConnect(gridplacement_GridPlacement));
// CONCATENATED MODULE: ./app/components/stylemenu.js

var stylemenu_REACT_ELEMENT_TYPE;

function stylemenu_jsx(type, props, key, children) { if (!stylemenu_REACT_ELEMENT_TYPE) { stylemenu_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: stylemenu_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }






















class stylemenu_StyleMenu extends external_react_["Component"] {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    var {
      state
    } = this.props;
    var active = IsCurrentNodeA(state, uiactions_NodeTypes.Style);
    var currentNode = Node(state, Visual(state, SELECTED_NODE));

    if (!currentNode || !active) {
      return stylemenu_jsx(tabpane_TabPane, {
        active: active
      });
    }

    let cellStyle = uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Style) || {};
    return stylemenu_jsx(sidebarmenu_SideBarMenu, {
      relative: true
    }, void 0, stylemenu_jsx(genericpropertycontainer, {
      active: true,
      title: "asdf",
      subTitle: "afaf",
      nodeType: NodeTypes.Selector
    }, void 0, stylemenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, Selector),
      active: true,
      title: Selector,
      toggle: () => {
        this.props.toggleVisual(Selector);
      }
    }, void 0, StyleNodeProperties.map(x => {
      return stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, x, stylemenu_jsx(checkboxproperty, {
        title: x,
        node: currentNode,
        property: x
      }));
    }))), stylemenu_jsx(genericpropertycontainer, {
      active: true,
      title: "asdf",
      subTitle: "afaf",
      nodeType: NodeTypes.Selector
    }, void 0, stylemenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, MediaQuery),
      active: true,
      title: MediaQuery,
      toggle: () => {
        this.props.toggleVisual(MediaQuery);
      }
    }, void 0, [nodetypes_NodeProperties.UseMediaQuery].map(x => {
      return stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, x, stylemenu_jsx(checkboxproperty, {
        title: x,
        node: currentNode,
        property: x
      }));
    }), stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, stylemenu_jsx(selectproperty, {
      title: MediaQuery,
      options: Object.keys(MediaQueries).map(v => ({
        title: v,
        id: v,
        value: v
      })),
      node: currentNode,
      property: nodetypes_NodeProperties.MediaQuery
    })))), stylemenu_jsx(genericpropertycontainer, {
      active: true,
      title: "asdf",
      subTitle: "afaf",
      nodeType: NodeTypes.Style
    }, void 0, stylemenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, Style),
      active: true,
      title: Style,
      toggle: () => {
        this.props.toggleVisual(Style);
      }
    }, void 0, stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, stylemenu_jsx(formcontrol_FormControl, {}, void 0, stylemenu_jsx(textinput_TextInput, {
      value: this.state.filter,
      label: Filter,
      immediate: true,
      onChange: value => {
        this.setState({
          filter: value
        });
      },
      placeholder: Filter
    }), this.getStyleSelect(), cellStyle && currentNode ? this.selectedStyle(value => {
      cellStyle[this.state.selectedStyleKey] = value;
      this.props.graphOperation(CHANGE_NODE_PROPERTY, {
        prop: uiactions_NodeProperties.Style,
        id: currentNode.id,
        value: cellStyle
      });
    }, cellStyle[this.state.selectedStyleKey]) : null, cellStyle ? this.getCurrentStyling(cellStyle) : null))), currentNode ? stylemenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, GridAreas),
      active: true,
      title: GridAreas,
      toggle: () => {
        this.props.toggleVisual(GridAreas);
      }
    }, void 0, stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, stylemenu_jsx(gridareaselect, {
      node: currentNode
    }))) : null, currentNode ? stylemenu_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, GridRow),
      active: true,
      title: GridRow,
      toggle: () => {
        this.props.toggleVisual(GridRow);
      }
    }, void 0, stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, stylemenu_jsx(selectproperty, {
      title: Rows,
      options: [].interpolate(0, 10, x => x).map(v => ({
        title: v,
        id: v,
        value: v
      })),
      node: currentNode,
      property: nodetypes_NodeProperties.GridRowCount
    })), stylemenu_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, stylemenu_jsx(components_gridplacement, {
      node: currentNode
    }))) : null));
  }

  selectedStyle(callback, value) {
    if (this.state.selectedStyleKey) {
      switch (this.state.selectedStyleKey) {
        default:
          return stylemenu_jsx(textinput_TextInput, {
            value: value,
            immediate: true,
            label: this.state.selectedStyleKey,
            onChange: callback,
            placeholder: Filter
          });
      }
    }

    return null;
  }

  getStyleSelect() {
    if (this.state.filter) {
      return stylemenu_jsx("ul", {
        style: {
          padding: 2,
          maxHeight: 200,
          overflowY: "auto"
        }
      }, void 0, Object.keys(StyleLib.js).filter(x => x.indexOf(this.state.filter) !== -1).map(key => {
        return stylemenu_jsx("li", {
          className: "treeview",
          style: {
            padding: 3,
            cursor: "pointer"
          },
          label: "Style",
          onClick: () => {
            this.setState({
              selectedStyleKey: key,
              filter: ""
            });
          }
        }, key, key);
      }));
    }

    return [];
  }

  getCurrentStyling(currentStyle) {
    if (currentStyle) {
      return stylemenu_jsx("ul", {
        style: {
          padding: 2,
          maxHeight: 400,
          overflowY: "auto"
        }
      }, void 0, Object.keys(currentStyle).map(key => {
        return stylemenu_jsx("li", {
          className: "treeview",
          style: {
            padding: 3,
            cursor: "pointer"
          },
          onClick: () => {
            this.setState({
              selectedStyleKey: key,
              filter: ""
            });
          }
        }, key, "[", key, "]:", stylemenu_jsx("div", {}, void 0, currentStyle[key]), stylemenu_jsx("hr", {
          style: {
            padding: 0,
            margin: 0
          }
        }));
      }));
    }

    return [];
  }

}

/* harmony default export */ var stylemenu = (UIConnect(stylemenu_StyleMenu));
// CONCATENATED MODULE: ./app/components/dashboard.js


var dashboard_REACT_ELEMENT_TYPE;

function dashboard_jsx(type, props, key, children) { if (!dashboard_REACT_ELEMENT_TYPE) { dashboard_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: dashboard_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }















































































































const {
  clipboard
} = __webpack_require__("electron");

const dashboard_SIDE_PANEL_OPEN = 'side-panel-open';
const NODE_MENU = 'NODE_MENU';
const CONNECTING_NODE = 'CONNECTING_NODE';
const LINK_DISTANCE = 'LINK_DISTANCE';

var dashboard_ref =
/*#__PURE__*/
dashboard_jsx(goomenu_GooMenuSVG, {});

var dashboard_ref2 =
/*#__PURE__*/
dashboard_jsx(dashboardlogo_Header, {});

var dashboard_ref3 =
/*#__PURE__*/
dashboard_jsx(sidebartoggle, {});

var dashboard_ref4 =
/*#__PURE__*/
dashboard_jsx(graphmenu, {});

var dashboard_ref5 =
/*#__PURE__*/
dashboard_jsx(sectionedit, {});

var dashboard_ref6 =
/*#__PURE__*/
dashboard_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, dashboard_jsx(depthchoice, {}));

var dashboard_ref7 =
/*#__PURE__*/
dashboard_jsx(sectionlist, {});

var _ref8 =
/*#__PURE__*/
dashboard_jsx(nodemanagement, {});

var _ref9 =
/*#__PURE__*/
dashboard_jsx(controllerdetailsmenu, {});

var _ref10 =
/*#__PURE__*/
dashboard_jsx(choicelistitemactivitymenu, {});

var _ref11 =
/*#__PURE__*/
dashboard_jsx(datachainactivitymenu, {});

var _ref12 =
/*#__PURE__*/
dashboard_jsx(conditionfiltermenu, {
  methodDefinitionKey: "validation"
});

var _ref13 =
/*#__PURE__*/
dashboard_jsx(conditionfiltermenu, {
  methodDefinitionKey: "permission"
});

var _ref14 =
/*#__PURE__*/
dashboard_jsx(conditionfiltermenu, {
  methodDefinitionKey: "filter"
});

var _ref15 =
/*#__PURE__*/
dashboard_jsx(conditionfiltermenu, {
  view: "datasource"
});

var _ref16 =
/*#__PURE__*/
dashboard_jsx(commonactivitymenu, {});

var _ref17 =
/*#__PURE__*/
dashboard_jsx(modelactivitymenu, {});

var _ref18 =
/*#__PURE__*/
dashboard_jsx(sidebarcontent_SideBarContent, {}, void 0, dashboard_jsx(controlleractivitymenu, {}), dashboard_jsx(modelfilteritemactivitymenu, {}), dashboard_jsx(datasourceactivitymenu, {}), dashboard_jsx(selectoractivitymenu, {}), dashboard_jsx(viewmodelactivitymenu, {}), dashboard_jsx(functionactivitymenu, {}), dashboard_jsx(configurationactivitymenu, {}), dashboard_jsx(methodactivitymenu, {}), dashboard_jsx(componentactivitymenu, {}), dashboard_jsx(attributeformcontrol, {}), dashboard_jsx(parameteractivitymenu, {}), dashboard_jsx(validatoractivitymenu, {}), dashboard_jsx(executoractivitymenu, {}), dashboard_jsx(propertyactivitymenu, {}), dashboard_jsx(validationitemactivitymenu, {}), dashboard_jsx(choiceactivitymenu, {}), dashboard_jsx(maestroactivitymenu, {}), dashboard_jsx(screenactivitymenu, {}), dashboard_jsx(validationactivitymenu, {}), dashboard_jsx(optionactivitymenu, {}), dashboard_jsx(components_ExtensionListActivityMenu, {}), dashboard_jsx(screenoptionsactivitymenu, {}), dashboard_jsx(optionitemformcontrol, {}), dashboard_jsx(permissionsactivitymenu, {}), dashboard_jsx(extensiondefinitionmenu, {}), dashboard_jsx(modelfilteractivitymenu, {}), dashboard_jsx(permissionsdependentactivitymenu, {}), dashboard_jsx(aftereffectsactivitymenu, {}), dashboard_jsx(enumerationactivitymenu, {}), dashboard_jsx(serviceactivitymenu, {}));

var _ref19 =
/*#__PURE__*/
dashboard_jsx(componentpropertymenu, {});

var _ref20 =
/*#__PURE__*/
dashboard_jsx(componentapimenu, {});

var _ref21 =
/*#__PURE__*/
dashboard_jsx(eventhandleractivitymenu, {});

var _ref22 =
/*#__PURE__*/
dashboard_jsx(sidebarcontent_SideBarContent, {}, void 0, dashboard_jsx(validatorpropertymenu, {}), dashboard_jsx(referenceactivitymenu, {}), dashboard_jsx(executorpropertymenu, {}), dashboard_jsx(modelrelationshipmenu, {}), dashboard_jsx(methodpropertymenu, {}), dashboard_jsx(permissionmenu, {}), dashboard_jsx(modelfiltermenu, {}));

var _ref23 =
/*#__PURE__*/
dashboard_jsx(validatorpropertyactivitymenu, {});

var _ref24 =
/*#__PURE__*/
dashboard_jsx(executorpropertyactivitymenu, {});

var _ref25 =
/*#__PURE__*/
dashboard_jsx(sidebarcontent_SideBarContent, {});

var _ref26 =
/*#__PURE__*/
dashboard_jsx(datachainoperator, {});

var _ref27 =
/*#__PURE__*/
dashboard_jsx(serviceinterfacemenu, {});

var _ref28 =
/*#__PURE__*/
dashboard_jsx(stylemenu, {});

var _ref29 =
/*#__PURE__*/
dashboard_jsx(uiparameters, {});

var _ref30 =
/*#__PURE__*/
dashboard_jsx(navigationparametermenu, {});

var _ref31 =
/*#__PURE__*/
dashboard_jsx(methodparameteremenu, {});

var _ref32 =
/*#__PURE__*/
dashboard_jsx(quickmethods, {});

var _ref33 =
/*#__PURE__*/
dashboard_jsx(currentnodeproperties, {});

var _ref34 =
/*#__PURE__*/
dashboard_jsx(themeproperties, {});

var _ref35 =
/*#__PURE__*/
dashboard_jsx(contextmenu, {});

class dashboard_Dashboard extends external_react_["Component"] {
  componentDidMount() {
    this.props.setState();
    this.props.setRemoteState();
    this.props.setVisual(NODE_COST, 5);
    this.props.setVisual(NODE_CONNECTION_COST, 1.5);
  }

  minified() {
    const {
      state
    } = this.props;
    return GetC(state, VISUAL, DASHBOARD_MENU) ? 'sidebar-collapse' : '';
  }

  nodeSelectionMenuItems() {
    const result = [];
    const {
      state
    } = this.props;

    if (Visual(state, SELECTED_NODE)) {
      const currentNode = Node(state, Visual(state, SELECTED_NODE));

      switch (uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType)) {
        case NodeTypes.DataChain:
          return this.getDataChainContext();

        case NodeTypes.Controller:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.MaestroLink,
                nodeTypes: [NodeTypes.Maestro]
              });
            },
            icon: 'fa  fa-music',
            title: AddMaestros
          });
          return result;

        case NodeTypes.Maestro:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.FunctionLink,
                nodeTypes: [NodeTypes.Method]
              });
            },
            icon: 'fa  fa-music',
            title: AddFunction
          });
          return result;

        case NodeTypes.Selector:
          result.push(...this.getSelectorContext());
          return result;

        case NodeTypes.Model:
        case NodeTypes.Property:
          result.push(...this.getModelContext());
          return result;

        case NodeTypes.ComponentNode:
          result.push(...this.getComponentContext());
          break;

        case NodeTypes.ViewType:
          result.push(...this.getViewTypeContext());
          return result;

        case NodeTypes.Permission:
          result.push(...this.getPermissionContext());
          return result;

        case NodeTypes.Executor:
          result.push(...this.getExecutorContext());
          return result;

        case NodeTypes.Validator:
          result.push(...this.getValidatorContext());
          return result;

        case NodeTypes.ClaimService:
          return [{
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ClaimServiceAuthorizationMethod,
                nodeTypes: [NodeTypes.Method]
              });
            },
            icon: 'fa fa-gears',
            title: ClaimServiceRegistrationCalls
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ClaimServiceUpdateUserMethod,
                nodeTypes: [NodeTypes.Method]
              });
            },
            icon: 'fa fa-truck',
            title: ClaimServiceUpdateUserMethod
          }];

        case NodeTypes.LifeCylceMethod:
          return this.getLifeCylcleMethods();

        case NodeTypes.EventMethod:
          return this.getEventMethods();

        case NodeTypes.EventMethodInstance:
          result.push(...this.getEventInstanceMethods(currentNode));
          return result;

        case NodeTypes.LifeCylceMethodInstance:
          result.push(...this.getLifeCylcleInstanceMethods());
          return result;

        case NodeTypes.ComponentApiConnector:
          result.push(...this.getComponentApiContextMenu());
          break;

        case NodeTypes.Method:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
                nodeTypes: [NodeTypes.DataChain]
              });
            },
            icon: 'fa fa-chain',
            title: DataChain
          });
          break;

        case NodeTypes.Action:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, nodetypes_LinkProperties.ModelItemFilter);
            },
            icon: 'fa fa-filter',
            title: ConnectModelItemFilter
          });
          break;

        case NodeTypes.ScreenOption:
          result.push({
            onClick: () => {
              this.props.addQueryMethodApi();
            },
            icon: 'fa fa-plus',
            title: AddQueryMethodApi
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.Style,
                nodeTypes: [NodeTypes.Style]
              });
            },
            icon: 'fa fa-css3',
            title: 'Style'
          }, {
            onClick: () => {// this.props.setVisual(CONNECTING_NODE, {
              // 	autoConnectViewType: currentNode.id
              // });
            },
            icon: 'fa fa-plus',
            title: `${AddComponentApi}`
          });
          break;

        case NodeTypes.MethodApiParameters:
          if (uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.QueryParameterObjectExtendible)) {
            result.push({
              onClick: () => {
                this.props.addQueryMethodParameter();
              },
              icon: 'fa fa-plus',
              title: AddQueryMethodApi
            });
          }

          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentApiConnection,
                singleLink: true,
                nodeTypes: [NodeTypes.DataChain]
              });
            },
            icon: 'fa  fa-contao',
            title: Body
          });
          break;

        case NodeTypes.Style:
          return [{
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.Style,
                singleLink: false,
                nodeTypes: [NodeTypes.Style]
              });
            },
            icon: 'fa fa-css3',
            title: Style
          }];

        case NodeTypes.Lists:
          return [{
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.Lists,
                nodeTypes: [NodeTypes.Screen]
              });
            },
            icon: 'fa  fa-list',
            title: 'Add to list'
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.Lists,
                allOfType: true,
                nodeTypes: [NodeTypes.Screen]
              });
            },
            icon: 'fa fa-list',
            title: 'Add All of [Type] list'
          }];

        case NodeTypes.FetchService:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.FetchService,
                nodeTypes: [NodeTypes.Method]
              });
            },
            icon: 'fa fa-bicycle',
            title: AddMethod
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.FetchServiceOuput,
                singleLink: true,
                nodeTypes: [NodeTypes.Model]
              });
            },
            icon: 'fa fa-plug',
            title: SetFetchServiceOutput
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.FetchSserviceAgent,
                singleLink: true,
                nodeTypes: [NodeTypes.Model],
                properties: {
                  [nodetypes_NodeProperties.IsAgent]: true
                }
              });
            },
            icon: 'fa  fa-user-secret',
            title: SetFetchSericeAgent
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
                singleLink: true,
                nodeTypes: [NodeTypes.DataChain]
              });
            },
            icon: 'fa fa-share-alt',
            title: DataChain
          });
          return result;

        case NodeTypes.ComponentExternalApi:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
                singleLink: true,
                nodeTypes: [NodeTypes.DataChain]
              });
            },
            icon: 'fa fa-share-alt',
            title: DataChain
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentExternalConnection,
                nodeTypes: [NodeTypes.ComponentApi]
              });
            },
            icon: 'fa fa-external-link-square',
            title: ExternalApiConnection
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentInternalConnection,
                singleLink: true,
                nodeTypes: [NodeTypes.ComponentApi]
              });
            },
            icon: 'fa fa-search-plus',
            title: InternalApiConnection
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.SelectorLink,
                singleLink: true,
                nodeTypes: [NodeTypes.Selector]
              });
            },
            icon: 'fa fa-reply',
            title: Selector
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.TitleServiceLink,
                singleLink: true,
                nodeTypes: [NodeTypes.TitleService]
              });
            },
            icon: 'fa  fa-font',
            title: TitleService
          });
          const graph = GetCurrentGraph(GetState());

          if (GetNodesLinkedTo(graph, {
            id: currentNode.id,
            link: nodetypes_LinkType.ComponentExternalApi
          }).some(v => uiactions_GetNodeProp(v, nodetypes_NodeProperties.NODEType) === NodeTypes.ScreenOption)) {
            result.push({
              onClick: () => {
                this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.QueryLink,
                  singleLink: true,
                  nodeTypes: [NodeTypes.MethodApiParameters]
                });
              },
              icon: 'fa fa-question',
              title: AddQueryMethodApi
            });
          }

          return result;

        case NodeTypes.ComponentApi:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
                singleLink: true,
                nodeTypes: [NodeTypes.DataChain]
              });
            },
            icon: 'fa fa-share-alt',
            title: DataChain
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentInternalConnection,
                singleLink: true,
                nodeTypes: [NodeTypes.ComponentExternalApi]
              });
            },
            icon: 'fa fa-search-plus',
            title: ExternalApiConnection
          }, {
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.SelectorLink,
                singleLink: true,
                nodeTypes: [NodeTypes.Selector]
              });
            },
            icon: 'fa fa-reply',
            title: Selector
          });
          return result;

        case NodeTypes.ScreenItem:
        case NodeTypes.ScreenCollection:
        case NodeTypes.ScreenContainer:
        case NodeTypes.Screen:
          result.push({
            onClick: () => {
              this.props.setVisual(CONNECTING_NODE, nodetypes_LinkProperties.ChildLink);
            },
            icon: 'fa fa-share-alt',
            title: ChildLink
          }, {
            onClick: () => {
              this.props.graphOperation([{
                operation: ADD_NEW_NODE,

                options() {
                  return {
                    nodeType: NodeTypes.ComponentApi,
                    parent: currentNode.id,
                    groupProperties: {},
                    linkProperties: {
                      properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                      }
                    },
                    properties: {
                      [nodetypes_NodeProperties.UIText]: `value`
                    }
                  };
                }

              }]);
            },
            icon: 'fa fa-plus',
            title: `${AddComponentApi}`
          });
          break;

        default:
          break;
      }

      result.push({
        onClick: () => {
          this.props.setVisual(CONNECTING_NODE, true);
        },
        icon: 'fa fa-plug',
        title: GenericLink
      });
    }

    return result;
  }

  getSelectorContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.SelectorLink
        });
      },
      icon: 'fa fa-font',
      title: `${Selector}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.SelectorInputLink
        });
      },
      icon: 'fa fa-exchange',
      title: `${SelectorInput}`
    });
    return result;
  }

  getViewTypeContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.SharedComponent
        });
      },
      icon: 'fa fa-coffee',
      title: `${SharedControl}`
    });
    return result;
  }

  getPermissionContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.PermissionServiceMethod
        });
      },
      icon: 'fa fa-unlock-alt',
      title: `${PermissionServiceMethod}`
    });
    return result;
  }

  getExecutorContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ExecutorServiceMethod
        });
      },
      icon: 'fa fa-rocket',
      title: `${ExecutorServiceMethod}`
    });
    return result;
  }

  getComponentApiContextMenu() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentApi,
          singleLink: true,
          nodeTypes: [NodeTypes.ComponentApi]
        });
      },
      icon: 'fa fa-genderless',
      title: `${InternalApiConnection}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentApiConnection
        });
      },
      icon: 'fa fa-rocket',
      title: `${ComponentApiConnection}`
    });
    return result;
  }

  getEventMethods() {
    const result = [];
    const {
      state
    } = this.props;
    result.push({
      onClick: () => {
        const currentNode = Node(state, Visual(state, SELECTED_NODE));
        this.props.graphOperation([{
          operation: ADD_NEW_NODE,
          options: addInstanceFunc(currentNode)
        }]);
      },
      icon: 'fa fa-plus',
      title: `${AddInstance}`
    });
    return result;
  }

  getLifeCylcleMethods() {
    const result = [];
    const {
      state
    } = this.props;
    result.push({
      onClick: () => {
        const currentNode = Node(state, Visual(state, SELECTED_NODE));
        this.props.graphOperation([{
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.LifeCylceMethodInstance,
              parent: currentNode.id,
              linkProperties: {
                properties: nodetypes_LinkProperties.LifeCylceMethodInstance
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.UIText]: `${GetNodeTitle(currentNode)} Instance`,
                [nodetypes_NodeProperties.AutoDelete]: {
                  properties: {
                    [nodetypes_NodeProperties.NODEType]: NodeTypes.ComponentApiConnector
                  }
                }
              }
            };
          }

        }]);
      },
      icon: 'fa fa-plus',
      title: `${AddInstance}`
    });
    return result;
  }

  getLifeCylcleInstanceMethods() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.LifeCylceMethod
        });
      },
      icon: 'fa fa-list-ol',
      title: `${ConnectLifeCylceMethods}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentApi,
          singleLink: true,
          nodeTypes: [NodeTypes.ComponentApi]
        });
      },
      icon: 'fa fa-genderless',
      title: `${InternalApiConnection}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          singleLink: true,
          nodeTypes: [NodeTypes.DataChain]
        });
      },
      icon: 'fa fa-chain',
      title: `${ConnectToDataChainResponseHandler}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.PreDataChainLink,
          singleLink: true,
          nodeTypes: [NodeTypes.DataChain]
        });
      },
      icon: 'fa fa-chain',
      title: `${ConnectToDataChainPrecallHandler}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.CallDataChainLink,
          singleLink: true,
          nodeTypes: [NodeTypes.DataChain]
        });
      },
      icon: 'fa fa-chain',
      title: `${ConnectToDataChainCaller}`
    });
    return result;
  }

  getEventInstanceMethods(currentNode) {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.EventMethod
        });
      },
      icon: 'fa fa-list-ol',
      title: `${ConnectEventMethods}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.NavigationMethod
        });
      },
      icon: 'fa fa-map-signs',
      title: `${NavigateTo}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.EventHandler,
          singleLink: true,
          nodeTypes: [NodeTypes.EventHandler]
        });
      },
      icon: 'fa fa-vimeo',
      title: `${ConnectEventHandler}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          singleLink: true,
          nodeTypes: [NodeTypes.DataChain]
        });
      },
      icon: 'fa fa-chain',
      title: `${DataChain}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ComponentApi,
          singleLink: true,
          nodeTypes: [NodeTypes.ComponentApi]
        });
      },
      icon: 'fa fa-genderless',
      title: `${InternalApiConnection}`
    }, {
      onClick: () => {
        if (currentNode) this.props.attachToNavigateNode(currentNode.id, NavigateTypes.Back);
      },
      icon: 'fa fa-backward',
      title: `${NavigateBack}`
    });
    return result;
  }

  getValidatorContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.ValidatorServiceMethod
        });
      },
      icon: 'fa fa-rocket',
      title: `${ValidatorServiceMethod}`
    });
    return result;
  }

  getComponentContext() {
    const result = [];
    const {
      state
    } = this.props;
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, {
          autoConnectViewType: currentNode.id
        });
      },
      icon: 'fa fa-soccer-ball-o',
      title: `${All}`
    }, {
      onClick: () => {
        this.props.graphOperation([{
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentApi,
              parent: currentNode.id,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentInternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.UIText]: `value`
              }
            };
          }

        }]);
      },
      icon: 'fa fa-plus',
      title: `${AddComponentApi}`
    }, {
      onClick: () => {
        this.props.graphOperation([{
          operation: ADD_NEW_NODE,

          options() {
            return {
              nodeType: NodeTypes.ComponentExternalApi,
              parent: currentNode.id,
              linkProperties: {
                properties: { ...nodetypes_LinkProperties.ComponentExternalApi
                }
              },
              groupProperties: {},
              properties: {
                [nodetypes_NodeProperties.UIText]: `value`
              }
            };
          }

        }]);
      },
      icon: 'fa fa-plus-circle',
      title: `${AddComponentExtApi}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.Style,
          singleLink: false,
          nodeTypes: [NodeTypes.Style]
        });
      },
      icon: 'fa fa-css3',
      title: Style
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          singleLink: false,
          nodeTypes: [NodeTypes.DataChain]
        });
      },
      icon: 'fa fa-chain',
      title: `${DataChain}`
    });
    return result;
  }

  getModelContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DefaultViewType,
          viewType: viewtypes_ViewTypes.Get
        });
      },
      icon: 'fa fa-get-pocket',
      title: `${viewtypes_ViewTypes.Get}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DefaultViewType,
          viewType: viewtypes_ViewTypes.GetAll
        });
      },
      icon: 'fa fa-reply-all',
      title: `${viewtypes_ViewTypes.GetAll}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DefaultViewType,
          viewType: viewtypes_ViewTypes.Create
        });
      },
      icon: 'fa fa-calendar-plus-o',
      title: `${viewtypes_ViewTypes.Create}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DefaultViewType,
          viewType: viewtypes_ViewTypes.Update
        });
      },
      icon: 'fa fa-fire',
      title: `${viewtypes_ViewTypes.Update}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DefaultViewType,
          viewType: viewtypes_ViewTypes.Delete
        });
      },
      icon: 'fa fa-remove',
      title: `${viewtypes_ViewTypes.Delete}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DefaultViewType,
          viewType: true,
          all: true
        });
      },
      icon: 'fa fa-soccer-ball-o',
      title: `${All}`
    });
    return result;
  }

  getDataChainContext() {
    const result = [];
    result.push({
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          context: 'Input1'
        });
      },
      icon: 'fa fa-font',
      title: `${Input} 1`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          context: 'Value'
        });
      },
      icon: 'fa fa-money',
      title: `${Value}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          context: 'StandardLink'
        });
      },
      icon: 'fa fa-chain',
      title: `${StandardLink}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainInputLink,
          nodeTypes: [NodeTypes.ComponentApi, NodeTypes.ComponentExternalApi]
        });
      },
      icon: 'fa fa-chain',
      title: `${DataChainInput}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.DataChainLink,
          context: 'InsertDataChain'
        });
      },
      icon: 'fa fa-yc',
      title: `${Insert}`
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.Style,
          nodeTypes: [NodeTypes.Style]
        });
      },
      icon: 'fa fa-css3',
      title: 'Modify Style'
    }, {
      onClick: () => {
        this.props.setVisual(CONNECTING_NODE, { ...nodetypes_LinkProperties.SelectorLink,
          nodeTypes: [NodeTypes.Selector]
        });
      },
      icon: 'fa fa-fire',
      title: 'Selector Input'
    });
    return result;
  }

  getCost() {
    const {
      state
    } = this.props;
    let cost = 0;
    const graph = GetCurrentGraph(state);
    const node_cost = Visual(state, NODE_COST) || 0;
    const node_connection_cost = Visual(state, NODE_CONNECTION_COST) || 0;

    if (graph) {
      cost = Object.keys(graph.linkLib || {}).length * node_cost + Object.keys(graph.nodeLib || {}).length * node_connection_cost;
    }

    return this.formatMoney(cost, 2, '.', ',');
  }

  formatMoney(number, decPlaces, decSep, thouSep) {
    decPlaces = isNaN(decPlaces = Math.abs(decPlaces)) ? 2 : decPlaces, decSep = typeof decSep === "undefined" ? "." : decSep;
    thouSep = typeof thouSep === "undefined" ? "," : thouSep;
    const sign = number < 0 ? "-" : "";
    const i = String(parseInt(number = Math.abs(Number(number) || 0).toFixed(decPlaces)));
    var j = (j = i.length) > 3 ? j % 3 : 0;
    return sign + (j ? i.substr(0, j) + thouSep : "") + i.substr(j).replace(/(\decSep{3})(?=\decSep)/g, `$1${thouSep}`) + (decPlaces ? decSep + Math.abs(number - i).toFixed(decPlaces).slice(2) : "");
  }

  render() {
    const {
      state
    } = this.props;
    const cost = this.getCost();
    const selected_node_bb = Visual(state, SELECTED_NODE_BB);
    let menu_left = 0;
    let menu_top = 0;

    if (selected_node_bb) {
      menu_left = selected_node_bb.right;
      menu_top = selected_node_bb.top;
    }

    const nodeSelectionMenuItems = this.nodeSelectionMenuItems();
    const currentNode = Node(state, Visual(state, SELECTED_NODE));
    const graph = GetCurrentGraph(state);
    const rootGraph = GetRootGraph(state);
    const vgraph = GetVisualGraph(state);
    const main_content = Visual(state, MAIN_CONTENT);
    let version = '0.0.0';
    let workspace = null;

    if (rootGraph) {
      version = `${rootGraph.version.major}.${rootGraph.version.minor}.${rootGraph.version.build}`;
      workspace = rootGraph.workspaces ? rootGraph.workspaces[Object(external_os_["platform"])()] || rootGraph.workspace : rootGraph.workspace;
    }

    let hoveredLink = null;

    if (Visual(state, HOVERED_LINK)) {
      hoveredLink = getLinkInstance(rootGraph, Visual(state, HOVERED_LINK));
    }

    return dashboard_jsx("div", {
      className: `skin-red sidebar-mini skin-red ${this.minified()}`,
      style: {
        height: 'auto',
        minHeight: '100vh'
      }
    }, void 0, dashboard_jsx("div", {
      className: "wrapper",
      style: {
        height: '100vh'
      }
    }, void 0, dashboard_ref, dashboard_jsx(goomenu_NavBarButton, {
      visible: Visual(state, SELECTED_NODE),
      left: menu_left - 20,
      open: Visual(state, NODE_MENU),
      onToggle: () => {
        this.props.toggleVisual(NODE_MENU);
      },
      top: menu_top + 30,
      menuItems: nodeSelectionMenuItems
    }), dashboard_jsx("div", {
      "data-tid": "container"
    }, void 0, dashboard_jsx(header_Header, {}, void 0, dashboard_ref2, dashboard_jsx(dashboardnavbar_Header, {}, void 0, dashboard_ref3, dashboard_jsx(navbarmenu_NavBarMenu, {}, void 0, Visual(state, SELECTED_LINK) ? dashboard_jsx(navbarbutton_NavBarButton, {
      icon: "fa fa-cube",
      onClick: () => {
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, Visual(state, SELECTED_LINK));
        this.props.setVisual(SELECTED_LINK, null);
      }
    }) : null, dashboard_ref4, dashboard_jsx(navbarbutton_NavBarButton, {
      icon: "fa fa-asterisk",
      onClick: () => {
        this.props.graphOperation(uiactions_REMOVE_LINK_BETWEEN_NODES, {
          source: currentNode.id,
          target: currentNode.id
        });
      }
    }), dashboard_jsx(navbarbutton_NavBarButton, {
      icon: "fa fa-plus",
      onClick: () => {
        this.props.graphOperation(NEW_NODE, {});
        this.props.setVisual(dashboard_SIDE_PANEL_OPEN, true);
        this.props.setVisual(dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB);
      }
    }), dashboard_jsx(navbarbutton_NavBarButton, {
      icon: "fa fa-minus",
      onClick: () => {
        this.props.graphOperation(REMOVE_NODE, {
          id: Visual(state, SELECTED_NODE)
        });
        this.props.setVisual(dashboard_SIDE_PANEL_OPEN, false);
        this.props.setVisual(dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB);
      }
    }), dashboard_jsx(navbarbutton_NavBarButton, {
      onClick: () => {
        this.props.toggleVisual('side-panel-open');
      }
    })), dashboard_jsx(navbarmenu_NavBarMenu, {
      paddingRight: 15
    }, void 0, dashboard_jsx(navbarbutton_NavBarButton, {
      icon: "fa fa-remove",
      title: ClearPinned,
      onClick: () => {
        this.props.graphOperation(GetNodes(state).filter(x => uiactions_GetNodeProp(x, nodetypes_NodeProperties.Pinned)).map(node => ({
          operation: CHANGE_NODE_PROPERTY,
          options: {
            prop: uiactions_NodeProperties.Pinned,
            id: node.id,
            value: false
          }
        })));
      }
    })), dashboard_jsx(navbarmenu_NavBarMenu, {
      paddingRight: 15,
      style: {
        float: 'left'
      }
    }, void 0, Visual(state, 'MAIN_NAV') ? dashboard_jsx(navbarbutton_NavBarButton, {
      active: main_content === MIND_MAP || !main_content,
      hideArrow: true,
      title: titles_MindMap,
      icon: "fa fa-map",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, MIND_MAP);
      }
    }) : null, Visual(state, 'MAIN_NAV') ? dashboard_jsx(navbarbutton_NavBarButton, {
      active: main_content === CODE_VIEW,
      hideArrow: true,
      title: titles_CodeView,
      icon: "fa fa-code",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, CODE_VIEW);
      }
    }) : null), dashboard_jsx(navbarmenu_NavBarMenu, {
      paddingRight: 15,
      style: {
        float: 'left'
      }
    }, void 0, dashboard_jsx(navbarbutton_NavBarButton, {
      title: New,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.newRedQuickBuilderGraph();
      }
    }), dashboard_jsx(navbarbutton_NavBarButton, {
      title: Open,
      icon: "fa fa-folder-open",
      onClick: () => {
        this.props.openRedQuickBuilderGraph();
      }
    }), dashboard_jsx(navbarbutton_NavBarButton, {
      title: `${Record} ${GetRecording().length}`,
      icon: Visual(state, RECORDING) ? 'fa fa-pause' : 'fa fa-play',
      onClick: () => {
        this.props.toggleVisual(RECORDING);
      }
    }), dashboard_jsx(navbarbutton_NavBarButton, {
      title: `${Save} ${Record}`,
      icon: "fa fa-save",
      onClick: () => {
        const recording = GetRecording();
        this.props.saveRecording(recording);
      }
    }), GetRecording().length ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: `${Record} ${GetRecording().length}`,
      icon: "fa fa-stop",
      onClick: () => {
        this.props.setVisual(RECORDING, false);
        this.props.clearRecording();
      }
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: SaveAs,
      icon: "fa fa-cloud-upload",
      onClick: () => {
        this.props.saveGraphToFile();
      }
    }) : null, rootGraph && rootGraph.graphFile ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: Save,
      icon: "fa fa-save",
      onClick: () => {
        this.props.saveGraph();
      }
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: Scaffold,
      icon: "fa fa-building",
      onClick: () => {
        if (confirm("Are you sure you want to scaffold the project")) this.props.scaffoldProject();
      }
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: PublishFiles,
      icon: "fa fa-building-o",
      onClick: () => {
        this.props.scaffoldProject({
          filesOnly: true
        });
      }
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: SetWorkingDirectory,
      icon: "fa fa-folder-open",
      onClick: () => {
        this.props.setWorkingDirectory();
      }
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: version
    }) : null, workspace ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: workspace,
      icon: "fa fa-cog"
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: SaveThemeAs,
      icon: "fa fa-paint-brush",
      secondaryicon: "fa fa-save fa-x1",
      onClick: () => {
        const theme = GetCurrentTheme();
        this.props.saveTheme(theme);
      }
    }) : null, rootGraph ? dashboard_jsx(navbarbutton_NavBarButton, {
      title: SelectThemeFromFile,
      icon: "fa fa-paint-brush",
      secondaryicon: "fa fa-folder-open-o",
      onClick: () => {
        this.props.openRedQuickBuilderTheme();
      }
    }) : null))), dashboard_jsx(mainsidebar_Header, {
      overflow: true
    }, void 0, dashboard_jsx(sidebarmenu_SideBarMenu, {}, void 0, dashboard_jsx(sidebarheader_SideBarHeader, {
      title: MainNavigation,
      onClick: () => {
        this.props.toggleVisual('MAIN_NAV');
      }
    }), Visual(state, 'MAIN_NAV') ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      active: main_content === MIND_MAP || !main_content,
      hideArrow: true,
      title: titles_MindMap,
      icon: "fa fa-map",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, MIND_MAP);
      }
    }) : null, Visual(state, 'MAIN_NAV') ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      active: main_content === CODE_VIEW,
      hideArrow: true,
      title: titles_CodeView,
      icon: "fa fa-code",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, CODE_VIEW);
      }
    }) : null, Visual(state, 'MAIN_NAV') ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      active: main_content === LAYOUT_VIEW,
      hideArrow: true,
      title: Layout,
      icon: "fa fa-code",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, LAYOUT_VIEW);
      }
    }) : null, Visual(state, 'MAIN_NAV') ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      active: main_content === THEME_VIEW,
      hideArrow: true,
      title: Theme,
      icon: "fa-paint-brush",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, THEME_VIEW);
      }
    }) : null, Visual(state, 'MAIN_NAV') ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      active: main_content === TRANSLATION_VIEW,
      hideArrow: true,
      title: Titles,
      icon: "fa fa-sort-alpha-asc",
      onClick: () => {
        this.props.setVisual(MAIN_CONTENT, TRANSLATION_VIEW);
      }
    }) : null, hoveredLink && hoveredLink.properties ? dashboard_jsx(sidebarheader_SideBarHeader, {
      title: hoveredLink.properties.type
    }) : null, dashboard_jsx(sidebarheader_SideBarHeader, {
      title: FileMenu
    }), dashboard_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, ApplicationMenu),
      active: Visual(state, ApplicationMenu),
      title: AppMenu,
      toggle: () => {
        this.props.toggleVisual(ApplicationMenu);
      }
    }, void 0, dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: New,
      icon: "fa fa-plus",
      onClick: () => {
        this.props.newRedQuickBuilderGraph();
      }
    }), dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: Open,
      icon: "fa fa-folder-open",
      onClick: () => {
        this.props.openRedQuickBuilderGraph();
      }
    }), rootGraph ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: SaveAs,
      icon: "fa fa-cloud-upload",
      onClick: () => {
        this.props.saveGraphToFile();
      }
    }) : null, rootGraph && rootGraph.fileName ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: Save,
      icon: "fa fa-save",
      onClick: () => {
        this.props.saveGraph();
      }
    }) : null, rootGraph ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: Scaffold,
      icon: "fa fa-building",
      onClick: () => {
        if (confirm("Are you sure you want to scaffold the project")) this.props.scaffoldProject();
      }
    }) : null, rootGraph ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: PublishFiles,
      icon: "fa fa-building-o",
      onClick: () => {
        this.props.scaffoldProject({
          filesOnly: true
        });
      }
    }) : null, rootGraph ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: SetWorkingDirectory,
      icon: "fa fa-folder-open",
      onClick: () => {
        this.props.setWorkingDirectory();
      }
    }) : null, rootGraph ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      title: version,
      hideArrow: true
    }) : null, workspace ? dashboard_jsx(treeviewmenu_TreeViewMenu, {
      hideArrow: true,
      title: workspace,
      icon: "fa fa-cog"
    }) : null, dashboard_ref5), dashboard_jsx(treeviewmenu_TreeViewMenu, {
      open: Visual(state, visual_GraphPropertiesMenu),
      active: Visual(state, visual_GraphPropertiesMenu),
      title: GraphPropertiesMenu,
      toggle: () => {
        this.props.toggleVisual(visual_GraphPropertiesMenu);
      }
    }, void 0, dashboard_jsx(treeviewitemcontainer_TreeViewItemContainer, {}, void 0, dashboard_jsx(slider_Slider, {
      min: 30,
      max: 500,
      onChange: value => {
        this.props.setVisual(LINK_DISTANCE, value);
      },
      value: Visual(state, LINK_DISTANCE)
    })), dashboard_ref6), dashboard_ref7, _ref8, dashboard_jsx(sidebarheader_SideBarHeader, {
      title: `$ ${cost}`,
      onClick: () => {}
    }), _ref9)), dashboard_jsx(content_Content, {}, void 0, dashboard_jsx(codeview, {
      active: Visual(state, MAIN_CONTENT) === CODE_VIEW
    }), dashboard_jsx(layoutview, {
      active: Visual(state, MAIN_CONTENT) === LAYOUT_VIEW
    }), dashboard_jsx(themeview, {
      active: Visual(state, MAIN_CONTENT) === THEME_VIEW
    }), dashboard_jsx(translationview, {
      active: Visual(state, MAIN_CONTENT) === TRANSLATION_VIEW
    }), main_content === MIND_MAP || true ? dashboard_jsx(mindmap_MindMap, {
      linkDistance: Visual(state, LINK_DISTANCE),
      onNodeClick: (nodeId, boundingBox) => {
        if (Visual(state, CONNECTING_NODE)) {
          const selectedId = Visual(state, SELECTED_NODE);
          console.log(`selectedId:${selectedId} => nodeId:${nodeId}`);
          const properties = Visual(state, CONNECTING_NODE);

          if (properties === true) {
            this.props.graphOperation(NEW_LINK, {
              target: nodeId,
              source: selectedId
            });
          } else if (properties && properties.type === nodetypes_LinkType.SharedComponent) {
            this.props.setSharedComponent({
              properties,
              target: nodeId,
              source: selectedId
            });
          } else if (properties && properties.type === nodetypes_LinkType.ComponentApiConnection) {
            this.props.setComponentApiConnection({
              properties,
              target: nodeId,
              source: selectedId
            });
          } else if (properties && [nodetypes_LinkType.LifeCylceMethod, nodetypes_LinkType.EventMethod, nodetypes_LinkType.NavigationMethod].some(v => v === properties.type)) {
            this.props.connectLifeCycleMethod({
              properties,
              target: nodeId,
              source: selectedId
            });
          } else if (properties && properties.type === nodetypes_LinkType.ModelItemFilter) {
            this.props.graphOperation([{
              operation: CHANGE_NODE_PROPERTY,
              options: {
                id: selectedId,
                prop: nodetypes_NodeProperties.FilterModel,
                value: nodeId
              }
            }, {
              operation: CHANGE_NODE_PROPERTY,
              options: {
                id: selectedId,
                prop: nodetypes_NodeProperties.ModelItemFilter,
                value: nodeId
              }
            }]);
            this.props.graphOperation(uiactions_ADD_LINK_BETWEEN_NODES, {
              target: nodeId,
              source: selectedId,
              properties: { ...uiactions_LinkProperties.ModelItemFilter,
                ...createEventProp(LinkEvents.Remove, {
                  function: 'OnRemoveModelFilterPropConnection'
                })
              }
            });
          } else if (properties && properties.viewType) {
            this.props.setupDefaultViewType({
              properties,
              target: nodeId,
              source: selectedId
            });
            this.props.SelectedNode(null);
          } else if (properties && properties.allOfType) {
            this.props.addAllOfType({
              properties,
              target: nodeId,
              source: selectedId
            });
          } else if (properties && properties.autoConnectViewType) {
            let connectto = [];
            Object.values(viewtypes_ViewTypes).map(viewType => {
              connectto = getViewTypeEndpointsForDefaults(viewType, null, nodeId);
              connectto.map(ct => {
                this.props.setSharedComponent({
                  properties: { ...nodetypes_LinkProperties.DefaultViewType,
                    viewType
                  },
                  source: ct.id,
                  target: properties.autoConnectViewType
                });
              });
            });
          } else if (properties && properties.context) {
            switch (properties.type) {
              case nodetypes_LinkType.DataChainLink:
                const func = DataChainContextMethods[properties.context].bind(this);
                func(currentNode, nodeId);
                break;

              default:
                break;
            }
          } else {
            const targetNodeType = uiactions_GetNodeProp(nodeId, nodetypes_NodeProperties.NODEType);

            if (properties.nodeTypes && properties.nodeTypes.length && !properties.nodeTypes.some(t => targetNodeType === t)) {} else {
              let skip = false;

              if (properties && properties.properties && Object.keys(properties.properties).map(key => uiactions_GetNodeProp(nodeId, key) !== properties.properties[key]).find(x => x)) {
                skip = true;
              }

              if (skip) {} else if (properties.singleLink) {
                this.props.graphOperation([...getNodesByLinkType(graph, {
                  type: properties.type,
                  direction: SOURCE,
                  id: selectedId
                }).map(rm => ({
                  operation: uiactions_REMOVE_LINK_BETWEEN_NODES,
                  options: {
                    target: rm.id,
                    source: selectedId
                  }
                })), {
                  operation: NEW_LINK,
                  options: {
                    target: nodeId,
                    source: selectedId,
                    properties
                  }
                }]);
              } else {
                this.props.graphOperation(NEW_LINK, {
                  target: nodeId,
                  source: selectedId,
                  properties
                });
              }
            }
          }

          this.props.setVisual(CONNECTING_NODE, false);
          this.props.setVisual(SELECTED_NODE, null);
        } else if ([Visual(state, SELECTED_NODE)].indexOf(nodeId) === -1) {
          this.props.SelectedNode(nodeId);
          this.props.setVisual(SELECTED_NODE_BB, boundingBox);
          this.props.setVisual(dashboard_SIDE_PANEL_OPEN, true);
        } else {
          this.props.SelectedNode(null);
        }
      },
      onLinkClick: (linkId, boundingBox) => {
        console.log(`link id : ${linkId}`);
        this.props.setVisual(SELECTED_LINK, linkId);
        this.props.setVisual(HOVERED_LINK, linkId);
      },
      minimizeTypes: Minimized(state),
      selectedColor: Colors.SelectedNode,
      markedColor: Colors.MarkedNode,
      selectedLinks: [Visual(state, SELECTED_LINK)].filter(x => x),
      selectedNodes: [Visual(state, SELECTED_NODE)].filter(x => x),
      markedNodes: graph ? graph.markedSelectedNodeIds : [],
      graph: vgraph || graph
    }) : null, "             "), dashboard_jsx(sidebar_SideBar, {
      open: Visual(state, dashboard_SIDE_PANEL_OPEN),
      style: {
        overflowY: 'auto',
        'maxHeight': '100vh',
        'height': '100vh'
      },
      extraWide: IsCurrentNodeA(state, uiactions_NodeTypes.ExtensionType)
    }, void 0, dashboard_jsx(sidebartabs_SideBarTabs, {}, void 0, dashboard_jsx(sidebartab_SideBarTab, {
      icon: "fa fa-cog",
      active: VisualEq(state, dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB),
      onClick: () => {
        this.props.setVisual(dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB);
      }
    }), dashboard_jsx(sidebartab_SideBarTab, {
      active: VisualEq(state, dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB),
      onClick: () => {
        this.props.setVisual(dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB);
      }
    }), dashboard_jsx(sidebartab_SideBarTab, {
      active: VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB),
      onClick: () => {
        this.props.setVisual(dashboard_SELECTED_TAB, dashboard_SCOPE_TAB);
      }
    }), dashboard_jsx(sidebartab_SideBarTab, {
      icon: "fa fa-institution",
      active: VisualEq(state, dashboard_SELECTED_TAB, dashboard_QUICK_MENU),
      onClick: () => {
        this.props.setVisual(dashboard_SELECTED_TAB, dashboard_QUICK_MENU);
      }
    })), currentNode && !ExcludeDefaultNode[uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType)] ? dashboard_jsx(sidemenucontainer, {
      active: true,
      tab: dashboard_DEFAULT_TAB,
      title: NodeProperties
    }, "node-properties", dashboard_jsx(formcontrol_FormControl, {}, void 0, dashboard_jsx(sidebarmenu_SideBarMenu, {}, void 0, dashboard_jsx(sidebarheader_SideBarHeader, {
      onClick: () => {
        clipboard.writeText(Visual(state, SELECTED_NODE));
      },
      title: Visual(state, SELECTED_NODE)
    })), _ref10, _ref11, dashboard_jsx(textinput_TextInput, {
      label: NodeLabel,
      value: currentNode.properties ? currentNode.properties.text : '',
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_TEXT, {
          id: currentNode.id,
          value
        });
      }
    }), NotSelectableNodeTypes[currentNode.properties ? uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType) : null] ? null : dashboard_jsx(selectinput_SelectInput, {
      disabled: !CanChangeType(currentNode),
      label: NodeType,
      options: Object.keys(uiactions_NodeTypes).filter(x => !NotSelectableNodeTypes[uiactions_NodeTypes[x]]).sort((a, b) => a.localeCompare(b)).map(x => ({
        value: uiactions_NodeTypes[x],
        title: x
      })),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.NODEType,
          id: currentNode.id,
          value
        });
      },
      value: currentNode.properties ? uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.NODEType) : null
    }), dashboard_jsx(checkbox_CheckBox, {
      label: Collapsed,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Collapsed),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Collapsed,
          id: currentNode.id,
          value
        });
      }
    }), dashboard_jsx(checkbox_CheckBox, {
      label: Pinned,
      title: PinnedShortCut,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Pinned),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Pinned,
          id: currentNode.id,
          value
        });
      }
    }), dashboard_jsx(checkbox_CheckBox, {
      label: Selected,
      title: SelectedShortCut,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.Selected),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.Selected,
          id: currentNode.id,
          value
        });
      }
    }), uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentExternalApi ? dashboard_jsx(checkbox_CheckBox, {
      label: IsUrlParameter,
      title: IsUrlParameter,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.IsUrlParameter),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.IsUrlParameter,
          id: currentNode.id,
          value
        });
      }
    }) : null, uiactions_GetNodeProp(currentNode, nodetypes_NodeProperties.NODEType) === uiactions_NodeTypes.ComponentApi ? dashboard_jsx(checkbox_CheckBox, {
      label: AsLocalContext,
      title: `${AsLocalContext}, usually for listitem.`,
      value: uiactions_GetNodeProp(currentNode, uiactions_NodeProperties.AsLocalContext),
      onChange: value => {
        this.props.graphOperation(CHANGE_NODE_PROPERTY, {
          prop: uiactions_NodeProperties.AsLocalContext,
          id: currentNode.id,
          value
        });
      }
    }) : null)) : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB) ? _ref12 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB) ? _ref13 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB) ? _ref14 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB) ? _ref15 : null, _ref16, _ref17, VisualEq(state, dashboard_SELECTED_TAB, dashboard_PARAMETER_TAB) ? _ref18 : null, _ref19, _ref20, _ref21, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? _ref22 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? _ref23 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? _ref24 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? dashboard_jsx(executorpropertyactivitymenu, {
      ui: FilterUI,
      modelKey: nodetypes_NodeProperties.ModelItemFilter,
      nodeType: NodeTypes.ModelItemFilter,
      nodeProp: nodetypes_NodeProperties.FilterModel
    }) : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? dashboard_jsx(executorpropertyactivitymenu, {
      ui: FilterUI,
      modelKey: nodetypes_NodeProperties.Condition,
      nodeType: NodeTypes.Condition,
      nodeProp: nodetypes_NodeProperties.Condition
    }) : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_QUICK_MENU) ? _ref25 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB) ? _ref26 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB) ? _ref27 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB) ? _ref28 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? _ref29 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? _ref30 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_SCOPE_TAB) ? _ref31 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_QUICK_MENU) ? _ref32 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_QUICK_MENU) ? _ref33 : null, VisualEq(state, dashboard_SELECTED_TAB, dashboard_DEFAULT_TAB) ? _ref34 : null))), _ref35);
  }

}

const dashboard_SELECTED_TAB = 'SELECTED_TAB';
const dashboard_DEFAULT_TAB = 'DEFAULT_TAB';
const dashboard_PARAMETER_TAB = 'PARAMETER_TAB';
const dashboard_SCOPE_TAB = 'SCOPE_TAB';
const dashboard_QUICK_MENU = 'QUICK_MENU';
/* harmony default export */ var dashboard = (UIConnect(dashboard_Dashboard));
// CONCATENATED MODULE: ./app/Routes.js
var Routes_REACT_ELEMENT_TYPE;

function Routes_jsx(type, props, key, children) { if (!Routes_REACT_ELEMENT_TYPE) { Routes_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: Routes_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }






/* harmony default export */ var Routes = (() => Routes_jsx(App_App, {}, void 0, Routes_jsx(external_react_router_["Switch"], {}, void 0, Routes_jsx(external_react_router_["Route"], {
  path: constants_routes.HOME,
  component: dashboard
}))));
// CONCATENATED MODULE: ./app/containers/Root.js
var Root_REACT_ELEMENT_TYPE;

function Root_jsx(type, props, key, children) { if (!Root_REACT_ELEMENT_TYPE) { Root_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: Root_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }






var Root_ref =
/*#__PURE__*/
Root_jsx(Routes, {});

class Root_Root extends external_react_["Component"] {
  render() {
    const {
      store,
      history
    } = this.props;
    return Root_jsx(external_react_redux_["Provider"], {
      store: store
    }, void 0, Root_jsx(connected_react_router_lib["ConnectedRouter"], {
      history: history
    }, void 0, Root_ref));
  }

}
// EXTERNAL MODULE: external "redux-thunk"
var external_redux_thunk_ = __webpack_require__("redux-thunk");
var external_redux_thunk_default = /*#__PURE__*/__webpack_require__.n(external_redux_thunk_);

// EXTERNAL MODULE: external "history"
var external_history_ = __webpack_require__("history");

// EXTERNAL MODULE: ./node_modules/redux-logger/dist/redux-logger.js
var redux_logger = __webpack_require__("./node_modules/redux-logger/dist/redux-logger.js");

// CONCATENATED MODULE: ./app/actions/counter.js
const INCREMENT_COUNTER = 'INCREMENT_COUNTER';
const DECREMENT_COUNTER = 'DECREMENT_COUNTER';
function increment() {
  return {
    type: INCREMENT_COUNTER
  };
}
function decrement() {
  return {
    type: DECREMENT_COUNTER
  };
}
function incrementIfOdd() {
  return (dispatch, getState) => {
    const {
      counter
    } = getState();

    if (counter % 2 === 0) {
      return;
    }

    dispatch(increment());
  };
}
function incrementAsync(delay = 1000) {
  return dispatch => {
    setTimeout(() => {
      dispatch(increment());
    }, delay);
  };
}
// CONCATENATED MODULE: ./app/reducers/counter.js

function counter(state = 0, action) {
  switch (action.type) {
    case INCREMENT_COUNTER:
      return state + 1;

    case DECREMENT_COUNTER:
      return state - 1;

    default:
      return state;
  }
}
// CONCATENATED MODULE: ./app/reducers/uiReducer.js

function updateUI(state, action) {
  var newstate = { ...state
  };
  newstate[action.section] = { ...(newstate[action.section] || {})
  };
  newstate[action.section][action.item] = action.value;
  return newstate;
}
function makeDefaultState() {
  return {};
}
function uiReducer(state, action) {
  state = state || makeDefaultState();

  switch (action.type) {
    case UI_UPDATE:
      return updateUI(state, action);

    default:
      return state;
  }
}
// CONCATENATED MODULE: ./app/reducers/index.js




function createRootReducer(history) {
  return Object(external_redux_["combineReducers"])({
    router: Object(connected_react_router_lib["connectRouter"])(history),
    counter: counter,
    uiReducer: uiReducer
  });
}
// CONCATENATED MODULE: ./app/store/configureStore.dev.js







const configureStore_dev_history = Object(external_history_["createHashHistory"])();
const rootReducer = createRootReducer(configureStore_dev_history);

const configureStore = initialState => {
  // Redux Configuration
  const middleware = [];
  const enhancers = []; // Thunk Middleware

  middleware.push(external_redux_thunk_default.a); // Logging Middleware

  const logger = Object(redux_logger["createLogger"])({
    level: 'info',
    collapsed: true
  }); // Skip redux logs in console during the tests

  if (true) {
    middleware.push(logger);
  } // Router Middleware


  const router = Object(connected_react_router_lib["routerMiddleware"])(configureStore_dev_history);
  middleware.push(router); // Redux DevTools Configuration

  const actionCreators = { ...counter_namespaceObject,
    ...connected_react_router_lib["routerActions"]
  }; // If Redux DevTools Extension is installed use it, otherwise use Redux compose

  /* eslint-disable no-underscore-dangle */

  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
    // Options: http://extension.remotedev.io/docs/API/Arguments.html
    actionCreators
  }) : external_redux_["compose"];
  /* eslint-enable no-underscore-dangle */
  // Apply Middleware & Compose Enhancers

  enhancers.push(Object(external_redux_["applyMiddleware"])(...middleware));
  const enhancer = composeEnhancers(...enhancers); // Create Store

  const store = Object(external_redux_["createStore"])(rootReducer, initialState, enhancer);

  if (false) {}

  return store;
};

/* harmony default export */ var configureStore_dev = ({
  configureStore,
  history: configureStore_dev_history
});
// CONCATENATED MODULE: ./app/store/configureStore.prod.js





const configureStore_prod_history = Object(external_history_["createHashHistory"])();
const configureStore_prod_rootReducer = createRootReducer(configureStore_prod_history);
const configureStore_prod_router = Object(connected_react_router_lib["routerMiddleware"])(configureStore_prod_history);
const configureStore_prod_enhancer = Object(external_redux_["applyMiddleware"])(external_redux_thunk_default.a, configureStore_prod_router);

function configureStore_prod_configureStore(initialState) {
  return Object(external_redux_["createStore"])(configureStore_prod_rootReducer, initialState, configureStore_prod_enhancer);
}

/* harmony default export */ var configureStore_prod = ({
  configureStore: configureStore_prod_configureStore,
  history: configureStore_prod_history
});
// CONCATENATED MODULE: ./app/store/configureStore.js


const selectedConfigureStore =  true ? configureStore_prod : undefined;
const {
  configureStore: configureStore_configureStore
} = selectedConfigureStore;
const {
  history: configureStore_history
} = selectedConfigureStore;
// EXTERNAL MODULE: ./app/app.global.css
var app_global = __webpack_require__("./app/app.global.css");

// CONCATENATED MODULE: ./app/index.js
var app_REACT_ELEMENT_TYPE;

function app_jsx(type, props, key, children) { if (!app_REACT_ELEMENT_TYPE) { app_REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7; } var defaultProps = type && type.defaultProps; var childrenLength = arguments.length - 3; if (!props && childrenLength !== 0) { props = { children: void 0 }; } if (props && defaultProps) { for (var propName in defaultProps) { if (props[propName] === void 0) { props[propName] = defaultProps[propName]; } } } else if (!props) { props = defaultProps || {}; } if (childrenLength === 1) { props.children = children; } else if (childrenLength > 1) { var childArray = new Array(childrenLength); for (var i = 0; i < childrenLength; i++) { childArray[i] = arguments[i + 3]; } props.children = childArray; } return { $$typeof: app_REACT_ELEMENT_TYPE, type: type, key: key === undefined ? null : '' + key, ref: null, props: props, _owner: null }; }







const app_store = configureStore_configureStore();
Object(external_react_dom_["render"])(app_jsx(external_react_hot_loader_["AppContainer"], {}, void 0, app_jsx(Root_Root, {
  store: app_store,
  history: configureStore_history
})), document.getElementById('root'));

if (false) {}

/***/ }),

/***/ "./node_modules/connected-react-router/lib/ConnectedRouter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__("./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactRedux = __webpack_require__("react-redux");

var _reactRouter = __webpack_require__("react-router");

var _actions = __webpack_require__("./node_modules/connected-react-router/lib/actions.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createConnectedRouter = function createConnectedRouter(structure) {
  var getIn = structure.getIn,
      toJS = structure.toJS;
  /*
   * ConnectedRouter listens to a history object passed from props.
   * When history is changed, it dispatches action to redux store.
   * Then, store will pass props to component to render.
   * This creates uni-directional flow from history->store->router->components.
   */

  var ConnectedRouter = function (_get__2) {
    _inherits(ConnectedRouter, _get__2);

    function ConnectedRouter(props, context) {
      _classCallCheck(this, ConnectedRouter);

      var _this = _possibleConstructorReturn(this, (ConnectedRouter.__proto__ || Object.getPrototypeOf(ConnectedRouter)).call(this, props));

      _this.inTimeTravelling = false;

      // Subscribe to store changes
      _this.unsubscribe = context.store.subscribe(function () {
        // Extract store's location
        var _toJS = toJS(getIn(context.store.getState(), ['router', 'location'])),
            pathnameInStore = _toJS.pathname,
            searchInStore = _toJS.search,
            hashInStore = _toJS.hash;
        // Extract history's location


        var _props$history$locati = props.history.location,
            pathnameInHistory = _props$history$locati.pathname,
            searchInHistory = _props$history$locati.search,
            hashInHistory = _props$history$locati.hash;

        // If we do time travelling, the location in store is changed but location in history is not changed

        if (pathnameInHistory !== pathnameInStore || searchInHistory !== searchInStore || hashInHistory !== hashInStore) {
          _this.inTimeTravelling = true;
          // Update history's location to match store's location
          props.history.push({
            pathname: pathnameInStore,
            search: searchInStore,
            hash: hashInStore
          });
        }
      });

      var handleLocationChange = function handleLocationChange(location, action) {
        // Dispatch onLocationChanged except when we're in time travelling
        if (!_this.inTimeTravelling) {
          props.onLocationChanged(location, action);
        } else {
          _this.inTimeTravelling = false;
        }
      };

      // Listen to history changes
      _this.unlisten = props.history.listen(handleLocationChange);
      // Dispatch a location change action for the initial location
      handleLocationChange(props.history.location, props.history.action);
      return _this;
    }

    _createClass(ConnectedRouter, [{
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.unlisten();
        this.unsubscribe();
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            history = _props.history,
            children = _props.children;


        return _get__('React').createElement(
          _get__('Router'),
          { history: history },
          children
        );
      }
    }]);

    return ConnectedRouter;
  }(_get__('Component'));

  ConnectedRouter.contextTypes = {
    store: _get__('PropTypes').shape({
      getState: _get__('PropTypes').func.isRequired,
      subscribe: _get__('PropTypes').func.isRequired
    }).isRequired
  };

  ConnectedRouter.propTypes = {
    history: _get__('PropTypes').shape({
      action: _get__('PropTypes').string.isRequired,
      listen: _get__('PropTypes').func.isRequired,
      location: _get__('PropTypes').object.isRequired,
      push: _get__('PropTypes').func.isRequired
    }).isRequired,
    location: _get__('PropTypes').oneOfType([_get__('PropTypes').object, _get__('PropTypes').string]).isRequired,
    action: _get__('PropTypes').string.isRequired,
    basename: _get__('PropTypes').string,
    children: _get__('PropTypes').oneOfType([_get__('PropTypes').func, _get__('PropTypes').node]),
    onLocationChanged: _get__('PropTypes').func.isRequired
  };

  var mapStateToProps = function mapStateToProps(state) {
    return {
      action: getIn(state, ['router', 'action']),
      location: getIn(state, ['router', 'location'])
    };
  };

  var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
      onLocationChanged: function onLocationChanged(location, action) {
        return dispatch(_get__('onLocationChanged')(location, action));
      }
    };
  };

  return _get__('connect')(mapStateToProps, mapDispatchToProps)(ConnectedRouter);
};

exports.default = _get__('createConnectedRouter');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'Component':
      return _react.Component;

    case 'PropTypes':
      return _propTypes2.default;

    case 'onLocationChanged':
      return _actions.onLocationChanged;

    case 'connect':
      return _reactRedux.connect;

    case 'createConnectedRouter':
      return createConnectedRouter;

    case 'React':
      return _react2.default;

    case 'Router':
      return _reactRouter.Router;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof createConnectedRouter === 'undefined' ? 'undefined' : _typeof(createConnectedRouter);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(createConnectedRouter, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(createConnectedRouter)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/actions.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * This action type will be dispatched when your history
 * receives a location change.
 */
var LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';

var onLocationChanged = exports.onLocationChanged = function onLocationChanged(location, action) {
  return {
    type: _get__('LOCATION_CHANGE'),
    payload: {
      location: location,
      action: action
    }
  };
};

/**
 * This action type will be dispatched by the history actions below.
 * If you're writing a middleware to watch for navigation events, be sure to
 * look for actions of this type.
 */
var CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';

var updateLocation = function updateLocation(method) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return {
      type: _get__('CALL_HISTORY_METHOD'),
      payload: {
        method: method,
        args: args
      }
    };
  };
};

/**
 * These actions correspond to the history API.
 * The associated routerMiddleware will capture these events before they get to
 * your reducer and reissue them as the matching function on your history.
 */
var push = exports.push = _get__('updateLocation')('push');
var replace = exports.replace = _get__('updateLocation')('replace');
var go = exports.go = _get__('updateLocation')('go');
var goBack = exports.goBack = _get__('updateLocation')('goBack');
var goForward = exports.goForward = _get__('updateLocation')('goForward');

var routerActions = exports.routerActions = { push: _get__('push'), replace: _get__('replace'), go: _get__('go'), goBack: _get__('goBack'), goForward: _get__('goForward') };

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'LOCATION_CHANGE':
      return LOCATION_CHANGE;

    case 'CALL_HISTORY_METHOD':
      return CALL_HISTORY_METHOD;

    case 'updateLocation':
      return updateLocation;

    case 'push':
      return push;

    case 'replace':
      return replace;

    case 'go':
      return go;

    case 'goBack':
      return goBack;

    case 'goForward':
      return goForward;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;
exports.default = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/createAll.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _actions = __webpack_require__("./node_modules/connected-react-router/lib/actions.js");

var actions = _interopRequireWildcard(_actions);

var _ConnectedRouter = __webpack_require__("./node_modules/connected-react-router/lib/ConnectedRouter.js");

var _ConnectedRouter2 = _interopRequireDefault(_ConnectedRouter);

var _reducer = __webpack_require__("./node_modules/connected-react-router/lib/reducer.js");

var _reducer2 = _interopRequireDefault(_reducer);

var _middleware = __webpack_require__("./node_modules/connected-react-router/lib/middleware.js");

var _middleware2 = _interopRequireDefault(_middleware);

var _selectors = __webpack_require__("./node_modules/connected-react-router/lib/selectors.js");

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var createAll = function createAll(structure) {
  return _extends({}, _get__('actions'), _get__('createSelectors')(structure), {
    ConnectedRouter: _get__('createConnectedRouter')(structure),
    connectRouter: _get__('createConnectRouter')(structure),
    routerMiddleware: _get__('routerMiddleware')
  });
};

exports.default = _get__('createAll');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'actions':
      return _filterWildcardImport__(actions);

    case 'createSelectors':
      return _selectors2.default;

    case 'createConnectedRouter':
      return _ConnectedRouter2.default;

    case 'createConnectRouter':
      return _reducer2.default;

    case 'routerMiddleware':
      return _middleware2.default;

    case 'createAll':
      return createAll;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof createAll === 'undefined' ? 'undefined' : _typeof(createAll);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(createAll, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(createAll)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

function _filterWildcardImport__() {
  var wildcardImport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var validPropertyNames = Object.keys(wildcardImport).filter(function (propertyName) {
    return propertyName !== '__get__' && propertyName !== '__set__' && propertyName !== '__reset__' && propertyName !== '__with__' && propertyName !== '__GetDependency__' && propertyName !== '__Rewire__' && propertyName !== '__ResetDependency__' && propertyName !== '__RewireAPI__';
  });
  return validPropertyNames.reduce(function (filteredWildcardImport, propertyName) {
    filteredWildcardImport[propertyName] = wildcardImport[propertyName];
    return filteredWildcardImport;
  }, {});
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = exports.createMatchSelector = exports.getAction = exports.getLocation = exports.routerMiddleware = exports.connectRouter = exports.ConnectedRouter = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.LOCATION_CHANGE = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createAll = __webpack_require__("./node_modules/connected-react-router/lib/createAll.js");

var _createAll2 = _interopRequireDefault(_createAll);

var _plain = __webpack_require__("./node_modules/connected-react-router/lib/structure/plain/index.js");

var _plain2 = _interopRequireDefault(_plain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _get__2 = _get__('createAll')(_get__('plainStructure'));

var LOCATION_CHANGE = _get__2.LOCATION_CHANGE,
    CALL_HISTORY_METHOD = _get__2.CALL_HISTORY_METHOD,
    push = _get__2.push,
    replace = _get__2.replace,
    go = _get__2.go,
    goBack = _get__2.goBack,
    goForward = _get__2.goForward,
    routerActions = _get__2.routerActions,
    ConnectedRouter = _get__2.ConnectedRouter,
    connectRouter = _get__2.connectRouter,
    routerMiddleware = _get__2.routerMiddleware,
    getLocation = _get__2.getLocation,
    getAction = _get__2.getAction,
    createMatchSelector = _get__2.createMatchSelector;
exports.LOCATION_CHANGE = LOCATION_CHANGE;
exports.CALL_HISTORY_METHOD = CALL_HISTORY_METHOD;
exports.push = push;
exports.replace = replace;
exports.go = go;
exports.goBack = goBack;
exports.goForward = goForward;
exports.routerActions = routerActions;
exports.ConnectedRouter = ConnectedRouter;
exports.connectRouter = connectRouter;
exports.routerMiddleware = routerMiddleware;
exports.getLocation = getLocation;
exports.getAction = getAction;
exports.createMatchSelector = createMatchSelector;

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'createAll':
      return _createAll2.default;

    case 'plainStructure':
      return _plain2.default;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;
exports.default = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/middleware.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _actions = __webpack_require__("./node_modules/connected-react-router/lib/actions.js");

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * This middleware captures CALL_HISTORY_METHOD actions to redirect to the
 * provided history object. This will prevent these actions from reaching your
 * reducer or any middleware that comes after this one.
 */
var routerMiddleware = function routerMiddleware(history) {
  return function (store) {
    return function (next) {
      return function (action) {
        // eslint-disable-line no-unused-vars
        if (action.type !== _get__('CALL_HISTORY_METHOD')) {
          return next(action);
        }

        var _action$payload = action.payload,
            method = _action$payload.method,
            args = _action$payload.args;

        history[method].apply(history, _toConsumableArray(args));
      };
    };
  };
};

exports.default = _get__('routerMiddleware');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'CALL_HISTORY_METHOD':
      return _actions.CALL_HISTORY_METHOD;

    case 'routerMiddleware':
      return routerMiddleware;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof routerMiddleware === 'undefined' ? 'undefined' : _typeof(routerMiddleware);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(routerMiddleware, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(routerMiddleware)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/reducer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _actions = __webpack_require__("./node_modules/connected-react-router/lib/actions.js");

var createConnectRouter = function createConnectRouter(structure) {
  var fromJS = structure.fromJS,
      merge = structure.merge;


  var createRouterReducer = function createRouterReducer(history) {
    var initialRouterState = fromJS({
      location: history.location,
      action: history.action
    });

    /*
    * This reducer will update the state with the most recent location history
    * has transitioned to.
    */
    return function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialRouterState;

      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          type = _ref.type,
          payload = _ref.payload;

      if (type === _get__('LOCATION_CHANGE')) {
        return merge(state, payload);
      }

      return state;
    };
  };

  return createRouterReducer;
};

exports.default = _get__('createConnectRouter');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'LOCATION_CHANGE':
      return _actions.LOCATION_CHANGE;

    case 'createConnectRouter':
      return createConnectRouter;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof createConnectRouter === 'undefined' ? 'undefined' : _typeof(createConnectRouter);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(createConnectRouter, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(createConnectRouter)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/selectors.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _reactRouter = __webpack_require__("react-router");

var createSelectors = function createSelectors(structure) {
  var getIn = structure.getIn,
      toJS = structure.toJS;

  var getLocation = function getLocation(state) {
    return toJS(getIn(state, ['router', 'location']));
  };
  var getAction = function getAction(state) {
    return toJS(getIn(state, ['router', 'action']));
  };

  // It only makes sense to recalculate the `matchPath` whenever the pathname
  // of the location changes. That's why `createMatchSelector` memoizes
  // the latest result based on the location's pathname.
  var createMatchSelector = function createMatchSelector(path) {
    var lastPathname = null;
    var lastMatch = null;

    return function (state) {
      var _ref = getLocation(state) || {},
          pathname = _ref.pathname;

      if (pathname === lastPathname) {
        return lastMatch;
      }
      lastPathname = pathname;
      var match = _get__('matchPath')(pathname, path);
      if (!match || !lastMatch || match.url !== lastMatch.url) {
        lastMatch = match;
      }

      return lastMatch;
    };
  };

  return { getLocation: getLocation, getAction: getAction, createMatchSelector: createMatchSelector };
};

exports.default = _get__('createSelectors');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'matchPath':
      return _reactRouter.matchPath;

    case 'createSelectors':
      return createSelectors;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof createSelectors === 'undefined' ? 'undefined' : _typeof(createSelectors);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(createSelectors, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(createSelectors)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/structure/plain/getIn.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* Code from github.com/erikras/redux-form by Erik Rasmussen */

var getIn = function getIn(state, path) {
  if (!state) {
    return state;
  }

  var length = path.length;
  if (!length) {
    return undefined;
  }

  var result = state;
  for (var i = 0; i < length && !!result; ++i) {
    result = result[path[i]];
  }

  return result;
};

exports.default = _get__("getIn");

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case "getIn":
      return getIn;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === "undefined" ? "undefined" : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof getIn === "undefined" ? "undefined" : _typeof(getIn);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(getIn, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(getIn)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/connected-react-router/lib/structure/plain/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _getIn = __webpack_require__("./node_modules/connected-react-router/lib/structure/plain/getIn.js");

var _getIn2 = _interopRequireDefault(_getIn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var structure = {
  fromJS: function fromJS(value) {
    return value;
  },
  getIn: _get__('getIn'),
  merge: function merge(state, payload) {
    return _extends({}, state, payload);
  },
  toJS: function toJS(value) {
    return value;
  }
};

exports.default = _get__('structure');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'getIn':
      return _getIn2.default;

    case 'structure':
      return structure;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof structure === 'undefined' ? 'undefined' : _typeof(structure);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(structure, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(structure)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__("./node_modules/core-js/modules/_wks.js")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__("./node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");
var invoke = __webpack_require__("./node_modules/core-js/modules/_invoke.js");
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__("./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");
var core = __webpack_require__("./node_modules/core-js/modules/_core.js");
var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__("./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__("./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__("./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("./node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("./node_modules/core-js/modules/_object-create.js");
var descriptor = __webpack_require__("./node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("./node_modules/core-js/modules/_library.js");
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");
var $iterCreate = __webpack_require__("./node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __webpack_require__("./node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__("./node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __webpack_require__("./node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");
var dPs = __webpack_require__("./node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __webpack_require__("./node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__("./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("./node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("./node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__("./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("./node_modules/core-js/modules/_object-dp.js");
var anObject = __webpack_require__("./node_modules/core-js/modules/_an-object.js");
var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__("./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("./node_modules/core-js/modules/_has.js");
var toObject = __webpack_require__("./node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __webpack_require__("./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("./node_modules/core-js/modules/_has.js");
var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__("./node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__("./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("./node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__("./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");
var has = __webpack_require__("./node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__("./node_modules/core-js/modules/_uid.js")('src');
var $toString = __webpack_require__("./node_modules/core-js/modules/_function-to-string.js");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__("./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("./node_modules/core-js/modules/_object-dp.js").f;
var has = __webpack_require__("./node_modules/core-js/modules/_has.js");
var TAG = __webpack_require__("./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("./node_modules/core-js/modules/_shared.js")('keys');
var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("./node_modules/core-js/modules/_core.js");
var global = __webpack_require__("./node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("./node_modules/core-js/modules/_iobject.js");
var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("./node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("./node_modules/core-js/modules/_shared.js")('wks');
var uid = __webpack_require__("./node_modules/core-js/modules/_uid.js");
var Symbol = __webpack_require__("./node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__("./node_modules/core-js/modules/_add-to-unscopables.js");
var step = __webpack_require__("./node_modules/core-js/modules/_iter-step.js");
var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");
var toIObject = __webpack_require__("./node_modules/core-js/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__("./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', { bind: __webpack_require__("./node_modules/core-js/modules/_bind.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__("./node_modules/core-js/modules/es6.array.iterator.js");
var getKeys = __webpack_require__("./node_modules/core-js/modules/_object-keys.js");
var redefine = __webpack_require__("./node_modules/core-js/modules/_redefine.js");
var global = __webpack_require__("./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__("./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__("./node_modules/core-js/modules/_iterators.js");
var wks = __webpack_require__("./node_modules/core-js/modules/_wks.js");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "./node_modules/prop-types/factoryWithThrowingShims.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__("./node_modules/prop-types/lib/ReactPropTypesSecret.js");

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__("./node_modules/prop-types/factoryWithThrowingShims.js")();
}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/redux-logger/dist/redux-logger.js":
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?t(exports):undefined}(this,function(e){"use strict";function t(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}function r(e,t){Object.defineProperty(this,"kind",{value:e,enumerable:!0}),t&&t.length&&Object.defineProperty(this,"path",{value:t,enumerable:!0})}function n(e,t,r){n.super_.call(this,"E",e),Object.defineProperty(this,"lhs",{value:t,enumerable:!0}),Object.defineProperty(this,"rhs",{value:r,enumerable:!0})}function o(e,t){o.super_.call(this,"N",e),Object.defineProperty(this,"rhs",{value:t,enumerable:!0})}function i(e,t){i.super_.call(this,"D",e),Object.defineProperty(this,"lhs",{value:t,enumerable:!0})}function a(e,t,r){a.super_.call(this,"A",e),Object.defineProperty(this,"index",{value:t,enumerable:!0}),Object.defineProperty(this,"item",{value:r,enumerable:!0})}function f(e,t,r){var n=e.slice((r||t)+1||e.length);return e.length=t<0?e.length+t:t,e.push.apply(e,n),e}function u(e){var t="undefined"==typeof e?"undefined":N(e);return"object"!==t?t:e===Math?"math":null===e?"null":Array.isArray(e)?"array":"[object Date]"===Object.prototype.toString.call(e)?"date":"function"==typeof e.toString&&/^\/.*\//.test(e.toString())?"regexp":"object"}function l(e,t,r,c,s,d,p){s=s||[],p=p||[];var g=s.slice(0);if("undefined"!=typeof d){if(c){if("function"==typeof c&&c(g,d))return;if("object"===("undefined"==typeof c?"undefined":N(c))){if(c.prefilter&&c.prefilter(g,d))return;if(c.normalize){var h=c.normalize(g,d,e,t);h&&(e=h[0],t=h[1])}}}g.push(d)}"regexp"===u(e)&&"regexp"===u(t)&&(e=e.toString(),t=t.toString());var y="undefined"==typeof e?"undefined":N(e),v="undefined"==typeof t?"undefined":N(t),b="undefined"!==y||p&&p[p.length-1].lhs&&p[p.length-1].lhs.hasOwnProperty(d),m="undefined"!==v||p&&p[p.length-1].rhs&&p[p.length-1].rhs.hasOwnProperty(d);if(!b&&m)r(new o(g,t));else if(!m&&b)r(new i(g,e));else if(u(e)!==u(t))r(new n(g,e,t));else if("date"===u(e)&&e-t!==0)r(new n(g,e,t));else if("object"===y&&null!==e&&null!==t)if(p.filter(function(t){return t.lhs===e}).length)e!==t&&r(new n(g,e,t));else{if(p.push({lhs:e,rhs:t}),Array.isArray(e)){var w;e.length;for(w=0;w<e.length;w++)w>=t.length?r(new a(g,w,new i(void 0,e[w]))):l(e[w],t[w],r,c,g,w,p);for(;w<t.length;)r(new a(g,w,new o(void 0,t[w++])))}else{var x=Object.keys(e),S=Object.keys(t);x.forEach(function(n,o){var i=S.indexOf(n);i>=0?(l(e[n],t[n],r,c,g,n,p),S=f(S,i)):l(e[n],void 0,r,c,g,n,p)}),S.forEach(function(e){l(void 0,t[e],r,c,g,e,p)})}p.length=p.length-1}else e!==t&&("number"===y&&isNaN(e)&&isNaN(t)||r(new n(g,e,t)))}function c(e,t,r,n){return n=n||[],l(e,t,function(e){e&&n.push(e)},r),n.length?n:void 0}function s(e,t,r){if(r.path&&r.path.length){var n,o=e[t],i=r.path.length-1;for(n=0;n<i;n++)o=o[r.path[n]];switch(r.kind){case"A":s(o[r.path[n]],r.index,r.item);break;case"D":delete o[r.path[n]];break;case"E":case"N":o[r.path[n]]=r.rhs}}else switch(r.kind){case"A":s(e[t],r.index,r.item);break;case"D":e=f(e,t);break;case"E":case"N":e[t]=r.rhs}return e}function d(e,t,r){if(e&&t&&r&&r.kind){for(var n=e,o=-1,i=r.path?r.path.length-1:0;++o<i;)"undefined"==typeof n[r.path[o]]&&(n[r.path[o]]="number"==typeof r.path[o]?[]:{}),n=n[r.path[o]];switch(r.kind){case"A":s(r.path?n[r.path[o]]:n,r.index,r.item);break;case"D":delete n[r.path[o]];break;case"E":case"N":n[r.path[o]]=r.rhs}}}function p(e,t,r){if(r.path&&r.path.length){var n,o=e[t],i=r.path.length-1;for(n=0;n<i;n++)o=o[r.path[n]];switch(r.kind){case"A":p(o[r.path[n]],r.index,r.item);break;case"D":o[r.path[n]]=r.lhs;break;case"E":o[r.path[n]]=r.lhs;break;case"N":delete o[r.path[n]]}}else switch(r.kind){case"A":p(e[t],r.index,r.item);break;case"D":e[t]=r.lhs;break;case"E":e[t]=r.lhs;break;case"N":e=f(e,t)}return e}function g(e,t,r){if(e&&t&&r&&r.kind){var n,o,i=e;for(o=r.path.length-1,n=0;n<o;n++)"undefined"==typeof i[r.path[n]]&&(i[r.path[n]]={}),i=i[r.path[n]];switch(r.kind){case"A":p(i[r.path[n]],r.index,r.item);break;case"D":i[r.path[n]]=r.lhs;break;case"E":i[r.path[n]]=r.lhs;break;case"N":delete i[r.path[n]]}}}function h(e,t,r){if(e&&t){var n=function(n){r&&!r(e,t,n)||d(e,t,n)};l(e,t,n)}}function y(e){return"color: "+F[e].color+"; font-weight: bold"}function v(e){var t=e.kind,r=e.path,n=e.lhs,o=e.rhs,i=e.index,a=e.item;switch(t){case"E":return[r.join("."),n,"",o];case"N":return[r.join("."),o];case"D":return[r.join(".")];case"A":return[r.join(".")+"["+i+"]",a];default:return[]}}function b(e,t,r,n){var o=c(e,t);try{n?r.groupCollapsed("diff"):r.group("diff")}catch(e){r.log("diff")}o?o.forEach(function(e){var t=e.kind,n=v(e);r.log.apply(r,["%c "+F[t].text,y(t)].concat(P(n)))}):r.log(" no diff ");try{r.groupEnd()}catch(e){r.log(" diff end  ")}}function m(e,t,r,n){switch("undefined"==typeof e?"undefined":N(e)){case"object":return"function"==typeof e[n]?e[n].apply(e,P(r)):e[n];case"function":return e(t);default:return e}}function w(e){var t=e.timestamp,r=e.duration;return function(e,n,o){var i=["action"];return i.push("%c"+String(e.type)),t&&i.push("%c@ "+n),r&&i.push("%c(in "+o.toFixed(2)+" ms)"),i.join(" ")}}function x(e,t){var r=t.logger,n=t.actionTransformer,o=t.titleFormatter,i=void 0===o?w(t):o,a=t.collapsed,f=t.colors,u=t.level,l=t.diff,c="undefined"==typeof t.titleFormatter;e.forEach(function(o,s){var d=o.started,p=o.startedTime,g=o.action,h=o.prevState,y=o.error,v=o.took,w=o.nextState,x=e[s+1];x&&(w=x.prevState,v=x.started-d);var S=n(g),k="function"==typeof a?a(function(){return w},g,o):a,j=D(p),E=f.title?"color: "+f.title(S)+";":"",A=["color: gray; font-weight: lighter;"];A.push(E),t.timestamp&&A.push("color: gray; font-weight: lighter;"),t.duration&&A.push("color: gray; font-weight: lighter;");var O=i(S,j,v);try{k?f.title&&c?r.groupCollapsed.apply(r,["%c "+O].concat(A)):r.groupCollapsed(O):f.title&&c?r.group.apply(r,["%c "+O].concat(A)):r.group(O)}catch(e){r.log(O)}var N=m(u,S,[h],"prevState"),P=m(u,S,[S],"action"),C=m(u,S,[y,h],"error"),F=m(u,S,[w],"nextState");if(N)if(f.prevState){var L="color: "+f.prevState(h)+"; font-weight: bold";r[N]("%c prev state",L,h)}else r[N]("prev state",h);if(P)if(f.action){var T="color: "+f.action(S)+"; font-weight: bold";r[P]("%c action    ",T,S)}else r[P]("action    ",S);if(y&&C)if(f.error){var M="color: "+f.error(y,h)+"; font-weight: bold;";r[C]("%c error     ",M,y)}else r[C]("error     ",y);if(F)if(f.nextState){var _="color: "+f.nextState(w)+"; font-weight: bold";r[F]("%c next state",_,w)}else r[F]("next state",w);l&&b(h,w,r,k);try{r.groupEnd()}catch(e){r.log(" log end ")}})}function S(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=Object.assign({},L,e),r=t.logger,n=t.stateTransformer,o=t.errorTransformer,i=t.predicate,a=t.logErrors,f=t.diffPredicate;if("undefined"==typeof r)return function(){return function(e){return function(t){return e(t)}}};if(e.getState&&e.dispatch)return console.error("[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n// Logger with default options\nimport { logger } from 'redux-logger'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from 'redux-logger'\nconst logger = createLogger({\n  // ...options\n});\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n"),function(){return function(e){return function(t){return e(t)}}};var u=[];return function(e){var r=e.getState;return function(e){return function(l){if("function"==typeof i&&!i(r,l))return e(l);var c={};u.push(c),c.started=O.now(),c.startedTime=new Date,c.prevState=n(r()),c.action=l;var s=void 0;if(a)try{s=e(l)}catch(e){c.error=o(e)}else s=e(l);c.took=O.now()-c.started,c.nextState=n(r());var d=t.diff&&"function"==typeof f?f(r,l):t.diff;if(x(u,Object.assign({},t,{diff:d})),u.length=0,c.error)throw c.error;return s}}}}var k,j,E=function(e,t){return new Array(t+1).join(e)},A=function(e,t){return E("0",t-e.toString().length)+e},D=function(e){return A(e.getHours(),2)+":"+A(e.getMinutes(),2)+":"+A(e.getSeconds(),2)+"."+A(e.getMilliseconds(),3)},O="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance:Date,N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},P=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},C=[];k="object"===("undefined"==typeof global?"undefined":N(global))&&global?global:"undefined"!=typeof window?window:{},j=k.DeepDiff,j&&C.push(function(){"undefined"!=typeof j&&k.DeepDiff===c&&(k.DeepDiff=j,j=void 0)}),t(n,r),t(o,r),t(i,r),t(a,r),Object.defineProperties(c,{diff:{value:c,enumerable:!0},observableDiff:{value:l,enumerable:!0},applyDiff:{value:h,enumerable:!0},applyChange:{value:d,enumerable:!0},revertChange:{value:g,enumerable:!0},isConflict:{value:function(){return"undefined"!=typeof j},enumerable:!0},noConflict:{value:function(){return C&&(C.forEach(function(e){e()}),C=null),c},enumerable:!0}});var F={E:{color:"#2196F3",text:"CHANGED:"},N:{color:"#4CAF50",text:"ADDED:"},D:{color:"#F44336",text:"DELETED:"},A:{color:"#2196F3",text:"ARRAY:"}},L={level:"log",logger:console,logErrors:!0,collapsed:void 0,predicate:void 0,duration:!1,timestamp:!0,stateTransformer:function(e){return e},actionTransformer:function(e){return e},errorTransformer:function(e){return e},colors:{title:function(){return"inherit"},prevState:function(){return"#9E9E9E"},action:function(){return"#03A9F4"},nextState:function(){return"#4CAF50"},error:function(){return"#F20404"}},diff:!1,diffPredicate:void 0,transformer:void 0},T=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.dispatch,r=e.getState;return"function"==typeof t||"function"==typeof r?S()({dispatch:t,getState:r}):void console.error("\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from 'redux-logger'\n[redux-logger v3] to\n[redux-logger v3] import { createLogger } from 'redux-logger'\n")};e.defaults=L,e.createLogger=S,e.logger=T,e.default=T,Object.defineProperty(e,"__esModule",{value:!0})});


/***/ }),

/***/ "async_hooks":
/***/ (function(module, exports) {

module.exports = require("async_hooks");

/***/ }),

/***/ "child_process":
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "d3":
/***/ (function(module, exports) {

module.exports = require("d3");

/***/ }),

/***/ "electron":
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),

/***/ "fs":
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "history":
/***/ (function(module, exports) {

module.exports = require("history");

/***/ }),

/***/ "net":
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "react":
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ "react-dom":
/***/ (function(module, exports) {

module.exports = require("react-dom");

/***/ }),

/***/ "react-draggable":
/***/ (function(module, exports) {

module.exports = require("react-draggable");

/***/ }),

/***/ "react-hot-loader":
/***/ (function(module, exports) {

module.exports = require("react-hot-loader");

/***/ }),

/***/ "react-redux":
/***/ (function(module, exports) {

module.exports = require("react-redux");

/***/ }),

/***/ "react-router":
/***/ (function(module, exports) {

module.exports = require("react-router");

/***/ }),

/***/ "react-router-dom":
/***/ (function(module, exports) {

module.exports = require("react-router-dom");

/***/ }),

/***/ "react-syntax-highlighter":
/***/ (function(module, exports) {

module.exports = require("react-syntax-highlighter");

/***/ }),

/***/ "redux":
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),

/***/ "redux-thunk":
/***/ (function(module, exports) {

module.exports = require("redux-thunk");

/***/ }),

/***/ "util":
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "webcola":
/***/ (function(module, exports) {

module.exports = require("webcola");

/***/ })

/******/ });
//# sourceMappingURL=renderer.prod.js.map