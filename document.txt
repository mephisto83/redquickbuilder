1. Who are you
	1. Andrew Porter
	2. Software Engineer
	3. Minnesota
2. What are you doing
	1. State the problem
		1. I want to execute my "what if ideas" faster.
		2. I want to be able to execute other people's ideas faster
		3. I want to build complete solutions that can scale to millions of users.
			1. Why not billions.
				1. I can solve those problems later.
2. State the solution
	1. The solution is abnoxiously large
	3. RedQuickBuilder
		1. Models
			1. Represent ideas.
				1. The may represent 
					1. people or personas
					2. Things
		2. Properties
			1. The things that keep information about the models.
			2. The may represent connections between models.
			3. The may represent abstract concepts that only make sense within the context of the application.
		3. Controllers 
			1. Are the same controllers that exist in most .net core web api based applications.
			2. Why use an API
				1. Multiple UIs can use the same UI, instead of generating html or whatever for the client side to render.
			3. Controllers Do
				1. Authentication
					1. Bearer Tokens 
				2. Authorization
					1. Business rules guide who can do what and when
				3. Execution
					1. Executing the logic 
					2. Eliminating Race conditions
				
			4. Filtering
				1. Filtering based on business rules
		4. Views
			1. Building basic UIs
		5. Language
			1. Building a title service to deliver content in the language of choice.
		6. Scaling
			1. Scaling the processing of commands, without losing the ability to guarentee no model is manipulated twice by the same
3. Graph
	1. The graph is the document that describes the application in terms of nodes and links.
	2. Nodes
		1. Nodes have properties that describe the node. There are lots of potential properties, and the majority are used for specific purposes depending on context.
		2. Required Properties
			1. NodeTypes
	3. Links
		1. Links describe relationships between nodes using properties attached to the link. 
		2. Generally links have types, and properties that may describe specific relationships.
			1. Example: A Model node references Property node with a link with the link type 'property-link'.
		
4. Models
	1. Modeles encapsulate concepts that are pertinent to the application.
		1. Models may be related to the functionality of the application or the operation of the application.
			1. Operation
				1. Models may describe User objects or other concepts used for logging in.
		2. Models can be Agents, Users or neither.
			1. Users are the actual accounts used by the system for logging in.
				1. Users may have multiple agents, and therefore can perform different actions based on their roles, and possible see more of less data in their UIs.
			2. Agents are personas that users may use to execute functionality with in the application.
				1. Example:
					1. A 'Customer' may be an Agent which performs operations on behalf of the User.
		3.	Models have properties.
			1. There are default properties which will exist on every model, but don't necessarily appear in the RedQuickBuilder UI.
			2. Default Properties
				1. Owner
				2. Updated
				3. Id
				4. Created
				5. Deleted
				6. Version
			3. The default properties will afford the system assumptions that can be made to implement features such as:
				1. constrained concurrency
					1. Guarenteeing that no race conditions can occur with a unique model instance.
				2. model versioning
					1. Reconciliation
				3. un-deletion.
		4. Referencing other models
			1. Models can reference other models by describing them as logical children.
				1. References are kept on the referenced model type as a string property with the Id of the model on a property named as the Model's name.
					1. Example.
						1. School has a child of ClassRoom, then ClassRoom has a property called School.
				2. If the model needs to encapsulate a Many to Many relationship, an intermediate Model can hold the references to the Models it is connecting. This also give an opportunity to keep more data describing the relationship on the intermediate model.
5. Properties
	1. Properties give models meaning. They have types which can be simple, like int, string, DateTime or they can be complex reference types.
	2. Models are almost always connected to properties.
	3. Attributes that are connected to properties, give clues to the expectations of the property.
		1. Example: An attribute with an Email type, suggests that the property will have to have a string with a valid email address.
		2. Attributes effects can be seen in the client and server side of the applications. The validation sections of the applications will generate code that enforce these attributes. The client side of the application will also attempt to enforce the rules descibed by the attributes.
		3. There are no limits to the number of attributes that can be applied to a property, but if they attributes contradict the type of property, build or runtime errors may occur.
6. Agent Access
	1. Purpose
		1. Describes how screens will be generated
		2. Describes which Agents can access screens.
		3. Describes functions for loading screens,
		4. Describes actions that can occur on the screens.
	2. Dashboard Screens
		1. Dashboard screens are meant as screens that direct "traffic" from on form to the next. At least at the time of this writing.
	3. Agent Screens
		1. Agent screen are meant for forms that the Agents can use to Update, Create or View Data.     
	
		